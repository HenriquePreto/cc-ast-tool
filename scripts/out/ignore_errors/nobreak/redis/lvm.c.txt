{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/lua/src/lvm.c#379:1#luaV_execute",
            "nobreaks": 3,
            "body": "{\n    LClosure *cl;\n    StkId base;\n    TValue *k;\n    const Instruction *pc;\n  reentry:\n    ((void)0);\n    pc = L->savedpc;\n    cl = &(&(L->ci->func)->value.gc->cl)->l;\n    base = L->base;\n    k = cl->p->k;\n    for (;;) {\n        const Instruction i = *pc++;\n        StkId ra;\n        if ((L->hookmask & ((1 << 2) | (1 << 3))) && (--L->hookcount == 0 || L->hookmask & (1 << 2))) {\n            traceexec(L, pc);\n            if (L->status == 1) {\n                L->savedpc = pc - 1;\n                return;\n            }\n            base = L->base;\n        }\n        ra = (base + (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0)))));\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        switch ((((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0))))) {\n          case OP_MOVE:\n            {\n                {\n                    const TValue *o2 = ((base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))));\n                    TValue *o1 = (ra);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                continue;\n            }\n          case OP_LOADK:\n            {\n                {\n                    const TValue *o2 = ((k + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0))))));\n                    TValue *o1 = (ra);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                continue;\n            }\n          case OP_LOADBOOL:\n            {\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.b = ((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    i_o->tt = 1;\n                }\n                ;\n                if ((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))))\n                    pc++;\n                continue;\n            }\n          case OP_LOADNIL:\n            {\n                TValue *rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                do {\n                    ((rb--)->tt = 0);\n                } while (rb >= ra);\n                continue;\n            }\n          case OP_GETUPVAL:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                {\n                    const TValue *o2 = (cl->upvals[b]->v);\n                    TValue *o1 = (ra);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                continue;\n            }\n          case OP_GETGLOBAL:\n            {\n                TValue g;\n                TValue *rb = (k + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0)))));\n                {\n                    TValue *i_o = (&g);\n                    i_o->value.gc = ((GCObject *)((cl->env)));\n                    i_o->tt = 5;\n                    ((void)0);\n                }\n                ;\n                ((void)0);\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_gettable(L, &g, rb, ra);\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_GETTABLE:\n            {\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_gettable(L, (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))), ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))), ra);\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_SETGLOBAL:\n            {\n                TValue g;\n                {\n                    TValue *i_o = (&g);\n                    i_o->value.gc = ((GCObject *)((cl->env)));\n                    i_o->tt = 5;\n                    ((void)0);\n                }\n                ;\n                ((void)0);\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_settable(L, &g, (k + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0))))), ra);\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_SETUPVAL:\n            {\n                UpVal *uv = cl->upvals[(((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))];\n                {\n                    const TValue *o2 = (ra);\n                    TValue *o1 = (uv->v);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                {\n                    if (((((ra)->tt) >= 4) && (((((ra)->value.gc))->gch.marked) & ((((1 << (0)) | (1 << (1))))))) && ((((((GCObject *)((uv)))))->gch.marked) & ((1 << (2)))))\n                        luaC_barrierf(L, (((GCObject *)((uv)))), ((ra)->value.gc));\n                }\n                ;\n                continue;\n            }\n          case OP_SETTABLE:\n            {\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_settable(L, ra, ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))), ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))));\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_NEWTABLE:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int c = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.gc = ((GCObject *)((luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)))));\n                    i_o->tt = 5;\n                    ((void)0);\n                }\n                ;\n                {\n                    L->savedpc = pc;\n                    {\n                        {\n                            ((void)0);\n                            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)\n                                luaC_step(L);\n                        }\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_SELF:\n            {\n                StkId rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                {\n                    const TValue *o2 = (rb);\n                    TValue *o1 = (ra + 1);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_gettable(L, rb, ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))), ra);\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_ADD:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) + (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_ADD);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_SUB:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) - (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_SUB);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_MUL:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) * (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_MUL);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_DIV:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) / (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_DIV);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_MOD:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) - floor((nb) / (nc)) * (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_MOD);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_POW:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = ((pow(nb, nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_POW);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_UNM:\n            {\n                TValue *rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                if ((((rb)->tt) == 3)) {\n                    lua_Number nb = ((rb)->value.n);\n                    {\n                        TValue *i_o = (ra);\n                        i_o->value.n = ((-(nb)));\n                        i_o->tt = 3;\n                    }\n                    ;\n                } else {\n                    {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rb, TM_UNM);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                continue;\n            }\n          case OP_NOT:\n            {\n                int res = (((((base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))))->tt) == 0) || (((((base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))))->tt) == 1) && (((base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))))->value.b) == 0));\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.b = (res);\n                    i_o->tt = 1;\n                }\n                ;\n                continue;\n            }\n          case OP_LEN:\n            {\n                const TValue *rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                switch (((rb)->tt)) {\n                  case 5:\n                    {\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((lua_Number)((luaH_getn((&(rb)->value.gc->h))))));\n                            i_o->tt = 3;\n                        }\n                        ;\n                        break;\n                    }\n                  case 4:\n                    {\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((lua_Number)(((&(&<recovery-expr>((rb)->value.gc))->tsv)->len))));\n                            i_o->tt = 3;\n                        }\n                        ;\n                        break;\n                    }\n                  default:\n                    {\n                        {\n                            L->savedpc = pc;\n                            {\n                                if (!call_binTM(L, rb, (&luaO_nilobject_), ra, TM_LEN))\n                                    luaG_typeerror(L, rb, \"get length of\");\n                                ;\n                            }\n                            ;\n                            base = L->base;\n                        }\n                    }\n                }\n                continue;\n            }\n          case OP_CONCAT:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int c = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_concat(L, c - b + 1, c);\n                        {\n                            ((void)0);\n                            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)\n                                luaC_step(L);\n                        }\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                {\n                    const TValue *o2 = (base + b);\n                    TValue *o1 = ((base + (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))));\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                continue;\n            }\n          case OP_JMP:\n            {\n                {\n                    {\n                        ((void)0);\n                        ((void)0);\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_EQ:\n            {\n                TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                {\n                    L->savedpc = pc;\n                    {\n                        if ((((rb)->tt) == ((rc)->tt) && luaV_equalval(L, rb, rc)) == (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) {\n                            {\n                                ((void)0);\n                                ((void)0);\n                            }\n                            ;\n                        }\n                        ;\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                pc++;\n                continue;\n            }\n          case OP_LT:\n            {\n                {\n                    L->savedpc = pc;\n                    {\n                        if (luaV_lessthan(L, ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))), ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))))) == (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) {\n                            {\n                                ((void)0);\n                                ((void)0);\n                            }\n                            ;\n                        }\n                        ;\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                pc++;\n                continue;\n            }\n          case OP_LE:\n            {\n                {\n                    L->savedpc = pc;\n                    {\n                        if (lessequal(L, ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))), ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))))) == (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) {\n                            {\n                                ((void)0);\n                                ((void)0);\n                            }\n                            ;\n                        }\n                        ;\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                pc++;\n                continue;\n            }\n          case OP_TEST:\n            {\n                if (((((ra)->tt) == 0) || ((((ra)->tt) == 1) && ((ra)->value.b) == 0)) != (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) {\n                    {\n                        ((void)0);\n                        ((void)0);\n                    }\n                    ;\n                }\n                ;\n                pc++;\n                continue;\n            }\n          case OP_TESTSET:\n            {\n                TValue *rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                if (((((rb)->tt) == 0) || ((((rb)->tt) == 1) && ((rb)->value.b) == 0)) != (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) {\n                    {\n                        const TValue *o2 = (rb);\n                        TValue *o1 = (ra);\n                        o1->value = o2->value;\n                        o1->tt = o2->tt;\n                        ((void)0);\n                    }\n                    ;\n                    {\n                        {\n                            ((void)0);\n                            ((void)0);\n                        }\n                        ;\n                    }\n                    ;\n                }\n                pc++;\n                continue;\n            }\n          case OP_CALL:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int nresults = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))) - 1;\n                if (b != 0)\n                    L->top = ra + b;\n                L->savedpc = pc;\n                switch (luaD_precall(L, ra, nresults)) {\n                  case 0:\n                    {\n                        nexeccalls++;\n                        goto reentry;\n                    }\n                  case 1:\n                    {\n                        if (nresults >= 0)\n                            L->top = L->ci->top;\n                        base = L->base;\n                        continue;\n                    }\n                  default:\n                    {\n                        return;\n                    }\n                }\n            }\n          case OP_TAILCALL:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                if (b != 0)\n                    L->top = ra + b;\n                L->savedpc = pc;\n                ((void)0);\n                switch (luaD_precall(L, ra, (-1))) {\n                  case 0:\n                    {\n                        CallInfo *ci = L->ci - 1;\n                        int aux;\n                        StkId func = ci->func;\n                        StkId pfunc = (ci + 1)->func;\n                        if (L->openupval)\n                            luaF_close(L, ci->base);\n                        L->base = ci->base = ci->func + ((ci + 1)->base - pfunc);\n                        for (aux = 0; pfunc + aux < L->top; aux++) {\n                            const TValue *o2 = (pfunc + aux);\n                            TValue *o1 = (func + aux);\n                            o1->value = o2->value;\n                            o1->tt = o2->tt;\n                            ((void)0);\n                        }\n                        ;\n                        ci->top = L->top = func + aux;\n                        ((void)0);\n                        ci->savedpc = L->savedpc;\n                        ci->tailcalls++;\n                        L->ci--;\n                        goto reentry;\n                    }\n                  case 1:\n                    {\n                        base = L->base;\n                        continue;\n                    }\n                  default:\n                    {\n                        return;\n                    }\n                }\n            }\n          case OP_RETURN:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                if (b != 0)\n                    L->top = ra + b - 1;\n                if (L->openupval)\n                    luaF_close(L, base);\n                L->savedpc = pc;\n                b = luaD_poscall(L, ra);\n                if (--nexeccalls == 0)\n                    return;\n                else {\n                    if (b)\n                        L->top = L->ci->top;\n                    ((void)0);\n                    ((void)0);\n                    goto reentry;\n                }\n            }\n          case OP_FORLOOP:\n            {\n                lua_Number step = ((ra + 2)->value.n);\n                lua_Number idx = ((((ra)->value.n)) + (step));\n                lua_Number limit = ((ra + 1)->value.n);\n                if (((0) < (step)) ? ((idx) <= (limit)) : ((limit) <= (idx))) {\n                    {\n                        {\n                            ((void)0);\n                            ((void)0);\n                        }\n                        ;\n                    }\n                    ;\n                    {\n                        TValue *i_o = (ra);\n                        i_o->value.n = (idx);\n                        i_o->tt = 3;\n                    }\n                    ;\n                    {\n                        TValue *i_o = (ra + 3);\n                        i_o->value.n = (idx);\n                        i_o->tt = 3;\n                    }\n                    ;\n                }\n                continue;\n            }\n          case OP_FORPREP:\n            {\n                const TValue *init = ra;\n                const TValue *plimit = ra + 1;\n                const TValue *pstep = ra + 2;\n                L->savedpc = pc;\n                if (<recovery-expr>())\n                    luaG_runerror(L, \"'for' initial value must be a number\");\n                else if (<recovery-expr>())\n                    luaG_runerror(L, \"'for' limit must be a number\");\n                else if (<recovery-expr>())\n                    luaG_runerror(L, \"'for' step must be a number\");\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.n = (((((ra)->value.n)) - (((pstep)->value.n))));\n                    i_o->tt = 3;\n                }\n                ;\n                {\n                    {\n                        ((void)0);\n                        ((void)0);\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_TFORLOOP:\n            {\n                StkId cb = ra + 3;\n                {\n                    const TValue *o2 = (ra + 2);\n                    TValue *o1 = (cb + 2);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                {\n                    const TValue *o2 = (ra + 1);\n                    TValue *o1 = (cb + 1);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                {\n                    const TValue *o2 = (ra);\n                    TValue *o1 = (cb);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                L->top = cb + 3;\n                {\n                    L->savedpc = pc;\n                    {\n                        luaD_call(L, cb, (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                L->top = L->ci->top;\n                cb = (base + (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) + 3;\n                if (!(((cb)->tt) == 0)) {\n                    {\n                        const TValue *o2 = (cb);\n                        TValue *o1 = (cb - 1);\n                        o1->value = o2->value;\n                        o1->tt = o2->tt;\n                        ((void)0);\n                    }\n                    ;\n                    {\n                        {\n                            ((void)0);\n                            ((void)0);\n                        }\n                        ;\n                    }\n                    ;\n                }\n                pc++;\n                continue;\n            }\n          case OP_SETLIST:\n            {\n                int n = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int c = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int last;\n                Table *h;\n                if (n == 0) {\n                    n = ((int)((L->top - ra))) - 1;\n                    L->top = L->ci->top;\n                }\n                if (c == 0)\n                    c = ((int)((*pc++)));\n                {\n                    if (!((((ra)->tt) == 5)))\n                        break;\n                }\n                ;\n                h = (&(ra)->value.gc->h);\n                last = ((c - 1) * 50) + n;\n                if (last > h->sizearray)\n                    luaH_resizearray(L, h, last);\n                for (; n > 0; n--) {\n                    TValue *val = ra + n;\n                    {\n                        const TValue *o2 = (val);\n                        TValue *o1 = (luaH_setnum(L, h, last--));\n                        o1->value = o2->value;\n                        o1->tt = o2->tt;\n                        ((void)0);\n                    }\n                    ;\n                    {\n                        if (((((val)->tt) >= 4) && (((((val)->value.gc))->gch.marked) & ((((1 << (0)) | (1 << (1))))))) && ((((((GCObject *)((h)))))->gch.marked) & ((1 << (2)))))\n                            luaC_barrierback(L, h);\n                    }\n                    ;\n                }\n                continue;\n            }\n          case OP_CLOSE:\n            {\n                luaF_close(L, ra);\n                continue;\n            }\n          case OP_CLOSURE:\n            {\n                Proto *p;\n                Closure *ncl;\n                int nup, j;\n                p = cl->p->p[(((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0))))];\n                nup = p->nups;\n                ncl = luaF_newLclosure(L, nup, cl->env);\n                ncl->l.p = p;\n                for (j = 0; j < nup; j++ , pc++) {\n                    if ((((OpCode)(((*pc) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) == OP_GETUPVAL)\n                        ncl->l.upvals[j] = cl->upvals[(((int)(((*pc) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))];\n                    else {\n                        ((void)0);\n                        ncl->l.upvals[j] = luaF_findupval(L, base + (((int)(((*pc) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    }\n                }\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.gc = ((GCObject *)((ncl)));\n                    i_o->tt = 6;\n                    ((void)0);\n                }\n                ;\n                {\n                    L->savedpc = pc;\n                    {\n                        {\n                            ((void)0);\n                            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)\n                                luaC_step(L);\n                        }\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_VARARG:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))) - 1;\n                int j;\n                CallInfo *ci = L->ci;\n                int n = ((int)((ci->base - ci->func))) - cl->p->numparams - 1;\n                if (b == (-1)) {\n                    {\n                        L->savedpc = pc;\n                        {\n                            if ((char *)L->stack_last - (char *)L->top <= (n) * (int)sizeof(TValue))\n                                luaD_growstack(L, n);\n                            else\n                                ((void)0);\n                            ;\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                    ra = (base + (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0)))));\n                    b = n;\n                    L->top = ra + n;\n                }\n                for (j = 0; j < b; j++) {\n                    if (j < n) {\n                        {\n                            const TValue *o2 = (ci->base - n + j);\n                            TValue *o1 = (ra + j);\n                            o1->value = o2->value;\n                            o1->tt = o2->tt;\n                            ((void)0);\n                        }\n                        ;\n                    } else {\n                        ((ra + j)->tt = 0);\n                    }\n                }\n                continue;\n            }\n        }\n    }\n}\n"
        }
    ],
    "total": 17,
    "visited": 1
}
