{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/lua/src/ldebug.c#316:1#symbexec",
            "nobreaks": 1,
            "body": "{\n    int pc;\n    int last;\n    last = pt->sizecode - 1;\n    if (!(precheck(pt)))\n        return 0;\n    ;\n    for (pc = 0; pc < lastpc; pc++) {\n        Instruction i = pt->code[pc];\n        OpCode op = (((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0))));\n        int a = (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))));\n        int b = 0;\n        int c = 0;\n        if (!(op < (((int)(OP_VARARG)) + 1)))\n            return 0;\n        ;\n        if (!((a) < (pt)->maxstacksize))\n            return 0;\n        ;\n        switch ((((enum OpMode)(luaP_opmodes[op] & 3)))) {\n          case iABC:\n            {\n                b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                c = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));\n                if (!(checkArgMode(pt, b, (((enum OpArgMask)((luaP_opmodes[op] >> 4) & 3))))))\n                    return 0;\n                ;\n                if (!(checkArgMode(pt, c, (((enum OpArgMask)((luaP_opmodes[op] >> 2) & 3))))))\n                    return 0;\n                ;\n                break;\n            }\n          case iABx:\n            {\n                b = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0))));\n                if ((((enum OpArgMask)((luaP_opmodes[op] >> 4) & 3))) == OpArgK)\n                    if (!(b < pt->sizek))\n                        return 0;\n                ;\n                break;\n            }\n          case iAsBx:\n            {\n                if ((((enum OpArgMask)((luaP_opmodes[op] >> 4) & 3))) == OpArgR) {\n                    int dest = pc + 1 + b;\n                    if (!(0 <= dest && dest < pt->sizecode))\n                        return 0;\n                    ;\n                    if (dest > 0) {\n                        int j;\n                        for (j = 0; j < dest; j++) {\n                            Instruction d = pt->code[dest - 1 - j];\n                            if (!((((OpCode)(((d) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) == OP_SETLIST && (((int)(((d) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))) == 0))\n                                break;\n                        }\n                        if (!((j & 1) == 0))\n                            return 0;\n                        ;\n                    }\n                }\n                break;\n            }\n        }\n        if ((luaP_opmodes[op] & (1 << 6))) {\n            if (a == reg)\n                last = pc;\n        }\n        if ((luaP_opmodes[op] & (1 << 7))) {\n            if (!(pc + 2 < pt->sizecode))\n                return 0;\n            ;\n            if (!((((OpCode)(((pt->code[pc + 1]) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) == OP_JMP))\n                return 0;\n            ;\n        }\n        switch (op) {\n          case OP_LOADBOOL:\n            {\n                if (c == 1) {\n                    if (!(pc + 2 < pt->sizecode))\n                        return 0;\n                    ;\n                    if (!((((OpCode)(((pt->code[pc + 1]) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) != OP_SETLIST || (((int)(((pt->code[pc + 1]) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))) != 0))\n                        return 0;\n                    ;\n                }\n                break;\n            }\n          case OP_LOADNIL:\n            {\n                if (a <= reg && reg <= b)\n                    last = pc;\n                break;\n            }\n          case OP_GETUPVAL:\n          case OP_SETUPVAL:\n            {\n                if (!(b < pt->nups))\n                    return 0;\n                ;\n                break;\n            }\n          case OP_GETGLOBAL:\n          case OP_SETGLOBAL:\n            {\n                if (!((((&pt->k[b])->tt) == 4)))\n                    return 0;\n                ;\n                break;\n            }\n          case OP_SELF:\n            {\n                if (!((a + 1) < (pt)->maxstacksize))\n                    return 0;\n                ;\n                if (reg == a + 1)\n                    last = pc;\n                break;\n            }\n          case OP_CONCAT:\n            {\n                if (!(b < c))\n                    return 0;\n                ;\n                break;\n            }\n          case OP_TFORLOOP:\n            {\n                if (!(c >= 1))\n                    return 0;\n                ;\n                if (!((a + 2 + c) < (pt)->maxstacksize))\n                    return 0;\n                ;\n                if (reg >= a + 2)\n                    last = pc;\n                break;\n            }\n          case OP_FORLOOP:\n          case OP_FORPREP:\n            if (!((a + 3) < (pt)->maxstacksize))\n                return 0;\n            ;\n          case OP_JMP:\n            {\n                int dest = pc + 1 + b;\n                if (reg != ((1 << 8) - 1) && pc < dest && dest <= lastpc)\n                    pc += b;\n                break;\n            }\n          case OP_CALL:\n          case OP_TAILCALL:\n            {\n                if (b != 0) {\n                    if (!((a + b - 1) < (pt)->maxstacksize))\n                        return 0;\n                    ;\n                }\n                c--;\n                if (c == (-1)) {\n                    if (!(luaG_checkopenop((pt)->code[(pc) + 1])))\n                        return 0;\n                    ;\n                } else if (c != 0)\n                    if (!((a + c - 1) < (pt)->maxstacksize))\n                        return 0;\n                ;\n                if (reg >= a)\n                    last = pc;\n                break;\n            }\n          case OP_RETURN:\n            {\n                b--;\n                if (b > 0)\n                    if (!((a + b - 1) < (pt)->maxstacksize))\n                        return 0;\n                ;\n                break;\n            }\n          case OP_SETLIST:\n            {\n                if (b > 0)\n                    if (!((a + b) < (pt)->maxstacksize))\n                        return 0;\n                ;\n                if (c == 0) {\n                    pc++;\n                    if (!(pc < pt->sizecode - 1))\n                        return 0;\n                    ;\n                }\n                break;\n            }\n          case OP_CLOSURE:\n            {\n                int nup, j;\n                if (!(b < pt->sizep))\n                    return 0;\n                ;\n                nup = pt->p[b]->nups;\n                if (!(pc + nup < pt->sizecode))\n                    return 0;\n                ;\n                for (j = 1; j <= nup; j++) {\n                    OpCode op1 = (((OpCode)(((pt->code[pc + j]) >> 0) & ((~((~(Instruction)0) << 6)) << 0))));\n                    if (!(op1 == OP_GETUPVAL || op1 == OP_MOVE))\n                        return 0;\n                    ;\n                }\n                if (reg != ((1 << 8) - 1))\n                    pc += nup;\n                break;\n            }\n          case OP_VARARG:\n            {\n                if (!((pt->is_vararg & 2) && !(pt->is_vararg & 4)))\n                    return 0;\n                ;\n                b--;\n                if (b == (-1))\n                    if (!(luaG_checkopenop((pt)->code[(pc) + 1])))\n                        return 0;\n                ;\n                if (!((a + b - 1) < (pt)->maxstacksize))\n                    return 0;\n                ;\n                break;\n            }\n          default:\n            break;\n        }\n    }\n    return pt->code[last];\n}\n"
        }
    ],
    "total": 32,
    "visited": 1
}
