{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/lua/src/lstrlib.c#756:1#str_format",
            "nobreaks": 1,
            "body": "{\n    int top = lua_gettop(L);\n    int arg = 1;\n    <recovery-expr>();\n    const char *strfrmt;\n    const char *strfrmt_end;\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    while (strfrmt < strfrmt_end)\n        {\n            if (*strfrmt != '%')\n                ;\n            else if (*++strfrmt == '%')\n                ;\n            else {\n                char form[18];\n                char buff[512];\n                if (++arg > top)\n                    luaL_argerror(L, arg, \"no value\");\n                strfrmt = scanformat(L, strfrmt, form);\n                switch (*strfrmt++) {\n                  case 'c':\n                    {\n                        sprintf(buff, form, (int)luaL_checknumber(L, arg));\n                        break;\n                    }\n                  case 'd':\n                  case 'i':\n                    {\n                        addintlen(form);\n                        sprintf(buff, form, (long)luaL_checknumber(L, arg));\n                        break;\n                    }\n                  case 'o':\n                  case 'u':\n                  case 'x':\n                  case 'X':\n                    {\n                        addintlen(form);\n                        sprintf(buff, form, (unsigned long)luaL_checknumber(L, arg));\n                        break;\n                    }\n                  case 'e':\n                  case 'E':\n                  case 'f':\n                  case 'g':\n                  case 'G':\n                    {\n                        sprintf(buff, form, (double)luaL_checknumber(L, arg));\n                        break;\n                    }\n                  case 'q':\n                    {\n                        addquoted(L, &b, arg);\n                        continue;\n                    }\n                  case 's':\n                    {\n                        <recovery-expr>();\n                        const char *s;\n                        if (<recovery-expr>()) {\n                            lua_pushvalue(L, arg);\n                            luaL_addvalue(&b);\n                            continue;\n                        } else {\n                            sprintf(buff, form, s);\n                            break;\n                        }\n                    }\n                  default:\n                    {\n                        return luaL_error(L, \"invalid option '%%%c' to 'format'\", *(strfrmt - 1));\n                    }\n                }\n                <recovery-expr>()(&b, buff, strlen(buff));\n            }\n        }\n    luaL_pushresult(&b);\n    return 1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/lua/src/lstrlib.c#365:1#match",
            "nobreaks": 3,
            "body": "{\n  init:\n    switch (*p) {\n      case '(':\n        {\n            if (*(p + 1) == ')')\n                return start_capture(ms, s, p + 2, (-2));\n            else\n                return start_capture(ms, s, p + 1, (-1));\n        }\n      case ')':\n        {\n            return end_capture(ms, s, p + 1);\n        }\n      case '%':\n        {\n            switch (*(p + 1)) {\n              case 'b':\n                {\n                    s = matchbalance(ms, s, p + 2);\n                    p += 4;\n                    goto init;\n                }\n              case 'f':\n                {\n                    const char *ep;\n                    char previous;\n                    p += 2;\n                    if (*p != '[')\n                        luaL_error(ms->L, \"missing '[' after '%%f' in pattern\");\n                    ep = classend(ms, p);\n                    previous = (s == ms->src_init) ? '\\x00' : *(s - 1);\n                    p = ep;\n                    goto init;\n                }\n              default:\n                {\n                    if (isdigit(((unsigned char)(*(p + 1))))) {\n                        s = match_capture(ms, s, ((unsigned char)(*(p + 1))));\n                        p += 2;\n                        goto init;\n                    }\n                    goto dflt;\n                }\n            }\n        }\n      case '\\x00':\n        {\n            return s;\n        }\n      case '$':\n        {\n            if (*(p + 1) == '\\x00')\n                ;\n            else\n                goto dflt;\n        }\n      default:\n      dflt:\n        {\n            const char *ep = classend(ms, p);\n            int m = s < ms->src_end && singlematch(((unsigned char)(*s)), p, ep);\n            switch (*ep) {\n              case '?':\n                {\n                    const char *res;\n                    if (<recovery-expr>())\n                        return res;\n                    p = ep + 1;\n                    goto init;\n                }\n              case '*':\n                {\n                    return max_expand(ms, s, p, ep);\n                }\n              case '+':\n                {\n                }\n              case '-':\n                {\n                    return min_expand(ms, s, p, ep);\n                }\n              default:\n                {\n                    s++;\n                    p = ep;\n                    goto init;\n                }\n            }\n        }\n    }\n}\n"
        }
    ],
    "total": 42,
    "visited": 2
}
