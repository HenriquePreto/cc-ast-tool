{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#25275:1#quickscan",
            "nobreaks": 2,
            "body": "{\n    char cin;\n    char cWait = (char)qss;\n    if (cWait == 0) {\n      PlainScan:\n        assert(cWait == 0);\n        while ((cin = *zLine++) != 0)\n            {\n                if (isspace((unsigned char)cin))\n                    continue;\n                switch (cin) {\n                  case '-':\n                    if (*zLine != '-')\n                        break;\n                    while ((cin = *++zLine) != 0)\n                        if (cin == '\\n')\n                            goto PlainScan;\n                    return qss;\n                  case ';':\n                    qss |= QSS_EndingSemi;\n                    continue;\n                  case '/':\n                    if (*zLine == '*') {\n                        ++zLine;\n                        cWait = '*';\n                        qss = ((cWait) | ((qss) & QSS_ScanMask));\n                        goto TermScan;\n                    }\n                    break;\n                  case '[':\n                    cin = ']';\n                  case '`':\n                  case '\\'':\n                  case '\"':\n                    cWait = cin;\n                    qss = QSS_HasDark | cWait;\n                    goto TermScan;\n                  default:\n                    break;\n                }\n                qss = (qss & ~QSS_EndingSemi) | QSS_HasDark;\n            }\n    } else {\n      TermScan:\n        while ((cin = *zLine++) != 0)\n            {\n                if (cin == cWait) {\n                    switch (cWait) {\n                      case '*':\n                        if (*zLine != '/')\n                            continue;\n                        ++zLine;\n                        cWait = 0;\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      case '`':\n                      case '\\'':\n                      case '\"':\n                        if (*zLine == cWait) {\n                            ++zLine;\n                            continue;\n                        }\n                      case ']':\n                        cWait = 0;\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      default:\n                        assert(0);\n                    }\n                }\n            }\n    }\n    return qss;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#3970:1#sqlite3re_match",
            "nobreaks": 1,
            "body": "{\n    ReStateSet aStateSet[2], *pThis, *pNext;\n    ReStateNumber aSpace[100];\n    ReStateNumber *pToFree;\n    unsigned int i = 0;\n    unsigned int iSwap = 0;\n    int c = 268435455;\n    int cPrev = 0;\n    int rc = 0;\n    ReInput in;\n    in.z = zIn;\n    in.i = 0;\n    in.mx = nIn >= 0 ? nIn : (int)strlen((const char *)zIn);\n    if (pRe->nInit) {\n        unsigned char x = pRe->zInit[0];\n        while (in.i + pRe->nInit <= in.mx && (zIn[in.i] != x || strncmp((const char *)zIn + in.i, (const char *)pRe->zInit, pRe->nInit) != 0))\n            {\n                in.i++;\n            }\n        if (in.i + pRe->nInit > in.mx)\n            return 0;\n        c = 268435455 - 1;\n    }\n    if (pRe->nState <= (sizeof (aSpace) / (sizeof (aSpace[0]) * 2))) {\n        pToFree = 0;\n        aStateSet[0].aState = aSpace;\n    } else {\n        pToFree = sqlite3_malloc64(sizeof(ReStateNumber) * 2 * pRe->nState);\n        if (pToFree == 0)\n            return -1;\n        aStateSet[0].aState = pToFree;\n    }\n    aStateSet[1].aState = &aStateSet[0].aState[pRe->nState];\n    pNext = &aStateSet[1];\n    pNext->nState = 0;\n    re_add_state(pNext, 0);\n    while (c != 0 && pNext->nState > 0)\n        {\n            cPrev = c;\n            c = pRe->xNextChar(&in);\n            pThis = pNext;\n            pNext = &aStateSet[iSwap];\n            iSwap = 1 - iSwap;\n            pNext->nState = 0;\n            for (i = 0; i < pThis->nState; i++) {\n                int x = pThis->aState[i];\n                switch (pRe->aOp[x]) {\n                  case 1:\n                    {\n                        if (pRe->aArg[x] == c)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 18:\n                    {\n                        if (cPrev == 268435455)\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 2:\n                    {\n                        if (c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 11:\n                    {\n                        if (re_word_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 12:\n                    {\n                        if (!re_word_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 13:\n                    {\n                        if (re_digit_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 14:\n                    {\n                        if (!re_digit_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 15:\n                    {\n                        if (re_space_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 16:\n                    {\n                        if (!re_space_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 17:\n                    {\n                        if (re_word_char(c) != re_word_char(cPrev))\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 3:\n                    {\n                        re_add_state(pNext, x);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 4:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 5:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        break;\n                    }\n                  case 6:\n                    {\n                        rc = 1;\n                        goto re_match_end;\n                    }\n                  case 8:\n                    {\n                        if (c == 0)\n                            break;\n                        goto re_op_cc_inc;\n                    }\n                  case 7:\n                  re_op_cc_inc:\n                    {\n                        int j = 1;\n                        int n = pRe->aArg[x];\n                        int hit = 0;\n                        for (j = 1; j > 0 && j < n; j++) {\n                            if (pRe->aOp[x + j] == 9) {\n                                if (pRe->aArg[x + j] == c) {\n                                    hit = 1;\n                                    j = -1;\n                                }\n                            } else {\n                                if (pRe->aArg[x + j] <= c && pRe->aArg[x + j + 1] >= c) {\n                                    hit = 1;\n                                    j = -1;\n                                } else {\n                                    j++;\n                                }\n                            }\n                        }\n                        if (pRe->aOp[x] == 8)\n                            hit = !hit;\n                        if (hit)\n                            re_add_state(pNext, x + n);\n                        break;\n                    }\n                }\n            }\n        }\n    for (i = 0; i < pNext->nState; i++) {\n        int x = pNext->aState[i];\n        while (pRe->aOp[x] == 5)\n            x += pRe->aArg[x];\n        if (pRe->aOp[x] == 6) {\n            rc = 1;\n            break;\n        }\n    }\n  re_match_end:\n    sqlite3_free(pToFree);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#5381:1#fsdirColumn",
            "nobreaks": 1,
            "body": "{\n    fsdir_cursor *pCur = (fsdir_cursor *)cur;\n    switch (i) {\n      case 0:\n        {\n            sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, ((sqlite3_destructor_type)-1));\n            break;\n        }\n      case 1:\n        sqlite3_result_int64(ctx, <recovery-expr>(pCur).st_mode);\n        break;\n      case 2:\n        sqlite3_result_int64(ctx, <recovery-expr>(pCur).st_mtime);\n        break;\n      case 3:\n        {\n            if (<recovery-expr>()) {\n                sqlite3_result_null(ctx);\n            } else if (<recovery-expr>()) {\n                char aStatic[64];\n                char *aBuf = aStatic;\n                sqlite3_int64 nBuf = 64;\n                int n;\n                while (1)\n                    {\n                        n = readlink(pCur->zPath, aBuf, nBuf);\n                        if (n < nBuf)\n                            break;\n                        if (aBuf != aStatic)\n                            sqlite3_free(aBuf);\n                        nBuf = nBuf * 2;\n                        aBuf = sqlite3_malloc64(nBuf);\n                        if (aBuf == 0) {\n                            sqlite3_result_error_nomem(ctx);\n                            return 7;\n                        }\n                    }\n                sqlite3_result_text(ctx, aBuf, n, ((sqlite3_destructor_type)-1));\n                if (aBuf != aStatic)\n                    sqlite3_free(aBuf);\n            } else {\n                readFileContents(ctx, pCur->zPath);\n            }\n        }\n      case 4:\n      default:\n        {\n            break;\n        }\n    }\n    return 0;\n}\n"
        }
    ],
    "total": 346,
    "visited": 3
}
