{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/../tool/lemon.c#2257:1#parseonetoken",
            "nobreaks": 1,
            "body": "{\n    const char *x;\n    x = Strsafe(psp->tokenstart);\n    switch (psp->state) {\n      case INITIALIZE:\n        psp->prevrule = 0;\n        psp->preccounter = 0;\n        psp->firstrule = psp->lastrule = 0;\n        psp->gp->nrule = 0;\n      case WAITING_FOR_DECL_OR_RULE:\n        if (x[0] == '%') {\n            psp->state = WAITING_FOR_DECL_KEYWORD;\n        } else if (islower((unsigned char)(x[0]))) {\n            psp->lhs = Symbol_new(x);\n            psp->nrhs = 0;\n            psp->lhsalias = 0;\n            psp->state = WAITING_FOR_ARROW;\n        } else if (x[0] == '{') {\n            if (psp->prevrule == 0) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"There is no prior rule upon which to attach the code fragment which begins on this line.\");\n                psp->errorcnt++;\n            } else if (psp->prevrule->code != 0) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Code fragment beginning on this line is not the first to follow the previous rule.\");\n                psp->errorcnt++;\n            } else if (strcmp(x, \"{NEVER-REDUCE\") == 0) {\n                psp->prevrule->neverReduce = 1;\n            } else {\n                psp->prevrule->line = psp->tokenlineno;\n                psp->prevrule->code = &x[1];\n                psp->prevrule->noCode = 0;\n            }\n        } else if (x[0] == '[') {\n            psp->state = PRECEDENCE_MARK_1;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Token \\\"%s\\\" should be either \\\"%%\\\" or a nonterminal name.\", x);\n            psp->errorcnt++;\n        }\n        break;\n      case PRECEDENCE_MARK_1:\n        if (!isupper((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"The precedence symbol must be a terminal.\");\n            psp->errorcnt++;\n        } else if (psp->prevrule == 0) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"There is no prior rule to assign precedence \\\"[%s]\\\".\", x);\n            psp->errorcnt++;\n        } else if (psp->prevrule->precsym != 0) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Precedence mark on this line is not the first to follow the previous rule.\");\n            psp->errorcnt++;\n        } else {\n            psp->prevrule->precsym = Symbol_new(x);\n        }\n        psp->state = PRECEDENCE_MARK_2;\n        break;\n      case PRECEDENCE_MARK_2:\n        if (x[0] != ']') {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Missing \\\"]\\\" on precedence mark.\");\n            psp->errorcnt++;\n        }\n        psp->state = WAITING_FOR_DECL_OR_RULE;\n        break;\n      case WAITING_FOR_ARROW:\n        if (x[0] == ':' && x[1] == ':' && x[2] == '=') {\n            psp->state = IN_RHS;\n        } else if (x[0] == '(') {\n            psp->state = LHS_ALIAS_1;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Expected to see a \\\":\\\" following the LHS symbol \\\"%s\\\".\", psp->lhs->name);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case LHS_ALIAS_1:\n        if (isalpha((unsigned char)(x[0]))) {\n            psp->lhsalias = x;\n            psp->state = LHS_ALIAS_2;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"\\\"%s\\\" is not a valid alias for the LHS \\\"%s\\\"\\n\", x, psp->lhs->name);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case LHS_ALIAS_2:\n        if (x[0] == ')') {\n            psp->state = LHS_ALIAS_3;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Missing \\\")\\\" following LHS alias name \\\"%s\\\".\", psp->lhsalias);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case LHS_ALIAS_3:\n        if (x[0] == ':' && x[1] == ':' && x[2] == '=') {\n            psp->state = IN_RHS;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Missing \\\"->\\\" following: \\\"%s(%s)\\\".\", psp->lhs->name, psp->lhsalias);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case IN_RHS:\n        if (x[0] == '.') {\n            struct rule *rp;\n            rp = (struct rule *)calloc(sizeof(struct rule) + sizeof(struct symbol *) * psp->nrhs + sizeof(char *) * psp->nrhs, 1);\n            if (rp == 0) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Can't allocate enough memory for this rule.\");\n                psp->errorcnt++;\n                psp->prevrule = 0;\n            } else {\n                int i;\n                rp->ruleline = psp->tokenlineno;\n                rp->rhs = (struct symbol **)&rp[1];\n                rp->rhsalias = (const char **)&(rp->rhs[psp->nrhs]);\n                for (i = 0; i < psp->nrhs; i++) {\n                    rp->rhs[i] = psp->rhs[i];\n                    rp->rhsalias[i] = psp->alias[i];\n                    if (rp->rhsalias[i] != 0) {\n                        rp->rhs[i]->bContent = 1;\n                    }\n                }\n                rp->lhs = psp->lhs;\n                rp->lhsalias = psp->lhsalias;\n                rp->nrhs = psp->nrhs;\n                rp->code = 0;\n                rp->noCode = 1;\n                rp->precsym = 0;\n                rp->index = psp->gp->nrule++;\n                rp->nextlhs = rp->lhs->rule;\n                rp->lhs->rule = rp;\n                rp->next = 0;\n                if (psp->firstrule == 0) {\n                    psp->firstrule = psp->lastrule = rp;\n                } else {\n                    psp->lastrule->next = rp;\n                    psp->lastrule = rp;\n                }\n                psp->prevrule = rp;\n            }\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (isalpha((unsigned char)(x[0]))) {\n            if (psp->nrhs >= 1000) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Too many symbols on RHS of rule beginning at \\\"%s\\\".\", x);\n                psp->errorcnt++;\n                psp->state = RESYNC_AFTER_RULE_ERROR;\n            } else {\n                psp->rhs[psp->nrhs] = Symbol_new(x);\n                psp->alias[psp->nrhs] = 0;\n                psp->nrhs++;\n            }\n        } else if ((x[0] == '|' || x[0] == '/') && psp->nrhs > 0 && isupper((unsigned char)(x[1]))) {\n            struct symbol *msp = psp->rhs[psp->nrhs - 1];\n            if (msp->type != MULTITERMINAL) {\n                struct symbol *origsp = msp;\n                msp = (struct symbol *)calloc(1, sizeof (*msp));\n                memset(msp, 0, sizeof (*msp));\n                msp->type = MULTITERMINAL;\n                msp->nsubsym = 1;\n                msp->subsym = (struct symbol **)calloc(1, sizeof(struct symbol *));\n                msp->subsym[0] = origsp;\n                msp->name = origsp->name;\n                psp->rhs[psp->nrhs - 1] = msp;\n            }\n            msp->nsubsym++;\n            msp->subsym = (struct symbol **)realloc(msp->subsym, sizeof(struct symbol *) * msp->nsubsym);\n            msp->subsym[msp->nsubsym - 1] = Symbol_new(&x[1]);\n            if (islower((unsigned char)(x[1])) || islower((unsigned char)(msp->subsym[0]->name[0]))) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Cannot form a compound containing a non-terminal\");\n                psp->errorcnt++;\n            }\n        } else if (x[0] == '(' && psp->nrhs > 0) {\n            psp->state = RHS_ALIAS_1;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Illegal character on RHS of rule: \\\"%s\\\".\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case RHS_ALIAS_1:\n        if (isalpha((unsigned char)(x[0]))) {\n            psp->alias[psp->nrhs - 1] = x;\n            psp->state = RHS_ALIAS_2;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"\\\"%s\\\" is not a valid alias for the RHS symbol \\\"%s\\\"\\n\", x, psp->rhs[psp->nrhs - 1]->name);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case RHS_ALIAS_2:\n        if (x[0] == ')') {\n            psp->state = IN_RHS;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Missing \\\")\\\" following LHS alias name \\\"%s\\\".\", psp->lhsalias);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_RULE_ERROR;\n        }\n        break;\n      case WAITING_FOR_DECL_KEYWORD:\n        if (isalpha((unsigned char)(x[0]))) {\n            psp->declkeyword = x;\n            psp->declargslot = 0;\n            psp->decllinenoslot = 0;\n            psp->insertLineMacro = 1;\n            psp->state = WAITING_FOR_DECL_ARG;\n            if (strcmp(x, \"name\") == 0) {\n                psp->declargslot = &(psp->gp->name);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"include\") == 0) {\n                psp->declargslot = &(psp->gp->include);\n            } else if (strcmp(x, \"code\") == 0) {\n                psp->declargslot = &(psp->gp->extracode);\n            } else if (strcmp(x, \"token_destructor\") == 0) {\n                psp->declargslot = &psp->gp->tokendest;\n            } else if (strcmp(x, \"default_destructor\") == 0) {\n                psp->declargslot = &psp->gp->vardest;\n            } else if (strcmp(x, \"token_prefix\") == 0) {\n                psp->declargslot = &psp->gp->tokenprefix;\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"syntax_error\") == 0) {\n                psp->declargslot = &(psp->gp->error);\n            } else if (strcmp(x, \"parse_accept\") == 0) {\n                psp->declargslot = &(psp->gp->accept);\n            } else if (strcmp(x, \"parse_failure\") == 0) {\n                psp->declargslot = &(psp->gp->failure);\n            } else if (strcmp(x, \"stack_overflow\") == 0) {\n                psp->declargslot = &(psp->gp->overflow);\n            } else if (strcmp(x, \"extra_argument\") == 0) {\n                psp->declargslot = &(psp->gp->arg);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"extra_context\") == 0) {\n                psp->declargslot = &(psp->gp->ctx);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"token_type\") == 0) {\n                psp->declargslot = &(psp->gp->tokentype);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"default_type\") == 0) {\n                psp->declargslot = &(psp->gp->vartype);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"stack_size\") == 0) {\n                psp->declargslot = &(psp->gp->stacksize);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"start_symbol\") == 0) {\n                psp->declargslot = &(psp->gp->start);\n                psp->insertLineMacro = 0;\n            } else if (strcmp(x, \"left\") == 0) {\n                psp->preccounter++;\n                psp->declassoc = LEFT;\n                psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\n            } else if (strcmp(x, \"right\") == 0) {\n                psp->preccounter++;\n                psp->declassoc = RIGHT;\n                psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\n            } else if (strcmp(x, \"nonassoc\") == 0) {\n                psp->preccounter++;\n                psp->declassoc = NONE;\n                psp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\n            } else if (strcmp(x, \"destructor\") == 0) {\n                psp->state = WAITING_FOR_DESTRUCTOR_SYMBOL;\n            } else if (strcmp(x, \"type\") == 0) {\n                psp->state = WAITING_FOR_DATATYPE_SYMBOL;\n            } else if (strcmp(x, \"fallback\") == 0) {\n                psp->fallback = 0;\n                psp->state = WAITING_FOR_FALLBACK_ID;\n            } else if (strcmp(x, \"token\") == 0) {\n                psp->state = WAITING_FOR_TOKEN_NAME;\n            } else if (strcmp(x, \"wildcard\") == 0) {\n                psp->state = WAITING_FOR_WILDCARD_ID;\n            } else if (strcmp(x, \"token_class\") == 0) {\n                psp->state = WAITING_FOR_CLASS_ID;\n            } else {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Unknown declaration keyword: \\\"%%%s\\\".\", x);\n                psp->errorcnt++;\n                psp->state = RESYNC_AFTER_DECL_ERROR;\n            }\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Illegal declaration keyword: \\\"%s\\\".\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        }\n        break;\n      case WAITING_FOR_DESTRUCTOR_SYMBOL:\n        if (!isalpha((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol name missing after %%destructor keyword\");\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        } else {\n            struct symbol *sp = Symbol_new(x);\n            psp->declargslot = &sp->destructor;\n            psp->decllinenoslot = &sp->destLineno;\n            psp->insertLineMacro = 1;\n            psp->state = WAITING_FOR_DECL_ARG;\n        }\n        break;\n      case WAITING_FOR_DATATYPE_SYMBOL:\n        if (!isalpha((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol name missing after %%type keyword\");\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        } else {\n            struct symbol *sp = Symbol_find(x);\n            if ((sp) && (sp->datatype)) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol %%type \\\"%s\\\" already defined\", x);\n                psp->errorcnt++;\n                psp->state = RESYNC_AFTER_DECL_ERROR;\n            } else {\n                if (!sp) {\n                    sp = Symbol_new(x);\n                }\n                psp->declargslot = &sp->datatype;\n                psp->insertLineMacro = 0;\n                psp->state = WAITING_FOR_DECL_ARG;\n            }\n        }\n        break;\n      case WAITING_FOR_PRECEDENCE_SYMBOL:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (isupper((unsigned char)(x[0]))) {\n            struct symbol *sp;\n            sp = Symbol_new(x);\n            if (sp->prec >= 0) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol \\\"%s\\\" has already be given a precedence.\", x);\n                psp->errorcnt++;\n            } else {\n                sp->prec = psp->preccounter;\n                sp->assoc = psp->declassoc;\n            }\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Can't assign a precedence to \\\"%s\\\".\", x);\n            psp->errorcnt++;\n        }\n        break;\n      case WAITING_FOR_DECL_ARG:\n        if (x[0] == '{' || x[0] == '\"' || isalnum((unsigned char)(x[0]))) {\n            const char *zOld, *zNew;\n            char *zBuf, *z;\n            int nOld, n, nLine = 0, nNew, nBack;\n            int addLineMacro;\n            char zLine[50];\n            zNew = x;\n            if (zNew[0] == '\"' || zNew[0] == '{')\n                zNew++;\n            nNew = ((int)strlen(zNew));\n            if (*psp->declargslot) {\n                zOld = *psp->declargslot;\n            } else {\n                zOld = \"\";\n            }\n            nOld = ((int)strlen(zOld));\n            n = nOld + nNew + 20;\n            addLineMacro = !psp->gp->nolinenosflag && psp->insertLineMacro && psp->tokenlineno > 1 && (psp->decllinenoslot == 0 || psp->decllinenoslot[0] != 0);\n            if (addLineMacro) {\n                for (z = psp->filename , nBack = 0; *z; z++) {\n                    if (*z == '\\\\')\n                        nBack++;\n                }\n                lemon_sprintf(zLine, \"#line %d \", psp->tokenlineno);\n                nLine = ((int)strlen(zLine));\n                n += nLine + ((int)strlen(psp->filename)) + nBack;\n            }\n            *psp->declargslot = (char *)realloc(*psp->declargslot, n);\n            zBuf = *psp->declargslot + nOld;\n            if (addLineMacro) {\n                if (nOld && zBuf[-1] != '\\n') {\n                    *(zBuf++) = '\\n';\n                }\n                memcpy(zBuf, zLine, nLine);\n                zBuf += nLine;\n                *(zBuf++) = '\"';\n                for (z = psp->filename; *z; z++) {\n                    if (*z == '\\\\') {\n                        *(zBuf++) = '\\\\';\n                    }\n                    *(zBuf++) = *z;\n                }\n                *(zBuf++) = '\"';\n                *(zBuf++) = '\\n';\n            }\n            if (psp->decllinenoslot && psp->decllinenoslot[0] == 0) {\n                psp->decllinenoslot[0] = psp->tokenlineno;\n            }\n            memcpy(zBuf, zNew, nNew);\n            zBuf += nNew;\n            *zBuf = 0;\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Illegal argument to %%%s: %s\", psp->declkeyword, x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        }\n        break;\n      case WAITING_FOR_FALLBACK_ID:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (!isupper((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%fallback argument \\\"%s\\\" should be a token\", x);\n            psp->errorcnt++;\n        } else {\n            struct symbol *sp = Symbol_new(x);\n            if (psp->fallback == 0) {\n                psp->fallback = sp;\n            } else if (sp->fallback) {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"More than one fallback assigned to token %s\", x);\n                psp->errorcnt++;\n            } else {\n                sp->fallback = psp->fallback;\n                psp->gp->has_fallback = 1;\n            }\n        }\n        break;\n      case WAITING_FOR_TOKEN_NAME:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (!isupper((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%token argument \\\"%s\\\" should be a token\", x);\n            psp->errorcnt++;\n        } else {\n            (void)Symbol_new(x);\n        }\n        break;\n      case WAITING_FOR_WILDCARD_ID:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (!isupper((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%wildcard argument \\\"%s\\\" should be a token\", x);\n            psp->errorcnt++;\n        } else {\n            struct symbol *sp = Symbol_new(x);\n            if (psp->gp->wildcard == 0) {\n                psp->gp->wildcard = sp;\n            } else {\n                ErrorMsg(psp->filename, psp->tokenlineno, \"Extra wildcard to token: %s\", x);\n                psp->errorcnt++;\n            }\n        }\n        break;\n      case WAITING_FOR_CLASS_ID:\n        if (!islower((unsigned char)(x[0]))) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%token_class must be followed by an identifier: %s\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        } else if (Symbol_find(x)) {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"Symbol \\\"%s\\\" already used\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        } else {\n            psp->tkclass = Symbol_new(x);\n            psp->tkclass->type = MULTITERMINAL;\n            psp->state = WAITING_FOR_CLASS_TOKEN;\n        }\n        break;\n      case WAITING_FOR_CLASS_TOKEN:\n        if (x[0] == '.') {\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        } else if (isupper((unsigned char)(x[0])) || ((x[0] == '|' || x[0] == '/') && isupper((unsigned char)(x[1])))) {\n            struct symbol *msp = psp->tkclass;\n            msp->nsubsym++;\n            msp->subsym = (struct symbol **)realloc(msp->subsym, sizeof(struct symbol *) * msp->nsubsym);\n            if (!isupper((unsigned char)(x[0])))\n                x++;\n            msp->subsym[msp->nsubsym - 1] = Symbol_new(x);\n        } else {\n            ErrorMsg(psp->filename, psp->tokenlineno, \"%%token_class argument \\\"%s\\\" should be a token\", x);\n            psp->errorcnt++;\n            psp->state = RESYNC_AFTER_DECL_ERROR;\n        }\n        break;\n      case RESYNC_AFTER_RULE_ERROR:\n      case RESYNC_AFTER_DECL_ERROR:\n        if (x[0] == '.')\n            psp->state = WAITING_FOR_DECL_OR_RULE;\n        if (x[0] == '%')\n            psp->state = WAITING_FOR_DECL_KEYWORD;\n        break;\n    }\n}\n"
        }
    ],
    "total": 124,
    "visited": 1
}
