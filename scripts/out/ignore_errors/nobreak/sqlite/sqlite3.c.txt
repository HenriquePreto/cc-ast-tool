{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#168793:1#yy_reduce",
            "nobreaks": 1,
            "body": "{\n    int yygoto;\n    unsigned short yyact;\n    yyStackEntry *yymsp;\n    int yysize;\n    (void)yyLookahead;\n    (void)yyLookaheadToken;\n    yymsp = yypParser->yytos;\n    switch (yyruleno) {\n        YYMINORTYPE yylhsminor;\n      case 0:\n        {\n            pParse->explain = 1;\n        }\n        break;\n      case 1:\n        {\n            pParse->explain = 2;\n        }\n        break;\n      case 2:\n        {\n            sqlite3FinishCoding(pParse);\n        }\n        break;\n      case 3:\n        {\n            sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 4:\n        {\n            yymsp[1].minor.yy394 = 7;\n        }\n        break;\n      case 5:\n      case 6:\n        ;\n      case 7:\n        ;\n      case 323:\n        ;\n        {\n            yymsp[0].minor.yy394 = yymsp[0].major;\n        }\n        break;\n      case 8:\n      case 9:\n        ;\n        {\n            sqlite3EndTransaction(pParse, yymsp[-1].major);\n        }\n        break;\n      case 10:\n        {\n            sqlite3Savepoint(pParse, 0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 11:\n        {\n            sqlite3Savepoint(pParse, 1, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 12:\n        {\n            sqlite3Savepoint(pParse, 2, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 13:\n        {\n            sqlite3StartTable(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy394, 0, 0, yymsp[-2].minor.yy394);\n        }\n        break;\n      case 14:\n        {\n            disableLookaside(pParse);\n        }\n        break;\n      case 15:\n      case 18:\n        ;\n      case 47:\n        ;\n      case 62:\n        ;\n      case 72:\n        ;\n      case 81:\n        ;\n      case 98:\n        ;\n      case 244:\n        ;\n        {\n            yymsp[1].minor.yy394 = 0;\n        }\n        break;\n      case 16:\n        {\n            yymsp[-2].minor.yy394 = 1;\n        }\n        break;\n      case 17:\n        {\n            yymsp[0].minor.yy394 = pParse->db->init.busy == 0;\n        }\n        break;\n      case 19:\n        {\n            sqlite3EndTable(pParse, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0, yymsp[0].minor.yy285, 0);\n        }\n        break;\n      case 20:\n        {\n            sqlite3EndTable(pParse, 0, 0, 0, yymsp[0].minor.yy47);\n            sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy47);\n        }\n        break;\n      case 21:\n        {\n            yymsp[1].minor.yy285 = 0;\n        }\n        break;\n      case 22:\n        {\n            yylhsminor.yy285 = yymsp[-2].minor.yy285 | yymsp[0].minor.yy285;\n        }\n        yymsp[-2].minor.yy285 = yylhsminor.yy285;\n        break;\n      case 23:\n        {\n            if (yymsp[0].minor.yy0.n == 5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z, \"rowid\", 5) == 0) {\n                yymsp[-1].minor.yy285 = 128 | 512;\n            } else {\n                yymsp[-1].minor.yy285 = 0;\n                sqlite3ErrorMsg(pParse, \"unknown table option: %.*s\", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);\n            }\n        }\n        break;\n      case 24:\n        {\n            if (yymsp[0].minor.yy0.n == 6 && sqlite3_strnicmp(yymsp[0].minor.yy0.z, \"strict\", 6) == 0) {\n                yylhsminor.yy285 = 65536;\n            } else {\n                yylhsminor.yy285 = 0;\n                sqlite3ErrorMsg(pParse, \"unknown table option: %.*s\", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);\n            }\n        }\n        yymsp[0].minor.yy285 = yylhsminor.yy285;\n        break;\n      case 25:\n        {\n            sqlite3AddColumn(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0);\n        }\n        break;\n      case 26:\n      case 65:\n        ;\n      case 104:\n        ;\n        {\n            yymsp[1].minor.yy0.n = 0;\n            yymsp[1].minor.yy0.z = 0;\n        }\n        break;\n      case 27:\n        {\n            yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);\n        }\n        break;\n      case 28:\n        {\n            yymsp[-5].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);\n        }\n        break;\n      case 29:\n        {\n            yymsp[-1].minor.yy0.n = yymsp[0].minor.yy0.n + (int)(yymsp[0].minor.yy0.z - yymsp[-1].minor.yy0.z);\n        }\n        break;\n      case 30:\n        {\n            assert(yyLookahead != 319);\n            yymsp[1].minor.yy522 = yyLookaheadToken.z;\n        }\n        break;\n      case 31:\n        {\n            assert(yyLookahead != 319);\n            yymsp[1].minor.yy0 = yyLookaheadToken;\n        }\n        break;\n      case 32:\n      case 67:\n        ;\n        {\n            pParse->constraintName = yymsp[0].minor.yy0;\n        }\n        break;\n      case 33:\n        {\n            sqlite3AddDefaultValue(pParse, yymsp[0].minor.yy528, yymsp[-1].minor.yy0.z, &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);\n        }\n        break;\n      case 34:\n        {\n            sqlite3AddDefaultValue(pParse, yymsp[-1].minor.yy528, yymsp[-2].minor.yy0.z + 1, yymsp[0].minor.yy0.z);\n        }\n        break;\n      case 35:\n        {\n            sqlite3AddDefaultValue(pParse, yymsp[0].minor.yy528, yymsp[-2].minor.yy0.z, &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);\n        }\n        break;\n      case 36:\n        {\n            Expr *p = sqlite3PExpr(pParse, 173, yymsp[0].minor.yy528, 0);\n            sqlite3AddDefaultValue(pParse, p, yymsp[-2].minor.yy0.z, &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);\n        }\n        break;\n      case 37:\n        {\n            Expr *p = tokenExpr(pParse, 117, yymsp[0].minor.yy0);\n            if (p) {\n                sqlite3ExprIdToTrueFalse(p);\n                ;\n            }\n            sqlite3AddDefaultValue(pParse, p, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.z + yymsp[0].minor.yy0.n);\n        }\n        break;\n      case 38:\n        {\n            sqlite3AddNotNull(pParse, yymsp[0].minor.yy394);\n        }\n        break;\n      case 39:\n        {\n            sqlite3AddPrimaryKey(pParse, 0, yymsp[-1].minor.yy394, yymsp[0].minor.yy394, yymsp[-2].minor.yy394);\n        }\n        break;\n      case 40:\n        {\n            sqlite3CreateIndex(pParse, 0, 0, 0, 0, yymsp[0].minor.yy394, 0, 0, 0, 0, 1);\n        }\n        break;\n      case 41:\n        {\n            sqlite3AddCheckConstraint(pParse, yymsp[-1].minor.yy528, yymsp[-2].minor.yy0.z, yymsp[0].minor.yy0.z);\n        }\n        break;\n      case 42:\n        {\n            sqlite3CreateForeignKey(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy322, yymsp[0].minor.yy394);\n        }\n        break;\n      case 43:\n        {\n            sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy394);\n        }\n        break;\n      case 44:\n        {\n            sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 45:\n        {\n            sqlite3AddGenerated(pParse, yymsp[-1].minor.yy528, 0);\n        }\n        break;\n      case 46:\n        {\n            sqlite3AddGenerated(pParse, yymsp[-2].minor.yy528, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 48:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 49:\n        {\n            yymsp[1].minor.yy394 = 0 * 257;\n        }\n        break;\n      case 50:\n        {\n            yymsp[-1].minor.yy394 = (yymsp[-1].minor.yy394 & ~yymsp[0].minor.yy231.mask) | yymsp[0].minor.yy231.value;\n        }\n        break;\n      case 51:\n        {\n            yymsp[-1].minor.yy231.value = 0;\n            yymsp[-1].minor.yy231.mask = 0;\n        }\n        break;\n      case 52:\n        {\n            yymsp[-2].minor.yy231.value = 0;\n            yymsp[-2].minor.yy231.mask = 0;\n        }\n        break;\n      case 53:\n        {\n            yymsp[-2].minor.yy231.value = yymsp[0].minor.yy394;\n            yymsp[-2].minor.yy231.mask = 255;\n        }\n        break;\n      case 54:\n        {\n            yymsp[-2].minor.yy231.value = yymsp[0].minor.yy394 << 8;\n            yymsp[-2].minor.yy231.mask = 65280;\n        }\n        break;\n      case 55:\n        {\n            yymsp[-1].minor.yy394 = 8;\n        }\n        break;\n      case 56:\n        {\n            yymsp[-1].minor.yy394 = 9;\n        }\n        break;\n      case 57:\n        {\n            yymsp[0].minor.yy394 = 10;\n        }\n        break;\n      case 58:\n        {\n            yymsp[0].minor.yy394 = 7;\n        }\n        break;\n      case 59:\n        {\n            yymsp[-1].minor.yy394 = 0;\n        }\n        break;\n      case 60:\n        {\n            yymsp[-2].minor.yy394 = 0;\n        }\n        break;\n      case 61:\n      case 76:\n        ;\n      case 171:\n        ;\n        {\n            yymsp[-1].minor.yy394 = yymsp[0].minor.yy394;\n        }\n        break;\n      case 63:\n      case 80:\n        ;\n      case 216:\n        ;\n      case 219:\n        ;\n      case 245:\n        ;\n        {\n            yymsp[-1].minor.yy394 = 1;\n        }\n        break;\n      case 64:\n        {\n            yymsp[-1].minor.yy394 = 0;\n        }\n        break;\n      case 66:\n        {\n            pParse->constraintName.n = 0;\n        }\n        break;\n      case 68:\n        {\n            sqlite3AddPrimaryKey(pParse, yymsp[-3].minor.yy322, yymsp[0].minor.yy394, yymsp[-2].minor.yy394, 0);\n        }\n        break;\n      case 69:\n        {\n            sqlite3CreateIndex(pParse, 0, 0, 0, yymsp[-2].minor.yy322, yymsp[0].minor.yy394, 0, 0, 0, 0, 1);\n        }\n        break;\n      case 70:\n        {\n            sqlite3AddCheckConstraint(pParse, yymsp[-2].minor.yy528, yymsp[-3].minor.yy0.z, yymsp[-1].minor.yy0.z);\n        }\n        break;\n      case 71:\n        {\n            sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy322, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[-1].minor.yy394);\n            sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy394);\n        }\n        break;\n      case 73:\n      case 75:\n        ;\n        {\n            yymsp[1].minor.yy394 = 11;\n        }\n        break;\n      case 74:\n        {\n            yymsp[-2].minor.yy394 = yymsp[0].minor.yy394;\n        }\n        break;\n      case 77:\n        {\n            yymsp[0].minor.yy394 = 4;\n        }\n        break;\n      case 78:\n      case 172:\n        ;\n        {\n            yymsp[0].minor.yy394 = 5;\n        }\n        break;\n      case 79:\n        {\n            sqlite3DropTable(pParse, yymsp[0].minor.yy131, 0, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 82:\n        {\n            sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[0].minor.yy47, yymsp[-7].minor.yy394, yymsp[-5].minor.yy394);\n        }\n        break;\n      case 83:\n        {\n            sqlite3DropTable(pParse, yymsp[0].minor.yy131, 1, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 84:\n        {\n            SelectDest dest = {9, 0, 0, 0, 0, 0, 0};\n            sqlite3Select(pParse, yymsp[0].minor.yy47, &dest);\n            sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy47);\n        }\n        break;\n      case 85:\n        {\n            yymsp[-2].minor.yy47 = attachWithToSelect(pParse, yymsp[0].minor.yy47, yymsp[-1].minor.yy521);\n        }\n        break;\n      case 86:\n        {\n            yymsp[-3].minor.yy47 = attachWithToSelect(pParse, yymsp[0].minor.yy47, yymsp[-1].minor.yy521);\n        }\n        break;\n      case 87:\n        {\n            Select *p = yymsp[0].minor.yy47;\n            if (p) {\n                parserDoubleLinkSelect(pParse, p);\n            }\n            yymsp[0].minor.yy47 = p;\n        }\n        break;\n      case 88:\n        {\n            Select *pRhs = yymsp[0].minor.yy47;\n            Select *pLhs = yymsp[-2].minor.yy47;\n            if (pRhs && pRhs->pPrior) {\n                SrcList *pFrom;\n                Token x;\n                x.n = 0;\n                parserDoubleLinkSelect(pParse, pRhs);\n                pFrom = sqlite3SrcListAppendFromTerm(pParse, 0, 0, 0, &x, pRhs, 0);\n                pRhs = sqlite3SelectNew(pParse, 0, pFrom, 0, 0, 0, 0, 0, 0);\n            }\n            if (pRhs) {\n                pRhs->op = (u8)yymsp[-1].minor.yy394;\n                pRhs->pPrior = pLhs;\n                if ((pLhs))\n                    pLhs->selFlags &= ~1024;\n                pRhs->selFlags &= ~1024;\n                if (yymsp[-1].minor.yy394 != 135)\n                    pParse->hasCompound = 1;\n            } else {\n                sqlite3SelectDelete(pParse->db, pLhs);\n            }\n            yymsp[-2].minor.yy47 = pRhs;\n        }\n        break;\n      case 89:\n      case 91:\n        ;\n        {\n            yymsp[0].minor.yy394 = yymsp[0].major;\n        }\n        break;\n      case 90:\n        {\n            yymsp[-1].minor.yy394 = 135;\n        }\n        break;\n      case 92:\n        {\n            yymsp[-8].minor.yy47 = sqlite3SelectNew(pParse, yymsp[-6].minor.yy322, yymsp[-5].minor.yy131, yymsp[-4].minor.yy528, yymsp[-3].minor.yy322, yymsp[-2].minor.yy528, yymsp[-1].minor.yy322, yymsp[-7].minor.yy394, yymsp[0].minor.yy528);\n        }\n        break;\n      case 93:\n        {\n            yymsp[-9].minor.yy47 = sqlite3SelectNew(pParse, yymsp[-7].minor.yy322, yymsp[-6].minor.yy131, yymsp[-5].minor.yy528, yymsp[-4].minor.yy322, yymsp[-3].minor.yy528, yymsp[-1].minor.yy322, yymsp[-8].minor.yy394, yymsp[0].minor.yy528);\n            if (yymsp[-9].minor.yy47) {\n                yymsp[-9].minor.yy47->pWinDefn = yymsp[-2].minor.yy41;\n            } else {\n                sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy41);\n            }\n        }\n        break;\n      case 94:\n        {\n            yymsp[-3].minor.yy47 = sqlite3SelectNew(pParse, yymsp[-1].minor.yy322, 0, 0, 0, 0, 0, 512, 0);\n        }\n        break;\n      case 95:\n        {\n            Select *pRight, *pLeft = yymsp[-4].minor.yy47;\n            pRight = sqlite3SelectNew(pParse, yymsp[-1].minor.yy322, 0, 0, 0, 0, 0, 512 | 1024, 0);\n            if ((pLeft))\n                pLeft->selFlags &= ~1024;\n            if (pRight) {\n                pRight->op = 135;\n                pRight->pPrior = pLeft;\n                yymsp[-4].minor.yy47 = pRight;\n            } else {\n                yymsp[-4].minor.yy47 = pLeft;\n            }\n        }\n        break;\n      case 96:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 97:\n        {\n            yymsp[0].minor.yy394 = 2;\n        }\n        break;\n      case 99:\n      case 132:\n        ;\n      case 142:\n        ;\n      case 232:\n        ;\n      case 235:\n        ;\n      case 240:\n        ;\n        {\n            yymsp[1].minor.yy322 = 0;\n        }\n        break;\n      case 100:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[-2].minor.yy528);\n            if (yymsp[0].minor.yy0.n > 0)\n                sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy322, &yymsp[0].minor.yy0, 1);\n            sqlite3ExprListSetSpan(pParse, yymsp[-4].minor.yy322, yymsp[-3].minor.yy522, yymsp[-1].minor.yy522);\n        }\n        break;\n      case 101:\n        {\n            Expr *p = sqlite3Expr(pParse->db, 180, 0);\n            yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, p);\n        }\n        break;\n      case 102:\n        {\n            Expr *pRight = sqlite3PExpr(pParse, 180, 0, 0);\n            Expr *pLeft = tokenExpr(pParse, 59, yymsp[-2].minor.yy0);\n            Expr *pDot = sqlite3PExpr(pParse, 141, pLeft, pRight);\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, pDot);\n        }\n        break;\n      case 103:\n      case 115:\n        ;\n      case 256:\n        ;\n      case 257:\n        ;\n        {\n            yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;\n        }\n        break;\n      case 105:\n      case 108:\n        ;\n        {\n            yymsp[1].minor.yy131 = 0;\n        }\n        break;\n      case 106:\n        {\n            yymsp[-1].minor.yy131 = yymsp[0].minor.yy131;\n            sqlite3SrcListShiftJoinType(pParse, yymsp[-1].minor.yy131);\n        }\n        break;\n      case 107:\n        {\n            if ((yymsp[-1].minor.yy131 && yymsp[-1].minor.yy131->nSrc > 0))\n                yymsp[-1].minor.yy131->a[yymsp[-1].minor.yy131->nSrc - 1].fg.jointype = (u8)yymsp[0].minor.yy394;\n        }\n        break;\n      case 109:\n        {\n            yymsp[-4].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-4].minor.yy131, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0, 0, &yymsp[0].minor.yy561);\n        }\n        break;\n      case 110:\n        {\n            yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-5].minor.yy131, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, 0, &yymsp[0].minor.yy561);\n            sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy131, &yymsp[-1].minor.yy0);\n        }\n        break;\n      case 111:\n        {\n            yymsp[-7].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-7].minor.yy131, &yymsp[-6].minor.yy0, &yymsp[-5].minor.yy0, &yymsp[-1].minor.yy0, 0, &yymsp[0].minor.yy561);\n            sqlite3SrcListFuncArgs(pParse, yymsp[-7].minor.yy131, yymsp[-3].minor.yy322);\n        }\n        break;\n      case 112:\n        {\n            yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-5].minor.yy131, 0, 0, &yymsp[-1].minor.yy0, yymsp[-3].minor.yy47, &yymsp[0].minor.yy561);\n        }\n        break;\n      case 113:\n        {\n            if (yymsp[-5].minor.yy131 == 0 && yymsp[-1].minor.yy0.n == 0 && yymsp[0].minor.yy561.pOn == 0 && yymsp[0].minor.yy561.pUsing == 0) {\n                yymsp[-5].minor.yy131 = yymsp[-3].minor.yy131;\n            } else if (yymsp[-3].minor.yy131->nSrc == 1) {\n                yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-5].minor.yy131, 0, 0, &yymsp[-1].minor.yy0, 0, &yymsp[0].minor.yy561);\n                if (yymsp[-5].minor.yy131) {\n                    SrcItem *pNew = &yymsp[-5].minor.yy131->a[yymsp[-5].minor.yy131->nSrc - 1];\n                    SrcItem *pOld = yymsp[-3].minor.yy131->a;\n                    pNew->zName = pOld->zName;\n                    pNew->zDatabase = pOld->zDatabase;\n                    pNew->pSelect = pOld->pSelect;\n                    if (pNew->pSelect && (pNew->pSelect->selFlags & 2048) != 0) {\n                        pNew->fg.isNestedFrom = 1;\n                    }\n                    if (pOld->fg.isTabFunc) {\n                        pNew->u1.pFuncArg = pOld->u1.pFuncArg;\n                        pOld->u1.pFuncArg = 0;\n                        pOld->fg.isTabFunc = 0;\n                        pNew->fg.isTabFunc = 1;\n                    }\n                    pOld->zName = pOld->zDatabase = 0;\n                    pOld->pSelect = 0;\n                }\n                sqlite3SrcListDelete(pParse->db, yymsp[-3].minor.yy131);\n            } else {\n                Select *pSubquery;\n                sqlite3SrcListShiftJoinType(pParse, yymsp[-3].minor.yy131);\n                pSubquery = sqlite3SelectNew(pParse, 0, yymsp[-3].minor.yy131, 0, 0, 0, 0, 2048, 0);\n                yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse, yymsp[-5].minor.yy131, 0, 0, &yymsp[-1].minor.yy0, pSubquery, &yymsp[0].minor.yy561);\n            }\n        }\n        break;\n      case 114:\n      case 129:\n        ;\n        {\n            yymsp[1].minor.yy0.z = 0;\n            yymsp[1].minor.yy0.n = 0;\n        }\n        break;\n      case 116:\n        {\n            yylhsminor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[0].minor.yy0, 0);\n            if ((pParse->eParseMode >= 2) && yylhsminor.yy131)\n                sqlite3RenameTokenMap(pParse, yylhsminor.yy131->a[0].zName, &yymsp[0].minor.yy0);\n        }\n        yymsp[0].minor.yy131 = yylhsminor.yy131;\n        break;\n      case 117:\n        {\n            yylhsminor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n            if ((pParse->eParseMode >= 2) && yylhsminor.yy131)\n                sqlite3RenameTokenMap(pParse, yylhsminor.yy131->a[0].zName, &yymsp[0].minor.yy0);\n        }\n        yymsp[-2].minor.yy131 = yylhsminor.yy131;\n        break;\n      case 118:\n        {\n            yymsp[0].minor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[0].minor.yy0, 0);\n        }\n        break;\n      case 119:\n        {\n            yymsp[-2].minor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 120:\n        {\n            yymsp[-4].minor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[-4].minor.yy0, &yymsp[-2].minor.yy0);\n            if (yymsp[-4].minor.yy131)\n                yymsp[-4].minor.yy131->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 121:\n        {\n            yymsp[-2].minor.yy131 = sqlite3SrcListAppend(pParse, 0, &yymsp[-2].minor.yy0, 0);\n            if (yymsp[-2].minor.yy131)\n                yymsp[-2].minor.yy131->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 122:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 123:\n        {\n            yymsp[-1].minor.yy394 = sqlite3JoinType(pParse, &yymsp[-1].minor.yy0, 0, 0);\n        }\n        break;\n      case 124:\n        {\n            yymsp[-2].minor.yy394 = sqlite3JoinType(pParse, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0, 0);\n        }\n        break;\n      case 125:\n        {\n            yymsp[-3].minor.yy394 = sqlite3JoinType(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0);\n        }\n        break;\n      case 126:\n        {\n            yymsp[-1].minor.yy561.pOn = yymsp[0].minor.yy528;\n            yymsp[-1].minor.yy561.pUsing = 0;\n        }\n        break;\n      case 127:\n        {\n            yymsp[-3].minor.yy561.pOn = 0;\n            yymsp[-3].minor.yy561.pUsing = yymsp[-1].minor.yy254;\n        }\n        break;\n      case 128:\n        {\n            yymsp[1].minor.yy561.pOn = 0;\n            yymsp[1].minor.yy561.pUsing = 0;\n        }\n        break;\n      case 130:\n        {\n            yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;\n        }\n        break;\n      case 131:\n        {\n            yymsp[-1].minor.yy0.z = 0;\n            yymsp[-1].minor.yy0.n = 1;\n        }\n        break;\n      case 133:\n      case 143:\n        ;\n        {\n            yymsp[-2].minor.yy322 = yymsp[0].minor.yy322;\n        }\n        break;\n      case 134:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[-2].minor.yy528);\n            sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy322, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n        }\n        break;\n      case 135:\n        {\n            yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy322, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n        }\n        break;\n      case 136:\n        {\n            yymsp[0].minor.yy394 = 0;\n        }\n        break;\n      case 137:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 138:\n      case 141:\n        ;\n        {\n            yymsp[1].minor.yy394 = -1;\n        }\n        break;\n      case 139:\n        {\n            yymsp[-1].minor.yy394 = 0;\n        }\n        break;\n      case 140:\n        {\n            yymsp[-1].minor.yy394 = 1;\n        }\n        break;\n      case 144:\n      case 146:\n        ;\n      case 151:\n        ;\n      case 153:\n        ;\n      case 229:\n        ;\n      case 231:\n        ;\n      case 250:\n        ;\n        {\n            yymsp[1].minor.yy528 = 0;\n        }\n        break;\n      case 145:\n      case 152:\n        ;\n      case 154:\n        ;\n      case 228:\n        ;\n      case 249:\n        ;\n        {\n            yymsp[-1].minor.yy528 = yymsp[0].minor.yy528;\n        }\n        break;\n      case 147:\n        {\n            yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, 148, yymsp[0].minor.yy528, 0);\n        }\n        break;\n      case 148:\n        {\n            yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 148, yymsp[-2].minor.yy528, yymsp[0].minor.yy528);\n        }\n        break;\n      case 149:\n        {\n            yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 148, yymsp[0].minor.yy528, yymsp[-2].minor.yy528);\n        }\n        break;\n      case 150:\n        {\n            sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy131, &yymsp[-1].minor.yy0);\n            sqlite3DeleteFrom(pParse, yymsp[-2].minor.yy131, yymsp[0].minor.yy528, 0, 0);\n        }\n        break;\n      case 155:\n        {\n            sqlite3AddReturning(pParse, yymsp[0].minor.yy322);\n            yymsp[-1].minor.yy528 = 0;\n        }\n        break;\n      case 156:\n        {\n            sqlite3AddReturning(pParse, yymsp[0].minor.yy322);\n            yymsp[-3].minor.yy528 = yymsp[-2].minor.yy528;\n        }\n        break;\n      case 157:\n        {\n            sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy131, &yymsp[-4].minor.yy0);\n            sqlite3ExprListCheckLength(pParse, yymsp[-2].minor.yy322, \"set list\");\n            if (yymsp[-1].minor.yy131) {\n                SrcList *pFromClause = yymsp[-1].minor.yy131;\n                if (pFromClause->nSrc > 1) {\n                    Select *pSubquery;\n                    Token as;\n                    pSubquery = sqlite3SelectNew(pParse, 0, pFromClause, 0, 0, 0, 0, 2048, 0);\n                    as.n = 0;\n                    as.z = 0;\n                    pFromClause = sqlite3SrcListAppendFromTerm(pParse, 0, 0, 0, &as, pSubquery, 0);\n                }\n                yymsp[-5].minor.yy131 = sqlite3SrcListAppendList(pParse, yymsp[-5].minor.yy131, pFromClause);\n            }\n            sqlite3Update(pParse, yymsp[-5].minor.yy131, yymsp[-2].minor.yy322, yymsp[0].minor.yy528, yymsp[-6].minor.yy394, 0, 0, 0);\n        }\n        break;\n      case 158:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[0].minor.yy528);\n            sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy322, &yymsp[-2].minor.yy0, 1);\n        }\n        break;\n      case 159:\n        {\n            yymsp[-6].minor.yy322 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy322, yymsp[-3].minor.yy254, yymsp[0].minor.yy528);\n        }\n        break;\n      case 160:\n        {\n            yylhsminor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy528);\n            sqlite3ExprListSetName(pParse, yylhsminor.yy322, &yymsp[-2].minor.yy0, 1);\n        }\n        yymsp[-2].minor.yy322 = yylhsminor.yy322;\n        break;\n      case 161:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy254, yymsp[0].minor.yy528);\n        }\n        break;\n      case 162:\n        {\n            sqlite3Insert(pParse, yymsp[-3].minor.yy131, yymsp[-1].minor.yy47, yymsp[-2].minor.yy254, yymsp[-5].minor.yy394, yymsp[0].minor.yy444);\n        }\n        break;\n      case 163:\n        {\n            sqlite3Insert(pParse, yymsp[-4].minor.yy131, 0, yymsp[-3].minor.yy254, yymsp[-6].minor.yy394, 0);\n        }\n        break;\n      case 164:\n        {\n            yymsp[1].minor.yy444 = 0;\n        }\n        break;\n      case 165:\n        {\n            yymsp[-1].minor.yy444 = 0;\n            sqlite3AddReturning(pParse, yymsp[0].minor.yy322);\n        }\n        break;\n      case 166:\n        {\n            yymsp[-11].minor.yy444 = sqlite3UpsertNew(pParse->db, yymsp[-8].minor.yy322, yymsp[-6].minor.yy528, yymsp[-2].minor.yy322, yymsp[-1].minor.yy528, yymsp[0].minor.yy444);\n        }\n        break;\n      case 167:\n        {\n            yymsp[-8].minor.yy444 = sqlite3UpsertNew(pParse->db, yymsp[-5].minor.yy322, yymsp[-3].minor.yy528, 0, 0, yymsp[0].minor.yy444);\n        }\n        break;\n      case 168:\n        {\n            yymsp[-4].minor.yy444 = sqlite3UpsertNew(pParse->db, 0, 0, 0, 0, 0);\n        }\n        break;\n      case 169:\n        {\n            yymsp[-7].minor.yy444 = sqlite3UpsertNew(pParse->db, 0, 0, yymsp[-2].minor.yy322, yymsp[-1].minor.yy528, 0);\n        }\n        break;\n      case 170:\n        {\n            sqlite3AddReturning(pParse, yymsp[0].minor.yy322);\n        }\n        break;\n      case 173:\n        {\n            yymsp[1].minor.yy254 = 0;\n        }\n        break;\n      case 174:\n        {\n            yymsp[-2].minor.yy254 = yymsp[-1].minor.yy254;\n        }\n        break;\n      case 175:\n        {\n            yymsp[-2].minor.yy254 = sqlite3IdListAppend(pParse, yymsp[-2].minor.yy254, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 176:\n        {\n            yymsp[0].minor.yy254 = sqlite3IdListAppend(pParse, 0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 177:\n        {\n            yymsp[-2].minor.yy528 = yymsp[-1].minor.yy528;\n        }\n        break;\n      case 178:\n      case 179:\n        ;\n        {\n            yymsp[0].minor.yy528 = tokenExpr(pParse, 59, yymsp[0].minor.yy0);\n        }\n        break;\n      case 180:\n        {\n            Expr *temp1 = tokenExpr(pParse, 59, yymsp[-2].minor.yy0);\n            Expr *temp2 = tokenExpr(pParse, 59, yymsp[0].minor.yy0);\n            yylhsminor.yy528 = sqlite3PExpr(pParse, 141, temp1, temp2);\n        }\n        yymsp[-2].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 181:\n        {\n            Expr *temp1 = tokenExpr(pParse, 59, yymsp[-4].minor.yy0);\n            Expr *temp2 = tokenExpr(pParse, 59, yymsp[-2].minor.yy0);\n            Expr *temp3 = tokenExpr(pParse, 59, yymsp[0].minor.yy0);\n            Expr *temp4 = sqlite3PExpr(pParse, 141, temp2, temp3);\n            if ((pParse->eParseMode >= 2)) {\n                sqlite3RenameTokenRemap(pParse, 0, temp1);\n            }\n            yylhsminor.yy528 = sqlite3PExpr(pParse, 141, temp1, temp4);\n        }\n        yymsp[-4].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 182:\n      case 183:\n        ;\n        {\n            yymsp[0].minor.yy528 = tokenExpr(pParse, yymsp[0].major, yymsp[0].minor.yy0);\n        }\n        break;\n      case 184:\n        {\n            yylhsminor.yy528 = sqlite3ExprAlloc(pParse->db, 155, &yymsp[0].minor.yy0, 1);\n            if (yylhsminor.yy528)\n                yylhsminor.yy528->w.iOfst = (int)(yymsp[0].minor.yy0.z - pParse->zTail);\n        }\n        yymsp[0].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 185:\n        {\n            if (!(yymsp[0].minor.yy0.z[0] == '#' && (sqlite3CtypeMap[(unsigned char)(yymsp[0].minor.yy0.z[1])] & 4))) {\n                u32 n = yymsp[0].minor.yy0.n;\n                yymsp[0].minor.yy528 = tokenExpr(pParse, 156, yymsp[0].minor.yy0);\n                sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy528, n);\n            } else {\n                Token t = yymsp[0].minor.yy0;\n                assert(t.n >= 2);\n                if (pParse->nested == 0) {\n                    sqlite3ErrorMsg(pParse, \"near \\\"%T\\\": syntax error\", &t);\n                    yymsp[0].minor.yy528 = 0;\n                } else {\n                    yymsp[0].minor.yy528 = sqlite3PExpr(pParse, 176, 0, 0);\n                    if (yymsp[0].minor.yy528)\n                        sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy528->iTable);\n                }\n            }\n        }\n        break;\n      case 186:\n        {\n            yymsp[-2].minor.yy528 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy528, &yymsp[0].minor.yy0, 1);\n        }\n        break;\n      case 187:\n        {\n            yymsp[-5].minor.yy528 = sqlite3ExprAlloc(pParse->db, 36, &yymsp[-1].minor.yy0, 1);\n            sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy528, yymsp[-3].minor.yy528, 0);\n        }\n        break;\n      case 188:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy322, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy394);\n        }\n        yymsp[-4].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 189:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);\n        }\n        yymsp[-3].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 190:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy322, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy394);\n            sqlite3WindowAttach(pParse, yylhsminor.yy528, yymsp[0].minor.yy41);\n        }\n        yymsp[-5].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 191:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);\n            sqlite3WindowAttach(pParse, yylhsminor.yy528, yymsp[0].minor.yy41);\n        }\n        yymsp[-4].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 192:\n        {\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);\n        }\n        yymsp[0].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 193:\n        {\n            ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy322, yymsp[-1].minor.yy528);\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 177, 0, 0);\n            if (yymsp[-4].minor.yy528) {\n                yymsp[-4].minor.yy528->x.pList = pList;\n                if ((pList->nExpr)) {\n                    yymsp[-4].minor.yy528->flags |= pList->a[0].pExpr->flags & (512 | 4194304 | 8);\n                }\n            } else {\n                sqlite3ExprListDelete(pParse->db, pList);\n            }\n        }\n        break;\n      case 194:\n        {\n            yymsp[-2].minor.yy528 = sqlite3ExprAnd(pParse, yymsp[-2].minor.yy528, yymsp[0].minor.yy528);\n        }\n        break;\n      case 195:\n      case 196:\n        ;\n      case 197:\n        ;\n      case 198:\n        ;\n      case 199:\n        ;\n      case 200:\n        ;\n      case 201:\n        ;\n        {\n            yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[-2].minor.yy528, yymsp[0].minor.yy528);\n        }\n        break;\n      case 202:\n        {\n            yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;\n            yymsp[-1].minor.yy0.n |= 2147483648U;\n        }\n        break;\n      case 203:\n        {\n            ExprList *pList;\n            int bNot = yymsp[-1].minor.yy0.n & 2147483648U;\n            yymsp[-1].minor.yy0.n &= 2147483647;\n            pList = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[-2].minor.yy528);\n            yymsp[-2].minor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n            if (bNot)\n                yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-2].minor.yy528, 0);\n            if (yymsp[-2].minor.yy528)\n                yymsp[-2].minor.yy528->flags |= 256;\n        }\n        break;\n      case 204:\n        {\n            ExprList *pList;\n            int bNot = yymsp[-3].minor.yy0.n & 2147483648U;\n            yymsp[-3].minor.yy0.n &= 2147483647;\n            pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[-4].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy528);\n            yymsp[-4].minor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);\n            if (bNot)\n                yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n            if (yymsp[-4].minor.yy528)\n                yymsp[-4].minor.yy528->flags |= 256;\n        }\n        break;\n      case 205:\n        {\n            yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, yymsp[0].major, yymsp[-1].minor.yy528, 0);\n        }\n        break;\n      case 206:\n        {\n            yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, 51, yymsp[-2].minor.yy528, 0);\n        }\n        break;\n      case 207:\n        {\n            yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, 45, yymsp[-2].minor.yy528, yymsp[0].minor.yy528);\n            binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-2].minor.yy528, 50);\n        }\n        break;\n      case 208:\n        {\n            yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 171, yymsp[-3].minor.yy528, yymsp[0].minor.yy528);\n            binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-3].minor.yy528, 51);\n        }\n        break;\n      case 209:\n        {\n            yymsp[-5].minor.yy528 = sqlite3PExpr(pParse, 45, yymsp[-5].minor.yy528, yymsp[0].minor.yy528);\n            binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-5].minor.yy528, 50);\n        }\n        break;\n      case 210:\n        {\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 171, yymsp[-4].minor.yy528, yymsp[0].minor.yy528);\n            binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-4].minor.yy528, 51);\n        }\n        break;\n      case 211:\n      case 212:\n        ;\n        {\n            yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy528, 0);\n        }\n        break;\n      case 213:\n        {\n            yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, yymsp[-1].major == 106 ? 174 : 173, yymsp[0].minor.yy528, 0);\n        }\n        break;\n      case 214:\n        {\n            ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy528);\n            yylhsminor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n        }\n        yymsp[-2].minor.yy528 = yylhsminor.yy528;\n        break;\n      case 215:\n      case 218:\n        ;\n        {\n            yymsp[0].minor.yy394 = 0;\n        }\n        break;\n      case 217:\n        {\n            ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy528);\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 48, yymsp[-4].minor.yy528, 0);\n            if (yymsp[-4].minor.yy528) {\n                yymsp[-4].minor.yy528->x.pList = pList;\n            } else {\n                sqlite3ExprListDelete(pParse->db, pList);\n            }\n            if (yymsp[-3].minor.yy394)\n                yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n        }\n        break;\n      case 220:\n        {\n            if (yymsp[-1].minor.yy322 == 0) {\n                sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy528);\n                yymsp[-4].minor.yy528 = sqlite3Expr(pParse->db, 117, yymsp[-3].minor.yy394 ? \"true\" : \"false\");\n                if (yymsp[-4].minor.yy528)\n                    sqlite3ExprIdToTrueFalse(yymsp[-4].minor.yy528);\n            } else {\n                Expr *pRHS = yymsp[-1].minor.yy322->a[0].pExpr;\n                if (yymsp[-1].minor.yy322->nExpr == 1 && sqlite3ExprIsConstant(pRHS) && yymsp[-4].minor.yy528->op != 177) {\n                    yymsp[-1].minor.yy322->a[0].pExpr = 0;\n                    sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n                    pRHS = sqlite3PExpr(pParse, 174, pRHS, 0);\n                    yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 53, yymsp[-4].minor.yy528, pRHS);\n                } else {\n                    yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy528, 0);\n                    if (yymsp[-4].minor.yy528 == 0) {\n                        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n                    } else if (yymsp[-4].minor.yy528->pLeft->op == 177) {\n                        int nExpr = yymsp[-4].minor.yy528->pLeft->x.pList->nExpr;\n                        Select *pSelectRHS = sqlite3ExprListToValues(pParse, nExpr, yymsp[-1].minor.yy322);\n                        if (pSelectRHS) {\n                            parserDoubleLinkSelect(pParse, pSelectRHS);\n                            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, pSelectRHS);\n                        }\n                    } else {\n                        yymsp[-4].minor.yy528->x.pList = yymsp[-1].minor.yy322;\n                        sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy528);\n                    }\n                }\n                if (yymsp[-3].minor.yy394)\n                    yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n            }\n        }\n        break;\n      case 221:\n        {\n            yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, 138, 0, 0);\n            sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy528, yymsp[-1].minor.yy47);\n        }\n        break;\n      case 222:\n        {\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy528, 0);\n            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, yymsp[-1].minor.yy47);\n            if (yymsp[-3].minor.yy394)\n                yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n        }\n        break;\n      case 223:\n        {\n            SrcList *pSrc = sqlite3SrcListAppend(pParse, 0, &yymsp[-2].minor.yy0, &yymsp[-1].minor.yy0);\n            Select *pSelect = sqlite3SelectNew(pParse, 0, pSrc, 0, 0, 0, 0, 0, 0);\n            if (yymsp[0].minor.yy322)\n                sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy322);\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy528, 0);\n            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, pSelect);\n            if (yymsp[-3].minor.yy394)\n                yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy528, 0);\n        }\n        break;\n      case 224:\n        {\n            Expr *p;\n            p = yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 20, 0, 0);\n            sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy47);\n        }\n        break;\n      case 225:\n        {\n            yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, 157, yymsp[-3].minor.yy528, 0);\n            if (yymsp[-4].minor.yy528) {\n                yymsp[-4].minor.yy528->x.pList = yymsp[-1].minor.yy528 ? sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, yymsp[-1].minor.yy528) : yymsp[-2].minor.yy322;\n                sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy528);\n            } else {\n                sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy322);\n                sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy528);\n            }\n        }\n        break;\n      case 226:\n        {\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[-2].minor.yy528);\n            yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[0].minor.yy528);\n        }\n        break;\n      case 227:\n        {\n            yymsp[-3].minor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n            yymsp[-3].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy322, yymsp[0].minor.yy528);\n        }\n        break;\n      case 230:\n        {\n            yymsp[0].minor.yy528 = yymsp[0].minor.yy528;\n        }\n        break;\n      case 233:\n        {\n            yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, yymsp[0].minor.yy528);\n        }\n        break;\n      case 234:\n        {\n            yymsp[0].minor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy528);\n        }\n        break;\n      case 236:\n      case 241:\n        ;\n        {\n            yymsp[-2].minor.yy322 = yymsp[-1].minor.yy322;\n        }\n        break;\n      case 237:\n        {\n            sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, sqlite3SrcListAppend(pParse, 0, &yymsp[-4].minor.yy0, 0), yymsp[-2].minor.yy322, yymsp[-10].minor.yy394, &yymsp[-11].minor.yy0, yymsp[0].minor.yy528, 0, yymsp[-8].minor.yy394, 0);\n            if ((pParse->eParseMode >= 2) && pParse->pNewIndex) {\n                sqlite3RenameTokenMap(pParse, pParse->pNewIndex->zName, &yymsp[-4].minor.yy0);\n            }\n        }\n        break;\n      case 238:\n      case 280:\n        ;\n        {\n            yymsp[0].minor.yy394 = 2;\n        }\n        break;\n      case 239:\n        {\n            yymsp[1].minor.yy394 = 0;\n        }\n        break;\n      case 242:\n        {\n            yymsp[-4].minor.yy322 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy322, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n        }\n        break;\n      case 243:\n        {\n            yymsp[-2].minor.yy322 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n        }\n        break;\n      case 246:\n        {\n            sqlite3DropIndex(pParse, yymsp[0].minor.yy131, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 247:\n        {\n            sqlite3Vacuum(pParse, 0, yymsp[0].minor.yy528);\n        }\n        break;\n      case 248:\n        {\n            sqlite3Vacuum(pParse, &yymsp[-1].minor.yy0, yymsp[0].minor.yy528);\n        }\n        break;\n      case 251:\n        {\n            sqlite3Pragma(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0, 0, 0);\n        }\n        break;\n      case 252:\n        {\n            sqlite3Pragma(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, 0);\n        }\n        break;\n      case 253:\n        {\n            sqlite3Pragma(pParse, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-1].minor.yy0, 0);\n        }\n        break;\n      case 254:\n        {\n            sqlite3Pragma(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, 1);\n        }\n        break;\n      case 255:\n        {\n            sqlite3Pragma(pParse, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-1].minor.yy0, 1);\n        }\n        break;\n      case 258:\n        {\n            Token all;\n            all.z = yymsp[-3].minor.yy0.z;\n            all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;\n            sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy33, &all);\n        }\n        break;\n      case 259:\n        {\n            sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy394, yymsp[-4].minor.yy180.a, yymsp[-4].minor.yy180.b, yymsp[-2].minor.yy131, yymsp[0].minor.yy528, yymsp[-10].minor.yy394, yymsp[-8].minor.yy394);\n            yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n == 0 ? yymsp[-7].minor.yy0 : yymsp[-6].minor.yy0);\n        }\n        break;\n      case 260:\n        {\n            yymsp[0].minor.yy394 = yymsp[0].major;\n        }\n        break;\n      case 261:\n        {\n            yymsp[-1].minor.yy394 = 65;\n        }\n        break;\n      case 262:\n        {\n            yymsp[1].minor.yy394 = 33;\n        }\n        break;\n      case 263:\n      case 264:\n        ;\n        {\n            yymsp[0].minor.yy180.a = yymsp[0].major;\n            yymsp[0].minor.yy180.b = 0;\n        }\n        break;\n      case 265:\n        {\n            yymsp[-2].minor.yy180.a = 129;\n            yymsp[-2].minor.yy180.b = yymsp[0].minor.yy254;\n        }\n        break;\n      case 266:\n      case 285:\n        ;\n        {\n            yymsp[1].minor.yy528 = 0;\n        }\n        break;\n      case 267:\n      case 286:\n        ;\n        {\n            yymsp[-1].minor.yy528 = yymsp[0].minor.yy528;\n        }\n        break;\n      case 268:\n        {\n            assert(yymsp[-2].minor.yy33 != 0);\n            yymsp[-2].minor.yy33->pLast->pNext = yymsp[-1].minor.yy33;\n            yymsp[-2].minor.yy33->pLast = yymsp[-1].minor.yy33;\n        }\n        break;\n      case 269:\n        {\n            assert(yymsp[-1].minor.yy33 != 0);\n            yymsp[-1].minor.yy33->pLast = yymsp[-1].minor.yy33;\n        }\n        break;\n      case 270:\n        {\n            yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;\n            sqlite3ErrorMsg(pParse, \"qualified table names are not allowed on INSERT, UPDATE, and DELETE statements within triggers\");\n        }\n        break;\n      case 271:\n        {\n            sqlite3ErrorMsg(pParse, \"the INDEXED BY clause is not allowed on UPDATE or DELETE statements within triggers\");\n        }\n        break;\n      case 272:\n        {\n            sqlite3ErrorMsg(pParse, \"the NOT INDEXED clause is not allowed on UPDATE or DELETE statements within triggers\");\n        }\n        break;\n      case 273:\n        {\n            yylhsminor.yy33 = sqlite3TriggerUpdateStep(pParse, &yymsp[-6].minor.yy0, yymsp[-2].minor.yy131, yymsp[-3].minor.yy322, yymsp[-1].minor.yy528, yymsp[-7].minor.yy394, yymsp[-8].minor.yy0.z, yymsp[0].minor.yy522);\n        }\n        yymsp[-8].minor.yy33 = yylhsminor.yy33;\n        break;\n      case 274:\n        {\n            yylhsminor.yy33 = sqlite3TriggerInsertStep(pParse, &yymsp[-4].minor.yy0, yymsp[-3].minor.yy254, yymsp[-2].minor.yy47, yymsp[-6].minor.yy394, yymsp[-1].minor.yy444, yymsp[-7].minor.yy522, yymsp[0].minor.yy522);\n        }\n        yymsp[-7].minor.yy33 = yylhsminor.yy33;\n        break;\n      case 275:\n        {\n            yylhsminor.yy33 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy528, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy522);\n        }\n        yymsp[-5].minor.yy33 = yylhsminor.yy33;\n        break;\n      case 276:\n        {\n            yylhsminor.yy33 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy47, yymsp[-2].minor.yy522, yymsp[0].minor.yy522);\n        }\n        yymsp[-2].minor.yy33 = yylhsminor.yy33;\n        break;\n      case 277:\n        {\n            yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, 71, 0, 0);\n            if (yymsp[-3].minor.yy528) {\n                yymsp[-3].minor.yy528->affExpr = 4;\n            }\n        }\n        break;\n      case 278:\n        {\n            yymsp[-5].minor.yy528 = sqlite3ExprAlloc(pParse->db, 71, &yymsp[-1].minor.yy0, 1);\n            if (yymsp[-5].minor.yy528) {\n                yymsp[-5].minor.yy528->affExpr = (char)yymsp[-3].minor.yy394;\n            }\n        }\n        break;\n      case 279:\n        {\n            yymsp[0].minor.yy394 = 1;\n        }\n        break;\n      case 281:\n        {\n            yymsp[0].minor.yy394 = 3;\n        }\n        break;\n      case 282:\n        {\n            sqlite3DropTrigger(pParse, yymsp[0].minor.yy131, yymsp[-1].minor.yy394);\n        }\n        break;\n      case 283:\n        {\n            sqlite3Attach(pParse, yymsp[-3].minor.yy528, yymsp[-1].minor.yy528, yymsp[0].minor.yy528);\n        }\n        break;\n      case 284:\n        {\n            sqlite3Detach(pParse, yymsp[0].minor.yy528);\n        }\n        break;\n      case 287:\n        {\n            sqlite3Reindex(pParse, 0, 0);\n        }\n        break;\n      case 288:\n        {\n            sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 289:\n        {\n            sqlite3Analyze(pParse, 0, 0);\n        }\n        break;\n      case 290:\n        {\n            sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 291:\n        {\n            sqlite3AlterRenameTable(pParse, yymsp[-3].minor.yy131, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 292:\n        {\n            yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z - yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;\n            sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0);\n        }\n        break;\n      case 293:\n        {\n            sqlite3AlterDropColumn(pParse, yymsp[-3].minor.yy131, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 294:\n        {\n            disableLookaside(pParse);\n            sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy131);\n        }\n        break;\n      case 295:\n        {\n            sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy131, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 296:\n        {\n            sqlite3VtabFinishParse(pParse, 0);\n        }\n        break;\n      case 297:\n        {\n            sqlite3VtabFinishParse(pParse, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 298:\n        {\n            sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy394);\n        }\n        break;\n      case 299:\n        {\n            sqlite3VtabArgInit(pParse);\n        }\n        break;\n      case 300:\n      case 301:\n        ;\n      case 302:\n        ;\n        {\n            sqlite3VtabArgExtend(pParse, &yymsp[0].minor.yy0);\n        }\n        break;\n      case 303:\n      case 304:\n        ;\n        {\n            sqlite3WithPush(pParse, yymsp[0].minor.yy521, 1);\n        }\n        break;\n      case 305:\n        {\n            yymsp[0].minor.yy516 = 1;\n        }\n        break;\n      case 306:\n        {\n            yymsp[-1].minor.yy516 = 0;\n        }\n        break;\n      case 307:\n        {\n            yymsp[-2].minor.yy516 = 2;\n        }\n        break;\n      case 308:\n        {\n            yymsp[-5].minor.yy385 = sqlite3CteNew(pParse, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy322, yymsp[-1].minor.yy47, yymsp[-3].minor.yy516);\n        }\n        break;\n      case 309:\n        {\n            yymsp[0].minor.yy521 = sqlite3WithAdd(pParse, 0, yymsp[0].minor.yy385);\n        }\n        break;\n      case 310:\n        {\n            yymsp[-2].minor.yy521 = sqlite3WithAdd(pParse, yymsp[-2].minor.yy521, yymsp[0].minor.yy385);\n        }\n        break;\n      case 311:\n        {\n            yylhsminor.yy41 = yymsp[0].minor.yy41;\n        }\n        yymsp[0].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 312:\n        {\n            assert(yymsp[0].minor.yy41 != 0);\n            sqlite3WindowChain(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy41);\n            yymsp[0].minor.yy41->pNextWin = yymsp[-2].minor.yy41;\n            yylhsminor.yy41 = yymsp[0].minor.yy41;\n        }\n        yymsp[-2].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 313:\n        {\n            if ((yymsp[-1].minor.yy41)) {\n                yymsp[-1].minor.yy41->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);\n            }\n            yylhsminor.yy41 = yymsp[-1].minor.yy41;\n        }\n        yymsp[-4].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 314:\n        {\n            yymsp[-4].minor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy322, yymsp[-1].minor.yy322, 0);\n        }\n        break;\n      case 315:\n        {\n            yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy322, yymsp[-1].minor.yy322, &yymsp[-5].minor.yy0);\n        }\n        yymsp[-5].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 316:\n        {\n            yymsp[-3].minor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, yymsp[-1].minor.yy322, 0);\n        }\n        break;\n      case 317:\n        {\n            yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, yymsp[-1].minor.yy322, &yymsp[-4].minor.yy0);\n        }\n        yymsp[-4].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 318:\n      case 337:\n        ;\n        {\n            yylhsminor.yy41 = yymsp[0].minor.yy41;\n        }\n        yymsp[0].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 319:\n        {\n            yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, 0, &yymsp[-1].minor.yy0);\n        }\n        yymsp[-1].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 320:\n        {\n            yymsp[1].minor.yy41 = sqlite3WindowAlloc(pParse, 0, 90, 0, 85, 0, 0);\n        }\n        break;\n      case 321:\n        {\n            yylhsminor.yy41 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy394, yymsp[-1].minor.yy595.eType, yymsp[-1].minor.yy595.pExpr, 85, 0, yymsp[0].minor.yy516);\n        }\n        yymsp[-2].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 322:\n        {\n            yylhsminor.yy41 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy394, yymsp[-3].minor.yy595.eType, yymsp[-3].minor.yy595.pExpr, yymsp[-1].minor.yy595.eType, yymsp[-1].minor.yy595.pExpr, yymsp[0].minor.yy516);\n        }\n        yymsp[-5].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 324:\n      case 326:\n        ;\n        {\n            yylhsminor.yy595 = yymsp[0].minor.yy595;\n        }\n        yymsp[0].minor.yy595 = yylhsminor.yy595;\n        break;\n      case 325:\n      case 327:\n        ;\n      case 329:\n        ;\n        {\n            yylhsminor.yy595.eType = yymsp[-1].major;\n            yylhsminor.yy595.pExpr = 0;\n        }\n        yymsp[-1].minor.yy595 = yylhsminor.yy595;\n        break;\n      case 328:\n        {\n            yylhsminor.yy595.eType = yymsp[0].major;\n            yylhsminor.yy595.pExpr = yymsp[-1].minor.yy528;\n        }\n        yymsp[-1].minor.yy595 = yylhsminor.yy595;\n        break;\n      case 330:\n        {\n            yymsp[1].minor.yy516 = 0;\n        }\n        break;\n      case 331:\n        {\n            yymsp[-1].minor.yy516 = yymsp[0].minor.yy516;\n        }\n        break;\n      case 332:\n      case 333:\n        ;\n        {\n            yymsp[-1].minor.yy516 = yymsp[-1].major;\n        }\n        break;\n      case 334:\n        {\n            yymsp[0].minor.yy516 = yymsp[0].major;\n        }\n        break;\n      case 335:\n        {\n            yymsp[-1].minor.yy41 = yymsp[0].minor.yy41;\n        }\n        break;\n      case 336:\n        {\n            if (yymsp[0].minor.yy41) {\n                yymsp[0].minor.yy41->pFilter = yymsp[-1].minor.yy528;\n            } else {\n                sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy528);\n            }\n            yylhsminor.yy41 = yymsp[0].minor.yy41;\n        }\n        yymsp[-1].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 338:\n        {\n            yylhsminor.yy41 = (Window *)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n            if (yylhsminor.yy41) {\n                yylhsminor.yy41->eFrmType = 166;\n                yylhsminor.yy41->pFilter = yymsp[0].minor.yy528;\n            } else {\n                sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy528);\n            }\n        }\n        yymsp[0].minor.yy41 = yylhsminor.yy41;\n        break;\n      case 339:\n        {\n            yymsp[-3].minor.yy41 = yymsp[-1].minor.yy41;\n            assert(yymsp[-3].minor.yy41 != 0);\n        }\n        break;\n      case 340:\n        {\n            yymsp[-1].minor.yy41 = (Window *)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n            if (yymsp[-1].minor.yy41) {\n                yymsp[-1].minor.yy41->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);\n            }\n        }\n        break;\n      case 341:\n        {\n            yymsp[-4].minor.yy528 = yymsp[-1].minor.yy528;\n        }\n        break;\n      default:\n        ;\n        ;\n        assert(yyruleno != 344);\n        ;\n        ;\n        assert(yyruleno != 347);\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        assert(yyruleno != 354);\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        assert(yyruleno != 362);\n        assert(yyruleno != 363);\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        assert(yyruleno != 371);\n        ;\n        assert(yyruleno != 373);\n        assert(yyruleno != 374);\n        assert(yyruleno != 375);\n        ;\n        ;\n        ;\n        assert(yyruleno != 379);\n        ;\n        assert(yyruleno != 381);\n        ;\n        ;\n        assert(yyruleno != 384);\n        assert(yyruleno != 385);\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        ;\n        break;\n    }\n    ;\n    assert(yyruleno < sizeof (yyRuleInfoLhs) / sizeof (yyRuleInfoLhs[0]));\n    yygoto = yyRuleInfoLhs[yyruleno];\n    yysize = yyRuleInfoNRhs[yyruleno];\n    yyact = yy_find_reduce_action(yymsp[yysize].stateno, (unsigned short)yygoto);\n    assert(!(yyact > 575 && yyact <= 1239));\n    assert(yyact != 1240);\n    yymsp += yysize + 1;\n    yypParser->yytos = yymsp;\n    yymsp->stateno = (unsigned short)yyact;\n    yymsp->major = (unsigned short)yygoto;\n    ;\n    return yyact;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#162874:1#selectWindowRewriteExprCb",
            "nobreaks": 1,
            "body": "{\n    struct WindowRewrite *p = pWalker->u.pRewrite;\n    Parse *pParse = pWalker->pParse;\n    assert(p != 0);\n    assert(p->pWin != 0);\n    if (p->pSubSelect) {\n        if (pExpr->op != 167) {\n            return 0;\n        } else {\n            int nSrc = p->pSrc->nSrc;\n            int i;\n            for (i = 0; i < nSrc; i++) {\n                if (pExpr->iTable == p->pSrc->a[i].iCursor)\n                    break;\n            }\n            if (i == nSrc)\n                return 0;\n        }\n    }\n    switch (pExpr->op) {\n      case 172:\n        if (!(((pExpr)->flags & (16777216)) != 0)) {\n            break;\n        } else {\n            Window *pWin;\n            for (pWin = p->pWin; pWin; pWin = pWin->pNextWin) {\n                if (pExpr->y.pWin == pWin) {\n                    assert(pWin->pOwner == pExpr);\n                    return 1;\n                }\n            }\n        }\n      case 168:\n      case 167:\n        {\n            int iCol = -1;\n            if (pParse->db->mallocFailed)\n                return 2;\n            if (p->pSub) {\n                int i;\n                for (i = 0; i < p->pSub->nExpr; i++) {\n                    if (0 == sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1)) {\n                        iCol = i;\n                        break;\n                    }\n                }\n            }\n            if (iCol < 0) {\n                Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);\n                if (pDup && pDup->op == 168)\n                    pDup->op = 172;\n                p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);\n            }\n            if (p->pSub) {\n                int f = pExpr->flags & 512;\n                assert((((pExpr)->flags & (134217728)) != 0) == 0);\n                (pExpr)->flags |= (134217728);\n                sqlite3ExprDelete(pParse->db, pExpr);\n                (pExpr)->flags &= ~(134217728);\n                memset(pExpr, 0, sizeof(Expr));\n                pExpr->op = 167;\n                pExpr->iColumn = (iCol < 0 ? p->pSub->nExpr - 1 : iCol);\n                pExpr->iTable = p->pWin->iEphCsr;\n                pExpr->y.pTab = p->pTab;\n                pExpr->flags = f;\n            }\n            if (pParse->db->mallocFailed)\n                return 2;\n            break;\n        }\n      default:\n        break;\n    }\n    return 0;\n}\n"
        },
        {
            "id": "#23:25#sqlite3ExprIfTrue",
            "nobreaks": 1,
            "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    assert(jumpIfNull == 16 || jumpIfNull == 0);\n    if ((v == 0))\n        return;\n    if ((pExpr == 0))\n        return;\n    assert(!0);\n    op = pExpr->op;\n    switch (op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);\n            } else if (op == 44) {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            } else {\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            } else {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (op == 45) ? 53 : 52;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            assert(56 == 56);\n            ;\n            ;\n            assert(55 == 55);\n            ;\n            ;\n            assert(54 == 54);\n            ;\n            ;\n            assert(57 == 57);\n            ;\n            ;\n            assert(53 == 53);\n            ;\n            ;\n            ;\n            assert(52 == 52);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            assert(50 == 50);\n            ;\n            assert(51 == 51);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = jumpIfNull ? dest : destIfFalse;\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeGoto(v, dest);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 16, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
        },
        {
            "id": "#23:25#sqlite3ExprCodeTarget",
            "nobreaks": 1,
            "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op;\n    int inReg = target;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    Expr tempX;\n    int p5 = 0;\n    assert(target > 0 && target <= pParse->nMem);\n    assert(v != 0);\n  expr_code_doover:\n    if (pExpr == 0) {\n        op = 121;\n    } else if (pParse->pIdxExpr != 0 && !(((pExpr)->flags & (8388608)) != 0) && (r1 = sqlite3IndexedExprLookup(pParse, pExpr, target)) >= 0) {\n        return r1;\n    } else {\n        assert(!0);\n        op = pExpr->op;\n    }\n    switch (op) {\n      case 169:\n        {\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            struct AggInfo_col *pCol;\n            assert(pAggInfo != 0);\n            assert(pExpr->iAgg >= 0 && pExpr->iAgg < pAggInfo->nColumn);\n            pCol = &pAggInfo->aCol[pExpr->iAgg];\n            if (!pAggInfo->directMode) {\n                assert(pCol->iMem > 0);\n                return pCol->iMem;\n            } else if (pAggInfo->useSortingIdx) {\n                Table *pTab = pCol->pTab;\n                sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pCol->iSorterColumn, target);\n                if (pCol->iColumn < 0) {\n                    ;\n                } else if ((pTab != 0)) {\n                    ;\n                    if (pTab->aCol[pCol->iColumn].affinity == 69) {\n                        sqlite3VdbeAddOp1(v, 87, target);\n                    }\n                }\n                return target;\n            }\n        }\n      case 167:\n        {\n            int iTab = pExpr->iTable;\n            int iReg;\n            if ((((pExpr)->flags & (32)) != 0)) {\n                int aff;\n                iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                assert(pExpr->y.pTab != 0);\n                aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n                if (aff > 65) {\n                    static const char zAff[] = \"B\\000C\\000D\\000E\";\n                    assert(65 == 'A');\n                    assert(66 == 'B');\n                    sqlite3VdbeAddOp4(v, 96, iReg, 1, 0, &zAff[(aff - 'B') * 2], (-1));\n                }\n                return iReg;\n            }\n            if (iTab < 0) {\n                if (pParse->iSelfTab < 0) {\n                    Column *pCol;\n                    Table *pTab;\n                    int iSrc;\n                    int iCol = pExpr->iColumn;\n                    assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                    pTab = pExpr->y.pTab;\n                    assert(pTab != 0);\n                    assert(iCol >= (-1));\n                    assert(iCol < pTab->nCol);\n                    if (iCol < 0) {\n                        return -1 - pParse->iSelfTab;\n                    }\n                    pCol = pTab->aCol + iCol;\n                    ;\n                    iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n                    if (pCol->colFlags & 96) {\n                        if (pCol->colFlags & 256) {\n                            sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zCnName);\n                            return 0;\n                        }\n                        pCol->colFlags |= 256;\n                        if (pCol->colFlags & 128) {\n                            sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc);\n                        }\n                        pCol->colFlags &= ~(256 | 128);\n                        return iSrc;\n                    } else if (pCol->affinity == 69) {\n                        sqlite3VdbeAddOp2(v, 81, iSrc, target);\n                        sqlite3VdbeAddOp1(v, 87, target);\n                        return target;\n                    } else {\n                        return iSrc;\n                    }\n                } else {\n                    iTab = pParse->iSelfTab - 1;\n                }\n            }\n            assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n            assert(pExpr->y.pTab != 0);\n            iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab, pExpr->iColumn, iTab, target, pExpr->op2);\n            return iReg;\n        }\n      case 155:\n        {\n            codeInteger(pParse, pExpr, 0, target);\n            return target;\n        }\n      case 170:\n        {\n            sqlite3VdbeAddOp2(v, 71, sqlite3ExprTruthValue(pExpr), target);\n            return target;\n        }\n      case 153:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            codeReal(v, pExpr->u.zToken, 0, target);\n            return target;\n        }\n      case 117:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n            return target;\n        }\n      default:\n        {\n            assert(op == 121 || op == 182 || pParse->db->mallocFailed);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            return target;\n        }\n      case 154:\n        {\n            int n;\n            const char *z;\n            char *zBlob;\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            assert(pExpr->u.zToken[0] == 'x' || pExpr->u.zToken[0] == 'X');\n            assert(pExpr->u.zToken[1] == '\\'');\n            z = &pExpr->u.zToken[2];\n            n = sqlite3Strlen30(z) - 1;\n            assert(z[n] == '\\'');\n            zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n            sqlite3VdbeAddOp4(v, 77, n / 2, target, 0, zBlob, (-6));\n            return target;\n        }\n      case 156:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            assert(pExpr->u.zToken != 0);\n            assert(pExpr->u.zToken[0] != 0);\n            sqlite3VdbeAddOp2(v, 78, pExpr->iColumn, target);\n            if (pExpr->u.zToken[1] != 0) {\n                const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n                assert(pExpr->u.zToken[0] == '?' || (z && !strcmp(pExpr->u.zToken, z)));\n                pParse->pVList[0] = 0;\n                sqlite3VdbeAppendP4(v, (char *)z, (-1));\n            }\n            return target;\n        }\n      case 176:\n        {\n            return pExpr->iTable;\n        }\n      case 36:\n        {\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            if (inReg != target) {\n                sqlite3VdbeAddOp2(v, 81, inReg, target);\n                inReg = target;\n            }\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            sqlite3VdbeAddOp2(v, 88, target, sqlite3AffinityType(pExpr->u.zToken, 0));\n            return inReg;\n        }\n      case 45:\n      case 171:\n        op = (op == 45) ? 53 : 52;\n        p5 = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            if (sqlite3ExprIsVector(pLeft)) {\n                codeVectorCompare(pParse, pExpr, target, op, p5);\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n                sqlite3VdbeAddOp2(v, 71, 1, inReg);\n                codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2, sqlite3VdbeCurrentAddr(v) + 2, p5, (((pExpr)->flags & (1024)) != 0));\n                assert(56 == 56);\n                ;\n                ;\n                assert(55 == 55);\n                ;\n                ;\n                assert(54 == 54);\n                ;\n                ;\n                assert(57 == 57);\n                ;\n                ;\n                assert(53 == 53);\n                ;\n                ;\n                assert(52 == 52);\n                ;\n                ;\n                if (p5 == 128) {\n                    sqlite3VdbeAddOp2(v, 71, 0, inReg);\n                } else {\n                    sqlite3VdbeAddOp3(v, 92, r1, inReg, r2);\n                }\n                ;\n                ;\n            }\n            break;\n        }\n      case 44:\n      case 43:\n      case 106:\n      case 108:\n      case 107:\n      case 110:\n      case 102:\n      case 103:\n      case 109:\n      case 104:\n      case 105:\n      case 111:\n        {\n            assert(44 == 44);\n            ;\n            assert(43 == 43);\n            ;\n            assert(106 == 106);\n            ;\n            assert(107 == 107);\n            ;\n            assert(110 == 110);\n            ;\n            assert(102 == 102);\n            ;\n            assert(103 == 103);\n            ;\n            assert(109 == 109);\n            ;\n            assert(104 == 104);\n            ;\n            assert(105 == 105);\n            ;\n            assert(111 == 111);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            sqlite3VdbeAddOp3(v, op, r2, r1, target);\n            ;\n            ;\n            break;\n        }\n      case 173:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            assert(pLeft);\n            if (pLeft->op == 155) {\n                codeInteger(pParse, pLeft, 1, target);\n                return target;\n            } else if (pLeft->op == 153) {\n                assert(!(((pExpr)->flags & (2048)) != 0));\n                codeReal(v, pLeft->u.zToken, 1, target);\n                return target;\n            } else {\n                tempX.op = 155;\n                tempX.flags = 2048 | 65536;\n                tempX.u.iValue = 0;\n                ;\n                r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n                sqlite3VdbeAddOp3(v, 107, r2, r1, target);\n                ;\n            }\n            break;\n        }\n      case 114:\n      case 19:\n        {\n            assert(114 == 114);\n            ;\n            assert(19 == 19);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            sqlite3VdbeAddOp2(v, op, r1, inReg);\n            break;\n        }\n      case 175:\n        {\n            int isTrue;\n            int bNormal;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            bNormal = pExpr->op2 == 45;\n            ;\n            ;\n            sqlite3VdbeAddOp4Int(v, 91, r1, inReg, !isTrue, isTrue ^ bNormal);\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            int addr;\n            assert(50 == 50);\n            ;\n            assert(51 == 51);\n            ;\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            addr = sqlite3VdbeAddOp1(v, op, r1);\n            ;\n            ;\n            sqlite3VdbeAddOp2(v, 71, 0, target);\n            sqlite3VdbeJumpHere(v, addr);\n            break;\n        }\n      case 168:\n        {\n            AggInfo *pInfo = pExpr->pAggInfo;\n            if (pInfo == 0 || (pExpr->iAgg < 0) || (pExpr->iAgg >= pInfo->nFunc)) {\n                assert(!(((pExpr)->flags & (2048)) != 0));\n                sqlite3ErrorMsg(pParse, \"misuse of aggregate: %#T()\", pExpr);\n            } else {\n                return pInfo->aFunc[pExpr->iAgg].iMem;\n            }\n            break;\n        }\n      case 172:\n        {\n            ExprList *pFarg;\n            int nFarg;\n            FuncDef *pDef;\n            const char *zId;\n            u32 constMask = 0;\n            int i;\n            sqlite3 *db = pParse->db;\n            u8 enc = ((db)->enc);\n            CollSeq *pColl = 0;\n            if ((((pExpr)->flags & (16777216)) != 0)) {\n                return pExpr->y.pWin->regResult;\n            }\n            if (((pParse)->okConstFactor) && sqlite3ExprIsConstantNotJoin(pExpr)) {\n                return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);\n            }\n            assert(!(((pExpr)->flags & (65536)) != 0));\n            assert((((pExpr)->flags & 4096) == 0));\n            pFarg = pExpr->x.pList;\n            nFarg = pFarg ? pFarg->nExpr : 0;\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            zId = pExpr->u.zToken;\n            pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n            if (pDef == 0 || pDef->xFinalize != 0) {\n                sqlite3ErrorMsg(pParse, \"unknown function: %#T()\", pExpr);\n                break;\n            }\n            if (pDef->funcFlags & 4194304) {\n                assert((pDef->funcFlags & 2097152) == 0);\n                assert((pDef->funcFlags & 524288) == 0);\n                return exprCodeInlineFunction(pParse, pFarg, ((int)(long)(pDef->pUserData)), target);\n            } else if (pDef->funcFlags & (524288 | 2097152)) {\n                sqlite3ExprFunctionUsable(pParse, pExpr, pDef);\n            }\n            for (i = 0; i < nFarg; i++) {\n                if (i < 32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr)) {\n                    ;\n                    constMask |= (((unsigned int)1) << (i));\n                }\n                if ((pDef->funcFlags & 32) != 0 && !pColl) {\n                    pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n                }\n            }\n            if (pFarg) {\n                if (constMask) {\n                    r1 = pParse->nMem + 1;\n                    pParse->nMem += nFarg;\n                } else {\n                    r1 = sqlite3GetTempRange(pParse, nFarg);\n                }\n                if ((pDef->funcFlags & (64 | 128)) != 0) {\n                    u8 exprOp;\n                    assert(nFarg == 1);\n                    assert(pFarg->a[0].pExpr != 0);\n                    exprOp = pFarg->a[0].pExpr->op;\n                    if (exprOp == 167 || exprOp == 169) {\n                        assert(64 == 64);\n                        assert(128 == 128);\n                        ;\n                        pFarg->a[0].pExpr->op2 = pDef->funcFlags & (64 | 128);\n                    }\n                }\n                sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, 1 | 2);\n            } else {\n                r1 = 0;\n            }\n            if (nFarg >= 2 && (((pExpr)->flags & (256)) != 0)) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n            } else if (nFarg > 0) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n            }\n            if (pDef->funcFlags & 32) {\n                if (!pColl)\n                    pColl = db->pDfltColl;\n                sqlite3VdbeAddOp4(v, 85, 0, 0, 0, (char *)pColl, (-2));\n            }\n            sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg, pDef, pExpr->op2);\n            if (nFarg) {\n                if (constMask == 0) {\n                    sqlite3ReleaseTempRange(pParse, r1, nFarg);\n                } else {\n                    ;\n                }\n            }\n            return target;\n        }\n      case 20:\n      case 138:\n        {\n            int nCol;\n            ;\n            ;\n            if (pParse->db->mallocFailed) {\n                return 0;\n            } else if (op == 138 && ((((pExpr)->flags & 4096) != 0)) && (nCol = pExpr->x.pSelect->pEList->nExpr) != 1) {\n                sqlite3SubselectError(pParse, nCol, 1);\n            } else {\n                return sqlite3CodeSubselect(pParse, pExpr);\n            }\n            break;\n        }\n      case 178:\n        {\n            int n;\n            Expr *pLeft = pExpr->pLeft;\n            if (pLeft->iTable == 0 || pParse->withinRJSubrtn > pLeft->op2) {\n                pLeft->iTable = sqlite3CodeSubselect(pParse, pLeft);\n                pLeft->op2 = pParse->withinRJSubrtn;\n            }\n            assert(pLeft->op == 138 || pLeft->op == 182);\n            n = sqlite3ExprVectorSize(pLeft);\n            if (pExpr->iTable != n) {\n                sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\", pExpr->iTable, n);\n            }\n            return pLeft->iTable + pExpr->iColumn;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = sqlite3VdbeMakeLabel(pParse);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            sqlite3VdbeAddOp2(v, 86, target, 0);\n            sqlite3VdbeResolveLabel(v, destIfNull);\n            return target;\n        }\n      case 48:\n        {\n            exprCodeBetween(pParse, pExpr, target, 0, 0);\n            return target;\n        }\n      case 113:\n        {\n            if (!(((pExpr)->flags & (512)) != 0) && (pExpr->pLeft) && pExpr->pLeft->op == 172) {\n                inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                if (inReg != target) {\n                    sqlite3VdbeAddOp2(v, 81, inReg, target);\n                    inReg = target;\n                }\n                sqlite3VdbeAddOp1(v, 179, inReg);\n                return inReg;\n            } else {\n                pExpr = pExpr->pLeft;\n                goto expr_code_doover;\n            }\n        }\n      case 181:\n      case 174:\n        {\n            pExpr = pExpr->pLeft;\n            goto expr_code_doover;\n        }\n      case 77:\n        {\n            Table *pTab;\n            int iCol;\n            int p1;\n            assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n            pTab = pExpr->y.pTab;\n            iCol = pExpr->iColumn;\n            p1 = pExpr->iTable * (pTab->nCol + 1) + 1 + sqlite3TableColumnToStorage(pTab, iCol);\n            assert(pExpr->iTable == 0 || pExpr->iTable == 1);\n            assert(iCol >= -1 && iCol < pTab->nCol);\n            assert(pTab->iPKey < 0 || iCol != pTab->iPKey);\n            assert(p1 >= 0 && p1 < (pTab->nCol * 2 + 2));\n            sqlite3VdbeAddOp2(v, 157, p1, target);\n            ;\n            if (iCol >= 0 && pTab->aCol[iCol].affinity == 69) {\n                sqlite3VdbeAddOp1(v, 87, target);\n            }\n            break;\n        }\n      case 177:\n        {\n            sqlite3ErrorMsg(pParse, \"row value misused\");\n            break;\n        }\n      case 179:\n        {\n            int addrINR;\n            u8 okConstFactor = pParse->okConstFactor;\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            if (pAggInfo) {\n                assert(pExpr->iAgg >= 0 && pExpr->iAgg < pAggInfo->nColumn);\n                if (!pAggInfo->directMode) {\n                    inReg = pAggInfo->aCol[pExpr->iAgg].iMem;\n                    break;\n                }\n                if (pExpr->pAggInfo->useSortingIdx) {\n                    sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pAggInfo->aCol[pExpr->iAgg].iSorterColumn, target);\n                    inReg = target;\n                    break;\n                }\n            }\n            addrINR = sqlite3VdbeAddOp1(v, 20, pExpr->iTable);\n            pParse->okConstFactor = 0;\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            pParse->okConstFactor = okConstFactor;\n            sqlite3VdbeJumpHere(v, addrINR);\n            sqlite3VdbeChangeP3(v, addrINR, inReg);\n            break;\n        }\n      case 157:\n        {\n            int endLabel;\n            int nextCase;\n            int nExpr;\n            int i;\n            ExprList *pEList;\n            struct ExprList_item *aListelem;\n            Expr opCompare;\n            Expr *pX;\n            Expr *pTest = 0;\n            Expr *pDel = 0;\n            sqlite3 *db = pParse->db;\n            assert((((pExpr)->flags & 4096) == 0) && pExpr->x.pList != 0);\n            assert(pExpr->x.pList->nExpr > 0);\n            pEList = pExpr->x.pList;\n            aListelem = pEList->a;\n            nExpr = pEList->nExpr;\n            endLabel = sqlite3VdbeMakeLabel(pParse);\n            if ((pX = pExpr->pLeft) != 0) {\n                pDel = sqlite3ExprDup(db, pX, 0);\n                if (db->mallocFailed) {\n                    sqlite3ExprDelete(db, pDel);\n                    break;\n                }\n                ;\n                exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n                ;\n                memset(&opCompare, 0, sizeof (opCompare));\n                opCompare.op = 53;\n                opCompare.pLeft = pDel;\n                pTest = &opCompare;\n                regFree1 = 0;\n            }\n            for (i = 0; i < nExpr - 1; i = i + 2) {\n                if (pX) {\n                    assert(pTest != 0);\n                    opCompare.pRight = aListelem[i].pExpr;\n                } else {\n                    pTest = aListelem[i].pExpr;\n                }\n                nextCase = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pTest, nextCase, 16);\n                ;\n                sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, target);\n                sqlite3VdbeGoto(v, endLabel);\n                sqlite3VdbeResolveLabel(v, nextCase);\n            }\n            if ((nExpr & 1) != 0) {\n                sqlite3ExprCode(pParse, pEList->a[nExpr - 1].pExpr, target);\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, target);\n            }\n            sqlite3ExprDelete(db, pDel);\n            setDoNotMergeFlagOnCopy(v);\n            sqlite3VdbeResolveLabel(v, endLabel);\n            break;\n        }\n      case 71:\n        {\n            assert(pExpr->affExpr == 1 || pExpr->affExpr == 2 || pExpr->affExpr == 3 || pExpr->affExpr == 4);\n            if (!pParse->pTriggerTab && !pParse->nested) {\n                sqlite3ErrorMsg(pParse, \"RAISE() may only be used within a trigger-program\");\n                return 0;\n            }\n            if (pExpr->affExpr == 2) {\n                sqlite3MayAbort(pParse);\n            }\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            if (pExpr->affExpr == 4) {\n                sqlite3VdbeAddOp4(v, 70, 0, 4, 0, pExpr->u.zToken, 0);\n                ;\n            } else {\n                sqlite3HaltConstraint(pParse, pParse->pTriggerTab ? (19 | (7 << 8)) : 1, pExpr->affExpr, pExpr->u.zToken, 0, 0);\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n    return inReg;\n}\n"
        },
        {
            "id": "#23:25#sqlite3VdbeExec",
            "nobreaks": 1,
            "body": "{\n    Op *aOp = p->aOp;\n    Op *pOp = aOp;\n    int rc = 0;\n    sqlite3 *db = p->db;\n    u8 resetSchemaOnFault = 0;\n    u8 encoding = ((db)->enc);\n    int iCompare = 0;\n    u64 nVmStep = 0;\n    u64 nProgressLimit;\n    Mem *aMem = p->aMem;\n    Mem *pIn1 = 0;\n    Mem *pIn2 = 0;\n    Mem *pIn3 = 0;\n    Mem *pOut = 0;\n    assert(p->eVdbeState == 2);\n    sqlite3VdbeEnter(p);\n    if (db->xProgress) {\n        u32 iPrior = p->aCounter[4];\n        assert(0 < db->nProgressOps);\n        nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);\n    } else {\n        nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n    }\n    if (p->rc == 7) {\n        goto no_mem;\n    }\n    assert(p->rc == 0 || (p->rc & 255) == 5);\n    ;\n    p->rc = 0;\n    assert(p->bIsReader || p->readOnly != 0);\n    p->iCurrentTime = 0;\n    assert(p->explain == 0);\n    p->pResultSet = 0;\n    db->busyHandler.nBusy = 0;\n    if (__atomic_load_n((&db->u1.isInterrupted), 0))\n        goto abort_due_to_interrupt;\n    ;\n    for (pOp = &aOp[p->pc]; 1; pOp++) {\n        assert(rc == 0);\n        assert(pOp >= aOp && pOp < &aOp[p->nOp]);\n        nVmStep++;\n        switch (pOp->opcode) {\n          case 9:\n            {\n              jump_to_p2_and_check_for_interrupt:\n                pOp = &aOp[pOp->p2 - 1];\n              check_for_interrupt:\n                if (__atomic_load_n((&db->u1.isInterrupted), 0))\n                    goto abort_due_to_interrupt;\n                while (nVmStep >= nProgressLimit && db->xProgress != 0)\n                    {\n                        assert(db->nProgressOps != 0);\n                        nProgressLimit += db->nProgressOps;\n                        if (db->xProgress(db->pProgressArg)) {\n                            nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                            rc = 9;\n                            goto abort_due_to_error;\n                        }\n                    }\n                break;\n            }\n          case 10:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert((((pIn1)->flags & (32768 | 4096)) != 0) == 0);\n                ;\n                pIn1->flags = 4;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                goto jump_to_p2_and_check_for_interrupt;\n            }\n          case 67:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & 4) {\n                    if (pOp->p3) {\n                        ;\n                    }\n                    pOp = &aOp[pIn1->u.i];\n                } else if ((pOp->p3)) {\n                    ;\n                }\n                break;\n            }\n          case 11:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                assert(pOp->p2 >= 0 && pOp->p2 < p->nOp);\n                assert(pOp->p3 >= 0 && pOp->p3 < p->nOp);\n                pOut = &aMem[pOp->p1];\n                assert(!(((pOut)->flags & (32768 | 4096)) != 0));\n                pOut->u.i = pOp->p3 - 1;\n                pOut->flags = 4;\n                if (pOp->p2 == 0)\n                    break;\n              jump_to_p2:\n                assert(pOp->p2 > 0);\n                assert(pOp->p2 < p->nOp);\n                pOp = &aOp[pOp->p2 - 1];\n                break;\n            }\n          case 68:\n            {\n                VdbeOp *pCaller;\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags == 4);\n                assert(pIn1->u.i >= 0 && pIn1->u.i < p->nOp);\n                pCaller = &aOp[pIn1->u.i];\n                assert(pCaller->opcode == 12);\n                assert(pCaller->p2 >= 0 && pCaller->p2 < p->nOp);\n                pOp = &aOp[pCaller->p2 - 1];\n                pIn1->flags = 0;\n                break;\n            }\n          case 12:\n            {\n                int pcDest;\n                pIn1 = &aMem[pOp->p1];\n                assert((((pIn1)->flags & (32768 | 4096)) != 0) == 0);\n                pIn1->flags = 4;\n                pcDest = (int)pIn1->u.i;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                pOp = &aOp[pcDest];\n                break;\n            }\n          case 69:\n            {\n                pIn3 = &aMem[pOp->p3];\n                if ((pIn3->flags & 1) == 0)\n                    break;\n            }\n          case 70:\n            {\n                VdbeFrame *pFrame;\n                int pcx;\n                if (p->pFrame && pOp->p1 == 0) {\n                    pFrame = p->pFrame;\n                    p->pFrame = pFrame->pParent;\n                    p->nFrame--;\n                    sqlite3VdbeSetChanges(db, p->nChange);\n                    pcx = sqlite3VdbeFrameRestore(pFrame);\n                    if (pOp->p2 == 4) {\n                        pcx = p->aOp[pcx].p2 - 1;\n                    }\n                    aOp = p->aOp;\n                    aMem = p->aMem;\n                    pOp = &aOp[pcx];\n                    break;\n                }\n                p->rc = pOp->p1;\n                p->errorAction = (u8)pOp->p2;\n                assert(pOp->p5 <= 4);\n                if (p->rc) {\n                    if (pOp->p5) {\n                        static const char *const azType[] = {\"NOT NULL\", \"UNIQUE\", \"CHECK\", \"FOREIGN KEY\"};\n                        ;\n                        ;\n                        ;\n                        ;\n                        sqlite3VdbeError(p, \"%s constraint failed\", azType[pOp->p5 - 1]);\n                        if (pOp->p4.z) {\n                            p->zErrMsg = sqlite3MPrintf(db, \"%z: %s\", p->zErrMsg, pOp->p4.z);\n                        }\n                    } else {\n                        sqlite3VdbeError(p, \"%s\", pOp->p4.z);\n                    }\n                    pcx = (int)(pOp - aOp);\n                    sqlite3_log(pOp->p1, \"abort at %d in [%s]: %s\", pcx, p->zSql, p->zErrMsg);\n                }\n                rc = sqlite3VdbeHalt(p);\n                assert(rc == 5 || rc == 0 || rc == 1);\n                if (rc == 5) {\n                    p->rc = 5;\n                } else {\n                    assert(rc == 0 || (p->rc & 255) == 19);\n                    assert(rc == 0 || db->nDeferredCons > 0 || db->nDeferredImmCons > 0);\n                    rc = p->rc ? 1 : 101;\n                }\n                goto vdbe_return;\n            }\n          case 71:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = pOp->p1;\n                break;\n            }\n          case 72:\n            {\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p4.pI64 != 0);\n                pOut->u.i = *pOp->p4.pI64;\n                break;\n            }\n          case 153:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 8;\n                assert(!sqlite3IsNaN(*pOp->p4.pReal));\n                pOut->u.r = *pOp->p4.pReal;\n                break;\n            }\n          case 117:\n            {\n                assert(pOp->p4.z != 0);\n                pOut = out2Prerelease(p, pOp);\n                pOp->p1 = sqlite3Strlen30(pOp->p4.z);\n                if (encoding != 1) {\n                    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, 1, ((sqlite3_destructor_type)0));\n                    assert(rc == 0 || rc == 18);\n                    if (rc)\n                        goto too_big;\n                    if (0 != sqlite3VdbeChangeEncoding(pOut, encoding))\n                        goto no_mem;\n                    assert(pOut->szMalloc > 0 && pOut->zMalloc == pOut->z);\n                    assert((((pOut)->flags & (32768 | 4096)) != 0) == 0);\n                    pOut->szMalloc = 0;\n                    pOut->flags |= 8192;\n                    if (pOp->p4type == (-6)) {\n                        sqlite3DbFree(db, pOp->p4.z);\n                    }\n                    pOp->p4type = (-6);\n                    pOp->p4.z = pOut->z;\n                    pOp->p1 = pOut->n;\n                }\n                if (pOp->p1 > db->aLimit[0]) {\n                    goto too_big;\n                }\n                pOp->opcode = 73;\n                assert(rc == 0);\n            }\n          case 73:\n            {\n                assert(pOp->p4.z != 0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = pOp->p4.z;\n                pOut->n = pOp->p1;\n                pOut->enc = encoding;\n                ;\n                if (pOp->p3 > 0) {\n                    assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                    pIn3 = &aMem[pOp->p3];\n                    assert(pIn3->flags & 4);\n                    if (pIn3->u.i == pOp->p5)\n                        pOut->flags = 16 | 8192 | 512;\n                }\n                break;\n            }\n          case 74:\n          case 75:\n            {\n                int cnt;\n                u16 nullFlag;\n                pOut = out2Prerelease(p, pOp);\n                cnt = pOp->p3 - pOp->p2;\n                assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pOut->flags = nullFlag = pOp->p1 ? (1 | 256) : 1;\n                pOut->n = 0;\n                while (cnt > 0)\n                    {\n                        pOut++;\n                        ;\n                        sqlite3VdbeMemSetNull(pOut);\n                        pOut->flags = nullFlag;\n                        pOut->n = 0;\n                        cnt--;\n                    }\n                break;\n            }\n          case 76:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pOut = &aMem[pOp->p1];\n                pOut->flags = (pOut->flags & ~(0 | 63)) | 1;\n                break;\n            }\n          case 77:\n            {\n                assert(pOp->p1 <= 1000000000);\n                pOut = out2Prerelease(p, pOp);\n                if (pOp->p4.z == 0) {\n                    sqlite3VdbeMemSetZeroBlob(pOut, pOp->p1);\n                    if (sqlite3VdbeMemExpandBlob(pOut))\n                        goto no_mem;\n                } else {\n                    sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);\n                }\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 78:\n            {\n                Mem *pVar;\n                assert(pOp->p1 > 0 && pOp->p1 <= p->nVar);\n                assert(pOp->p4.z == 0 || pOp->p4.z == sqlite3VListNumToName(p->pVList, pOp->p1));\n                pVar = &p->aVar[pOp->p1 - 1];\n                if (sqlite3VdbeMemTooBig(pVar)) {\n                    goto too_big;\n                }\n                pOut = &aMem[pOp->p2];\n                if ((((pOut)->flags & (32768 | 4096)) != 0))\n                    sqlite3VdbeMemSetNull(pOut);\n                memcpy(pOut, pVar, ((int)((char *)&((Mem *)0)->db)));\n                pOut->flags &= ~(4096 | 16384);\n                pOut->flags |= 8192 | 64;\n                ;\n                break;\n            }\n          case 79:\n            {\n                int n;\n                int p1;\n                int p2;\n                n = pOp->p3;\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                assert(n > 0 && p1 > 0 && p2 > 0);\n                assert(p1 + n <= p2 || p2 + n <= p1);\n                pIn1 = &aMem[p1];\n                pOut = &aMem[p2];\n                do {\n                    assert(pOut <= &aMem[(p->nMem + 1 - p->nCursor)]);\n                    assert(pIn1 <= &aMem[(p->nMem + 1 - p->nCursor)]);\n                    assert(memIsValid(pIn1));\n                    ;\n                    sqlite3VdbeMemMove(pOut, pIn1);\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                    ;\n                    ;\n                    pIn1++;\n                    pOut++;\n                } while (--n);\n                break;\n            }\n          case 80:\n            {\n                int n;\n                n = pOp->p3;\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                assert(pOut != pIn1);\n                while (1)\n                    {\n                        ;\n                        sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                        if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                            goto no_mem;\n                        }\n                        ;\n                        if ((pOut->flags & 2048) != 0 && (pOp->p5 & 2) != 0) {\n                            pOut->flags &= ~2048;\n                        }\n                        ;\n                        if ((n--) == 0)\n                            break;\n                        pOut++;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 81:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                assert(pOut != pIn1);\n                sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                break;\n            }\n          case 82:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 4) != 0);\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);\n                break;\n            }\n          case 83:\n            {\n                if ((rc = sqlite3VdbeCheckFk(p, 0)) != 0) {\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 84:\n            {\n                assert(p->nResColumn == pOp->p2);\n                assert(pOp->p1 > 0 || (sqlite3Config.neverCorrupt == 0));\n                assert(pOp->p1 + pOp->p2 <= (p->nMem + 1 - p->nCursor) + 1);\n                p->cacheCtr = (p->cacheCtr + 2) | 1;\n                p->pResultSet = &aMem[pOp->p1];\n                if (db->mallocFailed)\n                    goto no_mem;\n                if (db->mTrace & 4) {\n                    db->trace.xV2(4, db->pTraceArg, p, 0);\n                }\n                p->pc = (int)(pOp - aOp) + 1;\n                rc = 100;\n                goto vdbe_return;\n            }\n          case 111:\n            {\n                i64 nByte;\n                u16 flags1;\n                u16 flags2;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                ;\n                assert(pIn1 != pOut);\n                flags1 = pIn1->flags;\n                ;\n                ;\n                if ((flags1 | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                if ((flags1 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn1, encoding, 0))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                } else if ((flags1 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn1))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                }\n                flags2 = pIn2->flags;\n                if ((flags2 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn2, encoding, 0))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                } else if ((flags2 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn2))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                }\n                nByte = pIn1->n + pIn2->n;\n                if (nByte > db->aLimit[0]) {\n                    goto too_big;\n                }\n                if (sqlite3VdbeMemGrow(pOut, (int)nByte + 2, pOut == pIn2)) {\n                    goto no_mem;\n                }\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 2);\n                if (pOut != pIn2) {\n                    memcpy(pOut->z, pIn2->z, pIn2->n);\n                    assert((pIn2->flags & 4096) == (flags2 & 4096));\n                    pIn2->flags = flags2;\n                }\n                memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);\n                assert((pIn1->flags & 4096) == (flags1 & 4096));\n                pIn1->flags = flags1;\n                if (encoding > 1)\n                    nByte &= ~1;\n                pOut->z[nByte] = 0;\n                pOut->z[nByte + 1] = 0;\n                pOut->flags |= 512;\n                pOut->n = (int)nByte;\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n            {\n                u16 type1;\n                u16 type2;\n                i64 iA;\n                i64 iB;\n                double rA;\n                double rB;\n                pIn1 = &aMem[pOp->p1];\n                type1 = pIn1->flags;\n                pIn2 = &aMem[pOp->p2];\n                type2 = pIn2->flags;\n                pOut = &aMem[pOp->p3];\n                if ((type1 & type2 & 4) != 0) {\n                  int_math:\n                    iA = pIn1->u.i;\n                    iB = pIn2->u.i;\n                    switch (pOp->opcode) {\n                      case 106:\n                        if (sqlite3AddInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 107:\n                        if (sqlite3SubInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 108:\n                        if (sqlite3MulInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 109:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1 && iB == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                                goto fp_math;\n                            iB /= iA;\n                            break;\n                        }\n                      default:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            iB %= iA;\n                            break;\n                        }\n                    }\n                    pOut->u.i = iB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                } else if (((type1 | type2) & 1) != 0) {\n                    goto arithmetic_result_is_null;\n                } else {\n                    type1 = numericType(pIn1);\n                    type2 = numericType(pIn2);\n                    if ((type1 & type2 & 4) != 0)\n                        goto int_math;\n                  fp_math:\n                    rA = sqlite3VdbeRealValue(pIn1);\n                    rB = sqlite3VdbeRealValue(pIn2);\n                    switch (pOp->opcode) {\n                      case 106:\n                        rB += rA;\n                        break;\n                      case 107:\n                        rB -= rA;\n                        break;\n                      case 108:\n                        rB *= rA;\n                        break;\n                      case 109:\n                        {\n                            if (rA == (double)0)\n                                goto arithmetic_result_is_null;\n                            rB /= rA;\n                            break;\n                        }\n                      default:\n                        {\n                            iA = sqlite3VdbeIntValue(pIn1);\n                            iB = sqlite3VdbeIntValue(pIn2);\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            rB = (double)(iB % iA);\n                            break;\n                        }\n                    }\n                    if (sqlite3IsNaN(rB)) {\n                        goto arithmetic_result_is_null;\n                    }\n                    pOut->u.r = rB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 8);\n                }\n                break;\n              arithmetic_result_is_null:\n                sqlite3VdbeMemSetNull(pOut);\n                break;\n            }\n          case 85:\n            {\n                assert(pOp->p4type == (-2));\n                if (pOp->p1) {\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);\n                }\n                break;\n            }\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n            {\n                i64 iA;\n                u64 uA;\n                i64 iB;\n                u8 op;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                if ((pIn1->flags | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                iA = sqlite3VdbeIntValue(pIn2);\n                iB = sqlite3VdbeIntValue(pIn1);\n                op = pOp->opcode;\n                if (op == 102) {\n                    iA &= iB;\n                } else if (op == 103) {\n                    iA |= iB;\n                } else if (iB != 0) {\n                    assert(op == 105 || op == 104);\n                    if (iB < 0) {\n                        assert(105 == 104 + 1);\n                        op = 2 * 104 + 1 - op;\n                        iB = iB > (-64) ? -iB : 64;\n                    }\n                    if (iB >= 64) {\n                        iA = (iA >= 0 || op == 104) ? 0 : -1;\n                    } else {\n                        memcpy(&uA, &iA, sizeof (uA));\n                        if (op == 104) {\n                            uA <<= iB;\n                        } else {\n                            uA >>= iB;\n                            if (iA < 0)\n                                uA |= ((((u64)4294967295U) << 32) | 4294967295U) << (64 - iB);\n                        }\n                        memcpy(&iA, &uA, sizeof (iA));\n                    }\n                }\n                pOut->u.i = iA;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 86:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn1->u.i += pOp->p2;\n                break;\n            }\n          case 13:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if ((pIn1->flags & 4) == 0) {\n                    applyAffinity(pIn1, 67, encoding);\n                    if ((pIn1->flags & 4) == 0) {\n                        ;\n                        if (pOp->p2 == 0) {\n                            rc = 20;\n                            goto abort_due_to_error;\n                        } else {\n                            goto jump_to_p2;\n                        }\n                    }\n                }\n                ;\n                ((pIn1)->flags = ((pIn1)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 87:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & (4 | 32)) {\n                    ;\n                    ;\n                    sqlite3VdbeMemRealify(pIn1);\n                    ;\n                }\n                break;\n            }\n          case 88:\n            {\n                assert(pOp->p2 >= 65 && pOp->p2 <= 69);\n                ;\n                ;\n                ;\n                ;\n                ;\n                pIn1 = &aMem[pOp->p1];\n                ;\n                rc = (((pIn1)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                ;\n                ;\n                break;\n            }\n          case 53:\n          case 52:\n          case 56:\n          case 55:\n          case 54:\n          case 57:\n            {\n                int res, res2;\n                char affinity;\n                u16 flags1;\n                u16 flags3;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                flags1 = pIn1->flags;\n                flags3 = pIn3->flags;\n                if ((flags1 & flags3 & 4) != 0) {\n                    assert((pOp->p5 & 71) != 66 || (sqlite3Config.neverCorrupt == 0));\n                    if (pIn3->u.i > pIn1->u.i) {\n                        if (sqlite3aGTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = +1;\n                    } else if (pIn3->u.i < pIn1->u.i) {\n                        if (sqlite3aLTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = -1;\n                    } else {\n                        if (sqlite3aEQb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = 0;\n                    }\n                    ;\n                    break;\n                }\n                if ((flags1 | flags3) & 1) {\n                    if (pOp->p5 & 128) {\n                        assert((flags1 & 256) == 0);\n                        assert((pOp->p5 & 16) == 0 || (sqlite3Config.neverCorrupt == 0));\n                        ;\n                        if ((flags1 & flags3 & 1) != 0 && (flags3 & 256) == 0) {\n                            res = 0;\n                        } else {\n                            res = ((flags3 & 1) ? -1 : +1);\n                        }\n                    } else {\n                        ;\n                        if (pOp->p5 & 16) {\n                            goto jump_to_p2;\n                        }\n                        iCompare = 1;\n                        break;\n                    }\n                } else {\n                    affinity = pOp->p5 & 71;\n                    if (affinity >= 67) {\n                        if ((flags1 | flags3) & 2) {\n                            if ((flags1 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn1, 0);\n                                ;\n                                flags3 = pIn3->flags;\n                            }\n                            if ((flags3 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn3, 0);\n                            }\n                        }\n                    } else if (affinity == 66) {\n                        if ((flags1 & 2) == 0 && (flags1 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn1, encoding, 1);\n                            ;\n                            flags1 = (pIn1->flags & ~3519) | (flags1 & 3519);\n                            if (pIn1 == pIn3)\n                                flags3 = flags1 | 2;\n                        }\n                        if ((flags3 & 2) == 0 && (flags3 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn3, encoding, 1);\n                            ;\n                            flags3 = (pIn3->flags & ~3519) | (flags3 & 3519);\n                        }\n                    }\n                    assert(pOp->p4type == (-2) || pOp->p4.pColl == 0);\n                    res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);\n                }\n                assert(53 == 52 + 1);\n                assert(54 == 52 + 2);\n                assert(55 == 52 + 3);\n                assert(56 == 52 + 4);\n                assert(57 == 52 + 5);\n                if (res < 0) {\n                    res2 = sqlite3aLTb[pOp->opcode];\n                } else if (res == 0) {\n                    res2 = sqlite3aEQb[pOp->opcode];\n                } else {\n                    res2 = sqlite3aGTb[pOp->opcode];\n                }\n                iCompare = res;\n                assert((pIn3->flags & 4096) == (flags3 & 4096));\n                pIn3->flags = flags3;\n                assert((pIn1->flags & 4096) == (flags1 & 4096));\n                pIn1->flags = flags1;\n                ;\n                if (res2) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 58:\n            {\n                ;\n                if (iCompare == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 89:\n            {\n                assert(pOp->p4type == (-14));\n                assert(pOp->p4.ai);\n                assert(pOp[1].opcode == 90);\n                assert(pOp[1].p5 & 1);\n                break;\n            }\n          case 90:\n            {\n                int n;\n                int i;\n                int p1;\n                int p2;\n                const KeyInfo *pKeyInfo;\n                u32 idx;\n                CollSeq *pColl;\n                int bRev;\n                u32 *aPermute;\n                if ((pOp->p5 & 1) == 0) {\n                    aPermute = 0;\n                } else {\n                    assert(pOp > aOp);\n                    assert(pOp[-1].opcode == 89);\n                    assert(pOp[-1].p4type == (-14));\n                    aPermute = pOp[-1].p4.ai + 1;\n                    assert(aPermute != 0);\n                }\n                n = pOp->p3;\n                pKeyInfo = pOp->p4.pKeyInfo;\n                assert(n > 0);\n                assert(pKeyInfo != 0);\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                for (i = 0; i < n; i++) {\n                    idx = aPermute ? aPermute[i] : (u32)i;\n                    assert(memIsValid(&aMem[p1 + idx]));\n                    assert(memIsValid(&aMem[p2 + idx]));\n                    ;\n                    ;\n                    assert(i < pKeyInfo->nKeyField);\n                    pColl = pKeyInfo->aColl[i];\n                    bRev = (pKeyInfo->aSortFlags[i] & 1);\n                    iCompare = sqlite3MemCompare(&aMem[p1 + idx], &aMem[p2 + idx], pColl);\n                    if (iCompare) {\n                        if ((pKeyInfo->aSortFlags[i] & 2) && ((aMem[p1 + idx].flags & 1) || (aMem[p2 + idx].flags & 1))) {\n                            iCompare = -iCompare;\n                        }\n                        if (bRev)\n                            iCompare = -iCompare;\n                        break;\n                    }\n                }\n                assert(pOp[1].opcode == 14);\n                break;\n            }\n          case 14:\n            {\n                assert(pOp > aOp && pOp[-1].opcode == 90);\n                if (iCompare < 0) {\n                    ;\n                    pOp = &aOp[pOp->p1 - 1];\n                } else if (iCompare == 0) {\n                    ;\n                    pOp = &aOp[pOp->p2 - 1];\n                } else {\n                    ;\n                    pOp = &aOp[pOp->p3 - 1];\n                }\n                break;\n            }\n          case 44:\n          case 43:\n            {\n                int v1;\n                int v2;\n                v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);\n                v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);\n                if (pOp->opcode == 44) {\n                    static const unsigned char and_logic[] = {0, 0, 0, 0, 1, 2, 0, 2, 2};\n                    v1 = and_logic[v1 * 3 + v2];\n                } else {\n                    static const unsigned char or_logic[] = {0, 1, 2, 1, 1, 1, 2, 1, 2};\n                    v1 = or_logic[v1 * 3 + v2];\n                }\n                pOut = &aMem[pOp->p3];\n                if (v1 == 2) {\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                } else {\n                    pOut->u.i = v1;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                }\n                break;\n            }\n          case 91:\n            {\n                assert(pOp->p4type == (-3));\n                assert(pOp->p4.i == 0 || pOp->p4.i == 1);\n                assert(pOp->p3 == 0 || pOp->p3 == 1);\n                sqlite3VdbeMemSetInt64(&aMem[pOp->p2], sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);\n                break;\n            }\n          case 19:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                if ((pIn1->flags & 1) == 0) {\n                    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1, 0));\n                } else {\n                    sqlite3VdbeMemSetNull(pOut);\n                }\n                break;\n            }\n          case 114:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetNull(pOut);\n                if ((pIn1->flags & 1) == 0) {\n                    pOut->flags = 4;\n                    pOut->u.i = ~sqlite3VdbeIntValue(pIn1);\n                }\n                break;\n            }\n          case 15:\n            {\n                u32 iAddr;\n                assert(p->aOp[0].opcode == 8);\n                if (p->pFrame) {\n                    iAddr = (int)(pOp - p->aOp);\n                    if ((p->pFrame->aOnce[iAddr / 8] & (1 << (iAddr & 7))) != 0) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    p->pFrame->aOnce[iAddr / 8] |= 1 << (iAddr & 7);\n                } else {\n                    if (p->aOp[0].p1 == pOp->p1) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                }\n                ;\n                pOp->p1 = p->aOp[0].p1;\n                break;\n            }\n          case 16:\n            {\n                int c;\n                c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 17:\n            {\n                int c;\n                c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 50:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) != 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 18:\n            {\n                VdbeCursor *pC;\n                u16 typeMask;\n                u32 serialType;\n                assert(pOp->p1 >= (-1) && pOp->p1 < p->nCursor);\n                assert(pOp->p1 >= 0 || (pOp->p3 >= 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor)));\n                if (pOp->p1 >= 0) {\n                    pC = p->apCsr[pOp->p1];\n                    assert(pC != 0);\n                    assert(pOp->p3 >= 0);\n                    if (pOp->p3 < pC->nHdrParsed) {\n                        serialType = pC->aType[pOp->p3];\n                        if (serialType >= 12) {\n                            if (serialType & 1) {\n                                typeMask = 4;\n                            } else {\n                                typeMask = 8;\n                            }\n                        } else {\n                            static const unsigned char aMask[] = {16, 1, 1, 1, 1, 1, 1, 2, 1, 1, 16, 16};\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            typeMask = aMask[serialType];\n                        }\n                    } else {\n                        typeMask = 1 << (pOp->p4.i - 1);\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                    }\n                } else {\n                    assert(memIsValid(&aMem[pOp->p3]));\n                    typeMask = 1 << (sqlite3_value_type((sqlite3_value *)&aMem[pOp->p3]) - 1);\n                    ;\n                    ;\n                    ;\n                    ;\n                    ;\n                }\n                ;\n                if (typeMask & pOp->p5) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 92:\n            {\n                if ((aMem[pOp->p1].flags & 1) != 0 || (aMem[pOp->p3].flags & 1) != 0) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p2);\n                } else {\n                    sqlite3VdbeMemSetInt64(aMem + pOp->p2, 0);\n                }\n                break;\n            }\n          case 51:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 20:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if ((pC) && pC->nullRow) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p3);\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 94:\n            {\n                u32 p2;\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 *aOffset;\n                int len;\n                int i;\n                Mem *pDest;\n                Mem sMem;\n                const u8 *zData;\n                const u8 *zHdr;\n                const u8 *zEndHdr;\n                u64 offset64;\n                u32 t;\n                Mem *pReg;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pC = p->apCsr[pOp->p1];\n                p2 = (u32)pOp->p2;\n              op_column_restart:\n                assert(pC != 0);\n                assert(p2 < (u32)pC->nField || (pC->eCurType == 3 && pC->seekResult == 0));\n                aOffset = pC->aOffset;\n                assert(aOffset == pC->aType + pC->nField);\n                assert(pC->eCurType != 2);\n                assert(pC->eCurType != 3 || pC->nullRow);\n                assert(pC->eCurType != 1);\n                if (pC->cacheStatus != p->cacheCtr) {\n                    if (pC->nullRow) {\n                        if (pC->eCurType == 3 && pC->seekResult > 0) {\n                            pReg = &aMem[pC->seekResult];\n                            assert(pReg->flags & 16);\n                            assert(memIsValid(pReg));\n                            pC->payloadSize = pC->szRow = pReg->n;\n                            pC->aRow = (u8 *)pReg->z;\n                        } else {\n                            pDest = &aMem[pOp->p3];\n                            ;\n                            sqlite3VdbeMemSetNull(pDest);\n                            goto op_column_out;\n                        }\n                    } else {\n                        pCrsr = pC->uc.pCursor;\n                        if (pC->deferredMoveto) {\n                            u32 iMap;\n                            assert(!pC->isEphemeral);\n                            if (pC->ub.aAltMap && (iMap = pC->ub.aAltMap[1 + p2]) > 0) {\n                                pC = pC->pAltCursor;\n                                p2 = iMap - 1;\n                                goto op_column_restart;\n                            }\n                            rc = sqlite3VdbeFinishMoveto(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                        } else if (sqlite3BtreeCursorHasMoved(pCrsr)) {\n                            rc = sqlite3VdbeHandleMovedCursor(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                            goto op_column_restart;\n                        }\n                        assert(pC->eCurType == 0);\n                        assert(pCrsr);\n                        assert(sqlite3BtreeCursorIsValid(pCrsr));\n                        pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);\n                        pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &pC->szRow);\n                        assert(pC->szRow <= pC->payloadSize);\n                        assert(pC->szRow <= 65536);\n                    }\n                    pC->cacheStatus = p->cacheCtr;\n                    if ((aOffset[0] = pC->aRow[0]) < 128) {\n                        pC->iHdrOffset = 1;\n                    } else {\n                        pC->iHdrOffset = sqlite3GetVarint32(pC->aRow, aOffset);\n                    }\n                    pC->nHdrParsed = 0;\n                    if (pC->szRow < aOffset[0]) {\n                        pC->aRow = 0;\n                        pC->szRow = 0;\n                        if (aOffset[0] > 98307 || aOffset[0] > pC->payloadSize) {\n                            goto op_column_corrupt;\n                        }\n                    } else {\n                        zData = pC->aRow;\n                        assert(pC->nHdrParsed <= p2);\n                        ;\n                        goto op_column_read_header;\n                    }\n                } else if (sqlite3BtreeCursorHasMoved(pC->uc.pCursor)) {\n                    rc = sqlite3VdbeHandleMovedCursor(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    goto op_column_restart;\n                }\n                if (pC->nHdrParsed <= p2) {\n                    if (pC->iHdrOffset < aOffset[0]) {\n                        if (pC->aRow == 0) {\n                            memset(&sMem, 0, sizeof (sMem));\n                            rc = sqlite3VdbeMemFromBtreeZeroOffset(pC->uc.pCursor, aOffset[0], &sMem);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                            zData = (u8 *)sMem.z;\n                        } else {\n                            zData = pC->aRow;\n                        }\n                      op_column_read_header:\n                        i = pC->nHdrParsed;\n                        offset64 = aOffset[i];\n                        zHdr = zData + pC->iHdrOffset;\n                        zEndHdr = zData + aOffset[0];\n                        ;\n                        do {\n                            if ((pC->aType[i] = t = zHdr[0]) < 128) {\n                                zHdr++;\n                                offset64 += sqlite3VdbeOneByteSerialTypeLen(t);\n                            } else {\n                                zHdr += sqlite3GetVarint32(zHdr, &t);\n                                pC->aType[i] = t;\n                                offset64 += sqlite3VdbeSerialTypeLen(t);\n                            }\n                            aOffset[++i] = (u32)(offset64 & 4294967295U);\n                        } while ((u32)i <= p2 && zHdr < zEndHdr);\n                        if ((zHdr >= zEndHdr && (zHdr > zEndHdr || offset64 != pC->payloadSize)) || (offset64 > pC->payloadSize)) {\n                            if (aOffset[0] == 0) {\n                                i = 0;\n                                zHdr = zEndHdr;\n                            } else {\n                                if (pC->aRow == 0)\n                                    sqlite3VdbeMemRelease(&sMem);\n                                goto op_column_corrupt;\n                            }\n                        }\n                        pC->nHdrParsed = i;\n                        pC->iHdrOffset = (u32)(zHdr - zData);\n                        if (pC->aRow == 0)\n                            sqlite3VdbeMemRelease(&sMem);\n                    } else {\n                        t = 0;\n                    }\n                    if (pC->nHdrParsed <= p2) {\n                        pDest = &aMem[pOp->p3];\n                        ;\n                        if (pOp->p4type == (-10)) {\n                            sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, 8192);\n                        } else {\n                            sqlite3VdbeMemSetNull(pDest);\n                        }\n                        goto op_column_out;\n                    }\n                } else {\n                    t = pC->aType[p2];\n                }\n                assert(p2 < pC->nHdrParsed);\n                assert(rc == 0);\n                pDest = &aMem[pOp->p3];\n                ;\n                assert(sqlite3VdbeCheckMemInvariants(pDest));\n                if ((((pDest)->flags & (32768 | 4096)) != 0)) {\n                    sqlite3VdbeMemSetNull(pDest);\n                }\n                assert(t == pC->aType[p2]);\n                if (pC->szRow >= aOffset[p2 + 1]) {\n                    zData = pC->aRow + aOffset[p2];\n                    if (t < 12) {\n                        sqlite3VdbeSerialGet(zData, t, pDest);\n                    } else {\n                        static const u16 aFlag[] = {16, 2 | 512};\n                        pDest->n = len = (t - 12) / 2;\n                        pDest->enc = encoding;\n                        if (pDest->szMalloc < len + 2) {\n                            if (len > db->aLimit[0])\n                                goto too_big;\n                            pDest->flags = 1;\n                            if (sqlite3VdbeMemGrow(pDest, len + 2, 0))\n                                goto no_mem;\n                        } else {\n                            pDest->z = pDest->zMalloc;\n                        }\n                        memcpy(pDest->z, zData, len);\n                        pDest->z[len] = 0;\n                        pDest->z[len + 1] = 0;\n                        pDest->flags = aFlag[t & 1];\n                    }\n                } else {\n                    pDest->enc = encoding;\n                    if (((pOp->p5 & (64 | 128)) != 0 && ((t >= 12 && (t & 1) == 0) || (pOp->p5 & 128) != 0)) || (len = sqlite3VdbeSerialTypeLen(t)) == 0) {\n                        sqlite3VdbeSerialGet((u8 *)sqlite3CtypeMap, t, pDest);\n                    } else {\n                        if (len > db->aLimit[0])\n                            goto too_big;\n                        rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, aOffset[p2], len, pDest);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        sqlite3VdbeSerialGet((const u8 *)pDest->z, t, pDest);\n                        pDest->flags &= ~16384;\n                    }\n                }\n              op_column_out:\n                ;\n                ;\n                break;\n              op_column_corrupt:\n                if (aOp[0].p3 > 0) {\n                    pOp = &aOp[aOp[0].p3 - 1];\n                    break;\n                } else {\n                    rc = sqlite3CorruptError(92699);\n                    goto abort_due_to_error;\n                }\n            }\n          case 95:\n            {\n                Table *pTab;\n                Column *aCol;\n                int i;\n                assert(pOp->p4type == (-5));\n                pTab = pOp->p4.pTab;\n                assert(pTab->tabFlags & 65536);\n                assert(pTab->nNVCol == pOp->p2);\n                aCol = pTab->aCol;\n                pIn1 = &aMem[pOp->p1];\n                for (i = 0; i < pTab->nCol; i++) {\n                    if (aCol[i].colFlags & 96) {\n                        if (aCol[i].colFlags & 32)\n                            continue;\n                        if (pOp->p3) {\n                            pIn1++;\n                            continue;\n                        }\n                    }\n                    assert(pIn1 < &aMem[pOp->p1 + pOp->p2]);\n                    applyAffinity(pIn1, aCol[i].affinity, encoding);\n                    if ((pIn1->flags & 1) == 0) {\n                        switch (aCol[i].eCType) {\n                          case 2:\n                            {\n                                if ((pIn1->flags & 16) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 4:\n                          case 3:\n                            {\n                                if ((pIn1->flags & 4) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 6:\n                            {\n                                if ((pIn1->flags & 2) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 5:\n                            {\n                                ;\n                                ;\n                                if (pIn1->flags & 4) {\n                                    ;\n                                    ;\n                                    ;\n                                    ;\n                                    if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                        pIn1->flags |= 32;\n                                        pIn1->flags &= ~4;\n                                    } else {\n                                        pIn1->u.r = (double)pIn1->u.i;\n                                        pIn1->flags |= 8;\n                                        pIn1->flags &= ~4;\n                                    }\n                                } else if ((pIn1->flags & (8 | 32)) == 0) {\n                                    goto vdbe_type_error;\n                                }\n                                break;\n                            }\n                          default:\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    ;\n                    pIn1++;\n                }\n                assert(pIn1 == &aMem[pOp->p1 + pOp->p2]);\n                break;\n              vdbe_type_error:\n                sqlite3VdbeError(p, \"cannot store %s value in %s column %s.%s\", vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType - 1], pTab->zName, aCol[i].zCnName);\n                rc = (19 | (12 << 8));\n                goto abort_due_to_error;\n            }\n          case 96:\n            {\n                const char *zAffinity;\n                zAffinity = pOp->p4.z;\n                assert(zAffinity != 0);\n                assert(pOp->p2 > 0);\n                assert(zAffinity[pOp->p2] == 0);\n                pIn1 = &aMem[pOp->p1];\n                while (1)\n                    {\n                        assert(pIn1 <= &p->aMem[(p->nMem + 1 - p->nCursor)]);\n                        assert(zAffinity[0] == 64 || memIsValid(pIn1));\n                        applyAffinity(pIn1, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pIn1->flags & 4) != 0) {\n                            ;\n                            ;\n                            ;\n                            ;\n                            if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                pIn1->flags |= 32;\n                                pIn1->flags &= ~4;\n                            } else {\n                                pIn1->u.r = (double)pIn1->u.i;\n                                pIn1->flags |= 8;\n                                pIn1->flags &= ~4;\n                            }\n                        }\n                        ;\n                        zAffinity++;\n                        if (zAffinity[0] == 0)\n                            break;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 97:\n            {\n                Mem *pRec;\n                u64 nData;\n                int nHdr;\n                i64 nByte;\n                i64 nZero;\n                int nVarint;\n                u32 serial_type;\n                Mem *pData0;\n                Mem *pLast;\n                int nField;\n                char *zAffinity;\n                u32 len;\n                u8 *zHdr;\n                u8 *zPayload;\n                nData = 0;\n                nHdr = 0;\n                nZero = 0;\n                nField = pOp->p1;\n                zAffinity = pOp->p4.z;\n                assert(nField > 0 && pOp->p2 > 0 && pOp->p2 + nField <= (p->nMem + 1 - p->nCursor) + 1);\n                pData0 = &aMem[nField];\n                nField = pOp->p2;\n                pLast = &pData0[nField - 1];\n                assert(pOp->p3 < pOp->p1 || pOp->p3 >= pOp->p1 + pOp->p2);\n                pOut = &aMem[pOp->p3];\n                ;\n                assert(pData0 <= pLast);\n                if (zAffinity) {\n                    pRec = pData0;\n                    do {\n                        applyAffinity(pRec, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pRec->flags & 4)) {\n                            pRec->flags |= 32;\n                            pRec->flags &= ~(4);\n                        }\n                        ;\n                        zAffinity++;\n                        pRec++;\n                        assert(zAffinity[0] == 0 || pRec <= pLast);\n                    } while (zAffinity[0]);\n                }\n                pRec = pLast;\n                do {\n                    assert(memIsValid(pRec));\n                    if (pRec->flags & 1) {\n                        if (pRec->flags & 1024) {\n                            assert(pOp->p5 == 109 || (sqlite3Config.neverCorrupt == 0));\n                            pRec->uTemp = 10;\n                        } else {\n                            pRec->uTemp = 0;\n                        }\n                        nHdr++;\n                    } else if (pRec->flags & (4 | 32)) {\n                        i64 i = pRec->u.i;\n                        u64 uu;\n                        ;\n                        ;\n                        if (i < 0) {\n                            uu = ~i;\n                        } else {\n                            uu = i;\n                        }\n                        nHdr++;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        if (uu <= 127) {\n                            if ((i & 1) == i && p->minWriteFileFormat >= 4) {\n                                pRec->uTemp = 8 + (u32)uu;\n                            } else {\n                                nData++;\n                                pRec->uTemp = 1;\n                            }\n                        } else if (uu <= 32767) {\n                            nData += 2;\n                            pRec->uTemp = 2;\n                        } else if (uu <= 8388607) {\n                            nData += 3;\n                            pRec->uTemp = 3;\n                        } else if (uu <= 2147483647) {\n                            nData += 4;\n                            pRec->uTemp = 4;\n                        } else if (uu <= 140737488355327LL) {\n                            nData += 6;\n                            pRec->uTemp = 5;\n                        } else {\n                            nData += 8;\n                            if (pRec->flags & 32) {\n                                pRec->u.r = (double)pRec->u.i;\n                                pRec->flags &= ~32;\n                                pRec->flags |= 8;\n                                pRec->uTemp = 7;\n                            } else {\n                                pRec->uTemp = 6;\n                            }\n                        }\n                    } else if (pRec->flags & 8) {\n                        nHdr++;\n                        nData += 8;\n                        pRec->uTemp = 7;\n                    } else {\n                        assert(db->mallocFailed || pRec->flags & (2 | 16));\n                        assert(pRec->n >= 0);\n                        len = (u32)pRec->n;\n                        serial_type = (len * 2) + 12 + ((pRec->flags & 2) != 0);\n                        if (pRec->flags & 1024) {\n                            serial_type += pRec->u.nZero * 2;\n                            if (nData) {\n                                if (sqlite3VdbeMemExpandBlob(pRec))\n                                    goto no_mem;\n                                len += pRec->u.nZero;\n                            } else {\n                                nZero += pRec->u.nZero;\n                            }\n                        }\n                        nData += len;\n                        nHdr += sqlite3VarintLen(serial_type);\n                        pRec->uTemp = serial_type;\n                    }\n                    if (pRec == pData0)\n                        break;\n                    pRec--;\n                } while (1);\n                ;\n                ;\n                if (nHdr <= 126) {\n                    nHdr += 1;\n                } else {\n                    nVarint = sqlite3VarintLen(nHdr);\n                    nHdr += nVarint;\n                    if (nVarint < sqlite3VarintLen(nHdr))\n                        nHdr++;\n                }\n                nByte = nHdr + nData;\n                if (nByte + nZero <= pOut->szMalloc) {\n                    pOut->z = pOut->zMalloc;\n                } else {\n                    if (nByte + nZero > db->aLimit[0]) {\n                        goto too_big;\n                    }\n                    if (sqlite3VdbeMemClearAndResize(pOut, (int)nByte)) {\n                        goto no_mem;\n                    }\n                }\n                pOut->n = (int)nByte;\n                pOut->flags = 16;\n                if (nZero) {\n                    pOut->u.nZero = nZero;\n                    pOut->flags |= 1024;\n                }\n                ;\n                zHdr = (u8 *)pOut->z;\n                zPayload = zHdr + nHdr;\n                if (nHdr < 128) {\n                    *(zHdr++) = nHdr;\n                } else {\n                    zHdr += sqlite3PutVarint(zHdr, nHdr);\n                }\n                assert(pData0 <= pLast);\n                pRec = pData0;\n                while (1)\n                    {\n                        serial_type = pRec->uTemp;\n                        if (serial_type <= 7) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type == 0) {\n                            } else {\n                                u64 v;\n                                u32 i;\n                                if (serial_type == 7) {\n                                    assert(sizeof (v) == sizeof (pRec->u.r));\n                                    memcpy(&v, &pRec->u.r, sizeof (v));\n                                    ;\n                                } else {\n                                    v = pRec->u.i;\n                                }\n                                len = i = sqlite3SmallTypeSizes[serial_type];\n                                assert(i > 0);\n                                while (1)\n                                    {\n                                        zPayload[--i] = (u8)(v & 255);\n                                        if (i == 0)\n                                            break;\n                                        v >>= 8;\n                                    }\n                                zPayload += len;\n                            }\n                        } else if (serial_type < 128) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type >= 14 && pRec->n > 0) {\n                                assert(pRec->z != 0);\n                                memcpy(zPayload, pRec->z, pRec->n);\n                                zPayload += pRec->n;\n                            }\n                        } else {\n                            zHdr += sqlite3PutVarint(zHdr, serial_type);\n                            if (pRec->n) {\n                                assert(pRec->z != 0);\n                                memcpy(zPayload, pRec->z, pRec->n);\n                                zPayload += pRec->n;\n                            }\n                        }\n                        if (pRec == pLast)\n                            break;\n                        pRec++;\n                    }\n                assert(nHdr == (int)(zHdr - (u8 *)pOut->z));\n                assert(nByte == (int)(zPayload - (u8 *)pOut->z));\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                ;\n                break;\n            }\n          case 98:\n            {\n                i64 nEntry;\n                BtCursor *pCrsr;\n                assert(p->apCsr[pOp->p1]->eCurType == 0);\n                pCrsr = p->apCsr[pOp->p1]->uc.pCursor;\n                assert(pCrsr);\n                if (pOp->p3) {\n                    nEntry = sqlite3BtreeRowCountEst(pCrsr);\n                } else {\n                    nEntry = 0;\n                    rc = sqlite3BtreeCount(db, pCrsr, &nEntry);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = nEntry;\n                goto check_for_interrupt;\n            }\n          case 0:\n            {\n                int p1;\n                char *zName;\n                int nName;\n                Savepoint *pNew;\n                Savepoint *pSavepoint;\n                Savepoint *pTmp;\n                int iSavepoint;\n                int ii;\n                p1 = pOp->p1;\n                zName = pOp->p4.z;\n                assert(db->pSavepoint == 0 || db->autoCommit == 0);\n                assert(p1 == 0 || p1 == 1 || p1 == 2);\n                assert(db->pSavepoint || db->isTransactionSavepoint == 0);\n                assert(checkSavepointCount(db));\n                assert(p->bIsReader);\n                if (p1 == 0) {\n                    if (db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot open savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        nName = sqlite3Strlen30(zName);\n                        assert(db->autoCommit == 0 || db->nVTrans == 0);\n                        rc = sqlite3VtabSavepoint(db, 0, db->nStatement + db->nSavepoint);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint) + nName + 1);\n                        if (pNew) {\n                            pNew->zName = (char *)&pNew[1];\n                            memcpy(pNew->zName, zName, nName + 1);\n                            if (db->autoCommit) {\n                                db->autoCommit = 0;\n                                db->isTransactionSavepoint = 1;\n                            } else {\n                                db->nSavepoint++;\n                            }\n                            pNew->pNext = db->pSavepoint;\n                            db->pSavepoint = pNew;\n                            pNew->nDeferredCons = db->nDeferredCons;\n                            pNew->nDeferredImmCons = db->nDeferredImmCons;\n                        }\n                    }\n                } else {\n                    assert(p1 == 1 || p1 == 2);\n                    iSavepoint = 0;\n                    for (pSavepoint = db->pSavepoint; pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName); pSavepoint = pSavepoint->pNext) {\n                        iSavepoint++;\n                    }\n                    if (!pSavepoint) {\n                        sqlite3VdbeError(p, \"no such savepoint: %s\", zName);\n                        rc = 1;\n                    } else if (db->nVdbeWrite > 0 && p1 == 1) {\n                        sqlite3VdbeError(p, \"cannot release savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        int isTransaction = pSavepoint->pNext == 0 && db->isTransactionSavepoint;\n                        if (isTransaction && p1 == 1) {\n                            if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                                goto vdbe_return;\n                            }\n                            db->autoCommit = 1;\n                            if (sqlite3VdbeHalt(p) == 5) {\n                                p->pc = (int)(pOp - aOp);\n                                db->autoCommit = 0;\n                                p->rc = rc = 5;\n                                goto vdbe_return;\n                            }\n                            rc = p->rc;\n                            if (rc) {\n                                db->autoCommit = 0;\n                            } else {\n                                db->isTransactionSavepoint = 0;\n                            }\n                        } else {\n                            int isSchemaChange;\n                            iSavepoint = db->nSavepoint - iSavepoint - 1;\n                            if (p1 == 2) {\n                                isSchemaChange = (db->mDbFlags & 1) != 0;\n                                for (ii = 0; ii < db->nDb; ii++) {\n                                    rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt, (4 | (2 << 8)), isSchemaChange == 0);\n                                    if (rc != 0)\n                                        goto abort_due_to_error;\n                                }\n                            } else {\n                                assert(p1 == 1);\n                                isSchemaChange = 0;\n                            }\n                            for (ii = 0; ii < db->nDb; ii++) {\n                                rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);\n                                if (rc != 0) {\n                                    goto abort_due_to_error;\n                                }\n                            }\n                            if (isSchemaChange) {\n                                sqlite3ExpirePreparedStatements(db, 0);\n                                sqlite3ResetAllSchemasOfConnection(db);\n                                db->mDbFlags |= 1;\n                            }\n                        }\n                        if (rc)\n                            goto abort_due_to_error;\n                        while (db->pSavepoint != pSavepoint)\n                            {\n                                pTmp = db->pSavepoint;\n                                db->pSavepoint = pTmp->pNext;\n                                sqlite3DbFree(db, pTmp);\n                                db->nSavepoint--;\n                            }\n                        if (p1 == 1) {\n                            assert(pSavepoint == db->pSavepoint);\n                            db->pSavepoint = pSavepoint->pNext;\n                            sqlite3DbFree(db, pSavepoint);\n                            if (!isTransaction) {\n                                db->nSavepoint--;\n                            }\n                        } else {\n                            assert(p1 == 2);\n                            db->nDeferredCons = pSavepoint->nDeferredCons;\n                            db->nDeferredImmCons = pSavepoint->nDeferredImmCons;\n                        }\n                        if (!isTransaction || p1 == 2) {\n                            rc = sqlite3VtabSavepoint(db, p1, iSavepoint);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                if (p->eVdbeState == 3) {\n                    rc = 101;\n                    goto vdbe_return;\n                }\n                break;\n            }\n          case 1:\n            {\n                int desiredAutoCommit;\n                int iRollback;\n                desiredAutoCommit = pOp->p1;\n                iRollback = pOp->p2;\n                assert(desiredAutoCommit == 1 || desiredAutoCommit == 0);\n                assert(desiredAutoCommit == 1 || iRollback == 0);\n                assert(db->nVdbeActive > 0);\n                assert(p->bIsReader);\n                if (desiredAutoCommit != db->autoCommit) {\n                    if (iRollback) {\n                        assert(desiredAutoCommit == 1);\n                        sqlite3RollbackAll(db, (4 | (2 << 8)));\n                        db->autoCommit = 1;\n                    } else if (desiredAutoCommit && db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot commit transaction - SQL statements in progress\");\n                        rc = 5;\n                        goto abort_due_to_error;\n                    } else if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                        goto vdbe_return;\n                    } else {\n                        db->autoCommit = (u8)desiredAutoCommit;\n                    }\n                    if (sqlite3VdbeHalt(p) == 5) {\n                        p->pc = (int)(pOp - aOp);\n                        db->autoCommit = (u8)(1 - desiredAutoCommit);\n                        p->rc = rc = 5;\n                        goto vdbe_return;\n                    }\n                    sqlite3CloseSavepoints(db);\n                    if (p->rc == 0) {\n                        rc = 101;\n                    } else {\n                        rc = 1;\n                    }\n                    goto vdbe_return;\n                } else {\n                    sqlite3VdbeError(p, (!desiredAutoCommit) ? \"cannot start a transaction within a transaction\" : ((iRollback) ? \"cannot rollback - no transaction is active\" : \"cannot commit - no transaction is active\"));\n                    rc = 1;\n                    goto abort_due_to_error;\n                }\n                assert(0);\n            }\n          case 2:\n            {\n                Btree *pBt;\n                Db *pDb;\n                int iMeta = 0;\n                assert(p->bIsReader);\n                assert(p->readOnly == 0 || pOp->p2 == 0);\n                assert(pOp->p2 >= 0 && pOp->p2 <= 2);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(rc == 0);\n                if (pOp->p2 && (db->flags & (1048576 | ((u64)(2) << 32))) != 0) {\n                    if (db->flags & 1048576) {\n                        rc = 8;\n                    } else {\n                        rc = 11;\n                    }\n                    goto abort_due_to_error;\n                }\n                pDb = &db->aDb[pOp->p1];\n                pBt = pDb->pBt;\n                if (pBt) {\n                    rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, &iMeta);\n                    ;\n                    ;\n                    if (rc != 0) {\n                        if ((rc & 255) == 5) {\n                            p->pc = (int)(pOp - aOp);\n                            p->rc = rc;\n                            goto vdbe_return;\n                        }\n                        goto abort_due_to_error;\n                    }\n                    if (p->usesStmtJournal && pOp->p2 && (db->autoCommit == 0 || db->nVdbeRead > 1)) {\n                        assert(sqlite3BtreeTxnState(pBt) == 2);\n                        if (p->iStatement == 0) {\n                            assert(db->nStatement >= 0 && db->nSavepoint >= 0);\n                            db->nStatement++;\n                            p->iStatement = db->nSavepoint + db->nStatement;\n                        }\n                        rc = sqlite3VtabSavepoint(db, 0, p->iStatement - 1);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);\n                        }\n                        p->nStmtDefCons = db->nDeferredCons;\n                        p->nStmtDefImmCons = db->nDeferredImmCons;\n                    }\n                }\n                assert(pOp->p5 == 0 || pOp->p4type == (-3));\n                if (rc == 0 && pOp->p5 && (iMeta != pOp->p3 || pDb->pSchema->iGeneration != pOp->p4.i)) {\n                    sqlite3DbFree(db, p->zErrMsg);\n                    p->zErrMsg = sqlite3DbStrDup(db, \"database schema has changed\");\n                    if (db->aDb[pOp->p1].pSchema->schema_cookie != iMeta) {\n                        sqlite3ResetOneSchema(db, pOp->p1);\n                    }\n                    p->expired = 1;\n                    rc = 17;\n                    p->changeCntOn = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 99:\n            {\n                int iMeta;\n                int iDb;\n                int iCookie;\n                assert(p->bIsReader);\n                iDb = pOp->p1;\n                iCookie = pOp->p3;\n                assert(pOp->p3 < 16);\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert(db->aDb[iDb].pBt != 0);\n                assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = iMeta;\n                break;\n            }\n          case 100:\n            {\n                Db *pDb;\n                ;\n                assert(pOp->p2 < 16);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pDb = &db->aDb[pOp->p1];\n                assert(pDb->pBt != 0);\n                assert(sqlite3SchemaMutexHeld(db, pOp->p1, 0));\n                rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);\n                if (pOp->p2 == 1) {\n                    *(u32 *)&pDb->pSchema->schema_cookie = *(u32 *)&pOp->p3 - pOp->p5;\n                    db->mDbFlags |= 1;\n                    sqlite3FkClearTriggerCache(db, pOp->p1);\n                } else if (pOp->p2 == 2) {\n                    pDb->pSchema->file_format = pOp->p3;\n                }\n                if (pOp->p1 == 1) {\n                    sqlite3ExpirePreparedStatements(db, 0);\n                    p->expired = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 101:\n            {\n                int nField;\n                KeyInfo *pKeyInfo;\n                u32 p2;\n                int iDb;\n                int wrFlag;\n                Btree *pX;\n                VdbeCursor *pCur;\n                Db *pDb;\n                assert(pOp->p5 == 0 || pOp->p5 == 2);\n                assert(pOp->p4type == (-8));\n                pCur = p->apCsr[pOp->p1];\n                if (pCur && pCur->pgnoRoot == (u32)pOp->p2) {\n                    assert(pCur->iDb == pOp->p3);\n                    assert(pCur->eCurType == 0);\n                    sqlite3BtreeClearCursor(pCur->uc.pCursor);\n                    goto open_cursor_set_hints;\n                }\n              case 112:\n              case 113:\n                assert(pOp->opcode == 113 || pOp->p5 == 0 || pOp->p5 == 2);\n                assert(p->bIsReader);\n                assert(pOp->opcode == 112 || pOp->opcode == 101 || p->readOnly == 0);\n                if (p->expired == 1) {\n                    rc = (4 | (2 << 8));\n                    goto abort_due_to_error;\n                }\n                nField = 0;\n                pKeyInfo = 0;\n                p2 = (u32)pOp->p2;\n                iDb = pOp->p3;\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                pDb = &db->aDb[iDb];\n                pX = pDb->pBt;\n                assert(pX != 0);\n                if (pOp->opcode == 113) {\n                    assert(8 == 8);\n                    wrFlag = 4 | (pOp->p5 & 8);\n                    assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n                    if (pDb->pSchema->file_format < p->minWriteFileFormat) {\n                        p->minWriteFileFormat = pDb->pSchema->file_format;\n                    }\n                } else {\n                    wrFlag = 0;\n                }\n                if (pOp->p5 & 16) {\n                    assert(p2 > 0);\n                    assert(p2 <= (u32)(p->nMem + 1 - p->nCursor));\n                    assert(pOp->opcode == 113);\n                    pIn2 = &aMem[p2];\n                    assert(memIsValid(pIn2));\n                    assert((pIn2->flags & 4) != 0);\n                    sqlite3VdbeMemIntegerify(pIn2);\n                    p2 = (int)pIn2->u.i;\n                    assert(p2 >= 2);\n                }\n                if (pOp->p4type == (-8)) {\n                    pKeyInfo = pOp->p4.pKeyInfo;\n                    assert(pKeyInfo->enc == ((db)->enc));\n                    assert(pKeyInfo->db == db);\n                    nField = pKeyInfo->nAllField;\n                } else if (pOp->p4type == (-3)) {\n                    nField = pOp->p4.i;\n                }\n                assert(pOp->p1 >= 0);\n                assert(nField >= 0);\n                ;\n                pCur = allocateCursor(p, pOp->p1, nField, 0);\n                if (pCur == 0)\n                    goto no_mem;\n                pCur->iDb = iDb;\n                pCur->nullRow = 1;\n                pCur->isOrdered = 1;\n                pCur->pgnoRoot = p2;\n                rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);\n                pCur->pKeyInfo = pKeyInfo;\n                pCur->isTable = pOp->p4type != (-8);\n              open_cursor_set_hints:\n                assert(1 == 1);\n                assert(2 == 2);\n                ;\n                ;\n                sqlite3BtreeCursorHintFlags(pCur->uc.pCursor, (pOp->p5 & (1 | 2)));\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 115:\n            {\n                VdbeCursor *pOrig;\n                VdbeCursor *pCx;\n                pOrig = p->apCsr[pOp->p2];\n                assert(pOrig);\n                assert(pOrig->isEphemeral);\n                pCx = allocateCursor(p, pOp->p1, pOrig->nField, 0);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->isEphemeral = 1;\n                pCx->pKeyInfo = pOrig->pKeyInfo;\n                pCx->isTable = pOrig->isTable;\n                pCx->pgnoRoot = pOrig->pgnoRoot;\n                pCx->isOrdered = pOrig->isOrdered;\n                pCx->ub.pBtx = pOrig->ub.pBtx;\n                pCx->noReuse = 1;\n                pOrig->noReuse = 1;\n                rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pCx->pKeyInfo, pCx->uc.pCursor);\n                assert(rc == 0);\n                break;\n            }\n          case 116:\n          case 118:\n            {\n                VdbeCursor *pCx;\n                KeyInfo *pKeyInfo;\n                static const int vfsFlags = 2 | 4 | 16 | 8 | 1024;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p2 >= 0);\n                if (pOp->p3 > 0) {\n                    assert(pOp->p2 == 0);\n                    assert(pOp->opcode == 118);\n                    assert(aMem[pOp->p3].flags & 1);\n                    aMem[pOp->p3].n = 0;\n                    aMem[pOp->p3].z = \"\";\n                }\n                pCx = p->apCsr[pOp->p1];\n                if (pCx && !pCx->noReuse && (pOp->p2 <= pCx->nField)) {\n                    assert(pCx->isEphemeral);\n                    pCx->seqCount = 0;\n                    pCx->cacheStatus = 0;\n                    rc = sqlite3BtreeClearTable(pCx->ub.pBtx, pCx->pgnoRoot, 0);\n                } else {\n                    pCx = allocateCursor(p, pOp->p1, pOp->p2, 0);\n                    if (pCx == 0)\n                        goto no_mem;\n                    pCx->isEphemeral = 1;\n                    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->ub.pBtx, 1 | 4 | pOp->p5, vfsFlags);\n                    if (rc == 0) {\n                        rc = sqlite3BtreeBeginTrans(pCx->ub.pBtx, 1, 0);\n                        if (rc == 0) {\n                            if ((pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo) != 0) {\n                                assert(pOp->p4type == (-8));\n                                rc = sqlite3BtreeCreateTable(pCx->ub.pBtx, &pCx->pgnoRoot, 2 | pOp->p5);\n                                if (rc == 0) {\n                                    assert(pCx->pgnoRoot == 1 + 1);\n                                    assert(pKeyInfo->db == db);\n                                    assert(pKeyInfo->enc == ((db)->enc));\n                                    rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pKeyInfo, pCx->uc.pCursor);\n                                }\n                                pCx->isTable = 0;\n                            } else {\n                                pCx->pgnoRoot = 1;\n                                rc = sqlite3BtreeCursor(pCx->ub.pBtx, 1, 4, 0, pCx->uc.pCursor);\n                                pCx->isTable = 1;\n                            }\n                        }\n                        pCx->isOrdered = (pOp->p5 != 8);\n                        if (rc) {\n                            sqlite3BtreeClose(pCx->ub.pBtx);\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pCx->nullRow = 1;\n                break;\n            }\n          case 119:\n            {\n                VdbeCursor *pCx;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p2 >= 0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p2, 1);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->pKeyInfo = pOp->p4.pKeyInfo;\n                assert(pCx->pKeyInfo->db == db);\n                assert(pCx->pKeyInfo->enc == ((db)->enc));\n                rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 120:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                if ((pC->seqCount++) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 121:\n            {\n                VdbeCursor *pCx;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p3 >= 0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p3, 3);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->seekResult = pOp->p2;\n                pCx->isTable = 1;\n                pCx->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                assert(pOp->p5 == 0);\n                break;\n            }\n          case 122:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);\n                p->apCsr[pOp->p1] = 0;\n                break;\n            }\n          case 21:\n          case 22:\n          case 23:\n          case 24:\n            {\n                int res;\n                int oc;\n                VdbeCursor *pC;\n                UnpackedRecord r;\n                int nField;\n                i64 iKey;\n                int eqOnly;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p2 != 0);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(22 == 21 + 1);\n                assert(23 == 21 + 2);\n                assert(24 == 21 + 3);\n                assert(pC->isOrdered);\n                assert(pC->uc.pCursor != 0);\n                oc = pOp->opcode;\n                eqOnly = 0;\n                pC->nullRow = 0;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pC->isTable) {\n                    u16 flags3, newType;\n                    assert(sqlite3BtreeCursorHasHint(pC->uc.pCursor, 2) == 0 || (sqlite3Config.neverCorrupt == 0));\n                    pIn3 = &aMem[pOp->p3];\n                    flags3 = pIn3->flags;\n                    if ((flags3 & (4 | 8 | 32 | 2)) == 2) {\n                        applyNumericAffinity(pIn3, 0);\n                    }\n                    iKey = sqlite3VdbeIntValue(pIn3);\n                    newType = pIn3->flags;\n                    pIn3->flags = flags3;\n                    if ((newType & (4 | 32)) == 0) {\n                        int c;\n                        if ((newType & 8) == 0) {\n                            if ((newType & 1) || oc >= 23) {\n                                ;\n                                goto jump_to_p2;\n                            } else {\n                                rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                                if (rc != 0)\n                                    goto abort_due_to_error;\n                                goto seek_not_found;\n                            }\n                        }\n                        c = sqlite3IntFloatCompare(iKey, pIn3->u.r);\n                        if (c > 0) {\n                            assert(23 == (24 - 1));\n                            assert(21 == (22 - 1));\n                            assert((22 & 1) == (24 & 1));\n                            if ((oc & 1) == (24 & 1))\n                                oc--;\n                        } else if (c < 0) {\n                            assert(22 == (21 + 1));\n                            assert(24 == (23 + 1));\n                            assert((21 & 1) == (23 & 1));\n                            if ((oc & 1) == (21 & 1))\n                                oc++;\n                        }\n                    }\n                    rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)iKey, 0, &res);\n                    pC->movetoTarget = iKey;\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                } else {\n                    if (sqlite3BtreeCursorHasHint(pC->uc.pCursor, 2)) {\n                        eqOnly = 1;\n                        assert(pOp->opcode == 23 || pOp->opcode == 22);\n                        assert(pOp[1].opcode == 42 || pOp[1].opcode == 41);\n                        assert(pOp->opcode == 23 || pOp[1].opcode == 42);\n                        assert(pOp->opcode == 22 || pOp[1].opcode == 41);\n                        assert(pOp[1].p1 == pOp[0].p1);\n                        assert(pOp[1].p2 == pOp[0].p2);\n                        assert(pOp[1].p3 == pOp[0].p3);\n                        assert(pOp[1].p4.i == pOp[0].p4.i);\n                    }\n                    nField = pOp->p4.i;\n                    assert(pOp->p4type == (-3));\n                    assert(nField > 0);\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.nField = (u16)nField;\n                    r.default_rc = ((1 & (oc - 21)) ? -1 : +1);\n                    assert(oc != 24 || r.default_rc == -1);\n                    assert(oc != 22 || r.default_rc == -1);\n                    assert(oc != 23 || r.default_rc == +1);\n                    assert(oc != 21 || r.default_rc == +1);\n                    r.aMem = &aMem[pOp->p3];\n                    r.eqSeen = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &res);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (eqOnly && r.eqSeen == 0) {\n                        assert(res != 0);\n                        goto seek_not_found;\n                    }\n                }\n                if (oc >= 23) {\n                    assert(oc == 23 || oc == 24);\n                    if (res < 0 || (res == 0 && oc == 24)) {\n                        res = 0;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = 0;\n                    }\n                } else {\n                    assert(oc == 21 || oc == 22);\n                    if (res > 0 || (res == 0 && oc == 21)) {\n                        res = 0;\n                        rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = sqlite3BtreeEof(pC->uc.pCursor);\n                    }\n                }\n              seek_not_found:\n                assert(pOp->p2 > 0);\n                ;\n                if (res) {\n                    goto jump_to_p2;\n                } else if (eqOnly) {\n                    assert(pOp[1].opcode == 42 || pOp[1].opcode == 41);\n                    pOp++;\n                }\n                break;\n            }\n          case 124:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nStep;\n                UnpackedRecord r;\n                assert(pOp[1].opcode == 23);\n                assert(pOp->p2 >= (int)(pOp - aOp) + 2);\n                assert(pOp->p1 > 0);\n                pC = p->apCsr[pOp[1].p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(!pC->isTable);\n                if (!sqlite3BtreeCursorIsValidNN(pC->uc.pCursor)) {\n                    break;\n                }\n                nStep = pOp->p1;\n                assert(nStep >= 1);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp[1].p4.i;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp[1].p3];\n                res = 0;\n                while (1)\n                    {\n                        rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res > 0 && pOp->p5 == 0) {\n                          seekscan_search_fail:\n                            ;\n                            pOp++;\n                            goto jump_to_p2;\n                        }\n                        if (res >= 0) {\n                            ;\n                            goto jump_to_p2;\n                            break;\n                        }\n                        if (nStep <= 0) {\n                            ;\n                            break;\n                        }\n                        nStep--;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc) {\n                            if (rc == 101) {\n                                rc = 0;\n                                goto seekscan_search_fail;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    }\n                break;\n            }\n          case 125:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pOp->p3 >= pOp->p2);\n                if (pC->seekHit < pOp->p2) {\n                    pC->seekHit = pOp->p2;\n                } else if (pC->seekHit > pOp->p3) {\n                    pC->seekHit = pOp->p3;\n                }\n                break;\n            }\n          case 25:\n            {\n                VdbeCursor *pCur;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pCur = p->apCsr[pOp->p1];\n                ;\n                if (pCur == 0 || pCur->nullRow) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                break;\n            }\n          case 26:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                if (pC->seekHit >= pOp->p4.i)\n                    break;\n            }\n          case 27:\n          case 28:\n          case 29:\n            {\n                int alreadyExists;\n                int ii;\n                VdbeCursor *pC;\n                UnpackedRecord *pIdxKey;\n                UnpackedRecord r;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p4type == (-3));\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                r.aMem = &aMem[pOp->p3];\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->isTable == 0);\n                r.nField = (u16)pOp->p4.i;\n                if (r.nField > 0) {\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &pC->seekResult);\n                } else {\n                    assert(r.aMem->flags & 16);\n                    assert(pOp->opcode != 27);\n                    rc = (((r.aMem)->flags & 1024) ? sqlite3VdbeMemExpandBlob(r.aMem) : 0);\n                    assert(rc == 0 || rc == 7);\n                    if (rc)\n                        goto no_mem;\n                    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);\n                    if (pIdxKey == 0)\n                        goto no_mem;\n                    sqlite3VdbeRecordUnpack(pC->pKeyInfo, r.aMem->n, r.aMem->z, pIdxKey);\n                    pIdxKey->default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, pIdxKey, &pC->seekResult);\n                    sqlite3DbFreeNN(db, pIdxKey);\n                }\n                if (rc != 0) {\n                    goto abort_due_to_error;\n                }\n                alreadyExists = (pC->seekResult == 0);\n                pC->nullRow = 1 - alreadyExists;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pOp->opcode == 29) {\n                    ;\n                    if (alreadyExists)\n                        goto jump_to_p2;\n                } else {\n                    if (!alreadyExists) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    if (pOp->opcode == 27) {\n                        for (ii = 0; ii < r.nField; ii++) {\n                            if (r.aMem[ii].flags & 1) {\n                                ;\n                                goto jump_to_p2;\n                            }\n                        }\n                    }\n                    ;\n                    if (pOp->opcode == 26) {\n                        pC->seekHit = pOp->p4.i;\n                    }\n                }\n                break;\n            }\n          case 30:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                u64 iKey;\n                pIn3 = &aMem[pOp->p3];\n                ;\n                ;\n                ;\n                ;\n                if ((pIn3->flags & (4 | 32)) == 0) {\n                    Mem x = pIn3[0];\n                    applyAffinity(&x, 67, encoding);\n                    if ((x.flags & 4) == 0)\n                        goto jump_to_p2;\n                    iKey = x.u.i;\n                    goto notExistsWithKey;\n                }\n              case 31:\n                pIn3 = &aMem[pOp->p3];\n                assert((pIn3->flags & 4) != 0 || pOp->opcode == 30);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                iKey = pIn3->u.i;\n              notExistsWithKey:\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isTable);\n                assert(pC->eCurType == 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr != 0);\n                res = 0;\n                rc = sqlite3BtreeTableMoveto(pCrsr, iKey, 0, &res);\n                assert(rc == 0 || res == 0);\n                pC->movetoTarget = iKey;\n                pC->nullRow = 0;\n                pC->cacheStatus = 0;\n                pC->deferredMoveto = 0;\n                ;\n                pC->seekResult = res;\n                if (res != 0) {\n                    assert(rc == 0);\n                    if (pOp->p2 == 0) {\n                        rc = sqlite3CorruptError(94942);\n                    } else {\n                        goto jump_to_p2;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 126:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(p->apCsr[pOp->p1] != 0);\n                assert(p->apCsr[pOp->p1]->eCurType != 2);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = p->apCsr[pOp->p1]->seqCount++;\n                break;\n            }\n          case 127:\n            {\n                i64 v;\n                VdbeCursor *pC;\n                int res;\n                int cnt;\n                Mem *pMem;\n                VdbeFrame *pFrame;\n                v = 0;\n                res = 0;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isTable);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                {\n                    assert(pC->isTable);\n                    if (!pC->useRandomRowid) {\n                        rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                        if (rc != 0) {\n                            goto abort_due_to_error;\n                        }\n                        if (res) {\n                            v = 1;\n                        } else {\n                            assert(sqlite3BtreeCursorIsValid(pC->uc.pCursor));\n                            v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                            if (v >= (i64)((((u64)2147483647) << 32) | (u64)4294967295U)) {\n                                pC->useRandomRowid = 1;\n                            } else {\n                                v++;\n                            }\n                        }\n                    }\n                    if (pOp->p3) {\n                        assert(pOp->p3 > 0);\n                        if (p->pFrame) {\n                            for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                                ;\n                            assert(pOp->p3 <= pFrame->nMem);\n                            pMem = &pFrame->aMem[pOp->p3];\n                        } else {\n                            assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                            pMem = &aMem[pOp->p3];\n                            ;\n                        }\n                        assert(memIsValid(pMem));\n                        ;\n                        sqlite3VdbeMemIntegerify(pMem);\n                        assert((pMem->flags & 4) != 0);\n                        if (pMem->u.i == (i64)((((u64)2147483647) << 32) | (u64)4294967295U) || pC->useRandomRowid) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        if (v < pMem->u.i + 1) {\n                            v = pMem->u.i + 1;\n                        }\n                        pMem->u.i = v;\n                    }\n                    if (pC->useRandomRowid) {\n                        assert(pOp->p3 == 0);\n                        cnt = 0;\n                        do {\n                            sqlite3_randomness(sizeof (v), &v);\n                            v &= ((i64)((((u64)2147483647) << 32) | (u64)4294967295U) >> 1);\n                            v++;\n                        } while (((rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)v, 0, &res)) == 0) && (res == 0) && (++cnt < 100));\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res == 0) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        assert(v > 0);\n                    }\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 128:\n            {\n                Mem *pData;\n                Mem *pKey;\n                VdbeCursor *pC;\n                int seekResult;\n                const char *zDb;\n                Table *pTab;\n                BtreePayload x;\n                pData = &aMem[pOp->p2];\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(memIsValid(pData));\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->uc.pCursor != 0);\n                assert((pOp->p5 & 64) || pC->isTable);\n                assert(pOp->p4type == (-5) || pOp->p4type >= (-1));\n                ;\n                ;\n                pKey = &aMem[pOp->p3];\n                assert(pKey->flags & 4);\n                assert(memIsValid(pKey));\n                ;\n                x.nKey = pKey->u.i;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    assert(pC->iDb >= 0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    assert((pOp->p5 & 64) || (((pTab)->tabFlags & 128) == 0));\n                } else {\n                    pTab = 0;\n                    zDb = 0;\n                }\n                if (pOp->p5 & 1)\n                    p->nChange++;\n                if (pOp->p5 & 32)\n                    db->lastRowid = x.nKey;\n                assert((pData->flags & (16 | 2)) != 0 || pData->n == 0);\n                x.pData = pData->z;\n                x.nData = pData->n;\n                seekResult = ((pOp->p5 & 16) ? pC->seekResult : 0);\n                if (pData->flags & 1024) {\n                    x.nZero = pData->u.nZero;\n                } else {\n                    x.nZero = 0;\n                }\n                x.pKey = 0;\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), seekResult);\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pTab) {\n                    assert(db->xUpdateCallback != 0);\n                    assert(pTab->aCol != 0);\n                    db->xUpdateCallback(db->pUpdateArg, (pOp->p5 & 4) ? 23 : 18, zDb, pTab->zName, x.nKey);\n                }\n                break;\n            }\n          case 129:\n            {\n                VdbeCursor *pDest;\n                VdbeCursor *pSrc;\n                i64 iKey;\n                assert(pOp[1].opcode == 128 || pOp[1].opcode == 138);\n                assert(pOp[1].opcode == 128 || pOp->p3 == 0);\n                assert(pOp[1].opcode == 138 || pOp->p3 > 0);\n                assert(pOp[1].p5 & 128);\n                pDest = p->apCsr[pOp->p1];\n                pSrc = p->apCsr[pOp->p2];\n                iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;\n                rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 130:\n            {\n                VdbeCursor *pC;\n                const char *zDb;\n                Table *pTab;\n                int opflags;\n                opflags = pOp->p2;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->deferredMoveto == 0);\n                ;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    assert(pC->iDb >= 0);\n                    assert(pOp->p4.pTab != 0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    if ((pOp->p5 & 2) != 0 && pC->isTable) {\n                        pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                    }\n                } else {\n                    zDb = 0;\n                    pTab = 0;\n                }\n                assert((pOp->p5 & ~(2 | 4)) == 0);\n                assert(2 == 2);\n                assert(4 == 4);\n                rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (opflags & 1) {\n                    p->nChange++;\n                    if (db->xUpdateCallback && (pTab != 0) && (((pTab)->tabFlags & 128) == 0)) {\n                        db->xUpdateCallback(db->pUpdateArg, 9, zDb, pTab->zName, pC->movetoTarget);\n                        assert(pC->iDb >= 0);\n                    }\n                }\n                break;\n            }\n          case 131:\n            {\n                sqlite3VdbeSetChanges(db, p->nChange);\n                p->nChange = 0;\n                break;\n            }\n          case 132:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nKeyCol;\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                assert(pOp->p4type == (-3));\n                pIn3 = &aMem[pOp->p3];\n                nKeyCol = pOp->p4.i;\n                res = 0;\n                rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n            ;\n          case 133:\n            {\n                VdbeCursor *pC;\n                pOut = &aMem[pOp->p2];\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                rc = sqlite3VdbeSorterRowkey(pC, pOut);\n                assert(rc != 0 || (pOut->flags & 16));\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                if (rc)\n                    goto abort_due_to_error;\n                p->apCsr[pOp->p3]->cacheStatus = 0;\n                break;\n            }\n          case 134:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 n;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(((pC)->eCurType == 1) == 0);\n                assert(pC->nullRow == 0);\n                assert(pC->uc.pCursor != 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pC->deferredMoveto == 0);\n                assert(sqlite3BtreeCursorIsValid(pCrsr));\n                n = sqlite3BtreePayloadSize(pCrsr);\n                if (n > (u32)db->aLimit[0]) {\n                    goto too_big;\n                }\n                ;\n                rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut);\n                if (rc)\n                    goto abort_due_to_error;\n                if (!pOp->p3)\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                ;\n                ;\n                ;\n                break;\n            }\n          case 135:\n            {\n                VdbeCursor *pC;\n                i64 v;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType != 3 || pC->nullRow);\n                if (pC->nullRow) {\n                    pOut->flags = 1;\n                    break;\n                } else if (pC->deferredMoveto) {\n                    v = pC->movetoTarget;\n                } else if (pC->eCurType == 2) {\n                    assert(pC->uc.pVCur != 0);\n                    pVtab = pC->uc.pVCur->pVtab;\n                    pModule = pVtab->pModule;\n                    assert(pModule->xRowid);\n                    rc = pModule->xRowid(pC->uc.pVCur, &v);\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else {\n                    assert(pC->eCurType == 0);\n                    assert(pC->uc.pCursor != 0);\n                    rc = sqlite3VdbeCursorRestore(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (pC->nullRow) {\n                        pOut->flags = 1;\n                        break;\n                    }\n                    v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 136:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if (pC == 0) {\n                    pC = allocateCursor(p, pOp->p1, 1, 3);\n                    if (pC == 0)\n                        goto no_mem;\n                    pC->seekResult = 0;\n                    pC->isTable = 1;\n                    pC->noReuse = 1;\n                    pC->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                }\n                pC->nullRow = 1;\n                pC->cacheStatus = 0;\n                if (pC->eCurType == 0) {\n                    assert(pC->uc.pCursor != 0);\n                    sqlite3BtreeClearCursor(pC->uc.pCursor);\n                }\n                break;\n            }\n          case 137:\n          case 32:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                pCrsr = pC->uc.pCursor;\n                res = 0;\n                assert(pCrsr != 0);\n                if (pOp->opcode == 137) {\n                    assert(pOp->p2 == 0);\n                    pC->seekResult = -1;\n                    if (sqlite3BtreeCursorIsValidNN(pCrsr)) {\n                        break;\n                    }\n                }\n                rc = sqlite3BtreeLast(pCrsr, &res);\n                pC->nullRow = (u8)res;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pOp->p2 > 0) {\n                    ;\n                    if (res)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 33:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                i64 sz;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr);\n                rc = sqlite3BtreeFirst(pCrsr, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    sz = sqlite3BtreeRowCountEst(pCrsr);\n                    if ((sz >= 0) && sqlite3LogEst((u64)sz) < pOp->p3)\n                        res = 1;\n                }\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 34:\n          case 35:\n            {\n                p->aCounter[2]++;\n            }\n          case 36:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(((pC)->eCurType == 1) == (pOp->opcode == 34));\n                res = 1;\n                if (((pC)->eCurType == 1)) {\n                    rc = sqlite3VdbeSorterRewind(pC, &res);\n                } else {\n                    assert(pC->eCurType == 0);\n                    pCrsr = pC->uc.pCursor;\n                    assert(pCrsr);\n                    rc = sqlite3BtreeFirst(pCrsr, &res);\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pC->nullRow = (u8)res;\n                assert(pOp->p2 > 0 && pOp->p2 < p->nOp);\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 37:\n            {\n                VdbeCursor *pC;\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                rc = sqlite3VdbeSorterNext(db, pC);\n                goto next_tail;\n              case 38:\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0 || pOp->p5 == 1 || pOp->p5 == 3);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->eCurType == 0);\n                assert(<recovery-expr>(pC) == 21 || <recovery-expr>(pC) == 22 || <recovery-expr>(pC) == 32 || <recovery-expr>(pC) == 26 || <recovery-expr>(pC) == 136);\n                rc = sqlite3BtreePrevious(pC->uc.pCursor, pOp->p3);\n                goto next_tail;\n              case 39:\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0 || pOp->p5 == 1 || pOp->p5 == 3);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->eCurType == 0);\n                assert(<recovery-expr>(pC) == 24 || <recovery-expr>(pC) == 23 || <recovery-expr>(pC) == 36 || <recovery-expr>(pC) == 29 || <recovery-expr>(pC) == 136 || <recovery-expr>(pC) == 30 || <recovery-expr>(pC) == 26);\n                rc = sqlite3BtreeNext(pC->uc.pCursor, pOp->p3);\n              next_tail:\n                pC->cacheStatus = 0;\n                ;\n                if (rc == 0) {\n                    pC->nullRow = 0;\n                    p->aCounter[pOp->p5]++;\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                if (rc != 101)\n                    goto abort_due_to_error;\n                rc = 0;\n                pC->nullRow = 1;\n                goto check_for_interrupt;\n            }\n          case 138:\n            {\n                VdbeCursor *pC;\n                BtreePayload x;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                ;\n                assert(pC != 0);\n                assert(!((pC)->eCurType == 1));\n                pIn2 = &aMem[pOp->p2];\n                assert((pIn2->flags & 16) || (pOp->p5 & 128));\n                if (pOp->p5 & 1)\n                    p->nChange++;\n                assert(pC->eCurType == 0);\n                assert(pC->isTable == 0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                x.nKey = pIn2->n;\n                x.pKey = pIn2->z;\n                x.aMem = aMem + pOp->p3;\n                x.nMem = (u16)pOp->p4.i;\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), ((pOp->p5 & 16) ? pC->seekResult : 0));\n                assert(pC->deferredMoveto == 0);\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 139:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                ;\n                assert(pC != 0);\n                assert(((pC)->eCurType == 1));\n                pIn2 = &aMem[pOp->p2];\n                assert(pIn2->flags & 16);\n                assert(pC->isTable == 0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeSorterWrite(pC, pIn2);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 140:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                UnpackedRecord r;\n                assert(pOp->p3 > 0);\n                assert(pOp->p2 > 0 && pOp->p2 + pOp->p3 <= (p->nMem + 1 - p->nCursor) + 1);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                ;\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr != 0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p3;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp->p2];\n                rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    rc = sqlite3BtreeDelete(pCrsr, 4);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else if (pOp->p5 && !sqlite3WritableSchema(db)) {\n                    rc = sqlite3ReportError((11 | (3 << 8)), 96007, \"index corruption\");\n                    goto abort_due_to_error;\n                }\n                assert(pC->deferredMoveto == 0);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                break;\n            }\n          case 141:\n          case 142:\n            {\n                VdbeCursor *pC;\n                VdbeCursor *pTabCur;\n                i64 rowid;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0 || ((pC)->eCurType == 3 && (pC)->nullRow && (pC)->seekResult == 0));\n                assert(pC->uc.pCursor != 0);\n                assert(pC->isTable == 0 || ((pC)->eCurType == 3 && (pC)->nullRow && (pC)->seekResult == 0));\n                assert(pC->deferredMoveto == 0);\n                assert(!pC->nullRow || pOp->opcode == 142);\n                rc = sqlite3VdbeCursorRestore(pC);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                if (!pC->nullRow) {\n                    rowid = 0;\n                    rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (pOp->opcode == 141) {\n                        assert(pOp->p3 >= 0 && pOp->p3 < p->nCursor);\n                        pTabCur = p->apCsr[pOp->p3];\n                        assert(pTabCur != 0);\n                        assert(pTabCur->eCurType == 0);\n                        assert(pTabCur->uc.pCursor != 0);\n                        assert(pTabCur->isTable);\n                        pTabCur->nullRow = 0;\n                        pTabCur->movetoTarget = rowid;\n                        pTabCur->deferredMoveto = 1;\n                        pTabCur->cacheStatus = 0;\n                        assert(pOp->p4type == (-14) || pOp->p4.ai == 0);\n                        assert(!pTabCur->isEphemeral);\n                        pTabCur->ub.aAltMap = pOp->p4.ai;\n                        assert(!pC->isEphemeral);\n                        pTabCur->pAltCursor = pC;\n                    } else {\n                        pOut = out2Prerelease(p, pOp);\n                        pOut->u.i = rowid;\n                    }\n                } else {\n                    assert(pOp->opcode == 142);\n                    sqlite3VdbeMemSetNull(&aMem[pOp->p2]);\n                }\n                break;\n            }\n          case 143:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if (pC->deferredMoveto) {\n                    rc = sqlite3VdbeFinishMoveto(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 40:\n          case 41:\n          case 42:\n          case 45:\n            {\n                VdbeCursor *pC;\n                int res;\n                UnpackedRecord r;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isOrdered);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pOp->p4type == (-3));\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p4.i;\n                if (pOp->opcode < 42) {\n                    assert(pOp->opcode == 40 || pOp->opcode == 41);\n                    r.default_rc = -1;\n                } else {\n                    assert(pOp->opcode == 45 || pOp->opcode == 42);\n                    r.default_rc = 0;\n                }\n                r.aMem = &aMem[pOp->p3];\n                {\n                    i64 nCellKey = 0;\n                    BtCursor *pCur;\n                    Mem m;\n                    assert(pC->eCurType == 0);\n                    pCur = pC->uc.pCursor;\n                    assert(sqlite3BtreeCursorIsValid(pCur));\n                    nCellKey = sqlite3BtreePayloadSize(pCur);\n                    if (nCellKey <= 0 || nCellKey > 2147483647) {\n                        rc = sqlite3CorruptError(96212);\n                        goto abort_due_to_error;\n                    }\n                    sqlite3VdbeMemInit(&m, db, 0);\n                    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n                    if (rc)\n                        goto abort_due_to_error;\n                    res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);\n                    sqlite3VdbeMemReleaseMalloc(&m);\n                }\n                assert((40 & 1) == (42 & 1) && (45 & 1) == (41 & 1));\n                if ((pOp->opcode & 1) == (42 & 1)) {\n                    assert(pOp->opcode == 40 || pOp->opcode == 42);\n                    res = -res;\n                } else {\n                    assert(pOp->opcode == 45 || pOp->opcode == 41);\n                    res++;\n                }\n                ;\n                assert(rc == 0);\n                if (res > 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 144:\n            {\n                int iMoved;\n                int iDb;\n                ;\n                assert(p->readOnly == 0);\n                assert(pOp->p1 > 1);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                if (db->nVdbeRead > db->nVDestroy + 1) {\n                    rc = 6;\n                    p->errorAction = 2;\n                    goto abort_due_to_error;\n                } else {\n                    iDb = pOp->p3;\n                    assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                    iMoved = 0;\n                    rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);\n                    pOut->flags = 4;\n                    pOut->u.i = iMoved;\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (iMoved != 0) {\n                        sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);\n                        assert(resetSchemaOnFault == 0 || resetSchemaOnFault == iDb + 1);\n                        resetSchemaOnFault = iDb + 1;\n                    }\n                }\n                break;\n            }\n          case 145:\n            {\n                i64 nChange;\n                ;\n                nChange = 0;\n                assert(p->readOnly == 0);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p2))) != 0));\n                rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, (u32)pOp->p1, &nChange);\n                if (pOp->p3) {\n                    p->nChange += nChange;\n                    if (pOp->p3 > 0) {\n                        assert(memIsValid(&aMem[pOp->p3]));\n                        ;\n                        aMem[pOp->p3].u.i += nChange;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 146:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                if (((pC)->eCurType == 1)) {\n                    sqlite3VdbeSorterReset(db, pC->uc.pSorter);\n                } else {\n                    assert(pC->eCurType == 0);\n                    assert(pC->isEphemeral);\n                    rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 147:\n            {\n                Pgno pgno;\n                Db *pDb;\n                ;\n                pOut = out2Prerelease(p, pOp);\n                pgno = 0;\n                assert(pOp->p3 == 1 || pOp->p3 == 2);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pDb = &db->aDb[pOp->p1];\n                assert(pDb->pBt != 0);\n                rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, pOp->p3);\n                if (rc)\n                    goto abort_due_to_error;\n                pOut->u.i = pgno;\n                break;\n            }\n          case 148:\n            {\n                ;\n                db->nSqlExec++;\n                rc = sqlite3_exec(db, pOp->p4.z, 0, 0, 0);\n                db->nSqlExec--;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 149:\n            {\n                int iDb;\n                const char *zSchema;\n                char *zSql;\n                InitData initData;\n                iDb = pOp->p1;\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert((((db)->aDb[iDb].pSchema->schemaFlags & (1)) == (1)) || db->mallocFailed || ((sqlite3Config.neverCorrupt == 0) && (db->flags & 134217728) != 0));\n                if (pOp->p4.z == 0) {\n                    sqlite3SchemaClear(db->aDb[iDb].pSchema);\n                    db->mDbFlags &= ~16;\n                    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, pOp->p5);\n                    db->mDbFlags |= 1;\n                    p->expired = 0;\n                } else {\n                    zSchema = \"sqlite_master\";\n                    initData.db = db;\n                    initData.iDb = iDb;\n                    initData.pzErrMsg = &p->zErrMsg;\n                    initData.mInitFlags = 0;\n                    initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);\n                    zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".%s WHERE %s ORDER BY rowid\", db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);\n                    if (zSql == 0) {\n                        rc = 7;\n                    } else {\n                        assert(db->init.busy == 0);\n                        db->init.busy = 1;\n                        initData.rc = 0;\n                        initData.nInitRow = 0;\n                        assert(!db->mallocFailed);\n                        rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n                        if (rc == 0)\n                            rc = initData.rc;\n                        if (rc == 0 && initData.nInitRow == 0) {\n                            rc = sqlite3CorruptError(96464);\n                        }\n                        sqlite3DbFreeNN(db, zSql);\n                        db->init.busy = 0;\n                    }\n                }\n                if (rc) {\n                    sqlite3ResetAllSchemasOfConnection(db);\n                    if (rc == 7) {\n                        goto no_mem;\n                    }\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 150:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                rc = sqlite3AnalysisLoad(db, pOp->p1);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 151:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 152:\n            {\n                ;\n                sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 154:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 155:\n            {\n                int nRoot;\n                Pgno *aRoot;\n                int nErr;\n                char *z;\n                Mem *pnErr;\n                assert(p->bIsReader);\n                nRoot = pOp->p2;\n                aRoot = pOp->p4.ai;\n                assert(nRoot > 0);\n                assert(aRoot[0] == (Pgno)nRoot);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pnErr = &aMem[pOp->p3];\n                assert((pnErr->flags & 4) != 0);\n                assert((pnErr->flags & (2 | 16)) == 0);\n                pIn1 = &aMem[pOp->p1];\n                assert(pOp->p5 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p5))) != 0));\n                z = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot, (int)pnErr->u.i + 1, &nErr);\n                sqlite3VdbeMemSetNull(pIn1);\n                if (nErr == 0) {\n                    assert(z == 0);\n                } else if (z == 0) {\n                    goto no_mem;\n                } else {\n                    pnErr->u.i -= nErr - 1;\n                    sqlite3VdbeMemSetStr(pIn1, z, -1, 1, sqlite3_free);\n                }\n                ;\n                sqlite3VdbeChangeEncoding(pIn1, encoding);\n                goto check_for_interrupt;\n            }\n          case 156:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                assert((pIn2->flags & 4) != 0);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                assert(sqlite3VdbeMemIsRowSet(pIn1));\n                sqlite3RowSetInsert((RowSet *)pIn1->z, pIn2->u.i);\n                break;\n            }\n          case 46:\n            {\n                i64 val;\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 16) == 0 || sqlite3VdbeMemIsRowSet(pIn1));\n                if ((pIn1->flags & 16) == 0 || sqlite3RowSetNext((RowSet *)pIn1->z, &val) == 0) {\n                    sqlite3VdbeMemSetNull(pIn1);\n                    ;\n                    goto jump_to_p2_and_check_for_interrupt;\n                } else {\n                    ;\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);\n                }\n                goto check_for_interrupt;\n            }\n          case 47:\n            {\n                int iSet;\n                int exists;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                iSet = pOp->p4.i;\n                assert(pIn3->flags & 4);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                assert(sqlite3VdbeMemIsRowSet(pIn1));\n                assert(pOp->p4type == (-3));\n                assert(iSet == -1 || iSet >= 0);\n                if (iSet) {\n                    exists = sqlite3RowSetTest((RowSet *)pIn1->z, iSet, pIn3->u.i);\n                    ;\n                    if (exists)\n                        goto jump_to_p2;\n                }\n                if (iSet >= 0) {\n                    sqlite3RowSetInsert((RowSet *)pIn1->z, pIn3->u.i);\n                }\n                break;\n            }\n          case 48:\n            {\n                int nMem;\n                int nByte;\n                Mem *pRt;\n                Mem *pMem;\n                Mem *pEnd;\n                VdbeFrame *pFrame;\n                SubProgram *pProgram;\n                void *t;\n                pProgram = pOp->p4.pProgram;\n                pRt = &aMem[pOp->p3];\n                assert(pProgram->nOp > 0);\n                if (pOp->p5) {\n                    t = pProgram->token;\n                    for (pFrame = p->pFrame; pFrame && pFrame->token != t; pFrame = pFrame->pParent)\n                        ;\n                    if (pFrame)\n                        break;\n                }\n                if (p->nFrame >= db->aLimit[10]) {\n                    rc = 1;\n                    sqlite3VdbeError(p, \"too many levels of trigger recursion\");\n                    goto abort_due_to_error;\n                }\n                if ((pRt->flags & 16) == 0) {\n                    nMem = pProgram->nMem + pProgram->nCsr;\n                    assert(nMem > 0);\n                    if (pProgram->nCsr == 0)\n                        nMem++;\n                    nByte = (((sizeof(VdbeFrame)) + 7) & ~7) + nMem * sizeof(Mem) + pProgram->nCsr * sizeof(VdbeCursor *) + (pProgram->nOp + 7) / 8;\n                    pFrame = sqlite3DbMallocZero(db, nByte);\n                    if (!pFrame) {\n                        goto no_mem;\n                    }\n                    sqlite3VdbeMemRelease(pRt);\n                    pRt->flags = 16 | 4096;\n                    pRt->z = (char *)pFrame;\n                    pRt->n = nByte;\n                    pRt->xDel = sqlite3VdbeFrameMemDel;\n                    pFrame->v = p;\n                    pFrame->nChildMem = nMem;\n                    pFrame->nChildCsr = pProgram->nCsr;\n                    pFrame->pc = (int)(pOp - aOp);\n                    pFrame->aMem = p->aMem;\n                    pFrame->nMem = p->nMem;\n                    pFrame->apCsr = p->apCsr;\n                    pFrame->nCursor = p->nCursor;\n                    pFrame->aOp = p->aOp;\n                    pFrame->nOp = p->nOp;\n                    pFrame->token = pProgram->token;\n                    pEnd = &((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)])[pFrame->nChildMem];\n                    for (pMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]); pMem != pEnd; pMem++) {\n                        pMem->flags = 0;\n                        pMem->db = db;\n                    }\n                } else {\n                    pFrame = (VdbeFrame *)pRt->z;\n                    assert(pRt->xDel == sqlite3VdbeFrameMemDel);\n                    assert(pProgram->nMem + pProgram->nCsr == pFrame->nChildMem || (pProgram->nCsr == 0 && pProgram->nMem + 1 == pFrame->nChildMem));\n                    assert(pProgram->nCsr == pFrame->nChildCsr);\n                    assert((int)(pOp - aOp) == pFrame->pc);\n                }\n                p->nFrame++;\n                pFrame->pParent = p->pFrame;\n                pFrame->lastRowid = db->lastRowid;\n                pFrame->nChange = p->nChange;\n                pFrame->nDbChange = p->db->nChange;\n                assert(pFrame->pAuxData == 0);\n                pFrame->pAuxData = p->pAuxData;\n                p->pAuxData = 0;\n                p->nChange = 0;\n                p->pFrame = pFrame;\n                p->aMem = aMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]);\n                p->nMem = pFrame->nChildMem;\n                p->nCursor = (u16)pFrame->nChildCsr;\n                p->apCsr = (VdbeCursor **)&aMem[p->nMem];\n                pFrame->aOnce = (u8 *)&p->apCsr[pProgram->nCsr];\n                memset(pFrame->aOnce, 0, (pProgram->nOp + 7) / 8);\n                p->aOp = aOp = pProgram->aOp;\n                p->nOp = pProgram->nOp;\n                pOp = &aOp[-1];\n                goto check_for_interrupt;\n            }\n          case 157:\n            {\n                VdbeFrame *pFrame;\n                Mem *pIn;\n                pOut = out2Prerelease(p, pOp);\n                pFrame = p->pFrame;\n                pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];\n                sqlite3VdbeMemShallowCopy(pOut, pIn, 16384);\n                break;\n            }\n          case 158:\n            {\n                if (db->flags & 524288) {\n                    db->nDeferredImmCons += pOp->p2;\n                } else if (pOp->p1) {\n                    db->nDeferredCons += pOp->p2;\n                } else {\n                    p->nFkConstraint += pOp->p2;\n                }\n                break;\n            }\n          case 49:\n            {\n                if (pOp->p1) {\n                    ;\n                    if (db->nDeferredCons == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                } else {\n                    ;\n                    if (p->nFkConstraint == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 159:\n            {\n                VdbeFrame *pFrame;\n                if (p->pFrame) {\n                    for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                        ;\n                    pIn1 = &pFrame->aMem[pOp->p1];\n                } else {\n                    pIn1 = &aMem[pOp->p1];\n                }\n                assert(memIsValid(pIn1));\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn2 = &aMem[pOp->p2];\n                sqlite3VdbeMemIntegerify(pIn2);\n                if (pIn1->u.i < pIn2->u.i) {\n                    pIn1->u.i = pIn2->u.i;\n                }\n                break;\n            }\n          case 59:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                ;\n                if (pIn1->u.i > 0) {\n                    pIn1->u.i -= pOp->p3;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 160:\n            {\n                i64 x;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                assert(pIn1->flags & 4);\n                assert(pIn3->flags & 4);\n                x = pIn1->u.i;\n                if (x <= 0 || sqlite3AddInt64(&x, pIn3->u.i > 0 ? pIn3->u.i : 0)) {\n                    pOut->u.i = -1;\n                } else {\n                    pOut->u.i = x;\n                }\n                break;\n            }\n          case 60:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                ;\n                if (pIn1->u.i) {\n                    if (pIn1->u.i > 0)\n                        pIn1->u.i--;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 61:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                if (pIn1->u.i > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                    pIn1->u.i--;\n                ;\n                if (pIn1->u.i == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 161:\n          case 162:\n            {\n                int n;\n                sqlite3_context *pCtx;\n                assert(pOp->p4type == (-7));\n                n = pOp->p5;\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                assert(n == 0 || (pOp->p2 > 0 && pOp->p2 + n <= (p->nMem + 1 - p->nCursor) + 1));\n                assert(pOp->p3 < pOp->p2 || pOp->p3 >= pOp->p2 + n);\n                pCtx = sqlite3DbMallocRawNN(db, n * sizeof(sqlite3_value *) + (sizeof (pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value *)));\n                if (pCtx == 0)\n                    goto no_mem;\n                pCtx->pMem = 0;\n                pCtx->pOut = (Mem *)&(pCtx->argv[n]);\n                sqlite3VdbeMemInit(pCtx->pOut, db, 1);\n                pCtx->pFunc = pOp->p4.pFunc;\n                pCtx->iOp = (int)(pOp - aOp);\n                pCtx->pVdbe = p;\n                pCtx->skipFlag = 0;\n                pCtx->isError = 0;\n                pCtx->enc = encoding;\n                pCtx->argc = n;\n                pOp->p4type = (-15);\n                pOp->p4.pCtx = pCtx;\n                assert(pOp->p1 == (pOp->opcode == 161));\n                pOp->opcode = 163;\n            }\n          case 163:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                Mem *pMem;\n                assert(pOp->p4type == (-15));\n                pCtx = pOp->p4.pCtx;\n                pMem = &aMem[pOp->p3];\n                if (pCtx->pMem != pMem) {\n                    pCtx->pMem = pMem;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                pMem->n++;\n                assert(pCtx->pOut->flags == 1);\n                assert(pCtx->isError == 0);\n                assert(pCtx->skipFlag == 0);\n                if (pOp->p1) {\n                    (pCtx->pFunc->xInverse)(pCtx, pCtx->argc, pCtx->argv);\n                } else\n                    (pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pCtx->pOut));\n                        rc = pCtx->isError;\n                    }\n                    if (pCtx->skipFlag) {\n                        assert(pOp[-1].opcode == 85);\n                        i = pOp[-1].p1;\n                        if (i)\n                            sqlite3VdbeMemSetInt64(&aMem[i], 1);\n                        pCtx->skipFlag = 0;\n                    }\n                    sqlite3VdbeMemRelease(pCtx->pOut);\n                    pCtx->pOut->flags = 1;\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                assert(pCtx->pOut->flags == 1);\n                assert(pCtx->skipFlag == 0);\n                break;\n            }\n          case 164:\n          case 165:\n            {\n                Mem *pMem;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                assert(pOp->p3 == 0 || pOp->opcode == 164);\n                pMem = &aMem[pOp->p1];\n                assert((pMem->flags & ~(1 | 32768)) == 0);\n                if (pOp->p3) {\n                    ;\n                    rc = sqlite3VdbeMemAggValue(pMem, &aMem[pOp->p3], pOp->p4.pFunc);\n                    pMem = &aMem[pOp->p3];\n                } else {\n                    rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);\n                }\n                if (rc) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pMem));\n                    goto abort_due_to_error;\n                }\n                sqlite3VdbeChangeEncoding(pMem, encoding);\n                ;\n                break;\n            }\n          case 3:\n            {\n                int i;\n                int aRes[3];\n                Mem *pMem;\n                assert(p->readOnly == 0);\n                aRes[0] = 0;\n                aRes[1] = aRes[2] = -1;\n                assert(pOp->p2 == 0 || pOp->p2 == 1 || pOp->p2 == 2 || pOp->p2 == 3);\n                rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);\n                if (rc) {\n                    if (rc != 5)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    aRes[0] = 1;\n                }\n                for (i = 0 , pMem = &aMem[pOp->p3]; i < 3; i++ , pMem++) {\n                    sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);\n                }\n                break;\n            }\n            ;\n          case 4:\n            {\n                Btree *pBt;\n                Pager *pPager;\n                int eNew;\n                int eOld;\n                const char *zFilename;\n                pOut = out2Prerelease(p, pOp);\n                eNew = pOp->p3;\n                assert(eNew == 0 || eNew == 3 || eNew == 1 || eNew == 2 || eNew == 4 || eNew == 5 || eNew == (-1));\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert(p->readOnly == 0);\n                pBt = db->aDb[pOp->p1].pBt;\n                pPager = sqlite3BtreePager(pBt);\n                eOld = sqlite3PagerGetJournalMode(pPager);\n                if (eNew == (-1))\n                    eNew = eOld;\n                assert(sqlite3BtreeHoldsMutex(pBt));\n                if (!sqlite3PagerOkToChangeJournalMode(pPager))\n                    eNew = eOld;\n                zFilename = sqlite3PagerFilename(pPager, 1);\n                if (eNew == 5 && (sqlite3Strlen30(zFilename) == 0 || !sqlite3PagerWalSupported(pPager))) {\n                    eNew = eOld;\n                }\n                if ((eNew != eOld) && (eOld == 5 || eNew == 5)) {\n                    if (!db->autoCommit || db->nVdbeRead > 1) {\n                        rc = 1;\n                        sqlite3VdbeError(p, \"cannot change %s wal mode from within a transaction\", (eNew == 5 ? \"into\" : \"out of\"));\n                        goto abort_due_to_error;\n                    } else {\n                        if (eOld == 5) {\n                            rc = sqlite3PagerCloseWal(pPager, db);\n                            if (rc == 0) {\n                                sqlite3PagerSetJournalMode(pPager, eNew);\n                            }\n                        } else if (eOld == 4) {\n                            sqlite3PagerSetJournalMode(pPager, 2);\n                        }\n                        assert(sqlite3BtreeTxnState(pBt) != 2);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeSetVersion(pBt, (eNew == 5 ? 2 : 1));\n                        }\n                    }\n                }\n                if (rc)\n                    eNew = eOld;\n                eNew = sqlite3PagerSetJournalMode(pPager, eNew);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = (char *)sqlite3JournalModename(eNew);\n                pOut->n = sqlite3Strlen30(pOut->z);\n                pOut->enc = 1;\n                sqlite3VdbeChangeEncoding(pOut, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 5:\n            {\n                assert(p->readOnly == 0);\n                rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1, pOp->p2 ? &aMem[pOp->p2] : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 62:\n            {\n                Btree *pBt;\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pBt = db->aDb[pOp->p1].pBt;\n                rc = sqlite3BtreeIncrVacuum(pBt);\n                ;\n                if (rc) {\n                    if (rc != 101)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 166:\n            {\n                assert(pOp->p2 == 0 || pOp->p2 == 1);\n                if (!pOp->p1) {\n                    sqlite3ExpirePreparedStatements(db, pOp->p2);\n                } else {\n                    p->expired = pOp->p2 + 1;\n                }\n                break;\n            }\n          case 167:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                sqlite3BtreeCursorPin(pC->uc.pCursor);\n                break;\n            }\n          case 168:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                sqlite3BtreeCursorUnpin(pC->uc.pCursor);\n                break;\n            }\n          case 169:\n            {\n                u8 isWriteLock = (u8)pOp->p3;\n                if (isWriteLock || 0 == (db->flags & 1024)) {\n                    int p1 = pOp->p1;\n                    assert(p1 >= 0 && p1 < db->nDb);\n                    assert((((p->btreeMask) & (((yDbMask)1) << (p1))) != 0));\n                    assert(isWriteLock == 0 || isWriteLock == 1);\n                    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);\n                    if (rc) {\n                        if ((rc & 255) == 6) {\n                            const char *z = pOp->p4.z;\n                            sqlite3VdbeError(p, \"database table is locked: %s\", z);\n                        }\n                        goto abort_due_to_error;\n                    }\n                }\n                break;\n            }\n          case 170:\n            {\n                VTable *pVTab;\n                pVTab = pOp->p4.pVtab;\n                rc = sqlite3VtabBegin(db, pVTab);\n                if (pVTab)\n                    sqlite3VtabImportErrmsg(p, pVTab->pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 171:\n            {\n                Mem sMem;\n                const char *zTab;\n                memset(&sMem, 0, sizeof (sMem));\n                sMem.db = db;\n                assert((aMem[pOp->p2].flags & 2) != 0);\n                assert((aMem[pOp->p2].flags & 8192) != 0);\n                rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);\n                assert(rc == 0);\n                zTab = (const char *)sqlite3_value_text(&sMem);\n                assert(zTab || db->mallocFailed);\n                if (zTab) {\n                    rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);\n                }\n                sqlite3VdbeMemRelease(&sMem);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 172:\n            {\n                db->nVDestroy++;\n                rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);\n                db->nVDestroy--;\n                assert(p->errorAction == 2 && p->usesStmtJournal);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 173:\n            {\n                VdbeCursor *pCur;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                assert(p->bIsReader);\n                pCur = 0;\n                pVCur = 0;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                rc = pModule->xOpen(pVtab, &pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                pVCur->pVtab = pVtab;\n                pCur = allocateCursor(p, pOp->p1, 0, 2);\n                if (pCur) {\n                    pCur->uc.pVCur = pVCur;\n                    pVtab->nRef++;\n                } else {\n                    assert(db->mallocFailed);\n                    pModule->xClose(pVCur);\n                    goto no_mem;\n                }\n                break;\n            }\n          case 174:\n            {\n                VdbeCursor *pC;\n                ValueList *pRhs;\n                pC = p->apCsr[pOp->p1];\n                pRhs = sqlite3_malloc64(sizeof (*pRhs));\n                if (pRhs == 0)\n                    goto no_mem;\n                pRhs->pCsr = pC->uc.pCursor;\n                pRhs->pOut = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                sqlite3VdbeMemSetPointer(pOut, pRhs, \"ValueList\", sqlite3_free);\n                break;\n            }\n          case 6:\n            {\n                int nArg;\n                int iQuery;\n                const sqlite3_module *pModule;\n                Mem *pQuery;\n                Mem *pArgc;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                VdbeCursor *pCur;\n                int res;\n                int i;\n                Mem **apArg;\n                pQuery = &aMem[pOp->p3];\n                pArgc = &pQuery[1];\n                pCur = p->apCsr[pOp->p1];\n                assert(memIsValid(pQuery));\n                ;\n                assert(pCur != 0);\n                assert(pCur->eCurType == 2);\n                pVCur = pCur->uc.pVCur;\n                pVtab = pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert((pQuery->flags & 4) != 0 && pArgc->flags == 4);\n                nArg = (int)pArgc->u.i;\n                iQuery = (int)pQuery->u.i;\n                apArg = p->apArg;\n                for (i = 0; i < nArg; i++) {\n                    apArg[i] = &pArgc[i + 1];\n                }\n                rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pVCur);\n                pCur->nullRow = 0;\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 175:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                Mem *pDest;\n                sqlite3_context sContext;\n                VdbeCursor *pCur = p->apCsr[pOp->p1];\n                assert(pCur != 0);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pDest = &aMem[pOp->p3];\n                ;\n                if (pCur->nullRow) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    break;\n                }\n                assert(pCur->eCurType == 2);\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert(pModule->xColumn);\n                memset(&sContext, 0, sizeof (sContext));\n                sContext.pOut = pDest;\n                sContext.enc = encoding;\n                assert(pOp->p5 == 1 || pOp->p5 == 0);\n                if (pOp->p5 & 1) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    pDest->flags = 1 | 1024;\n                    pDest->u.nZero = 0;\n                } else {\n                    ((pDest)->flags = ((pDest)->flags & ~(3519 | 1024)) | 1);\n                }\n                rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (sContext.isError > 0) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pDest));\n                    rc = sContext.isError;\n                }\n                sqlite3VdbeChangeEncoding(pDest, encoding);\n                ;\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 63:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int res;\n                VdbeCursor *pCur;\n                pCur = p->apCsr[pOp->p1];\n                assert(pCur != 0);\n                assert(pCur->eCurType == 2);\n                if (pCur->nullRow) {\n                    break;\n                }\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert(pModule->xNext);\n                rc = pModule->xNext(pCur->uc.pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pCur->uc.pVCur);\n                ;\n                if (!res) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                goto check_for_interrupt;\n            }\n          case 176:\n            {\n                sqlite3_vtab *pVtab;\n                Mem *pName;\n                int isLegacy;\n                isLegacy = (db->flags & 67108864);\n                db->flags |= 67108864;\n                pVtab = pOp->p4.pVtab->pVtab;\n                pName = &aMem[pOp->p1];\n                assert(pVtab->pModule->xRename);\n                assert(memIsValid(pName));\n                assert(p->readOnly == 0);\n                ;\n                assert(pName->flags & 2);\n                ;\n                ;\n                ;\n                rc = sqlite3VdbeChangeEncoding(pName, 1);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = pVtab->pModule->xRename(pVtab, pName->z);\n                if (isLegacy == 0)\n                    db->flags &= ~(u64)67108864;\n                sqlite3VtabImportErrmsg(p, pVtab);\n                p->expired = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 7:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int nArg;\n                int i;\n                sqlite_int64 rowid = 0;\n                Mem **apArg;\n                Mem *pX;\n                assert(pOp->p2 == 1 || pOp->p5 == 3 || pOp->p5 == 1 || pOp->p5 == 2 || pOp->p5 == 4 || pOp->p5 == 5);\n                assert(p->readOnly == 0);\n                if (db->mallocFailed)\n                    goto no_mem;\n                ;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                nArg = pOp->p2;\n                assert(pOp->p4type == (-11));\n                if ((pModule->xUpdate)) {\n                    u8 vtabOnConflict = db->vtabOnConflict;\n                    apArg = p->apArg;\n                    pX = &aMem[pOp->p3];\n                    for (i = 0; i < nArg; i++) {\n                        assert(memIsValid(pX));\n                        ;\n                        apArg[i] = pX;\n                        pX++;\n                    }\n                    db->vtabOnConflict = pOp->p5;\n                    rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);\n                    db->vtabOnConflict = vtabOnConflict;\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc == 0 && pOp->p1) {\n                        assert(nArg > 1 && apArg[0] && (apArg[0]->flags & 1));\n                        db->lastRowid = rowid;\n                    }\n                    if ((rc & 255) == 19 && pOp->p4.pVtab->bConstraint) {\n                        if (pOp->p5 == 4) {\n                            rc = 0;\n                        } else {\n                            p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5);\n                        }\n                    } else {\n                        p->nChange++;\n                    }\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 177:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);\n                break;\n            }\n          case 178:\n            {\n                unsigned int newMax;\n                Btree *pBt;\n                pOut = out2Prerelease(p, pOp);\n                pBt = db->aDb[pOp->p1].pBt;\n                newMax = 0;\n                if (pOp->p3) {\n                    newMax = sqlite3BtreeLastPage(pBt);\n                    if (newMax < (unsigned int)pOp->p3)\n                        newMax = (unsigned int)pOp->p3;\n                }\n                pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);\n                break;\n            }\n          case 65:\n          case 66:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                assert(pOp->p4type == (-15));\n                pCtx = pOp->p4.pCtx;\n                pOut = &aMem[pOp->p3];\n                if (pCtx->pOut != pOut) {\n                    pCtx->pVdbe = p;\n                    pCtx->pOut = pOut;\n                    pCtx->enc = encoding;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                assert(pCtx->pVdbe == p);\n                ;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                assert(pCtx->isError == 0);\n                (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pOut));\n                        rc = pCtx->isError;\n                    }\n                    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                assert((pOut->flags & 2) == 0 || pOut->enc == encoding || db->mallocFailed);\n                assert(!sqlite3VdbeMemTooBig(pOut));\n                ;\n                ;\n                break;\n            }\n          case 179:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn1->flags &= ~2048;\n                break;\n            }\n          case 180:\n            {\n                u64 h;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 16);\n                assert(pIn1->n > 0);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                pIn1->z[h / 8] |= 1 << (h & 7);\n                break;\n            }\n          case 64:\n            {\n                u64 h;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 16) != 0);\n                assert(pIn1->n >= 1);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                if ((pIn1->z[h / 8] & (1 << (h & 7))) == 0) {\n                    ;\n                    p->aCounter[8]++;\n                    goto jump_to_p2;\n                } else {\n                    p->aCounter[7]++;\n                    ;\n                }\n                break;\n            }\n          case 181:\n          case 8:\n            {\n                int i;\n                char *zTrace;\n                assert(pOp->p4.z == 0 || strncmp(pOp->p4.z, \"-- \", 3) == 0);\n                assert(pOp == p->aOp || pOp->opcode == 181);\n                if ((db->mTrace & (1 | 64)) != 0 && p->minWriteFileFormat != 254 && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0) {\n                    if (db->mTrace & 64) {\n                        char *z = sqlite3VdbeExpandSql(p, zTrace);\n                        db->trace.xLegacy(db->pTraceArg, z);\n                        sqlite3_free(z);\n                    } else if (db->nVdbeExec > 1) {\n                        char *z = sqlite3MPrintf(db, \"-- %s\", zTrace);\n                        (void)db->trace.xV2(1, db->pTraceArg, p, z);\n                        sqlite3DbFree(db, z);\n                    } else {\n                        (void)db->trace.xV2(1, db->pTraceArg, p, zTrace);\n                    }\n                }\n                assert(pOp->p2 > 0);\n                if (pOp->p1 >= sqlite3Config.iOnceResetThreshold) {\n                    if (pOp->opcode == 181)\n                        break;\n                    for (i = 1; i < p->nOp; i++) {\n                        if (p->aOp[i].opcode == 15)\n                            p->aOp[i].p1 = 0;\n                    }\n                    pOp->p1 = 0;\n                }\n                pOp->p1++;\n                p->aCounter[6]++;\n                goto jump_to_p2;\n            }\n          default:\n            {\n                assert(pOp->opcode == 184 || pOp->opcode == 185);\n                break;\n            }\n        }\n    }\n  abort_due_to_error:\n    if (db->mallocFailed) {\n        rc = 7;\n    } else if (rc == (10 | (33 << 8))) {\n        rc = sqlite3CorruptError(98408);\n    }\n    assert(rc);\n    if (p->zErrMsg == 0 && rc != (10 | (12 << 8))) {\n        sqlite3VdbeError(p, \"%s\", sqlite3ErrStr(rc));\n    }\n    p->rc = rc;\n    sqlite3SystemError(db, rc);\n    ;\n    sqlite3_log(rc, \"statement aborts at %d: [%s] %s\", (int)(pOp - aOp), p->zSql, p->zErrMsg);\n    if (p->eVdbeState == 2)\n        sqlite3VdbeHalt(p);\n    if (rc == (10 | (12 << 8)))\n        sqlite3OomFault(db);\n    if (rc == 11 && db->autoCommit == 0) {\n        db->flags |= ((u64)(2) << 32);\n    }\n    rc = 1;\n    if (resetSchemaOnFault > 0) {\n        sqlite3ResetOneSchema(db, resetSchemaOnFault - 1);\n    }\n  vdbe_return:\n    while (nVmStep >= nProgressLimit && db->xProgress != 0)\n        {\n            nProgressLimit += db->nProgressOps;\n            if (db->xProgress(db->pProgressArg)) {\n                nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                rc = 9;\n                goto abort_due_to_error;\n            }\n        }\n    p->aCounter[4] += (int)nVmStep;\n    sqlite3VdbeLeave(p);\n    return rc;\n  too_big:\n    sqlite3VdbeError(p, \"string or blob too big\");\n    rc = 18;\n    goto abort_due_to_error;\n  no_mem:\n    sqlite3OomFault(db);\n    sqlite3VdbeError(p, \"out of memory\");\n    rc = 7;\n    goto abort_due_to_error;\n  abort_due_to_interrupt:\n    assert(__atomic_load_n((&db->u1.isInterrupted), 0));\n    rc = 9;\n    goto abort_due_to_error;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#197568:1#jsonRenderNode",
            "nobreaks": 1,
            "body": "{\n    assert(pNode != 0);\n    if (pNode->jnFlags & (8 | 16)) {\n        if ((pNode->jnFlags & 8) != 0 && (aReplace != 0)) {\n            assert(pNode->eU == 4);\n            jsonAppendValue(pOut, aReplace[pNode->u.iReplace]);\n            return;\n        }\n        assert(pNode->eU == 5);\n        pNode = pNode->u.pPatch;\n    }\n    switch (pNode->eType) {\n      default:\n        {\n            assert(pNode->eType == 0);\n            jsonAppendRaw(pOut, \"null\", 4);\n            break;\n        }\n      case 1:\n        {\n            jsonAppendRaw(pOut, \"true\", 4);\n            break;\n        }\n      case 2:\n        {\n            jsonAppendRaw(pOut, \"false\", 5);\n            break;\n        }\n      case 5:\n        {\n            if (pNode->jnFlags & 1) {\n                assert(pNode->eU == 1);\n                jsonAppendString(pOut, pNode->u.zJContent, pNode->n);\n                break;\n            }\n        }\n      case 4:\n      case 3:\n        {\n            assert(pNode->eU == 1);\n            jsonAppendRaw(pOut, pNode->u.zJContent, pNode->n);\n            break;\n        }\n      case 6:\n        {\n            u32 j = 1;\n            jsonAppendChar(pOut, '[');\n            for (;;) {\n                while (j <= pNode->n)\n                    {\n                        if ((pNode[j].jnFlags & 4) == 0) {\n                            jsonAppendSeparator(pOut);\n                            jsonRenderNode(&pNode[j], pOut, aReplace);\n                        }\n                        j += jsonNodeSize(&pNode[j]);\n                    }\n                if ((pNode->jnFlags & 32) == 0)\n                    break;\n                assert(pNode->eU == 2);\n                pNode = &pNode[pNode->u.iAppend];\n                j = 1;\n            }\n            jsonAppendChar(pOut, ']');\n            break;\n        }\n      case 7:\n        {\n            u32 j = 1;\n            jsonAppendChar(pOut, '{');\n            for (;;) {\n                while (j <= pNode->n)\n                    {\n                        if ((pNode[j + 1].jnFlags & 4) == 0) {\n                            jsonAppendSeparator(pOut);\n                            jsonRenderNode(&pNode[j], pOut, aReplace);\n                            jsonAppendChar(pOut, ':');\n                            jsonRenderNode(&pNode[j + 1], pOut, aReplace);\n                        }\n                        j += 1 + jsonNodeSize(&pNode[j + 1]);\n                    }\n                if ((pNode->jnFlags & 32) == 0)\n                    break;\n                assert(pNode->eU == 2);\n                pNode = &pNode[pNode->u.iAppend];\n                j = 1;\n            }\n            jsonAppendChar(pOut, '}');\n            break;\n        }\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#82738:1#resolveP2Values",
            "nobreaks": 1,
            "body": "{\n    int nMaxArgs = *pMaxFuncArgs;\n    Op *pOp;\n    Parse *pParse = p->pParse;\n    int *aLabel = pParse->aLabel;\n    p->readOnly = 1;\n    p->bIsReader = 0;\n    pOp = &p->aOp[p->nOp - 1];\n    assert(p->aOp[0].opcode == 8);\n    while (1)\n        {\n            if (pOp->opcode <= 64) {\n                switch (pOp->opcode) {\n                  case 2:\n                    {\n                        if (pOp->p2 != 0)\n                            p->readOnly = 0;\n                    }\n                  case 1:\n                  case 0:\n                    {\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 3:\n                  case 5:\n                  case 4:\n                    {\n                        p->readOnly = 0;\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 8:\n                    {\n                        assert(pOp->p2 >= 0);\n                        goto resolve_p2_values_loop_exit;\n                    }\n                  case 7:\n                    {\n                        if (pOp->p2 > nMaxArgs)\n                            nMaxArgs = pOp->p2;\n                        break;\n                    }\n                  case 6:\n                    {\n                        int n;\n                        assert((pOp - p->aOp) >= 3);\n                        assert(pOp[-1].opcode == 71);\n                        n = pOp[-1].p1;\n                        if (n > nMaxArgs)\n                            nMaxArgs = n;\n                    }\n                  default:\n                    {\n                        if (pOp->p2 < 0) {\n                            assert((sqlite3OpcodeProperty[pOp->opcode] & 1) != 0);\n                            assert((~(pOp->p2)) < -pParse->nLabel);\n                            pOp->p2 = aLabel[(~(pOp->p2))];\n                        }\n                        break;\n                    }\n                }\n                assert((sqlite3OpcodeProperty[pOp->opcode] & 1) == 0 || pOp->p2 >= 0);\n            }\n            assert(pOp > p->aOp);\n            pOp--;\n        }\n  resolve_p2_values_loop_exit:\n    if (aLabel) {\n        sqlite3DbNNFreeNN(p->db, pParse->aLabel);\n        pParse->aLabel = 0;\n    }\n    pParse->nLabel = 0;\n    *pMaxFuncArgs = nMaxArgs;\n    assert(p->bIsReader != 0 || (p->btreeMask) == 0);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#197703:1#jsonReturn",
            "nobreaks": 1,
            "body": "{\n    switch (pNode->eType) {\n      default:\n        {\n            assert(pNode->eType == 0);\n            sqlite3_result_null(pCtx);\n            break;\n        }\n      case 1:\n        {\n            sqlite3_result_int(pCtx, 1);\n            break;\n        }\n      case 2:\n        {\n            sqlite3_result_int(pCtx, 0);\n            break;\n        }\n      case 3:\n        {\n            sqlite3_int64 i = 0;\n            const char *z;\n            assert(pNode->eU == 1);\n            z = pNode->u.zJContent;\n            if (z[0] == '-') {\n                z++;\n            }\n            while (z[0] >= '0' && z[0] <= '9')\n                {\n                    unsigned int v = *(z++) - '0';\n                    if (i >= (4294967295U | (((i64)2147483647) << 32)) / 10) {\n                        if (i > (4294967295U | (((i64)2147483647) << 32)) / 10)\n                            goto int_as_real;\n                        if (z[0] >= '0' && z[0] <= '9')\n                            goto int_as_real;\n                        if (v == 9)\n                            goto int_as_real;\n                        if (v == 8) {\n                            if (pNode->u.zJContent[0] == '-') {\n                                sqlite3_result_int64(pCtx, (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))));\n                                goto int_done;\n                            } else {\n                                goto int_as_real;\n                            }\n                        }\n                    }\n                    i = i * 10 + v;\n                }\n            if (pNode->u.zJContent[0] == '-') {\n                i = -i;\n            }\n            sqlite3_result_int64(pCtx, i);\n          int_done:\n            break;\n          int_as_real:\n            ;\n        }\n      case 4:\n        {\n            double r;\n            const char *z;\n            assert(pNode->eU == 1);\n            z = pNode->u.zJContent;\n            sqlite3AtoF(z, &r, sqlite3Strlen30(z), 1);\n            sqlite3_result_double(pCtx, r);\n            break;\n        }\n      case 5:\n        {\n            assert((pNode->jnFlags & 1) == 0);\n            if ((pNode->jnFlags & 2) == 0) {\n                assert(pNode->eU == 1);\n                sqlite3_result_text(pCtx, pNode->u.zJContent + 1, pNode->n - 2, ((sqlite3_destructor_type)-1));\n            } else {\n                u32 i;\n                u32 n = pNode->n;\n                const char *z;\n                char *zOut;\n                u32 j;\n                assert(pNode->eU == 1);\n                z = pNode->u.zJContent;\n                zOut = sqlite3_malloc(n + 1);\n                if (zOut == 0) {\n                    sqlite3_result_error_nomem(pCtx);\n                    break;\n                }\n                for (i = 1 , j = 0; i < n - 1; i++) {\n                    char c = z[i];\n                    if (c != '\\\\') {\n                        zOut[j++] = c;\n                    } else {\n                        c = z[++i];\n                        if (c == 'u') {\n                            u32 v = jsonHexToInt4(z + i + 1);\n                            i += 4;\n                            if (v == 0)\n                                break;\n                            if (v <= 127) {\n                                zOut[j++] = (char)v;\n                            } else if (v <= 2047) {\n                                zOut[j++] = (char)(192 | (v >> 6));\n                                zOut[j++] = 128 | (v & 63);\n                            } else {\n                                u32 vlo;\n                                if ((v & 64512) == 55296 && i < n - 6 && z[i + 1] == '\\\\' && z[i + 2] == 'u' && ((vlo = jsonHexToInt4(z + i + 3)) & 64512) == 56320) {\n                                    v = ((v & 1023) << 10) + (vlo & 1023) + 65536;\n                                    i += 6;\n                                    zOut[j++] = 240 | (v >> 18);\n                                    zOut[j++] = 128 | ((v >> 12) & 63);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                } else {\n                                    zOut[j++] = 224 | (v >> 12);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                }\n                            }\n                        } else {\n                            if (c == 'b') {\n                                c = '\\b';\n                            } else if (c == 'f') {\n                                c = '\\f';\n                            } else if (c == 'n') {\n                                c = '\\n';\n                            } else if (c == 'r') {\n                                c = '\\r';\n                            } else if (c == 't') {\n                                c = '\\t';\n                            }\n                            zOut[j++] = c;\n                        }\n                    }\n                }\n                zOut[j] = 0;\n                sqlite3_result_text(pCtx, zOut, j, sqlite3_free);\n            }\n            break;\n        }\n      case 6:\n      case 7:\n        {\n            jsonReturnJson(pNode, pCtx, aReplace);\n            break;\n        }\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#23189:12#sqlite3_db_status",
            "nobreaks": 1,
            "body": "{\n    int rc = 0;\n    sqlite3_mutex_enter(db->mutex);\n    switch (op) {\n      case 0:\n        {\n            *pCurrent = sqlite3LookasideUsed(db, pHighwater);\n            if (resetFlag) {\n                LookasideSlot *p = db->lookaside.pFree;\n                if (p) {\n                    while (p->pNext)\n                        p = p->pNext;\n                    p->pNext = db->lookaside.pInit;\n                    db->lookaside.pInit = db->lookaside.pFree;\n                    db->lookaside.pFree = 0;\n                }\n                p = db->lookaside.pSmallFree;\n                if (p) {\n                    while (p->pNext)\n                        p = p->pNext;\n                    p->pNext = db->lookaside.pSmallInit;\n                    db->lookaside.pSmallInit = db->lookaside.pSmallFree;\n                    db->lookaside.pSmallFree = 0;\n                }\n            }\n            break;\n        }\n      case 4:\n      case 5:\n      case 6:\n        {\n            ;\n            ;\n            ;\n            assert((op - 4) >= 0);\n            assert((op - 4) < 3);\n            *pCurrent = 0;\n            *pHighwater = db->lookaside.anStat[op - 4];\n            if (resetFlag) {\n                db->lookaside.anStat[op - 4] = 0;\n            }\n            break;\n        }\n      case 11:\n      case 1:\n        {\n            int totalUsed = 0;\n            int i;\n            sqlite3BtreeEnterAll(db);\n            for (i = 0; i < db->nDb; i++) {\n                Btree *pBt = db->aDb[i].pBt;\n                if (pBt) {\n                    Pager *pPager = sqlite3BtreePager(pBt);\n                    int nByte = sqlite3PagerMemUsed(pPager);\n                    if (op == 11) {\n                        nByte = nByte / sqlite3BtreeConnectionCount(pBt);\n                    }\n                    totalUsed += nByte;\n                }\n            }\n            sqlite3BtreeLeaveAll(db);\n            *pCurrent = totalUsed;\n            *pHighwater = 0;\n            break;\n        }\n      case 2:\n        {\n            int i;\n            int nByte = 0;\n            sqlite3BtreeEnterAll(db);\n            db->pnBytesFreed = &nByte;\n            assert(db->lookaside.pEnd == db->lookaside.pTrueEnd);\n            db->lookaside.pEnd = db->lookaside.pStart;\n            for (i = 0; i < db->nDb; i++) {\n                Schema *pSchema = db->aDb[i].pSchema;\n                if ((pSchema != 0)) {\n                    HashElem *p;\n                    nByte += sqlite3Config.m.xRoundup(sizeof(HashElem)) * (pSchema->tblHash.count + pSchema->trigHash.count + pSchema->idxHash.count + pSchema->fkeyHash.count);\n                    nByte += sqlite3_msize(pSchema->tblHash.ht);\n                    nByte += sqlite3_msize(pSchema->trigHash.ht);\n                    nByte += sqlite3_msize(pSchema->idxHash.ht);\n                    nByte += sqlite3_msize(pSchema->fkeyHash.ht);\n                    for (p = ((&pSchema->trigHash)->first); p; p = ((p)->next)) {\n                        sqlite3DeleteTrigger(db, (Trigger *)((p)->data));\n                    }\n                    for (p = ((&pSchema->tblHash)->first); p; p = ((p)->next)) {\n                        sqlite3DeleteTable(db, (Table *)((p)->data));\n                    }\n                }\n            }\n            db->pnBytesFreed = 0;\n            db->lookaside.pEnd = db->lookaside.pTrueEnd;\n            sqlite3BtreeLeaveAll(db);\n            *pHighwater = 0;\n            *pCurrent = nByte;\n            break;\n        }\n      case 3:\n        {\n            struct Vdbe *pVdbe;\n            int nByte = 0;\n            db->pnBytesFreed = &nByte;\n            assert(db->lookaside.pEnd == db->lookaside.pTrueEnd);\n            db->lookaside.pEnd = db->lookaside.pStart;\n            for (pVdbe = db->pVdbe; pVdbe; pVdbe = pVdbe->pVNext) {\n                sqlite3VdbeDelete(pVdbe);\n            }\n            db->lookaside.pEnd = db->lookaside.pTrueEnd;\n            db->pnBytesFreed = 0;\n            *pHighwater = 0;\n            *pCurrent = nByte;\n            break;\n        }\n      case 12:\n        op = 9 + 1;\n      case 7:\n      case 8:\n      case 9:\n        {\n            int i;\n            int nRet = 0;\n            assert(8 == 7 + 1);\n            assert(9 == 7 + 2);\n            for (i = 0; i < db->nDb; i++) {\n                if (db->aDb[i].pBt) {\n                    Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);\n                    sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);\n                }\n            }\n            *pHighwater = 0;\n            *pCurrent = nRet;\n            break;\n        }\n      case 10:\n        {\n            *pHighwater = 0;\n            *pCurrent = db->nDeferredImmCons > 0 || db->nDeferredCons > 0;\n            break;\n        }\n      default:\n        {\n            rc = 1;\n        }\n    }\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#107224:1#exprNodeIsConstant",
            "nobreaks": 1,
            "body": "{\n    if (pWalker->eCode == 2 && (((pExpr)->flags & (1)) != 0)) {\n        pWalker->eCode = 0;\n        return 2;\n    }\n    switch (pExpr->op) {\n      case 172:\n        if ((pWalker->eCode >= 4 || (((pExpr)->flags & (1048576)) != 0)) && !(((pExpr)->flags & (16777216)) != 0)) {\n            if (pWalker->eCode == 5)\n                (pExpr)->flags |= (1073741824);\n            return 0;\n        } else {\n            pWalker->eCode = 0;\n            return 2;\n        }\n      case 59:\n        if (sqlite3ExprIdToTrueFalse(pExpr)) {\n            return 1;\n        }\n      case 167:\n      case 168:\n      case 169:\n        ;\n        ;\n        ;\n        ;\n        if ((((pExpr)->flags & (32)) != 0) && pWalker->eCode != 2) {\n            return 0;\n        }\n        if (pWalker->eCode == 3 && pExpr->iTable == pWalker->u.iCur) {\n            return 0;\n        }\n      case 179:\n      case 176:\n      case 141:\n        ;\n        ;\n        ;\n        pWalker->eCode = 0;\n        return 2;\n      case 156:\n        if (pWalker->eCode == 5) {\n            pExpr->op = 121;\n        } else if (pWalker->eCode == 4) {\n            pWalker->eCode = 0;\n            return 2;\n        }\n      default:\n        ;\n        ;\n        return 0;\n    }\n}\n"
        },
        {
            "id": "#23:25#sqlite3ExprIfFalse",
            "nobreaks": 1,
            "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    assert(jumpIfNull == 16 || jumpIfNull == 0);\n    if ((v == 0))\n        return;\n    if (pExpr == 0)\n        return;\n    assert(!0);\n    op = ((pExpr->op + (50 & 1)) ^ 1) - (50 & 1);\n    assert(pExpr->op != 50 || op == 51);\n    assert(pExpr->op != 51 || op == 50);\n    assert(pExpr->op != 52 || op == 53);\n    assert(pExpr->op != 53 || op == 52);\n    assert(pExpr->op != 56 || op == 57);\n    assert(pExpr->op != 55 || op == 54);\n    assert(pExpr->op != 54 || op == 55);\n    assert(pExpr->op != 57 || op == 56);\n    switch (pExpr->op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);\n            } else if (pExpr->op == 44) {\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n            } else {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            } else {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (pExpr->op == 45) ? 52 : 53;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            assert(56 == 56);\n            ;\n            ;\n            assert(55 == 55);\n            ;\n            ;\n            assert(54 == 54);\n            ;\n            ;\n            assert(57 == 57);\n            ;\n            ;\n            assert(53 == 53);\n            ;\n            ;\n            ;\n            assert(52 == 52);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            if (jumpIfNull) {\n                sqlite3ExprCodeIN(pParse, pExpr, dest, dest);\n            } else {\n                int destIfNull = sqlite3VdbeMakeLabel(pParse);\n                sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);\n                sqlite3VdbeResolveLabel(v, destIfNull);\n            }\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 17, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#30033:12#sqlite3_str_vappendf",
            "nobreaks": 1,
            "body": "{\n    int c;\n    char *bufpt;\n    int precision;\n    int length;\n    int idx;\n    int width;\n    etByte flag_leftjustify;\n    etByte flag_prefix;\n    etByte flag_alternateform;\n    etByte flag_altform2;\n    etByte flag_zeropad;\n    etByte flag_long;\n    etByte done;\n    etByte cThousand;\n    etByte xtype = 17;\n    u8 bArgList;\n    char prefix;\n    sqlite_uint64 longvalue;\n    long double realvalue;\n    const et_info *infop;\n    char *zOut;\n    int nOut;\n    char *zExtra = 0;\n    int exp, e2;\n    int nsd;\n    double rounder;\n    etByte flag_dp;\n    etByte flag_rtz;\n    PrintfArguments *pArgList = 0;\n    char buf[70];\n    assert(pAccum->nChar > 0 || (pAccum->printfFlags & 4) == 0);\n    bufpt = 0;\n    if ((pAccum->printfFlags & 2) != 0) {\n        bArgList = 1;\n    } else {\n        bArgList = 0;\n    }\n    for (; (c = (*fmt)) != 0; ++fmt) {\n        if (c != '%') {\n            bufpt = (char *)fmt;\n            do {\n                fmt++;\n            } while (*fmt && *fmt != '%');\n            sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));\n            if (*fmt == 0)\n                break;\n        }\n        if ((c = (*++fmt)) == 0) {\n            sqlite3_str_append(pAccum, \"%\", 1);\n            break;\n        }\n        flag_leftjustify = flag_prefix = cThousand = flag_alternateform = flag_altform2 = flag_zeropad = 0;\n        done = 0;\n        width = 0;\n        flag_long = 0;\n        precision = -1;\n        do {\n            switch (c) {\n              case '-':\n                flag_leftjustify = 1;\n                break;\n              case '+':\n                flag_prefix = '+';\n                break;\n              case ' ':\n                flag_prefix = ' ';\n                break;\n              case '#':\n                flag_alternateform = 1;\n                break;\n              case '!':\n                flag_altform2 = 1;\n                break;\n              case '0':\n                flag_zeropad = 1;\n                break;\n              case ',':\n                cThousand = ',';\n                break;\n              default:\n                done = 1;\n                break;\n              case 'l':\n                {\n                    flag_long = 1;\n                    c = *++fmt;\n                    if (c == 'l') {\n                        c = *++fmt;\n                        flag_long = 2;\n                    }\n                    done = 1;\n                    break;\n                }\n              case '1':\n              case '2':\n              case '3':\n              case '4':\n              case '5':\n              case '6':\n              case '7':\n              case '8':\n              case '9':\n                {\n                    unsigned int wx = c - '0';\n                    while ((c = *++fmt) >= '0' && c <= '9')\n                        {\n                            wx = wx * 10 + c - '0';\n                        }\n                    ;\n                    width = wx & 2147483647;\n                    if (c != '.' && c != 'l') {\n                        done = 1;\n                    } else {\n                        fmt--;\n                    }\n                    break;\n                }\n              case '*':\n                {\n                    if (bArgList) {\n                        width = (int)getIntArg(pArgList);\n                    } else {\n                    }\n                    if (width < 0) {\n                        flag_leftjustify = 1;\n                        width = width >= -2147483647 ? -width : 0;\n                    }\n                    if ((c = fmt[1]) != '.' && c != 'l') {\n                        c = *++fmt;\n                        done = 1;\n                    }\n                    break;\n                }\n              case '.':\n                {\n                    c = *++fmt;\n                    if (c == '*') {\n                        if (bArgList) {\n                            precision = (int)getIntArg(pArgList);\n                        } else {\n                        }\n                        if (precision < 0) {\n                            precision = precision >= -2147483647 ? -precision : -1;\n                        }\n                        c = *++fmt;\n                    } else {\n                        unsigned int px = 0;\n                        while (c >= '0' && c <= '9')\n                            {\n                                px = px * 10 + c - '0';\n                                c = *++fmt;\n                            }\n                        ;\n                        precision = px & 2147483647;\n                    }\n                    if (c == 'l') {\n                        --fmt;\n                    } else {\n                        done = 1;\n                    }\n                    break;\n                }\n            }\n        } while (!done && (c = (*++fmt)) != 0);\n        infop = &fmtinfo[0];\n        xtype = 17;\n        for (idx = 0; idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0]))); idx++) {\n            if (c == fmtinfo[idx].fmttype) {\n                infop = &fmtinfo[idx];\n                xtype = infop->type;\n                break;\n            }\n        }\n        assert(width >= 0);\n        assert(precision >= (-1));\n        switch (xtype) {\n          case 13:\n            flag_long = sizeof(char *) == sizeof(i64) ? 2 : sizeof(char *) == sizeof(long) ? 1 : 0;\n          case 15:\n          case 0:\n            cThousand = 0;\n          case 16:\n            if (infop->flags & 1) {\n                i64 v;\n                if (bArgList) {\n                    v = getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        v = va_arg(<recovery-expr>(), <recovery-expr>());\n                    } else {\n                    }\n                } else {\n                }\n                if (v < 0) {\n                    ;\n                    ;\n                    longvalue = ~v;\n                    longvalue++;\n                    prefix = '-';\n                } else {\n                    longvalue = v;\n                    prefix = flag_prefix;\n                }\n            } else {\n                if (bArgList) {\n                    longvalue = (u64)getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        longvalue = va_arg(<recovery-expr>(), <recovery-expr>());\n                    } else {\n                    }\n                } else {\n                }\n                prefix = 0;\n            }\n            if (longvalue == 0)\n                flag_alternateform = 0;\n            if (flag_zeropad && precision < width - (prefix != 0)) {\n                precision = width - (prefix != 0);\n            }\n            if (precision < 70 - 10 - 70 / 3) {\n                nOut = 70;\n                zOut = buf;\n            } else {\n                u64 n;\n                n = (u64)precision + 10;\n                if (cThousand)\n                    n += precision / 3;\n                zOut = zExtra = printfTempBuf(pAccum, n);\n                if (zOut == 0)\n                    return;\n                nOut = (int)n;\n            }\n            bufpt = &zOut[nOut - 1];\n            if (xtype == 15) {\n                static const char zOrd[] = \"thstndrd\";\n                int x = (int)(longvalue % 10);\n                if (x >= 4 || (longvalue / 10) % 10 == 1) {\n                    x = 0;\n                }\n                *(--bufpt) = zOrd[x * 2 + 1];\n                *(--bufpt) = zOrd[x * 2];\n            }\n            {\n                const char *cset = &aDigits[infop->charset];\n                u8 base = infop->base;\n                do {\n                    *(--bufpt) = cset[longvalue % base];\n                    longvalue = longvalue / base;\n                } while (longvalue > 0);\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            while (precision > length)\n                {\n                    *(--bufpt) = '0';\n                    length++;\n                }\n            if (cThousand) {\n                int nn = (length - 1) / 3;\n                int ix = (length - 1) % 3 + 1;\n                bufpt -= nn;\n                for (idx = 0; nn > 0; idx++) {\n                    bufpt[idx] = bufpt[idx + nn];\n                    ix--;\n                    if (ix == 0) {\n                        bufpt[++idx] = cThousand;\n                        nn--;\n                        ix = 3;\n                    }\n                }\n            }\n            if (prefix)\n                *(--bufpt) = prefix;\n            if (flag_alternateform && infop->prefix) {\n                const char *pre;\n                char x;\n                pre = &aPrefix[infop->prefix];\n                for (; (x = (*pre)) != 0; pre++)\n                    *(--bufpt) = x;\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            break;\n          case 1:\n          case 2:\n          case 3:\n            if (bArgList) {\n                realvalue = getDoubleArg(pArgList);\n            } else {\n            }\n            if (precision < 0)\n                precision = 6;\n            if (precision > 100000000) {\n                precision = 100000000;\n            }\n            if (realvalue < 0.) {\n                realvalue = -realvalue;\n                prefix = '-';\n            } else {\n                prefix = flag_prefix;\n            }\n            if (xtype == 3 && precision > 0)\n                precision--;\n            ;\n            idx = precision & 4095;\n            rounder = arRound[idx % 10];\n            while (idx >= 10)\n                {\n                    rounder *= 1.0E-10;\n                    idx -= 10;\n                }\n            if (xtype == 1) {\n                double rx = (double)realvalue;\n                sqlite3_uint64 u;\n                int ex;\n                memcpy(&u, &rx, sizeof (u));\n                ex = -1023 + (int)((u >> 52) & 2047);\n                if (precision + (ex / 3) < 15)\n                    rounder += realvalue * 2.9999999999999999E-16;\n                realvalue += rounder;\n            }\n            exp = 0;\n            if (sqlite3IsNaN((double)realvalue)) {\n                bufpt = \"NaN\";\n                length = 3;\n                break;\n            }\n            if (realvalue > 0.) {\n                long double scale = 1.;\n                while (realvalue >= 1.0E+100 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+100;\n                        exp += 100;\n                    }\n                while (realvalue >= 1.0E+10 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+10;\n                        exp += 10;\n                    }\n                while (realvalue >= 10. * scale && exp <= 350)\n                    {\n                        scale *= 10.;\n                        exp++;\n                    }\n                realvalue /= scale;\n                while (realvalue < 1.0E-8)\n                    {\n                        realvalue *= 1.0E+8;\n                        exp -= 8;\n                    }\n                while (realvalue < 1.)\n                    {\n                        realvalue *= 10.;\n                        exp--;\n                    }\n                if (exp > 350) {\n                    bufpt = buf;\n                    buf[0] = prefix;\n                    memcpy(buf + (prefix != 0), \"Inf\", 4);\n                    length = 3 + (prefix != 0);\n                    break;\n                }\n            }\n            bufpt = buf;\n            if (xtype != 1) {\n                realvalue += rounder;\n                if (realvalue >= 10.) {\n                    realvalue *= 0.10000000000000001;\n                    exp++;\n                }\n            }\n            if (xtype == 3) {\n                flag_rtz = !flag_alternateform;\n                if (exp < -4 || exp > precision) {\n                    xtype = 2;\n                } else {\n                    precision = precision - exp;\n                    xtype = 1;\n                }\n            } else {\n                flag_rtz = flag_altform2;\n            }\n            if (xtype == 2) {\n                e2 = 0;\n            } else {\n                e2 = exp;\n            }\n            {\n                i64 szBufNeeded;\n                szBufNeeded = ((e2) > (0) ? (e2) : (0)) + (i64)precision + (i64)width + 15;\n                if (szBufNeeded > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);\n                    if (bufpt == 0)\n                        return;\n                }\n            }\n            zOut = bufpt;\n            nsd = 16 + flag_altform2 * 10;\n            flag_dp = (precision > 0 ? 1 : 0) | flag_alternateform | flag_altform2;\n            if (prefix) {\n                *(bufpt++) = prefix;\n            }\n            if (e2 < 0) {\n                *(bufpt++) = '0';\n            } else {\n                for (; e2 >= 0; e2--) {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            }\n            if (flag_dp) {\n                *(bufpt++) = '.';\n            }\n            for (e2++; e2 < 0; precision-- , e2++) {\n                assert(precision > 0);\n                *(bufpt++) = '0';\n            }\n            while ((precision--) > 0)\n                {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            if (flag_rtz && flag_dp) {\n                while (bufpt[-1] == '0')\n                    *(--bufpt) = 0;\n                assert(bufpt > zOut);\n                if (bufpt[-1] == '.') {\n                    if (flag_altform2) {\n                        *(bufpt++) = '0';\n                    } else {\n                        *(--bufpt) = 0;\n                    }\n                }\n            }\n            if (xtype == 2) {\n                *(bufpt++) = aDigits[infop->charset];\n                if (exp < 0) {\n                    *(bufpt++) = '-';\n                    exp = -exp;\n                } else {\n                    *(bufpt++) = '+';\n                }\n                if (exp >= 100) {\n                    *(bufpt++) = (char)((exp / 100) + '0');\n                    exp %= 100;\n                }\n                *(bufpt++) = (char)(exp / 10 + '0');\n                *(bufpt++) = (char)(exp % 10 + '0');\n            }\n            *bufpt = 0;\n            length = (int)(bufpt - zOut);\n            bufpt = zOut;\n            if (flag_zeropad && !flag_leftjustify && length < width) {\n                int i;\n                int nPad = width - length;\n                for (i = width; i >= nPad; i--) {\n                    bufpt[i] = bufpt[i - nPad];\n                }\n                i = prefix != 0;\n                while (nPad--)\n                    bufpt[i++] = '0';\n                length = width;\n            }\n            break;\n          case 4:\n            if (!bArgList) {\n            }\n            length = width = 0;\n            break;\n          case 7:\n            buf[0] = '%';\n            bufpt = buf;\n            length = 1;\n            break;\n          case 8:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                length = 1;\n                if (bufpt) {\n                    buf[0] = c = *(bufpt++);\n                    if ((c & 192) == 192) {\n                        while (length < 4 && (bufpt[0] & 192) == 128)\n                            {\n                                buf[length++] = *(bufpt++);\n                            }\n                    }\n                } else {\n                    buf[0] = 0;\n                }\n            } else {\n                unsigned int ch;\n                if (ch < 128) {\n                    buf[0] = ch & 255;\n                    length = 1;\n                } else if (ch < 2048) {\n                    buf[0] = 192 + (u8)((ch >> 6) & 31);\n                    buf[1] = 128 + (u8)(ch & 63);\n                    length = 2;\n                } else if (ch < 65536) {\n                    buf[0] = 224 + (u8)((ch >> 12) & 15);\n                    buf[1] = 128 + (u8)((ch >> 6) & 63);\n                    buf[2] = 128 + (u8)(ch & 63);\n                    length = 3;\n                } else {\n                    buf[0] = 240 + (u8)((ch >> 18) & 7);\n                    buf[1] = 128 + (u8)((ch >> 12) & 63);\n                    buf[2] = 128 + (u8)((ch >> 6) & 63);\n                    buf[3] = 128 + (u8)(ch & 63);\n                    length = 4;\n                }\n            }\n            if (precision > 1) {\n                width -= precision - 1;\n                if (width > 1 && !flag_leftjustify) {\n                    sqlite3_str_appendchar(pAccum, width - 1, ' ');\n                    width = 0;\n                }\n                while (precision-- > 1)\n                    {\n                        sqlite3_str_append(pAccum, buf, length);\n                    }\n            }\n            bufpt = buf;\n            flag_altform2 = 1;\n            goto adjust_width_for_utf8;\n          case 5:\n          case 6:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                xtype = 5;\n            } else {\n            }\n            if (bufpt == 0) {\n                bufpt = \"\";\n            } else if (xtype == 6) {\n                if (pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 && pAccum->accError == 0) {\n                    assert((pAccum->printfFlags & 4) == 0);\n                    pAccum->zText = bufpt;\n                    pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);\n                    pAccum->nChar = 2147483647 & (int)strlen(bufpt);\n                    pAccum->printfFlags |= 4;\n                    length = 0;\n                    break;\n                }\n                zExtra = bufpt;\n            }\n            if (precision >= 0) {\n                if (flag_altform2) {\n                    unsigned char *z = (unsigned char *)bufpt;\n                    while (precision-- > 0 && z[0])\n                        {\n                            {\n                                if ((*(z++)) >= 192) {\n                                    while ((*z & 192) == 128)\n                                        {\n                                            z++;\n                                        }\n                                }\n                            }\n                            ;\n                        }\n                    length = (int)(z - (unsigned char *)bufpt);\n                } else {\n                    for (length = 0; length < precision && bufpt[length]; length++) {\n                    }\n                }\n            } else {\n                length = 2147483647 & (int)strlen(bufpt);\n            }\n          adjust_width_for_utf8:\n            if (flag_altform2 && width > 0) {\n                int ii = length - 1;\n                while (ii >= 0)\n                    if ((bufpt[ii--] & 192) == 128)\n                        width++;\n            }\n            break;\n          case 9:\n          case 10:\n          case 14:\n            {\n                i64 i, j, k, n;\n                int needQuote, isnull;\n                char ch;\n                char q = ((xtype == 14) ? '\"' : '\\'');\n                char *escarg;\n                if (bArgList) {\n                    escarg = getTextArg(pArgList);\n                } else {\n                }\n                isnull = escarg == 0;\n                if (isnull)\n                    escarg = (xtype == 10 ? \"NULL\" : \"(NULL)\");\n                k = precision;\n                for (i = n = 0; k != 0 && (ch = escarg[i]) != 0; i++ , k--) {\n                    if (ch == q)\n                        n++;\n                    if (flag_altform2 && (ch & 192) == 192) {\n                        while ((escarg[i + 1] & 192) == 128)\n                            {\n                                i++;\n                            }\n                    }\n                }\n                needQuote = !isnull && xtype == 10;\n                n += i + 3;\n                if (n > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, n);\n                    if (bufpt == 0)\n                        return;\n                } else {\n                    bufpt = buf;\n                }\n                j = 0;\n                if (needQuote)\n                    bufpt[j++] = q;\n                k = i;\n                for (i = 0; i < k; i++) {\n                    bufpt[j++] = ch = escarg[i];\n                    if (ch == q)\n                        bufpt[j++] = ch;\n                }\n                if (needQuote)\n                    bufpt[j++] = q;\n                bufpt[j] = 0;\n                length = j;\n                goto adjust_width_for_utf8;\n            }\n          case 11:\n            {\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                if (flag_alternateform) {\n                    Expr *pExpr;\n                    if ((pExpr) && (!(((pExpr)->flags & (2048)) != 0))) {\n                        sqlite3_str_appendall(pAccum, (const char *)pExpr->u.zToken);\n                        sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);\n                    }\n                } else {\n                    Token *pToken;\n                    assert(bArgList == 0);\n                    if (pToken && pToken->n) {\n                        sqlite3_str_append(pAccum, (const char *)pToken->z, pToken->n);\n                        sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          case 12:\n            {\n                SrcItem *pItem;\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                assert(bArgList == 0);\n                if (pItem->zAlias && !flag_altform2) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else if (pItem->zName) {\n                    if (pItem->zDatabase) {\n                        sqlite3_str_appendall(pAccum, pItem->zDatabase);\n                        sqlite3_str_append(pAccum, \".\", 1);\n                    }\n                    sqlite3_str_appendall(pAccum, pItem->zName);\n                } else if (pItem->zAlias) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else {\n                    Select *pSel = pItem->pSelect;\n                    assert(pSel != 0);\n                    if (pSel->selFlags & 2048) {\n                        sqlite3_str_appendf(pAccum, \"(join-%u)\", pSel->selId);\n                    } else {\n                        sqlite3_str_appendf(pAccum, \"(subquery-%u)\", pSel->selId);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          default:\n            {\n                assert(xtype == 17);\n                return;\n            }\n        }\n        width -= length;\n        if (width > 0) {\n            if (!flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n            sqlite3_str_append(pAccum, bufpt, length);\n            if (flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n        } else {\n            sqlite3_str_append(pAccum, bufpt, length);\n        }\n        if (zExtra) {\n            sqlite3DbFree(pAccum->db, zExtra);\n            zExtra = 0;\n        }\n    }\n}\n"
        },
        {
            "id": "#23:25#sqlite3GetToken",
            "nobreaks": 1,
            "body": "{\n    int i, c;\n    switch (aiClass[*z]) {\n      case 7:\n        {\n            ;\n            ;\n            ;\n            ;\n            ;\n            for (i = 1; (sqlite3CtypeMap[(unsigned char)(z[i])] & 1); i++) {\n            }\n            *tokenType = 183;\n            return i;\n        }\n      case 11:\n        {\n            if (z[1] == '-') {\n                for (i = 2; (c = z[i]) != 0 && c != '\\n'; i++) {\n                }\n                *tokenType = 183;\n                return i;\n            } else if (z[1] == '>') {\n                *tokenType = 112;\n                return 2 + (z[2] == '>');\n            }\n            *tokenType = 107;\n            return 1;\n        }\n      case 17:\n        {\n            *tokenType = 22;\n            return 1;\n        }\n      case 18:\n        {\n            *tokenType = 23;\n            return 1;\n        }\n      case 19:\n        {\n            *tokenType = 1;\n            return 1;\n        }\n      case 20:\n        {\n            *tokenType = 106;\n            return 1;\n        }\n      case 21:\n        {\n            *tokenType = 108;\n            return 1;\n        }\n      case 16:\n        {\n            if (z[1] != '*' || z[2] == 0) {\n                *tokenType = 109;\n                return 1;\n            }\n            for (i = 3 , c = z[2]; (c != '*' || z[i] != '/') && (c = z[i]) != 0; i++) {\n            }\n            if (c)\n                i++;\n            *tokenType = 183;\n            return i;\n        }\n      case 22:\n        {\n            *tokenType = 110;\n            return 1;\n        }\n      case 14:\n        {\n            *tokenType = 53;\n            return 1 + (z[1] == '=');\n        }\n      case 12:\n        {\n            if ((c = z[1]) == '=') {\n                *tokenType = 55;\n                return 2;\n            } else if (c == '>') {\n                *tokenType = 52;\n                return 2;\n            } else if (c == '<') {\n                *tokenType = 104;\n                return 2;\n            } else {\n                *tokenType = 56;\n                return 1;\n            }\n        }\n      case 13:\n        {\n            if ((c = z[1]) == '=') {\n                *tokenType = 57;\n                return 2;\n            } else if (c == '>') {\n                *tokenType = 105;\n                return 2;\n            } else {\n                *tokenType = 54;\n                return 1;\n            }\n        }\n      case 15:\n        {\n            if (z[1] != '=') {\n                *tokenType = 184;\n                return 1;\n            } else {\n                *tokenType = 52;\n                return 2;\n            }\n        }\n      case 10:\n        {\n            if (z[1] != '|') {\n                *tokenType = 103;\n                return 1;\n            } else {\n                *tokenType = 111;\n                return 2;\n            }\n        }\n      case 23:\n        {\n            *tokenType = 25;\n            return 1;\n        }\n      case 24:\n        {\n            *tokenType = 102;\n            return 1;\n        }\n      case 25:\n        {\n            *tokenType = 114;\n            return 1;\n        }\n      case 8:\n        {\n            int delim = z[0];\n            ;\n            ;\n            ;\n            for (i = 1; (c = z[i]) != 0; i++) {\n                if (c == delim) {\n                    if (z[i + 1] == delim) {\n                        i++;\n                    } else {\n                        break;\n                    }\n                }\n            }\n            if (c == '\\'') {\n                *tokenType = 117;\n                return i + 1;\n            } else if (c != 0) {\n                *tokenType = 59;\n                return i + 1;\n            } else {\n                *tokenType = 184;\n                return i;\n            }\n        }\n      case 26:\n        {\n            if (!(sqlite3CtypeMap[(unsigned char)(z[1])] & 4)) {\n                *tokenType = 141;\n                return 1;\n            }\n        }\n      case 3:\n        {\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            *tokenType = 155;\n            if (z[0] == '0' && (z[1] == 'x' || z[1] == 'X') && (sqlite3CtypeMap[(unsigned char)(z[2])] & 8)) {\n                for (i = 3; (sqlite3CtypeMap[(unsigned char)(z[i])] & 8); i++) {\n                }\n                return i;\n            }\n            for (i = 0; (sqlite3CtypeMap[(unsigned char)(z[i])] & 4); i++) {\n            }\n            if (z[i] == '.') {\n                i++;\n                while ((sqlite3CtypeMap[(unsigned char)(z[i])] & 4))\n                    {\n                        i++;\n                    }\n                *tokenType = 153;\n            }\n            if ((z[i] == 'e' || z[i] == 'E') && ((sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) || ((z[i + 1] == '+' || z[i + 1] == '-') && (sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4)))) {\n                i += 2;\n                while ((sqlite3CtypeMap[(unsigned char)(z[i])] & 4))\n                    {\n                        i++;\n                    }\n                *tokenType = 153;\n            }\n            while (((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0))\n                {\n                    *tokenType = 184;\n                    i++;\n                }\n            return i;\n        }\n      case 9:\n        {\n            for (i = 1 , c = z[0]; c != ']' && (c = z[i]) != 0; i++) {\n            }\n            *tokenType = c == ']' ? 59 : 184;\n            return i;\n        }\n      case 6:\n        {\n            *tokenType = 156;\n            for (i = 1; (sqlite3CtypeMap[(unsigned char)(z[i])] & 4); i++) {\n            }\n            return i;\n        }\n      case 4:\n      case 5:\n        {\n            int n = 0;\n            ;\n            ;\n            ;\n            ;\n            *tokenType = 156;\n            for (i = 1; (c = z[i]) != 0; i++) {\n                if (((sqlite3CtypeMap[(unsigned char)c] & 70) != 0)) {\n                    n++;\n                } else if (c == '(' && n > 0) {\n                    do {\n                        i++;\n                    } while ((c = z[i]) != 0 && !(sqlite3CtypeMap[(unsigned char)(c)] & 1) && c != ')');\n                    if (c == ')') {\n                        i++;\n                    } else {\n                        *tokenType = 184;\n                    }\n                    break;\n                } else if (c == ':' && z[i + 1] == ':') {\n                    i++;\n                } else {\n                    break;\n                }\n            }\n            if (n == 0)\n                *tokenType = 184;\n            return i;\n        }\n      case 1:\n        {\n            for (i = 1; aiClass[z[i]] <= 2; i++) {\n            }\n            if (((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0)) {\n                i++;\n                break;\n            }\n            *tokenType = 59;\n            return keywordCode((char *)z, i, tokenType);\n        }\n      case 0:\n        {\n            ;\n            ;\n            if (z[1] == '\\'') {\n                *tokenType = 154;\n                for (i = 2; (sqlite3CtypeMap[(unsigned char)(z[i])] & 8); i++) {\n                }\n                if (z[i] != '\\'' || i % 2) {\n                    *tokenType = 184;\n                    while (z[i] && z[i] != '\\'')\n                        {\n                            i++;\n                        }\n                }\n                if (z[i])\n                    i++;\n                return i;\n            }\n        }\n      case 2:\n      case 27:\n        {\n            i = 1;\n            break;\n        }\n      case 30:\n        {\n            if (z[1] == 187 && z[2] == 191) {\n                *tokenType = 183;\n                return 3;\n            }\n            i = 1;\n            break;\n        }\n      case 29:\n        {\n            *tokenType = 184;\n            return 0;\n        }\n      default:\n        {\n            *tokenType = 184;\n            return 1;\n        }\n    }\n    while (((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0))\n        {\n            i++;\n        }\n    *tokenType = 59;\n    return i;\n}\n"
        },
        {
            "id": "#23:25#sqlite3GenerateConstraintChecks",
            "nobreaks": 3,
            "body": "{\n    Vdbe *v;\n    Index *pIdx;\n    Index *pPk = 0;\n    sqlite3 *db;\n    int i;\n    int ix;\n    int nCol;\n    int onError;\n    int seenReplace = 0;\n    int nPkField;\n    Upsert *pUpsertClause = 0;\n    u8 isUpdate;\n    u8 bAffinityDone = 0;\n    int upsertIpkReturn = 0;\n    int upsertIpkDelay = 0;\n    int ipkTop = 0;\n    int ipkBottom = 0;\n    int regTrigCnt;\n    int addrRecheck = 0;\n    int lblRecheckOk = 0;\n    Trigger *pTrigger;\n    int nReplaceTrig = 0;\n    IndexIterator sIdxIter;\n    isUpdate = regOldData != 0;\n    db = pParse->db;\n    v = pParse->pVdbe;\n    assert(v != 0);\n    assert(!((pTab)->eTabType == 2));\n    nCol = pTab->nCol;\n    if ((((pTab)->tabFlags & 128) == 0)) {\n        pPk = 0;\n        nPkField = 1;\n    } else {\n        pPk = sqlite3PrimaryKeyIndex(pTab);\n        nPkField = pPk->nKeyCol;\n    }\n    ;\n    if (pTab->tabFlags & 2048) {\n        int b2ndPass = 0;\n        int nSeenReplace = 0;\n        int nGenerated = 0;\n        while (1)\n            {\n                for (i = 0; i < nCol; i++) {\n                    int iReg;\n                    Column *pCol = &pTab->aCol[i];\n                    int isGenerated;\n                    onError = pCol->notNull;\n                    if (onError == 0)\n                        continue;\n                    if (i == pTab->iPKey) {\n                        continue;\n                    }\n                    isGenerated = pCol->colFlags & 96;\n                    if (isGenerated && !b2ndPass) {\n                        nGenerated++;\n                        continue;\n                    }\n                    if (aiChng && aiChng[i] < 0 && !isGenerated) {\n                        continue;\n                    }\n                    if (overrideError != 11) {\n                        onError = overrideError;\n                    } else if (onError == 11) {\n                        onError = 2;\n                    }\n                    if (onError == 5) {\n                        if (b2ndPass || pCol->iDflt == 0) {\n                            ;\n                            ;\n                            ;\n                            onError = 2;\n                        } else {\n                            assert(!isGenerated);\n                        }\n                    } else if (b2ndPass && !isGenerated) {\n                        continue;\n                    }\n                    assert(onError == 1 || onError == 2 || onError == 3 || onError == 4 || onError == 5);\n                    ;\n                    iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;\n                    switch (onError) {\n                      case 5:\n                        {\n                            int addr1 = sqlite3VdbeAddOp1(v, 51, iReg);\n                            ;\n                            assert((pCol->colFlags & 96) == 0);\n                            nSeenReplace++;\n                            sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), iReg);\n                            sqlite3VdbeJumpHere(v, addr1);\n                            break;\n                        }\n                      case 2:\n                        sqlite3MayAbort(pParse);\n                      case 1:\n                      case 3:\n                        {\n                            char *zMsg = sqlite3MPrintf(db, \"%s.%s\", pTab->zName, pCol->zCnName);\n                            sqlite3VdbeAddOp3(v, 69, (19 | (5 << 8)), onError, iReg);\n                            sqlite3VdbeAppendP4(v, zMsg, (-6));\n                            sqlite3VdbeChangeP5(v, 1);\n                            ;\n                            break;\n                        }\n                      default:\n                        {\n                            assert(onError == 4);\n                            sqlite3VdbeAddOp2(v, 50, iReg, ignoreDest);\n                            ;\n                            break;\n                        }\n                    }\n                }\n                if (nGenerated == 0 && nSeenReplace == 0) {\n                    break;\n                }\n                if (b2ndPass)\n                    break;\n                b2ndPass = 1;\n                if (nSeenReplace > 0 && (pTab->tabFlags & 96) != 0) {\n                    sqlite3ComputeGeneratedColumns(pParse, regNewData + 1, pTab);\n                }\n            }\n    }\n    if (pTab->pCheck && (db->flags & 512) == 0) {\n        ExprList *pCheck = pTab->pCheck;\n        pParse->iSelfTab = -(regNewData + 1);\n        onError = overrideError != 11 ? overrideError : 2;\n        for (i = 0; i < pCheck->nExpr; i++) {\n            int allOk;\n            Expr *pCopy;\n            Expr *pExpr = pCheck->a[i].pExpr;\n            if (aiChng && !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)) {\n                continue;\n            }\n            if (bAffinityDone == 0) {\n                sqlite3TableAffinity(v, pTab, regNewData + 1);\n                bAffinityDone = 1;\n            }\n            allOk = sqlite3VdbeMakeLabel(pParse);\n            ;\n            pCopy = sqlite3ExprDup(db, pExpr, 0);\n            if (!db->mallocFailed) {\n                sqlite3ExprIfTrue(pParse, pCopy, allOk, 16);\n            }\n            sqlite3ExprDelete(db, pCopy);\n            if (onError == 4) {\n                sqlite3VdbeGoto(v, ignoreDest);\n            } else {\n                char *zName = pCheck->a[i].zEName;\n                assert(zName != 0 || pParse->db->mallocFailed);\n                if (onError == 5)\n                    onError = 2;\n                sqlite3HaltConstraint(pParse, (19 | (1 << 8)), onError, zName, 0, 3);\n            }\n            sqlite3VdbeResolveLabel(v, allOk);\n        }\n        pParse->iSelfTab = 0;\n    }\n    sIdxIter.eType = 0;\n    sIdxIter.i = 0;\n    sIdxIter.u.ax.aIdx = 0;\n    sIdxIter.u.lx.pIdx = pTab->pIndex;\n    if (pUpsert) {\n        if (pUpsert->pUpsertTarget == 0) {\n            assert(pUpsert->pNextUpsert == 0);\n            if (pUpsert->isDoUpdate == 0) {\n                overrideError = 4;\n                pUpsert = 0;\n            } else {\n                overrideError = 6;\n            }\n        } else if (pTab->pIndex != 0) {\n            int nIdx, jj;\n            u64 nByte;\n            Upsert *pTerm;\n            u8 *bUsed;\n            for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n                assert(aRegIdx[nIdx] > 0);\n            }\n            sIdxIter.eType = 1;\n            sIdxIter.u.ax.nIdx = nIdx;\n            nByte = (sizeof(IndexListTerm) + 1) * nIdx + nIdx;\n            sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, nByte);\n            if (sIdxIter.u.ax.aIdx == 0)\n                return;\n            bUsed = (u8 *)&sIdxIter.u.ax.aIdx[nIdx];\n            pUpsert->pToFree = sIdxIter.u.ax.aIdx;\n            for (i = 0 , pTerm = pUpsert; pTerm; pTerm = pTerm->pNextUpsert) {\n                if (pTerm->pUpsertTarget == 0)\n                    break;\n                if (pTerm->pUpsertIdx == 0)\n                    continue;\n                jj = 0;\n                pIdx = pTab->pIndex;\n                while ((pIdx != 0) && pIdx != pTerm->pUpsertIdx)\n                    {\n                        pIdx = pIdx->pNext;\n                        jj++;\n                    }\n                if (bUsed[jj])\n                    continue;\n                bUsed[jj] = 1;\n                sIdxIter.u.ax.aIdx[i].p = pIdx;\n                sIdxIter.u.ax.aIdx[i].ix = jj;\n                i++;\n            }\n            for (jj = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , jj++) {\n                if (bUsed[jj])\n                    continue;\n                sIdxIter.u.ax.aIdx[i].p = pIdx;\n                sIdxIter.u.ax.aIdx[i].ix = jj;\n                i++;\n            }\n            assert(i == nIdx);\n        }\n    }\n    if ((db->flags & (8192 | 16384)) == 0) {\n        pTrigger = 0;\n        regTrigCnt = 0;\n    } else {\n        if (db->flags & 8192) {\n            pTrigger = sqlite3TriggersExist(pParse, pTab, 128, 0, 0);\n            regTrigCnt = pTrigger != 0 || sqlite3FkRequired(pParse, pTab, 0, 0);\n        } else {\n            pTrigger = 0;\n            regTrigCnt = sqlite3FkRequired(pParse, pTab, 0, 0);\n        }\n        if (regTrigCnt) {\n            regTrigCnt = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 71, 0, regTrigCnt);\n            ;\n            lblRecheckOk = sqlite3VdbeMakeLabel(pParse);\n            addrRecheck = lblRecheckOk;\n        }\n    }\n    if (pkChng && pPk == 0) {\n        int addrRowidOk = sqlite3VdbeMakeLabel(pParse);\n        onError = pTab->keyConf;\n        if (overrideError != 11) {\n            onError = overrideError;\n        } else if (onError == 11) {\n            onError = 2;\n        }\n        if (pUpsert) {\n            pUpsertClause = sqlite3UpsertOfIndex(pUpsert, 0);\n            if (pUpsertClause != 0) {\n                if (pUpsertClause->isDoUpdate == 0) {\n                    onError = 4;\n                } else {\n                    onError = 6;\n                }\n            }\n            if (pUpsertClause != pUpsert) {\n                upsertIpkDelay = sqlite3VdbeAddOp0(v, 9);\n            }\n        }\n        if (onError == 5 && onError != overrideError && pTab->pIndex && !upsertIpkDelay) {\n            ipkTop = sqlite3VdbeAddOp0(v, 9) + 1;\n            ;\n        }\n        if (isUpdate) {\n            sqlite3VdbeAddOp3(v, 53, regNewData, addrRowidOk, regOldData);\n            sqlite3VdbeChangeP5(v, 144);\n            ;\n        }\n        ;\n        ;\n        sqlite3VdbeAddOp3(v, 31, iDataCur, addrRowidOk, regNewData);\n        ;\n        switch (onError) {\n          default:\n            {\n                onError = 2;\n            }\n          case 1:\n          case 2:\n          case 3:\n            {\n                ;\n                ;\n                ;\n                sqlite3RowidConstraint(pParse, onError, pTab);\n                break;\n            }\n          case 5:\n            {\n                if (regTrigCnt) {\n                    sqlite3MultiWrite(pParse);\n                    sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, regNewData, 1, 0, 5, 1, -1);\n                    sqlite3VdbeAddOp2(v, 86, regTrigCnt, 1);\n                    nReplaceTrig++;\n                } else {\n                    if (pTab->pIndex) {\n                        sqlite3MultiWrite(pParse);\n                        sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, 0, -1);\n                    }\n                }\n                seenReplace = 1;\n                break;\n            }\n          case 6:\n            {\n                sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, 0, iDataCur);\n            }\n          case 4:\n            {\n                ;\n                sqlite3VdbeGoto(v, ignoreDest);\n                break;\n            }\n        }\n        sqlite3VdbeResolveLabel(v, addrRowidOk);\n        if (pUpsert && pUpsertClause != pUpsert) {\n            upsertIpkReturn = sqlite3VdbeAddOp0(v, 9);\n        } else if (ipkTop) {\n            ipkBottom = sqlite3VdbeAddOp0(v, 9);\n            sqlite3VdbeJumpHere(v, ipkTop - 1);\n        }\n    }\n    for (pIdx = indexIteratorFirst(&sIdxIter, &ix); pIdx; pIdx = indexIteratorNext(&sIdxIter, &ix)) {\n        int regIdx;\n        int regR;\n        int iThisCur;\n        int addrUniqueOk;\n        int addrConflictCk;\n        if (aRegIdx[ix] == 0)\n            continue;\n        if (pUpsert) {\n            pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);\n            if (upsertIpkDelay && pUpsertClause == pUpsert) {\n                sqlite3VdbeJumpHere(v, upsertIpkDelay);\n            }\n        }\n        addrUniqueOk = sqlite3VdbeMakeLabel(pParse);\n        if (bAffinityDone == 0) {\n            sqlite3TableAffinity(v, pTab, regNewData + 1);\n            bAffinityDone = 1;\n        }\n        ;\n        iThisCur = iIdxCur + ix;\n        if (pIdx->pPartIdxWhere) {\n            sqlite3VdbeAddOp2(v, 75, 0, aRegIdx[ix]);\n            pParse->iSelfTab = -(regNewData + 1);\n            sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk, 16);\n            pParse->iSelfTab = 0;\n        }\n        regIdx = aRegIdx[ix] + 1;\n        for (i = 0; i < pIdx->nColumn; i++) {\n            int iField = pIdx->aiColumn[i];\n            int x;\n            if (iField == (-2)) {\n                pParse->iSelfTab = -(regNewData + 1);\n                sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx + i);\n                pParse->iSelfTab = 0;\n                ;\n            } else if (iField == (-1) || iField == pTab->iPKey) {\n                x = regNewData;\n                sqlite3VdbeAddOp2(v, 82, x, regIdx + i);\n                ;\n            } else {\n                ;\n                x = sqlite3TableColumnToStorage(pTab, iField) + regNewData + 1;\n                sqlite3VdbeAddOp2(v, 81, x, regIdx + i);\n                ;\n            }\n        }\n        sqlite3VdbeAddOp3(v, 97, regIdx, pIdx->nColumn, aRegIdx[ix]);\n        ;\n        ;\n        if (isUpdate && pPk == pIdx && pkChng == 0) {\n            sqlite3VdbeResolveLabel(v, addrUniqueOk);\n            continue;\n        }\n        onError = pIdx->onError;\n        if (onError == 0) {\n            sqlite3VdbeResolveLabel(v, addrUniqueOk);\n            continue;\n        }\n        if (overrideError != 11) {\n            onError = overrideError;\n        } else if (onError == 11) {\n            onError = 2;\n        }\n        if (pUpsertClause) {\n            if (pUpsertClause->isDoUpdate == 0) {\n                onError = 4;\n            } else {\n                onError = 6;\n            }\n        }\n        assert(((pTab)->eTabType == 0));\n        if ((ix == 0 && pIdx->pNext == 0) && pPk == pIdx && onError == 5 && (0 == (db->flags & 8192) || 0 == sqlite3TriggersExist(pParse, pTab, 128, 0, 0)) && (0 == (db->flags & 16384) || (0 == pTab->u.tab.pFKey && 0 == sqlite3FkReferences(pTab)))) {\n            sqlite3VdbeResolveLabel(v, addrUniqueOk);\n            continue;\n        }\n        ;\n        addrConflictCk = sqlite3VdbeAddOp4Int(v, 27, iThisCur, addrUniqueOk, regIdx, pIdx->nKeyCol);\n        ;\n        regR = pIdx == pPk ? regIdx : sqlite3GetTempRange(pParse, nPkField);\n        if (isUpdate || onError == 5) {\n            if ((((pTab)->tabFlags & 128) == 0)) {\n                sqlite3VdbeAddOp2(v, 142, iThisCur, regR);\n                if (isUpdate) {\n                    sqlite3VdbeAddOp3(v, 53, regR, addrUniqueOk, regOldData);\n                    sqlite3VdbeChangeP5(v, 144);\n                    ;\n                }\n            } else {\n                int x;\n                if (pIdx != pPk) {\n                    for (i = 0; i < pPk->nKeyCol; i++) {\n                        assert(pPk->aiColumn[i] >= 0);\n                        x = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);\n                        sqlite3VdbeAddOp3(v, 94, iThisCur, x, regR + i);\n                        ;\n                    }\n                }\n                if (isUpdate) {\n                    int addrJump = sqlite3VdbeCurrentAddr(v) + pPk->nKeyCol;\n                    int op = 52;\n                    int regCmp = (((pIdx)->idxType == 2) ? regIdx : regR);\n                    for (i = 0; i < pPk->nKeyCol; i++) {\n                        char *p4 = (char *)sqlite3LocateCollSeq(pParse, pPk->azColl[i]);\n                        x = pPk->aiColumn[i];\n                        assert(x >= 0);\n                        if (i == (pPk->nKeyCol - 1)) {\n                            addrJump = addrUniqueOk;\n                            op = 53;\n                        }\n                        x = sqlite3TableColumnToStorage(pTab, x);\n                        sqlite3VdbeAddOp4(v, op, regOldData + 1 + x, addrJump, regCmp + i, p4, (-2));\n                        sqlite3VdbeChangeP5(v, 144);\n                        ;\n                        ;\n                    }\n                }\n            }\n        }\n        assert(onError == 1 || onError == 2 || onError == 3 || onError == 4 || onError == 5 || onError == 6);\n        switch (onError) {\n          case 1:\n          case 2:\n          case 3:\n            {\n                ;\n                ;\n                ;\n                sqlite3UniqueConstraint(pParse, onError, pIdx);\n                break;\n            }\n          case 6:\n            {\n                sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur + ix);\n            }\n          case 4:\n            {\n                ;\n                sqlite3VdbeGoto(v, ignoreDest);\n                break;\n            }\n          default:\n            {\n                int nConflictCk;\n                assert(onError == 5);\n                nConflictCk = sqlite3VdbeCurrentAddr(v) - addrConflictCk;\n                assert(nConflictCk > 0 || db->mallocFailed);\n                ;\n                ;\n                if (regTrigCnt) {\n                    sqlite3MultiWrite(pParse);\n                    nReplaceTrig++;\n                }\n                if (pTrigger && isUpdate) {\n                    sqlite3VdbeAddOp1(v, 167, iDataCur);\n                }\n                sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, regR, nPkField, 0, 5, (pIdx == pPk ? 1 : 0), iThisCur);\n                if (pTrigger && isUpdate) {\n                    sqlite3VdbeAddOp1(v, 168, iDataCur);\n                }\n                if (regTrigCnt) {\n                    int addrBypass;\n                    sqlite3VdbeAddOp2(v, 86, regTrigCnt, 1);\n                    addrBypass = sqlite3VdbeAddOp0(v, 9);\n                    ;\n                    sqlite3VdbeResolveLabel(v, lblRecheckOk);\n                    lblRecheckOk = sqlite3VdbeMakeLabel(pParse);\n                    if (pIdx->pPartIdxWhere) {\n                        sqlite3VdbeAddOp2(v, 50, regIdx - 1, lblRecheckOk);\n                        ;\n                    }\n                    while (nConflictCk > 0)\n                        {\n                            VdbeOp x;\n                            x = *sqlite3VdbeGetOp(v, addrConflictCk);\n                            if (x.opcode != 142) {\n                                int p2;\n                                const char *zP4;\n                                if (sqlite3OpcodeProperty[x.opcode] & 1) {\n                                    p2 = lblRecheckOk;\n                                } else {\n                                    p2 = x.p2;\n                                }\n                                zP4 = x.p4type == (-3) ? ((void *)(long)(x.p4.i)) : x.p4.z;\n                                sqlite3VdbeAddOp4(v, x.opcode, x.p1, p2, x.p3, zP4, x.p4type);\n                                sqlite3VdbeChangeP5(v, x.p5);\n                                ;\n                            }\n                            nConflictCk--;\n                            addrConflictCk++;\n                        }\n                    sqlite3UniqueConstraint(pParse, 2, pIdx);\n                    sqlite3VdbeJumpHere(v, addrBypass);\n                }\n                seenReplace = 1;\n                break;\n            }\n        }\n        sqlite3VdbeResolveLabel(v, addrUniqueOk);\n        if (regR != regIdx)\n            sqlite3ReleaseTempRange(pParse, regR, nPkField);\n        if (pUpsertClause && upsertIpkReturn && sqlite3UpsertNextIsIPK(pUpsertClause)) {\n            sqlite3VdbeGoto(v, upsertIpkDelay + 1);\n            sqlite3VdbeJumpHere(v, upsertIpkReturn);\n            upsertIpkReturn = 0;\n        }\n    }\n    if (ipkTop) {\n        sqlite3VdbeGoto(v, ipkTop);\n        ;\n        assert(ipkBottom > 0);\n        sqlite3VdbeJumpHere(v, ipkBottom);\n    }\n    ;\n    assert(regTrigCnt != 0 || nReplaceTrig == 0);\n    if (nReplaceTrig) {\n        sqlite3VdbeAddOp2(v, 17, regTrigCnt, lblRecheckOk);\n        ;\n        if (!pPk) {\n            if (isUpdate) {\n                sqlite3VdbeAddOp3(v, 53, regNewData, addrRecheck, regOldData);\n                sqlite3VdbeChangeP5(v, 144);\n                ;\n            }\n            sqlite3VdbeAddOp3(v, 31, iDataCur, addrRecheck, regNewData);\n            ;\n            sqlite3RowidConstraint(pParse, 2, pTab);\n        } else {\n            sqlite3VdbeGoto(v, addrRecheck);\n        }\n        sqlite3VdbeResolveLabel(v, lblRecheckOk);\n    }\n    if ((((pTab)->tabFlags & 128) == 0)) {\n        int regRec = aRegIdx[ix];\n        sqlite3VdbeAddOp3(v, 97, regNewData + 1, pTab->nNVCol, regRec);\n        ;\n        if (!bAffinityDone) {\n            sqlite3TableAffinity(v, pTab, 0);\n        }\n    }\n    *pbMayReplace = seenReplace;\n    ;\n}\n"
        }
    ],
    "total": 2429,
    "visited": 14
}
