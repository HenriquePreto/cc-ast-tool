{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#199033:1#jsonSetFunc",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    int bApnd;\n    int bIsSet = sqlite3_user_data(ctx) != 0;\n    if (argc < 1)\n        return;\n    if ((argc & 1) == 0) {\n        jsonWrongNumArgs(ctx, bIsSet ? \"set\" : \"insert\");\n        return;\n    }\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    assert(x.nNode);\n    for (i = 1; i < (u32)argc; i += 2) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        bApnd = 0;\n        pNode = jsonLookup(&x, zPath, &bApnd, ctx);\n        if (x.oom) {\n            sqlite3_result_error_nomem(ctx);\n            goto jsonSetDone;\n        } else if (x.nErr) {\n            goto jsonSetDone;\n        } else if (pNode && (bApnd || bIsSet)) {\n            ;\n            assert(pNode->eU != 3 && pNode->eU != 5);\n            ;\n            pNode->jnFlags |= (u8)8;\n            pNode->u.iReplace = i + 1;\n        }\n    }\n    if (x.aNode[0].jnFlags & 8) {\n        assert(x.aNode[0].eU == 4);\n        sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);\n    } else {\n        jsonReturnJson(x.aNode, ctx, argv);\n    }\n  jsonSetDone:\n    jsonParseReset(&x);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#198981:1#jsonReplaceFunc",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    if (argc < 1)\n        return;\n    if ((argc & 1) == 0) {\n        jsonWrongNumArgs(ctx, \"replace\");\n        return;\n    }\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    assert(x.nNode);\n    for (i = 1; i < (u32)argc; i += 2) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        pNode = jsonLookup(&x, zPath, 0, ctx);\n        if (x.nErr)\n            goto replace_err;\n        if (pNode) {\n            assert(pNode->eU == 0 || pNode->eU == 1 || pNode->eU == 4);\n            ;\n            pNode->jnFlags |= (u8)8;\n            ;\n            pNode->u.iReplace = i + 1;\n        }\n    }\n    if (x.aNode[0].jnFlags & 8) {\n        assert(x.aNode[0].eU == 4);\n        sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);\n    } else {\n        jsonReturnJson(x.aNode, ctx, argv);\n    }\n  replace_err:\n    jsonParseReset(&x);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#197432:1#jsonAppendString",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    u32 i;\n    if (zIn == 0 || ((N + p->nUsed + 2 >= p->nAlloc) && jsonGrow(p, N + 2) != 0))\n        return;\n    p->zBuf[p->nUsed++] = '\"';\n    for (i = 0; i < N; i++) {\n        unsigned char c = ((const unsigned char *)zIn)[i];\n        if (c == '\"' || c == '\\\\') {\n          json_simple_escape:\n            if ((p->nUsed + N + 3 - i > p->nAlloc) && jsonGrow(p, N + 3 - i) != 0)\n                return;\n            p->zBuf[p->nUsed++] = '\\\\';\n        } else if (c <= 31) {\n            static const char aSpecial[] = {0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n            assert(sizeof (aSpecial) == 32);\n            assert(aSpecial['\\b'] == 'b');\n            assert(aSpecial['\\f'] == 'f');\n            assert(aSpecial['\\n'] == 'n');\n            assert(aSpecial['\\r'] == 'r');\n            assert(aSpecial['\\t'] == 't');\n            if (aSpecial[c]) {\n                c = aSpecial[c];\n                goto json_simple_escape;\n            }\n            if ((p->nUsed + N + 7 + i > p->nAlloc) && jsonGrow(p, N + 7 - i) != 0)\n                return;\n            p->zBuf[p->nUsed++] = '\\\\';\n            p->zBuf[p->nUsed++] = 'u';\n            p->zBuf[p->nUsed++] = '0';\n            p->zBuf[p->nUsed++] = '0';\n            p->zBuf[p->nUsed++] = '0' + (c >> 4);\n            c = \"0123456789abcdef\"[c & 15];\n        }\n        p->zBuf[p->nUsed++] = c;\n    }\n    p->zBuf[p->nUsed++] = '\"';\n    assert(p->nUsed < p->nAlloc);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#175569:1#openDatabase",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    sqlite3 *db;\n    int rc;\n    int isThreadsafe;\n    char *zOpen = 0;\n    char *zErrMsg = 0;\n    int i;\n    *ppDb = 0;\n    rc = sqlite3_initialize();\n    if (rc)\n        return rc;\n    if (sqlite3Config.bCoreMutex == 0) {\n        isThreadsafe = 0;\n    } else if (flags & 32768) {\n        isThreadsafe = 0;\n    } else if (flags & 65536) {\n        isThreadsafe = 1;\n    } else {\n        isThreadsafe = sqlite3Config.bFullMutex;\n    }\n    if (flags & 262144) {\n        flags &= ~131072;\n    } else if (sqlite3Config.sharedCacheEnabled) {\n        flags |= 131072;\n    }\n    flags &= ~(8 | 16 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768 | 65536 | 524288);\n    db = sqlite3MallocZero(sizeof(sqlite3));\n    if (db == 0)\n        goto opendb_out;\n    if (isThreadsafe) {\n        db->mutex = sqlite3MutexAlloc(1);\n        if (db->mutex == 0) {\n            sqlite3_free(db);\n            db = 0;\n            goto opendb_out;\n        }\n        if (isThreadsafe == 0) {\n            ;\n        }\n    }\n    sqlite3_mutex_enter(db->mutex);\n    db->errMask = (flags & 33554432) != 0 ? 4294967295U : 255;\n    db->nDb = 2;\n    db->eOpenState = 109;\n    db->aDb = db->aDbStatic;\n    db->lookaside.bDisable = 1;\n    db->lookaside.sz = 0;\n    assert(sizeof (db->aLimit) == sizeof (aHardLimit));\n    memcpy(db->aLimit, aHardLimit, sizeof (db->aLimit));\n    db->aLimit[11] = 0;\n    db->autoCommit = 1;\n    db->nextAutovac = -1;\n    db->szMmap = sqlite3Config.szMmap;\n    db->nextPagesize = 0;\n    db->init.azInit = sqlite3StdType;\n    db->flags |= 64 | 262144 | 2147483648U | 32 | 128 | 1073741824 | 536870912 | 32768;\n    sqlite3HashInit(&db->aCollSeq);\n    sqlite3HashInit(&db->aModule);\n    createCollation(db, sqlite3StrBINARY, 1, 0, binCollFunc, 0);\n    createCollation(db, sqlite3StrBINARY, 3, 0, binCollFunc, 0);\n    createCollation(db, sqlite3StrBINARY, 2, 0, binCollFunc, 0);\n    createCollation(db, \"NOCASE\", 1, 0, nocaseCollatingFunc, 0);\n    createCollation(db, \"RTRIM\", 1, 0, rtrimCollFunc, 0);\n    if (db->mallocFailed) {\n        goto opendb_out;\n    }\n    db->openFlags = flags;\n    assert(1 == 1);\n    assert(2 == 2);\n    assert(4 == 4);\n    ;\n    ;\n    ;\n    if (((1 << (flags & 7)) & 70) == 0) {\n        rc = sqlite3MisuseError(175795);\n    } else {\n        rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);\n    }\n    if (rc != 0) {\n        if (rc == 7)\n            sqlite3OomFault(db);\n        sqlite3ErrorWithMsg(db, rc, zErrMsg ? \"%s\" : 0, zErrMsg);\n        sqlite3_free(zErrMsg);\n        goto opendb_out;\n    }\n    assert(db->pVfs != 0);\n    rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, &db->aDb[0].pBt, 0, flags | 256);\n    if (rc != 0) {\n        if (rc == (10 | (12 << 8))) {\n            rc = 7;\n        }\n        sqlite3Error(db, rc);\n        goto opendb_out;\n    }\n    sqlite3BtreeEnter(db->aDb[0].pBt);\n    db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);\n    if (!db->mallocFailed) {\n        sqlite3SetTextEncoding(db, ((db)->aDb[0].pSchema->enc));\n    }\n    sqlite3BtreeLeave(db->aDb[0].pBt);\n    db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);\n    db->aDb[0].zDbSName = \"main\";\n    db->aDb[0].safety_level = 2 + 1;\n    db->aDb[1].zDbSName = \"temp\";\n    db->aDb[1].safety_level = 1;\n    db->eOpenState = 118;\n    if (db->mallocFailed) {\n        goto opendb_out;\n    }\n    sqlite3Error(db, 0);\n    sqlite3RegisterPerConnectionBuiltinFunctions(db);\n    rc = sqlite3_errcode(db);\n    for (i = 0; rc == 0 && i < ((int)(sizeof (sqlite3BuiltinExtensions) / sizeof (sqlite3BuiltinExtensions[0]))); i++) {\n        rc = sqlite3BuiltinExtensions[i](db);\n    }\n    if (rc == 0) {\n        sqlite3AutoLoadExtensions(db);\n        rc = sqlite3_errcode(db);\n        if (rc != 0) {\n            goto opendb_out;\n        }\n    }\n    if (rc)\n        sqlite3Error(db, rc);\n    setupLookaside(db, 0, sqlite3Config.szLookaside, sqlite3Config.nLookaside);\n    sqlite3_wal_autocheckpoint(db, 1000);\n  opendb_out:\n    if (db) {\n        assert(db->mutex != 0 || isThreadsafe == 0 || sqlite3Config.bFullMutex == 0);\n        sqlite3_mutex_leave(db->mutex);\n    }\n    rc = sqlite3_errcode(db);\n    assert(db != 0 || (rc & 255) == 7);\n    if ((rc & 255) == 7) {\n        sqlite3_close(db);\n        db = 0;\n    } else if (rc != 0) {\n        db->eOpenState = 186;\n    }\n    *ppDb = db;\n    sqlite3_free_filename(zOpen);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3WindowAlloc",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    Window *pWin = 0;\n    int bImplicitFrame = 0;\n    assert(eType == 0 || eType == 89 || eType == 76 || eType == 92);\n    assert(eStart == 85 || eStart == 88 || eStart == 90 || eStart == 86);\n    assert(eEnd == 85 || eEnd == 86 || eEnd == 90 || eEnd == 88);\n    assert((eStart == 88 || eStart == 86) == (pStart != 0));\n    assert((eEnd == 86 || eEnd == 88) == (pEnd != 0));\n    if (eType == 0) {\n        bImplicitFrame = 1;\n        eType = 89;\n    }\n    if ((eStart == 85 && eEnd == 88) || (eStart == 86 && (eEnd == 88 || eEnd == 85))) {\n        sqlite3ErrorMsg(pParse, \"unsupported frame specification\");\n        goto windowAllocErr;\n    }\n    pWin = (Window *)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n    if (pWin == 0)\n        goto windowAllocErr;\n    pWin->eFrmType = eType;\n    pWin->eStart = eStart;\n    pWin->eEnd = eEnd;\n    if (eExclude == 0 && (((pParse->db)->dbOptFlags & (2)) != 0)) {\n        eExclude = 66;\n    }\n    pWin->eExclude = eExclude;\n    pWin->bImplicitFrame = bImplicitFrame;\n    pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);\n    pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);\n    return pWin;\n  windowAllocErr:\n    sqlite3ExprDelete(pParse->db, pEnd);\n    sqlite3ExprDelete(pParse->db, pStart);\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#162336:1#nth_valueStepFunc",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    struct NthValueCtx *p;\n    p = (struct NthValueCtx *)sqlite3_aggregate_context(pCtx, sizeof (*p));\n    if (p) {\n        i64 iVal;\n        switch (sqlite3_value_numeric_type(apArg[1])) {\n          case 1:\n            iVal = sqlite3_value_int64(apArg[1]);\n            break;\n          case 2:\n            {\n                double fVal = sqlite3_value_double(apArg[1]);\n                if (((i64)fVal) != fVal)\n                    goto error_out;\n                iVal = (i64)fVal;\n                break;\n            }\n          default:\n            goto error_out;\n        }\n        if (iVal <= 0)\n            goto error_out;\n        p->nStep++;\n        if (iVal == p->nStep) {\n            p->pValue = sqlite3_value_dup(apArg[0]);\n            if (!p->pValue) {\n                sqlite3_result_error_nomem(pCtx);\n            }\n        }\n    }\n    (void)(nArg);\n    (void)(apArg);\n    return;\n  error_out:\n    sqlite3_result_error(pCtx, \"second argument to nth_value must be a positive integer\", -1);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#155753:1#whereOrInsert",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    u16 i;\n    WhereOrCost *p;\n    for (i = pSet->n , p = pSet->a; i > 0; i-- , p++) {\n        if (rRun <= p->rRun && (prereq & p->prereq) == prereq) {\n            goto whereOrInsert_done;\n        }\n        if (p->rRun <= rRun && (p->prereq & prereq) == p->prereq) {\n            return 0;\n        }\n    }\n    if (pSet->n < 3) {\n        p = &pSet->a[pSet->n++];\n        p->nOut = nOut;\n    } else {\n        p = pSet->a;\n        for (i = 1; i < pSet->n; i++) {\n            if (p->rRun > pSet->a[i].rRun)\n                p = pSet->a + i;\n        }\n        if (p->rRun <= rRun)\n            return 0;\n    }\n  whereOrInsert_done:\n    p->prereq = prereq;\n    p->rRun = rRun;\n    if (p->nOut > nOut)\n        p->nOut = nOut;\n    return 1;\n}\n"
        },
        {
            "id": "#23:25#sqlite3Update",
            "gotos": 13,
            "labels": 1,
            "body": "{\n    int i, j, k;\n    Table *pTab;\n    int addrTop = 0;\n    WhereInfo *pWInfo = 0;\n    Vdbe *v;\n    Index *pIdx;\n    Index *pPk;\n    int nIdx;\n    int nAllIdx;\n    int iBaseCur;\n    int iDataCur;\n    int iIdxCur;\n    sqlite3 *db;\n    int *aRegIdx = 0;\n    int *aXRef = 0;\n    u8 *aToOpen;\n    u8 chngPk;\n    u8 chngRowid;\n    u8 chngKey;\n    Expr *pRowidExpr = 0;\n    int iRowidExpr = -1;\n    AuthContext sContext;\n    NameContext sNC;\n    int iDb;\n    int eOnePass;\n    int hasFK;\n    int labelBreak;\n    int labelContinue;\n    int flags;\n    int isView;\n    Trigger *pTrigger;\n    int tmask;\n    int newmask;\n    int iEph = 0;\n    int nKey = 0;\n    int aiCurOnePass[2];\n    int addrOpen = 0;\n    int iPk = 0;\n    i16 nPk = 0;\n    int bReplace = 0;\n    int bFinishSeek = 1;\n    int nChangeFrom = 0;\n    int regRowCount = 0;\n    int regOldRowid = 0;\n    int regNewRowid = 0;\n    int regNew = 0;\n    int regOld = 0;\n    int regRowSet = 0;\n    int regKey = 0;\n    memset(&sContext, 0, sizeof (sContext));\n    db = pParse->db;\n    assert(db->pParse == pParse);\n    if (pParse->nErr) {\n        goto update_cleanup;\n    }\n    assert(db->mallocFailed == 0);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0)\n        goto update_cleanup;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 129, pChanges, &tmask);\n    isView = ((pTab)->eTabType == 2);\n    assert(pTrigger || tmask == 0);\n    nChangeFrom = (pTabList->nSrc > 1) ? pChanges->nExpr : 0;\n    assert(nChangeFrom == 0 || pUpsert == 0);\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto update_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, tmask)) {\n        goto update_cleanup;\n    }\n    iBaseCur = iDataCur = pParse->nTab++;\n    iIdxCur = iDataCur + 1;\n    pPk = (((pTab)->tabFlags & 128) == 0) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n    ;\n    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n        if (pPk == pIdx) {\n            iDataCur = pParse->nTab;\n        }\n        pParse->nTab++;\n    }\n    if (pUpsert) {\n        iDataCur = pUpsert->iDataCur;\n        iIdxCur = pUpsert->iIdxCur;\n        pParse->nTab = iBaseCur;\n    }\n    pTabList->a[0].iCursor = iDataCur;\n    aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol + nIdx + 1) + nIdx + 2);\n    if (aXRef == 0)\n        goto update_cleanup;\n    aRegIdx = aXRef + pTab->nCol;\n    aToOpen = (u8 *)(aRegIdx + nIdx + 1);\n    memset(aToOpen, 1, nIdx + 1);\n    aToOpen[nIdx + 1] = 0;\n    for (i = 0; i < pTab->nCol; i++)\n        aXRef[i] = -1;\n    memset(&sNC, 0, sizeof (sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pUpsert = pUpsert;\n    sNC.ncFlags = 512;\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0)\n        goto update_cleanup;\n    chngRowid = chngPk = 0;\n    for (i = 0; i < pChanges->nExpr; i++) {\n        u8 hCol = sqlite3StrIHash(pChanges->a[i].zEName);\n        if (nChangeFrom == 0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr)) {\n            goto update_cleanup;\n        }\n        for (j = 0; j < pTab->nCol; j++) {\n            if (pTab->aCol[j].hName == hCol && sqlite3StrICmp(pTab->aCol[j].zCnName, pChanges->a[i].zEName) == 0) {\n                if (j == pTab->iPKey) {\n                    chngRowid = 1;\n                    pRowidExpr = pChanges->a[i].pExpr;\n                    iRowidExpr = i;\n                } else if (pPk && (pTab->aCol[j].colFlags & 1) != 0) {\n                    chngPk = 1;\n                } else if (pTab->aCol[j].colFlags & 96) {\n                    ;\n                    ;\n                    sqlite3ErrorMsg(pParse, \"cannot UPDATE generated column \\\"%s\\\"\", pTab->aCol[j].zCnName);\n                    goto update_cleanup;\n                }\n                aXRef[j] = i;\n                break;\n            }\n        }\n        if (j >= pTab->nCol) {\n            if (pPk == 0 && sqlite3IsRowid(pChanges->a[i].zEName)) {\n                j = -1;\n                chngRowid = 1;\n                pRowidExpr = pChanges->a[i].pExpr;\n                iRowidExpr = i;\n            } else {\n                sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zEName);\n                pParse->checkSchema = 1;\n                goto update_cleanup;\n            }\n        }\n        {\n            int rc;\n            rc = sqlite3AuthCheck(pParse, 23, pTab->zName, j < 0 ? \"ROWID\" : pTab->aCol[j].zCnName, db->aDb[iDb].zDbSName);\n            if (rc == 1) {\n                goto update_cleanup;\n            } else if (rc == 2) {\n                aXRef[j] = -1;\n            }\n        }\n    }\n    assert((chngRowid & chngPk) == 0);\n    assert(chngRowid == 0 || chngRowid == 1);\n    assert(chngPk == 0 || chngPk == 1);\n    chngKey = chngRowid + chngPk;\n    if (pTab->tabFlags & 96) {\n        int bProgress;\n        ;\n        ;\n        do {\n            bProgress = 0;\n            for (i = 0; i < pTab->nCol; i++) {\n                if (aXRef[i] >= 0)\n                    continue;\n                if ((pTab->aCol[i].colFlags & 96) == 0)\n                    continue;\n                if (sqlite3ExprReferencesUpdatedColumn(sqlite3ColumnExpr(pTab, &pTab->aCol[i]), aXRef, chngRowid)) {\n                    aXRef[i] = 99999;\n                    bProgress = 1;\n                }\n            }\n        } while (bProgress);\n    }\n    pTabList->a[0].colUsed = ((pTab)->eTabType == 1) ? ((Bitmask)-1) : 0;\n    hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);\n    if (onError == 5)\n        bReplace = 1;\n    for (nAllIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nAllIdx++) {\n        int reg;\n        if (chngKey || hasFK > 1 || pIdx == pPk || indexWhereClauseMightChange(pIdx, aXRef, chngRowid)) {\n            reg = ++pParse->nMem;\n            pParse->nMem += pIdx->nColumn;\n        } else {\n            reg = 0;\n            for (i = 0; i < pIdx->nKeyCol; i++) {\n                if (indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid)) {\n                    reg = ++pParse->nMem;\n                    pParse->nMem += pIdx->nColumn;\n                    if (onError == 11 && pIdx->onError == 5) {\n                        bReplace = 1;\n                    }\n                    break;\n                }\n            }\n        }\n        if (reg == 0)\n            aToOpen[nAllIdx + 1] = 0;\n        aRegIdx[nAllIdx] = reg;\n    }\n    aRegIdx[nAllIdx] = ++pParse->nMem;\n    if (bReplace) {\n        memset(aToOpen, 1, nIdx + 1);\n    }\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);\n    if (!((pTab)->eTabType == 1)) {\n        assert(aRegIdx[nAllIdx] == pParse->nMem);\n        regRowSet = aRegIdx[nAllIdx];\n        regOldRowid = regNewRowid = ++pParse->nMem;\n        if (chngPk || pTrigger || hasFK) {\n            regOld = pParse->nMem + 1;\n            pParse->nMem += pTab->nCol;\n        }\n        if (chngKey || pTrigger || hasFK) {\n            regNewRowid = ++pParse->nMem;\n        }\n        regNew = pParse->nMem + 1;\n        pParse->nMem += pTab->nCol;\n    }\n    if (isView) {\n        sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n    }\n    if (nChangeFrom == 0 && isView) {\n        sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iDataCur);\n        pOrderBy = 0;\n        pLimit = 0;\n    }\n    if (nChangeFrom == 0 && sqlite3ResolveExprNames(&sNC, pWhere)) {\n        goto update_cleanup;\n    }\n    if (((pTab)->eTabType == 1)) {\n        updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere, onError);\n        goto update_cleanup;\n    }\n    labelContinue = labelBreak = sqlite3VdbeMakeLabel(pParse);\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning && pUpsert == 0) {\n        regRowCount = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, regRowCount);\n    }\n    if (nChangeFrom == 0 && (((pTab)->tabFlags & 128) == 0)) {\n        sqlite3VdbeAddOp3(v, 75, 0, regRowSet, regOldRowid);\n        iEph = pParse->nTab++;\n        addrOpen = sqlite3VdbeAddOp3(v, 118, iEph, 0, regRowSet);\n    } else {\n        assert(pPk != 0 || (((pTab)->tabFlags & 128) == 0));\n        nPk = pPk ? pPk->nKeyCol : 0;\n        iPk = pParse->nMem + 1;\n        pParse->nMem += nPk;\n        pParse->nMem += nChangeFrom;\n        regKey = ++pParse->nMem;\n        if (pUpsert == 0) {\n            int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);\n            iEph = pParse->nTab++;\n            if (pPk)\n                sqlite3VdbeAddOp3(v, 75, 0, iPk, iPk + nPk - 1);\n            addrOpen = sqlite3VdbeAddOp2(v, 118, iEph, nEphCol);\n            if (pPk) {\n                KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);\n                if (pKeyInfo) {\n                    pKeyInfo->nAllField = nEphCol;\n                    sqlite3VdbeAppendP4(v, pKeyInfo, (-8));\n                }\n            }\n            if (nChangeFrom) {\n                updateFromSelect(pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit);\n                if (isView)\n                    iDataCur = iEph;\n            }\n        }\n    }\n    if (nChangeFrom) {\n        sqlite3MultiWrite(pParse);\n        eOnePass = 0;\n        nKey = nPk;\n        regKey = iPk;\n    } else {\n        if (pUpsert) {\n            pWInfo = 0;\n            eOnePass = 1;\n            sqlite3ExprIfFalse(pParse, pWhere, labelBreak, 16);\n            bFinishSeek = 0;\n        } else {\n            flags = 4;\n            if (!pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace) {\n                flags |= 8;\n            }\n            pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0, flags, iIdxCur);\n            if (pWInfo == 0)\n                goto update_cleanup;\n            eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n            bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);\n            if (eOnePass != 1) {\n                sqlite3MultiWrite(pParse);\n                if (eOnePass == 2) {\n                    int iCur = aiCurOnePass[1];\n                    if (iCur >= 0 && iCur != iDataCur && aToOpen[iCur - iBaseCur]) {\n                        eOnePass = 0;\n                    }\n                    assert(iCur != iDataCur || !(((pTab)->tabFlags & 128) == 0));\n                }\n            }\n        }\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp2(v, 135, iDataCur, regOldRowid);\n            if (eOnePass == 0) {\n                aRegIdx[nAllIdx] = ++pParse->nMem;\n                sqlite3VdbeAddOp3(v, 128, iEph, regRowSet, regOldRowid);\n            } else {\n                if ((addrOpen))\n                    sqlite3VdbeChangeToNoop(v, addrOpen);\n            }\n        } else {\n            for (i = 0; i < nPk; i++) {\n                assert(pPk->aiColumn[i] >= 0);\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, pPk->aiColumn[i], iPk + i);\n            }\n            if (eOnePass) {\n                if (addrOpen)\n                    sqlite3VdbeChangeToNoop(v, addrOpen);\n                nKey = nPk;\n                regKey = iPk;\n            } else {\n                sqlite3VdbeAddOp4(v, 97, iPk, nPk, regKey, sqlite3IndexAffinityStr(db, pPk), nPk);\n                sqlite3VdbeAddOp4Int(v, 138, iEph, regKey, iPk, nPk);\n            }\n        }\n    }\n    if (pUpsert == 0) {\n        if (nChangeFrom == 0 && eOnePass != 2) {\n            sqlite3WhereEnd(pWInfo);\n        }\n        if (!isView) {\n            int addrOnce = 0;\n            if (eOnePass != 0) {\n                if (aiCurOnePass[0] >= 0)\n                    aToOpen[aiCurOnePass[0] - iBaseCur] = 0;\n                if (aiCurOnePass[1] >= 0)\n                    aToOpen[aiCurOnePass[1] - iBaseCur] = 0;\n            }\n            if (eOnePass == 2 && (nIdx - (aiCurOnePass[1] >= 0)) > 0) {\n                addrOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n            }\n            sqlite3OpenTableAndIndices(pParse, pTab, 113, 0, iBaseCur, aToOpen, 0, 0);\n            if (addrOnce) {\n                sqlite3VdbeJumpHereOrPopInst(v, addrOnce);\n            }\n        }\n        if (eOnePass != 0) {\n            if (aiCurOnePass[0] != iDataCur && aiCurOnePass[1] != iDataCur) {\n                assert(pPk);\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelBreak, regKey, nKey);\n                ;\n            }\n            if (eOnePass != 1) {\n                labelContinue = sqlite3VdbeMakeLabel(pParse);\n            }\n            sqlite3VdbeAddOp2(v, 50, pPk ? regKey : regOldRowid, labelBreak);\n            ;\n            ;\n        } else if (pPk || nChangeFrom) {\n            labelContinue = sqlite3VdbeMakeLabel(pParse);\n            sqlite3VdbeAddOp2(v, 36, iEph, labelBreak);\n            ;\n            addrTop = sqlite3VdbeCurrentAddr(v);\n            if (nChangeFrom) {\n                if (!isView) {\n                    if (pPk) {\n                        for (i = 0; i < nPk; i++) {\n                            sqlite3VdbeAddOp3(v, 94, iEph, i, iPk + i);\n                        }\n                        sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, iPk, nPk);\n                        ;\n                    } else {\n                        sqlite3VdbeAddOp2(v, 135, iEph, regOldRowid);\n                        sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n                        ;\n                    }\n                }\n            } else {\n                sqlite3VdbeAddOp2(v, 134, iEph, regKey);\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, 0);\n                ;\n            }\n        } else {\n            sqlite3VdbeAddOp2(v, 36, iEph, labelBreak);\n            ;\n            labelContinue = sqlite3VdbeMakeLabel(pParse);\n            addrTop = sqlite3VdbeAddOp2(v, 135, iEph, regOldRowid);\n            ;\n            sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n            ;\n        }\n    }\n    assert(chngKey || pTrigger || hasFK || regOldRowid == regNewRowid);\n    if (chngRowid) {\n        assert(iRowidExpr >= 0);\n        if (nChangeFrom == 0) {\n            sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);\n        } else {\n            sqlite3VdbeAddOp3(v, 94, iEph, iRowidExpr, regNewRowid);\n        }\n        sqlite3VdbeAddOp1(v, 13, regNewRowid);\n        ;\n    }\n    if (chngPk || hasFK || pTrigger) {\n        u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);\n        oldmask |= sqlite3TriggerColmask(pParse, pTrigger, pChanges, 0, 1 | 2, pTab, onError);\n        for (i = 0; i < pTab->nCol; i++) {\n            u32 colFlags = pTab->aCol[i].colFlags;\n            k = sqlite3TableColumnToStorage(pTab, i) + regOld;\n            if (oldmask == 4294967295U || (i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0) || (colFlags & 1) != 0) {\n                ;\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, k);\n            }\n        }\n        if (chngRowid == 0 && pPk == 0) {\n            sqlite3VdbeAddOp2(v, 80, regOldRowid, regNewRowid);\n        }\n    }\n    newmask = sqlite3TriggerColmask(pParse, pTrigger, pChanges, 1, 1, pTab, onError);\n    for (i = 0 , k = regNew; i < pTab->nCol; i++ , k++) {\n        if (i == pTab->iPKey) {\n            sqlite3VdbeAddOp2(v, 75, 0, k);\n        } else if ((pTab->aCol[i].colFlags & 96) != 0) {\n            if (pTab->aCol[i].colFlags & 32)\n                k--;\n        } else {\n            j = aXRef[i];\n            if (j >= 0) {\n                if (nChangeFrom) {\n                    int nOff = (isView ? pTab->nCol : nPk);\n                    assert(eOnePass == 0);\n                    sqlite3VdbeAddOp3(v, 94, iEph, nOff + j, k);\n                } else {\n                    sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);\n                }\n            } else if (0 == (tmask & 1) || i > 31 || (newmask & (((unsigned int)1) << (i)))) {\n                ;\n                ;\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n                bFinishSeek = 0;\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, k);\n            }\n        }\n    }\n    if (pTab->tabFlags & 96) {\n        ;\n        ;\n        sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n    }\n    if (tmask & 1) {\n        sqlite3TableAffinity(v, pTab, regNew);\n        sqlite3CodeRowTrigger(pParse, pTrigger, 129, pChanges, 1, pTab, regOldRowid, onError, labelContinue);\n        if (!isView) {\n            if (pPk) {\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, nKey);\n                ;\n            } else {\n                sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n                ;\n            }\n            for (i = 0 , k = regNew; i < pTab->nCol; i++ , k++) {\n                if (pTab->aCol[i].colFlags & 96) {\n                    if (pTab->aCol[i].colFlags & 32)\n                        k--;\n                } else if (aXRef[i] < 0 && i != pTab->iPKey) {\n                    sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n                }\n            }\n            if (pTab->tabFlags & 96) {\n                ;\n                ;\n                sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n            }\n        }\n    }\n    if (!isView) {\n        assert(regOldRowid > 0);\n        sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace, aXRef, 0);\n        if (bReplace || chngKey) {\n            if (pPk) {\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, nKey);\n            } else {\n                sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n            }\n            ;\n        }\n        if (hasFK) {\n            sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);\n        }\n        sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);\n        if (bFinishSeek) {\n            sqlite3VdbeAddOp1(v, 143, iDataCur);\n        }\n        assert(regNew == regNewRowid + 1);\n        if (hasFK > 1 || chngKey) {\n            sqlite3VdbeAddOp2(v, 130, iDataCur, 0);\n        }\n        if (hasFK) {\n            sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);\n        }\n        sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx, 4 | (eOnePass == 2 ? 2 : 0), 0, 0);\n        if (hasFK) {\n            sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);\n        }\n    }\n    if (regRowCount) {\n        sqlite3VdbeAddOp2(v, 86, regRowCount, 1);\n    }\n    sqlite3CodeRowTrigger(pParse, pTrigger, 129, pChanges, 2, pTab, regOldRowid, onError, labelContinue);\n    if (eOnePass == 1) {\n    } else if (eOnePass == 2) {\n        sqlite3VdbeResolveLabel(v, labelContinue);\n        sqlite3WhereEnd(pWInfo);\n    } else {\n        sqlite3VdbeResolveLabel(v, labelContinue);\n        sqlite3VdbeAddOp2(v, 39, iEph, addrTop);\n        ;\n    }\n    sqlite3VdbeResolveLabel(v, labelBreak);\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0 && pUpsert == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (regRowCount) {\n        sqlite3CodeChangeCount(v, regRowCount, \"rows updated\");\n    }\n  update_cleanup:\n    sqlite3AuthContextPop(&sContext);\n    sqlite3DbFree(db, aXRef);\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprListDelete(db, pChanges);\n    sqlite3ExprDelete(db, pWhere);\n    return;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#146134:1#triggersReallyExist",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int mask = 0;\n    Trigger *pList = 0;\n    Trigger *p;\n    pList = sqlite3TriggerList(pParse, pTab);\n    assert(pList == 0 || ((pTab)->eTabType == 1) == 0 || (pList->bReturning && pList->pNext == 0));\n    if (pList != 0) {\n        p = pList;\n        if ((pParse->db->flags & 262144) == 0 && pTab->pTrigger != 0) {\n            if (pList == pTab->pTrigger) {\n                pList = 0;\n                goto exit_triggers_exist;\n            }\n            while ((p->pNext) && p->pNext != pTab->pTrigger)\n                p = p->pNext;\n            p->pNext = 0;\n            p = pList;\n        }\n        do {\n            if (p->op == op && checkColumnOverlap(p->pColumns, pChanges)) {\n                mask |= p->tr_tm;\n            } else if (p->op == 150) {\n                assert(((pParse)->pToplevel == 0));\n                p->op = op;\n                if (((pTab)->eTabType == 1)) {\n                    if (op != 127) {\n                        sqlite3ErrorMsg(pParse, \"%s RETURNING is not available on virtual tables\", op == 128 ? \"DELETE\" : \"UPDATE\");\n                    }\n                    p->tr_tm = 1;\n                } else {\n                    p->tr_tm = 2;\n                }\n                mask |= p->tr_tm;\n            } else if (p->bReturning && p->op == 127 && op == 129 && ((pParse)->pToplevel == 0)) {\n                mask |= p->tr_tm;\n            }\n            p = p->pNext;\n        } while (p);\n    }\n  exit_triggers_exist:\n    if (pMask) {\n        *pMask = mask;\n    }\n    return (mask ? pList : 0);\n}\n"
        },
        {
            "id": "#23:25#sqlite3DropTrigger",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    Trigger *pTrigger = 0;\n    int i;\n    const char *zDb;\n    const char *zName;\n    sqlite3 *db = pParse->db;\n    if (db->mallocFailed)\n        goto drop_trigger_cleanup;\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto drop_trigger_cleanup;\n    }\n    assert(pName->nSrc == 1);\n    zDb = pName->a[0].zDatabase;\n    zName = pName->a[0].zName;\n    assert(zDb != 0 || sqlite3BtreeHoldsAllMutexes(db));\n    for (i = 0; i < db->nDb; i++) {\n        int j = (i < 2) ? i ^ 1 : i;\n        if (zDb && sqlite3DbIsNamed(db, j, zDb) == 0)\n            continue;\n        assert(sqlite3SchemaMutexHeld(db, j, 0));\n        pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName);\n        if (pTrigger)\n            break;\n    }\n    if (!pTrigger) {\n        if (!noErr) {\n            sqlite3ErrorMsg(pParse, \"no such trigger: %S\", pName->a);\n        } else {\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n        }\n        pParse->checkSchema = 1;\n        goto drop_trigger_cleanup;\n    }\n    sqlite3DropTriggerPtr(pParse, pTrigger);\n  drop_trigger_cleanup:\n    sqlite3SrcListDelete(db, pName);\n}\n"
        },
        {
            "id": "#23:25#sqlite3FinishTrigger",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    Trigger *pTrig = pParse->pNewTrigger;\n    char *zName;\n    sqlite3 *db = pParse->db;\n    DbFixer sFix;\n    int iDb;\n    Token nameToken;\n    pParse->pNewTrigger = 0;\n    if ((pParse->nErr) || !pTrig)\n        goto triggerfinish_cleanup;\n    zName = pTrig->zName;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);\n    pTrig->step_list = pStepList;\n    while (pStepList)\n        {\n            pStepList->pTrig = pTrig;\n            pStepList = pStepList->pNext;\n        }\n    sqlite3TokenInit(&nameToken, pTrig->zName);\n    sqlite3FixInit(&sFix, pParse, iDb, \"trigger\", &nameToken);\n    if (sqlite3FixTriggerStep(&sFix, pTrig->step_list) || sqlite3FixExpr(&sFix, pTrig->pWhen)) {\n        goto triggerfinish_cleanup;\n    }\n    if ((pParse->eParseMode >= 2)) {\n        assert(!db->init.busy);\n        pParse->pNewTrigger = pTrig;\n        pTrig = 0;\n    } else if (!db->init.busy) {\n        Vdbe *v;\n        char *z;\n        if (sqlite3ReadOnlyShadowTables(db)) {\n            TriggerStep *pStep;\n            for (pStep = pTrig->step_list; pStep; pStep = pStep->pNext) {\n                if (pStep->zTarget != 0 && sqlite3ShadowTableName(db, pStep->zTarget)) {\n                    sqlite3ErrorMsg(pParse, \"trigger \\\"%s\\\" may not write to shadow table \\\"%s\\\"\", pTrig->zName, pStep->zTarget);\n                    goto triggerfinish_cleanup;\n                }\n            }\n        }\n        v = sqlite3GetVdbe(pParse);\n        if (v == 0)\n            goto triggerfinish_cleanup;\n        sqlite3BeginWriteOperation(pParse, 0, iDb);\n        z = sqlite3DbStrNDup(db, (char *)pAll->z, pAll->n);\n        ;\n        sqlite3NestedParse(pParse, \"INSERT INTO %Q.sqlite_master VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')\", db->aDb[iDb].zDbSName, zName, pTrig->table, z);\n        sqlite3DbFree(db, z);\n        sqlite3ChangeCookie(pParse, iDb);\n        sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, \"type='trigger' AND name='%q'\", zName), 0);\n    }\n    if (db->init.busy) {\n        Trigger *pLink = pTrig;\n        Hash *pHash = &db->aDb[iDb].pSchema->trigHash;\n        assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n        assert(pLink != 0);\n        pTrig = sqlite3HashInsert(pHash, zName, pTrig);\n        if (pTrig) {\n            sqlite3OomFault(db);\n        } else if (pLink->pSchema == pLink->pTabSchema) {\n            Table *pTab;\n            pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table);\n            assert(pTab != 0);\n            pLink->pNext = pTab->pTrigger;\n            pTab->pTrigger = pLink;\n        }\n    }\n  triggerfinish_cleanup:\n    sqlite3DeleteTrigger(db, pTrig);\n    assert((pParse->eParseMode >= 2) || !pParse->pNewTrigger);\n    sqlite3DeleteTriggerStep(db, pStepList);\n}\n"
        },
        {
            "id": "#23:25#sqlite3BeginTrigger",
            "gotos": 17,
            "labels": 2,
            "body": "{\n    Trigger *pTrigger = 0;\n    Table *pTab;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    Token *pName;\n    DbFixer sFix;\n    assert(pName1 != 0);\n    assert(pName2 != 0);\n    assert(op == 127 || op == 129 || op == 128);\n    assert(op > 0 && op < 255);\n    if (isTemp) {\n        if (pName2->n > 0) {\n            sqlite3ErrorMsg(pParse, \"temporary trigger may not have qualified name\");\n            goto trigger_cleanup;\n        }\n        iDb = 1;\n        pName = pName1;\n    } else {\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0) {\n            goto trigger_cleanup;\n        }\n    }\n    if (!pTableName || db->mallocFailed) {\n        goto trigger_cleanup;\n    }\n    if (db->init.busy && iDb != 1) {\n        sqlite3DbFree(db, pTableName->a[0].zDatabase);\n        pTableName->a[0].zDatabase = 0;\n    }\n    pTab = sqlite3SrcListLookup(pParse, pTableName);\n    if (db->init.busy == 0 && pName2->n == 0 && pTab && pTab->pSchema == db->aDb[1].pSchema) {\n        iDb = 1;\n    }\n    if (db->mallocFailed)\n        goto trigger_cleanup;\n    assert(pTableName->nSrc == 1);\n    sqlite3FixInit(&sFix, pParse, iDb, \"trigger\", pName);\n    if (sqlite3FixSrcList(&sFix, pTableName)) {\n        goto trigger_cleanup;\n    }\n    pTab = sqlite3SrcListLookup(pParse, pTableName);\n    if (!pTab) {\n        goto trigger_orphan_error;\n    }\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"cannot create triggers on virtual tables\");\n        goto trigger_orphan_error;\n    }\n    zName = sqlite3NameFromToken(db, pName);\n    if (zName == 0) {\n        assert(db->mallocFailed);\n        goto trigger_cleanup;\n    }\n    if (sqlite3CheckObjectName(pParse, zName, \"trigger\", pTab->zName)) {\n        goto trigger_cleanup;\n    }\n    assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n    if (!(pParse->eParseMode >= 2)) {\n        if (sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash), zName)) {\n            if (!noErr) {\n                sqlite3ErrorMsg(pParse, \"trigger %T already exists\", pName);\n            } else {\n                assert(!db->init.busy);\n                sqlite3CodeVerifySchema(pParse, iDb);\n            }\n            goto trigger_cleanup;\n        }\n    }\n    if (sqlite3_strnicmp(pTab->zName, \"sqlite_\", 7) == 0) {\n        sqlite3ErrorMsg(pParse, \"cannot create trigger on system table\");\n        goto trigger_cleanup;\n    }\n    if (((pTab)->eTabType == 2) && tr_tm != 65) {\n        sqlite3ErrorMsg(pParse, \"cannot create %s trigger on view: %S\", (tr_tm == 33) ? \"BEFORE\" : \"AFTER\", pTableName->a);\n        goto trigger_orphan_error;\n    }\n    if (!((pTab)->eTabType == 2) && tr_tm == 65) {\n        sqlite3ErrorMsg(pParse, \"cannot create INSTEAD OF trigger on table: %S\", pTableName->a);\n        goto trigger_orphan_error;\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        int code = 7;\n        const char *zDb = db->aDb[iTabDb].zDbSName;\n        const char *zDbTrig = isTemp ? db->aDb[1].zDbSName : zDb;\n        if (iTabDb == 1 || isTemp)\n            code = 5;\n        if (sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig)) {\n            goto trigger_cleanup;\n        }\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (iTabDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto trigger_cleanup;\n        }\n    }\n    if (tr_tm == 65) {\n        tr_tm = 33;\n    }\n    pTrigger = (Trigger *)sqlite3DbMallocZero(db, sizeof(Trigger));\n    if (pTrigger == 0)\n        goto trigger_cleanup;\n    pTrigger->zName = zName;\n    zName = 0;\n    pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);\n    pTrigger->pSchema = db->aDb[iDb].pSchema;\n    pTrigger->pTabSchema = pTab->pSchema;\n    pTrigger->op = (u8)op;\n    pTrigger->tr_tm = tr_tm == 33 ? 1 : 2;\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameTokenRemap(pParse, pTrigger->table, pTableName->a[0].zName);\n        pTrigger->pWhen = pWhen;\n        pWhen = 0;\n    } else {\n        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 1);\n    }\n    pTrigger->pColumns = pColumns;\n    pColumns = 0;\n    assert(pParse->pNewTrigger == 0);\n    pParse->pNewTrigger = pTrigger;\n  trigger_cleanup:\n    sqlite3DbFree(db, zName);\n    sqlite3SrcListDelete(db, pTableName);\n    sqlite3IdListDelete(db, pColumns);\n    sqlite3ExprDelete(db, pWhen);\n    if (!pParse->pNewTrigger) {\n        sqlite3DeleteTrigger(db, pTrigger);\n    } else {\n        assert(pParse->pNewTrigger == pTrigger);\n    }\n    return;\n  trigger_orphan_error:\n    if (db->init.iDb == 1) {\n        db->init.orphanTrigger = 1;\n    }\n    goto trigger_cleanup;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#145213:1#sqlite3_get_table_cb",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    TabResult *p = (TabResult *)pArg;\n    int need;\n    int i;\n    char *z;\n    if (p->nRow == 0 && argv != 0) {\n        need = nCol * 2;\n    } else {\n        need = nCol;\n    }\n    if (p->nData + need > p->nAlloc) {\n        char **azNew;\n        p->nAlloc = p->nAlloc * 2 + need;\n        azNew = sqlite3Realloc(p->azResult, sizeof(char *) * p->nAlloc);\n        if (azNew == 0)\n            goto malloc_failed;\n        p->azResult = azNew;\n    }\n    if (p->nRow == 0) {\n        p->nColumn = nCol;\n        for (i = 0; i < nCol; i++) {\n            z = sqlite3_mprintf(\"%s\", colv[i]);\n            if (z == 0)\n                goto malloc_failed;\n            p->azResult[p->nData++] = z;\n        }\n    } else if ((int)p->nColumn != nCol) {\n        sqlite3_free(p->zErrMsg);\n        p->zErrMsg = sqlite3_mprintf(\"sqlite3_get_table() called with two or more incompatible queries\");\n        p->rc = 1;\n        return 1;\n    }\n    if (argv != 0) {\n        for (i = 0; i < nCol; i++) {\n            if (argv[i] == 0) {\n                z = 0;\n            } else {\n                int n = sqlite3Strlen30(argv[i]) + 1;\n                z = sqlite3_malloc64(n);\n                if (z == 0)\n                    goto malloc_failed;\n                memcpy(z, argv[i], n);\n            }\n            p->azResult[p->nData++] = z;\n        }\n        p->nRow++;\n    }\n    return 0;\n  malloc_failed:\n    p->rc = 7;\n    return 1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#140062:1#multiSelect",
            "gotos": 6,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    Select *pPrior;\n    Vdbe *v;\n    SelectDest dest;\n    Select *pDelete = 0;\n    sqlite3 *db;\n    assert(p && p->pPrior);\n    assert((p->selFlags & 8192) == 0 || p->op == 135 || p->op == 134);\n    assert(p->selFlags & 256);\n    db = pParse->db;\n    pPrior = p->pPrior;\n    dest = *pDest;\n    assert(pPrior->pOrderBy == 0);\n    assert(pPrior->pLimit == 0);\n    v = sqlite3GetVdbe(pParse);\n    assert(v != 0);\n    if (dest.eDest == 12) {\n        assert(p->pEList);\n        sqlite3VdbeAddOp2(v, 118, dest.iSDParm, p->pEList->nExpr);\n        dest.eDest = 14;\n    }\n    if (p->selFlags & 1024) {\n        rc = multiSelectValues(pParse, p, &dest);\n        if (rc >= 0)\n            goto multi_select_end;\n        rc = 0;\n    }\n    assert(p->pEList && pPrior->pEList);\n    assert(p->pEList->nExpr == pPrior->pEList->nExpr);\n    if ((p->selFlags & 8192) != 0 && hasAnchor(p)) {\n        generateWithRecursiveQuery(pParse, p, &dest);\n    } else if (p->pOrderBy) {\n        return multiSelectOrderBy(pParse, p, pDest);\n    } else {\n        if (pPrior->pPrior == 0) {\n            sqlite3VdbeExplain(pParse, 1, \"COMPOUND QUERY\");\n            sqlite3VdbeExplain(pParse, 1, \"LEFT-MOST SUBQUERY\");\n        }\n        switch (p->op) {\n          case 135:\n            {\n                int addr = 0;\n                int nLimit = 0;\n                assert(!pPrior->pLimit);\n                pPrior->iLimit = p->iLimit;\n                pPrior->iOffset = p->iOffset;\n                pPrior->pLimit = p->pLimit;\n                ;\n                rc = sqlite3Select(pParse, pPrior, &dest);\n                pPrior->pLimit = 0;\n                if (rc) {\n                    goto multi_select_end;\n                }\n                p->pPrior = 0;\n                p->iLimit = pPrior->iLimit;\n                p->iOffset = pPrior->iOffset;\n                if (p->iLimit) {\n                    addr = sqlite3VdbeAddOp1(v, 17, p->iLimit);\n                    ;\n                    ;\n                    if (p->iOffset) {\n                        sqlite3VdbeAddOp3(v, 160, p->iLimit, p->iOffset + 1, p->iOffset);\n                    }\n                }\n                sqlite3VdbeExplain(pParse, 1, \"UNION ALL\");\n                ;\n                rc = sqlite3Select(pParse, p, &dest);\n                ;\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n                if (p->pLimit && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit) && nLimit > 0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)) {\n                    p->nSelectRow = sqlite3LogEst((u64)nLimit);\n                }\n                if (addr) {\n                    sqlite3VdbeJumpHere(v, addr);\n                }\n                break;\n            }\n          case 136:\n          case 134:\n            {\n                int unionTab;\n                u8 op = 0;\n                int priorOp;\n                Expr *pLimit;\n                int addr;\n                SelectDest uniondest;\n                ;\n                ;\n                priorOp = 1;\n                if (dest.eDest == priorOp) {\n                    assert(p->pLimit == 0);\n                    unionTab = dest.iSDParm;\n                } else {\n                    unionTab = pParse->nTab++;\n                    assert(p->pOrderBy == 0);\n                    addr = sqlite3VdbeAddOp2(v, 118, unionTab, 0);\n                    assert(p->addrOpenEphm[0] == -1);\n                    p->addrOpenEphm[0] = addr;\n                    findRightmost(p)->selFlags |= 32;\n                    assert(p->pEList);\n                }\n                assert(!pPrior->pOrderBy);\n                sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n                ;\n                rc = sqlite3Select(pParse, pPrior, &uniondest);\n                if (rc) {\n                    goto multi_select_end;\n                }\n                if (p->op == 136) {\n                    op = 2;\n                } else {\n                    assert(p->op == 134);\n                    op = 1;\n                }\n                p->pPrior = 0;\n                pLimit = p->pLimit;\n                p->pLimit = 0;\n                uniondest.eDest = op;\n                sqlite3VdbeExplain(pParse, 1, \"%s USING TEMP B-TREE\", sqlite3SelectOpName(p->op));\n                ;\n                rc = sqlite3Select(pParse, p, &uniondest);\n                ;\n                assert(p->pOrderBy == 0);\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                p->pOrderBy = 0;\n                if (p->op == 134) {\n                    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n                }\n                sqlite3ExprDelete(db, p->pLimit);\n                p->pLimit = pLimit;\n                p->iLimit = 0;\n                p->iOffset = 0;\n                assert(unionTab == dest.iSDParm || dest.eDest != priorOp);\n                assert(p->pEList || db->mallocFailed);\n                if (dest.eDest != priorOp && db->mallocFailed == 0) {\n                    int iCont, iBreak, iStart;\n                    iBreak = sqlite3VdbeMakeLabel(pParse);\n                    iCont = sqlite3VdbeMakeLabel(pParse);\n                    computeLimitRegisters(pParse, p, iBreak);\n                    sqlite3VdbeAddOp2(v, 36, unionTab, iBreak);\n                    ;\n                    iStart = sqlite3VdbeCurrentAddr(v);\n                    selectInnerLoop(pParse, p, unionTab, 0, 0, &dest, iCont, iBreak);\n                    sqlite3VdbeResolveLabel(v, iCont);\n                    sqlite3VdbeAddOp2(v, 39, unionTab, iStart);\n                    ;\n                    sqlite3VdbeResolveLabel(v, iBreak);\n                    sqlite3VdbeAddOp2(v, 122, unionTab, 0);\n                }\n                break;\n            }\n          default:\n            assert(p->op == 137);\n            {\n                int tab1, tab2;\n                int iCont, iBreak, iStart;\n                Expr *pLimit;\n                int addr;\n                SelectDest intersectdest;\n                int r1;\n                tab1 = pParse->nTab++;\n                tab2 = pParse->nTab++;\n                assert(p->pOrderBy == 0);\n                addr = sqlite3VdbeAddOp2(v, 118, tab1, 0);\n                assert(p->addrOpenEphm[0] == -1);\n                p->addrOpenEphm[0] = addr;\n                findRightmost(p)->selFlags |= 32;\n                assert(p->pEList);\n                sqlite3SelectDestInit(&intersectdest, 1, tab1);\n                ;\n                rc = sqlite3Select(pParse, pPrior, &intersectdest);\n                if (rc) {\n                    goto multi_select_end;\n                }\n                addr = sqlite3VdbeAddOp2(v, 118, tab2, 0);\n                assert(p->addrOpenEphm[1] == -1);\n                p->addrOpenEphm[1] = addr;\n                p->pPrior = 0;\n                pLimit = p->pLimit;\n                p->pLimit = 0;\n                intersectdest.iSDParm = tab2;\n                sqlite3VdbeExplain(pParse, 1, \"%s USING TEMP B-TREE\", sqlite3SelectOpName(p->op));\n                ;\n                rc = sqlite3Select(pParse, p, &intersectdest);\n                ;\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                if (p->nSelectRow > pPrior->nSelectRow) {\n                    p->nSelectRow = pPrior->nSelectRow;\n                }\n                sqlite3ExprDelete(db, p->pLimit);\n                p->pLimit = pLimit;\n                if (rc)\n                    break;\n                assert(p->pEList);\n                iBreak = sqlite3VdbeMakeLabel(pParse);\n                iCont = sqlite3VdbeMakeLabel(pParse);\n                computeLimitRegisters(pParse, p, iBreak);\n                sqlite3VdbeAddOp2(v, 36, tab1, iBreak);\n                ;\n                r1 = sqlite3GetTempReg(pParse);\n                iStart = sqlite3VdbeAddOp2(v, 134, tab1, r1);\n                sqlite3VdbeAddOp4Int(v, 28, tab2, iCont, r1, 0);\n                ;\n                sqlite3ReleaseTempReg(pParse, r1);\n                selectInnerLoop(pParse, p, tab1, 0, 0, &dest, iCont, iBreak);\n                sqlite3VdbeResolveLabel(v, iCont);\n                sqlite3VdbeAddOp2(v, 39, tab1, iStart);\n                ;\n                sqlite3VdbeResolveLabel(v, iBreak);\n                sqlite3VdbeAddOp2(v, 122, tab2, 0);\n                sqlite3VdbeAddOp2(v, 122, tab1, 0);\n                break;\n            }\n        }\n        if (p->pNext == 0) {\n            sqlite3VdbeExplainPop(pParse);\n        }\n    }\n    if (pParse->nErr)\n        goto multi_select_end;\n    if (p->selFlags & 32) {\n        int i;\n        KeyInfo *pKeyInfo;\n        Select *pLoop;\n        CollSeq **apColl;\n        int nCol;\n        assert(p->pNext == 0);\n        assert(p->pEList != 0);\n        nCol = p->pEList->nExpr;\n        pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n        if (!pKeyInfo) {\n            rc = 7;\n            goto multi_select_end;\n        }\n        for (i = 0 , apColl = pKeyInfo->aColl; i < nCol; i++ , apColl++) {\n            *apColl = multiSelectCollSeq(pParse, p, i);\n            if (0 == *apColl) {\n                *apColl = db->pDfltColl;\n            }\n        }\n        for (pLoop = p; pLoop; pLoop = pLoop->pPrior) {\n            for (i = 0; i < 2; i++) {\n                int addr = pLoop->addrOpenEphm[i];\n                if (addr < 0) {\n                    assert(pLoop->addrOpenEphm[1] < 0);\n                    break;\n                }\n                sqlite3VdbeChangeP2(v, addr, nCol);\n                sqlite3VdbeChangeP4(v, addr, (char *)sqlite3KeyInfoRef(pKeyInfo), (-8));\n                pLoop->addrOpenEphm[i] = -1;\n            }\n        }\n        sqlite3KeyInfoUnref(pKeyInfo);\n    }\n  multi_select_end:\n    pDest->iSdst = dest.iSdst;\n    pDest->nSdst = dest.nSdst;\n    if (pDelete) {\n        sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3SelectDelete, pDelete);\n    }\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#139813:1#generateWithRecursiveQuery",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    SrcList *pSrc = p->pSrc;\n    int nCol = p->pEList->nExpr;\n    Vdbe *v = pParse->pVdbe;\n    Select *pSetup;\n    Select *pFirstRec;\n    int addrTop;\n    int addrCont, addrBreak;\n    int iCurrent = 0;\n    int regCurrent;\n    int iQueue;\n    int iDistinct = 0;\n    int eDest = 8;\n    SelectDest destQueue;\n    int i;\n    int rc;\n    ExprList *pOrderBy;\n    Expr *pLimit;\n    int regLimit, regOffset;\n    if (p->pWin) {\n        sqlite3ErrorMsg(pParse, \"cannot use window functions in recursive queries\");\n        return;\n    }\n    if (sqlite3AuthCheck(pParse, 33, 0, 0, 0))\n        return;\n    addrBreak = sqlite3VdbeMakeLabel(pParse);\n    p->nSelectRow = 320;\n    computeLimitRegisters(pParse, p, addrBreak);\n    pLimit = p->pLimit;\n    regLimit = p->iLimit;\n    regOffset = p->iOffset;\n    p->pLimit = 0;\n    p->iLimit = p->iOffset = 0;\n    pOrderBy = p->pOrderBy;\n    for (i = 0; (i < pSrc->nSrc); i++) {\n        if (pSrc->a[i].fg.isRecursive) {\n            iCurrent = pSrc->a[i].iCursor;\n            break;\n        }\n    }\n    iQueue = pParse->nTab++;\n    if (p->op == 134) {\n        eDest = pOrderBy ? 6 : 5;\n        iDistinct = pParse->nTab++;\n    } else {\n        eDest = pOrderBy ? 7 : 8;\n    }\n    sqlite3SelectDestInit(&destQueue, eDest, iQueue);\n    regCurrent = ++pParse->nMem;\n    sqlite3VdbeAddOp3(v, 121, iCurrent, regCurrent, nCol);\n    if (pOrderBy) {\n        KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);\n        sqlite3VdbeAddOp4(v, 118, iQueue, pOrderBy->nExpr + 2, 0, (char *)pKeyInfo, (-8));\n        destQueue.pOrderBy = pOrderBy;\n    } else {\n        sqlite3VdbeAddOp2(v, 118, iQueue, nCol);\n    }\n    ;\n    if (iDistinct) {\n        p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, 118, iDistinct, 0);\n        p->selFlags |= 32;\n    }\n    p->pOrderBy = 0;\n    for (pFirstRec = p; (pFirstRec != 0); pFirstRec = pFirstRec->pPrior) {\n        if (pFirstRec->selFlags & 8) {\n            sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");\n            goto end_of_recursive_query;\n        }\n        pFirstRec->op = 135;\n        if ((pFirstRec->pPrior->selFlags & 8192) == 0)\n            break;\n    }\n    pSetup = pFirstRec->pPrior;\n    pSetup->pNext = 0;\n    sqlite3VdbeExplain(pParse, 1, \"SETUP\");\n    rc = sqlite3Select(pParse, pSetup, &destQueue);\n    pSetup->pNext = p;\n    if (rc)\n        goto end_of_recursive_query;\n    addrTop = sqlite3VdbeAddOp2(v, 36, iQueue, addrBreak);\n    ;\n    sqlite3VdbeAddOp1(v, 136, iCurrent);\n    if (pOrderBy) {\n        sqlite3VdbeAddOp3(v, 94, iQueue, pOrderBy->nExpr + 1, regCurrent);\n    } else {\n        sqlite3VdbeAddOp2(v, 134, iQueue, regCurrent);\n    }\n    sqlite3VdbeAddOp1(v, 130, iQueue);\n    addrCont = sqlite3VdbeMakeLabel(pParse);\n    codeOffset(v, regOffset, addrCont);\n    selectInnerLoop(pParse, p, iCurrent, 0, 0, pDest, addrCont, addrBreak);\n    if (regLimit) {\n        sqlite3VdbeAddOp2(v, 61, regLimit, addrBreak);\n        ;\n    }\n    sqlite3VdbeResolveLabel(v, addrCont);\n    pFirstRec->pPrior = 0;\n    sqlite3VdbeExplain(pParse, 1, \"RECURSIVE STEP\");\n    sqlite3Select(pParse, p, &destQueue);\n    assert(pFirstRec->pPrior == 0);\n    pFirstRec->pPrior = pSetup;\n    sqlite3VdbeGoto(v, addrTop);\n    sqlite3VdbeResolveLabel(v, addrBreak);\n  end_of_recursive_query:\n    sqlite3ExprListDelete(pParse->db, p->pOrderBy);\n    p->pOrderBy = pOrderBy;\n    p->pLimit = pLimit;\n    return;\n}\n"
        },
        {
            "id": "#23:25#sqlite3Pragma",
            "gotos": 8,
            "labels": 1,
            "body": "{\n    char *zLeft = 0;\n    char *zRight = 0;\n    const char *zDb = 0;\n    Token *pId;\n    char *aFcntl[4];\n    int iDb;\n    int rc;\n    sqlite3 *db = pParse->db;\n    Db *pDb;\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    const PragmaName *pPragma;\n    if (v == 0)\n        return;\n    sqlite3VdbeRunOnlyOnce(v);\n    pParse->nMem = 2;\n    iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);\n    if (iDb < 0)\n        return;\n    pDb = &db->aDb[iDb];\n    if (iDb == 1 && sqlite3OpenTempDatabase(pParse)) {\n        return;\n    }\n    zLeft = sqlite3NameFromToken(db, pId);\n    if (!zLeft)\n        return;\n    if (minusFlag) {\n        zRight = sqlite3MPrintf(db, \"-%T\", pValue);\n    } else {\n        zRight = sqlite3NameFromToken(db, pValue);\n    }\n    assert(pId2);\n    zDb = pId2->n > 0 ? pDb->zDbSName : 0;\n    if (sqlite3AuthCheck(pParse, 19, zLeft, zRight, zDb)) {\n        goto pragma_out;\n    }\n    aFcntl[0] = 0;\n    aFcntl[1] = zLeft;\n    aFcntl[2] = zRight;\n    aFcntl[3] = 0;\n    db->busyHandler.nBusy = 0;\n    rc = sqlite3_file_control(db, zDb, 14, (void *)aFcntl);\n    if (rc == 0) {\n        sqlite3VdbeSetNumCols(v, 1);\n        sqlite3VdbeSetColName(v, 0, 0, aFcntl[0], ((sqlite3_destructor_type)-1));\n        returnSingleText(v, aFcntl[0]);\n        sqlite3_free(aFcntl[0]);\n        goto pragma_out;\n    }\n    if (rc != 12) {\n        if (aFcntl[0]) {\n            sqlite3ErrorMsg(pParse, \"%s\", aFcntl[0]);\n            sqlite3_free(aFcntl[0]);\n        }\n        pParse->nErr++;\n        pParse->rc = rc;\n        goto pragma_out;\n    }\n    pPragma = pragmaLocate(zLeft);\n    if (pPragma == 0) {\n        goto pragma_out;\n    }\n    if ((pPragma->mPragFlg & 1) != 0) {\n        if (sqlite3ReadSchema(pParse))\n            goto pragma_out;\n    }\n    if ((pPragma->mPragFlg & 2) == 0 && ((pPragma->mPragFlg & 4) == 0 || zRight == 0)) {\n        setPragmaResultColumnNames(v, pPragma);\n    }\n    switch (pPragma->ePragTyp) {\n      case 13:\n        {\n            static const int iLn = 0;\n            static const VdbeOpList getCacheSize[] = {{2, 0, 0, 0}, {99, 0, 1, 3}, {59, 1, 8, 0}, {71, 0, 2, 0}, {107, 1, 2, 1}, {59, 1, 8, 0}, {71, 0, 1, 0}, {184, 0, 0, 0}, {84, 1, 1, 0}};\n            VdbeOp *aOp;\n            sqlite3VdbeUsesBtree(v, iDb);\n            if (!zRight) {\n                pParse->nMem += 2;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (getCacheSize) / sizeof (getCacheSize[0]))), getCacheSize, iLn);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[6].p1 = -2000;\n            } else {\n                int size = sqlite3AbsInt32(sqlite3Atoi(zRight));\n                sqlite3BeginWriteOperation(pParse, 0, iDb);\n                sqlite3VdbeAddOp3(v, 100, iDb, 3, size);\n                assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n                pDb->pSchema->cache_size = size;\n                sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n            }\n            break;\n        }\n      case 31:\n        {\n            Btree *pBt = pDb->pBt;\n            assert(pBt != 0);\n            if (!zRight) {\n                int size = (pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;\n                returnSingleInt(v, size);\n            } else {\n                db->nextPagesize = sqlite3Atoi(zRight);\n                if (7 == sqlite3BtreeSetPageSize(pBt, db->nextPagesize, 0, 0)) {\n                    sqlite3OomFault(db);\n                }\n            }\n            break;\n        }\n      case 33:\n        {\n            Btree *pBt = pDb->pBt;\n            int b = -1;\n            assert(pBt != 0);\n            if (zRight) {\n                if (sqlite3_stricmp(zRight, \"fast\") == 0) {\n                    b = 2;\n                } else {\n                    b = sqlite3GetBoolean(zRight, 0);\n                }\n            }\n            if (pId2->n == 0 && b >= 0) {\n                int ii;\n                for (ii = 0; ii < db->nDb; ii++) {\n                    sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);\n                }\n            }\n            b = sqlite3BtreeSecureDelete(pBt, b);\n            returnSingleInt(v, b);\n            break;\n        }\n      case 27:\n        {\n            int iReg;\n            i64 x = 0;\n            sqlite3CodeVerifySchema(pParse, iDb);\n            iReg = ++pParse->nMem;\n            if ((sqlite3UpperToLower[(unsigned char)(zLeft[0])]) == 'p') {\n                sqlite3VdbeAddOp2(v, 177, iDb, iReg);\n            } else {\n                if (zRight && sqlite3DecOrHexToI64(zRight, &x) == 0) {\n                    if (x < 0)\n                        x = 0;\n                    else if (x > 4294967294U)\n                        x = 4294967294U;\n                } else {\n                    x = 0;\n                }\n                sqlite3VdbeAddOp3(v, 178, iDb, iReg, (int)x);\n            }\n            sqlite3VdbeAddOp2(v, 84, iReg, 1);\n            break;\n        }\n      case 26:\n        {\n            const char *zRet = \"normal\";\n            int eMode = getLockingMode(zRight);\n            if (pId2->n == 0 && eMode == -1) {\n                eMode = db->dfltLockMode;\n            } else {\n                Pager *pPager;\n                if (pId2->n == 0) {\n                    int ii;\n                    assert(pDb == &db->aDb[0]);\n                    for (ii = 2; ii < db->nDb; ii++) {\n                        pPager = sqlite3BtreePager(db->aDb[ii].pBt);\n                        sqlite3PagerLockingMode(pPager, eMode);\n                    }\n                    db->dfltLockMode = (u8)eMode;\n                }\n                pPager = sqlite3BtreePager(pDb->pBt);\n                eMode = sqlite3PagerLockingMode(pPager, eMode);\n            }\n            assert(eMode == 0 || eMode == 1);\n            if (eMode == 1) {\n                zRet = \"exclusive\";\n            }\n            returnSingleText(v, zRet);\n            break;\n        }\n      case 23:\n        {\n            int eMode;\n            int ii;\n            if (zRight == 0) {\n                eMode = (-1);\n            } else {\n                const char *zMode;\n                int n = sqlite3Strlen30(zRight);\n                for (eMode = 0; (zMode = sqlite3JournalModename(eMode)) != 0; eMode++) {\n                    if (sqlite3_strnicmp(zRight, zMode, n) == 0)\n                        break;\n                }\n                if (!zMode) {\n                    eMode = (-1);\n                }\n                if (eMode == 2 && (db->flags & 268435456) != 0) {\n                    eMode = (-1);\n                }\n            }\n            if (eMode == (-1) && pId2->n == 0) {\n                iDb = 0;\n                pId2->n = 1;\n            }\n            for (ii = db->nDb - 1; ii >= 0; ii--) {\n                if (db->aDb[ii].pBt && (ii == iDb || pId2->n == 0)) {\n                    sqlite3VdbeUsesBtree(v, ii);\n                    sqlite3VdbeAddOp3(v, 4, ii, 1, eMode);\n                }\n            }\n            sqlite3VdbeAddOp2(v, 84, 1, 1);\n            break;\n        }\n      case 24:\n        {\n            Pager *pPager = sqlite3BtreePager(pDb->pBt);\n            i64 iLimit = -2;\n            if (zRight) {\n                sqlite3DecOrHexToI64(zRight, &iLimit);\n                if (iLimit < -1)\n                    iLimit = -1;\n            }\n            iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);\n            returnSingleInt(v, iLimit);\n            break;\n        }\n      case 3:\n        {\n            Btree *pBt = pDb->pBt;\n            assert(pBt != 0);\n            if (!zRight) {\n                returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));\n            } else {\n                int eAuto = getAutoVacuum(zRight);\n                assert(eAuto >= 0 && eAuto <= 2);\n                db->nextAutovac = (u8)eAuto;\n                rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);\n                if (rc == 0 && (eAuto == 1 || eAuto == 2)) {\n                    static const int iLn = 0;\n                    static const VdbeOpList setMeta6[] = {{2, 0, 1, 0}, {99, 0, 1, 4}, {16, 1, 0, 0}, {70, 0, 2, 0}, {100, 0, 7, 0}};\n                    VdbeOp *aOp;\n                    int iAddr = sqlite3VdbeCurrentAddr(v);\n                    ;\n                    aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (setMeta6) / sizeof (setMeta6[0]))), setMeta6, iLn);\n                    if ((0))\n                        break;\n                    aOp[0].p1 = iDb;\n                    aOp[1].p1 = iDb;\n                    aOp[2].p2 = iAddr + 4;\n                    aOp[4].p1 = iDb;\n                    aOp[4].p3 = eAuto - 1;\n                    sqlite3VdbeUsesBtree(v, iDb);\n                }\n            }\n            break;\n        }\n      case 19:\n        {\n            int iLimit = 0, addr;\n            if (zRight == 0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit <= 0) {\n                iLimit = 2147483647;\n            }\n            sqlite3BeginWriteOperation(pParse, 0, iDb);\n            sqlite3VdbeAddOp2(v, 71, iLimit, 1);\n            addr = sqlite3VdbeAddOp1(v, 62, iDb);\n            ;\n            sqlite3VdbeAddOp1(v, 84, 1);\n            sqlite3VdbeAddOp2(v, 86, 1, -1);\n            sqlite3VdbeAddOp2(v, 59, 1, addr);\n            ;\n            sqlite3VdbeJumpHere(v, addr);\n            break;\n        }\n      case 6:\n        {\n            assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n            if (!zRight) {\n                returnSingleInt(v, pDb->pSchema->cache_size);\n            } else {\n                int size = sqlite3Atoi(zRight);\n                pDb->pSchema->cache_size = size;\n                sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n            }\n            break;\n        }\n      case 7:\n        {\n            assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n            if (!zRight) {\n                returnSingleInt(v, (db->flags & 32) == 0 ? 0 : sqlite3BtreeSetSpillSize(pDb->pBt, 0));\n            } else {\n                int size = 1;\n                if (sqlite3GetInt32(zRight, &size)) {\n                    sqlite3BtreeSetSpillSize(pDb->pBt, size);\n                }\n                if (sqlite3GetBoolean(zRight, size != 0)) {\n                    db->flags |= 32;\n                } else {\n                    db->flags &= ~(u64)32;\n                }\n                setAllPagerFlags(db);\n            }\n            break;\n        }\n      case 28:\n        {\n            sqlite3_int64 sz;\n            assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n            if (zRight) {\n                int ii;\n                sqlite3DecOrHexToI64(zRight, &sz);\n                if (sz < 0)\n                    sz = sqlite3Config.szMmap;\n                if (pId2->n == 0)\n                    db->szMmap = sz;\n                for (ii = db->nDb - 1; ii >= 0; ii--) {\n                    if (db->aDb[ii].pBt && (ii == iDb || pId2->n == 0)) {\n                        sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);\n                    }\n                }\n            }\n            sz = -1;\n            rc = sqlite3_file_control(db, zDb, 18, &sz);\n            if (rc == 0) {\n                returnSingleInt(v, sz);\n            } else if (rc != 12) {\n                pParse->nErr++;\n                pParse->rc = rc;\n            }\n            break;\n        }\n      case 39:\n        {\n            if (!zRight) {\n                returnSingleInt(v, db->temp_store);\n            } else {\n                changeTempStorage(pParse, zRight);\n            }\n            break;\n        }\n      case 40:\n        {\n            sqlite3_mutex_enter(sqlite3MutexAlloc(11));\n            if (!zRight) {\n                returnSingleText(v, sqlite3_temp_directory);\n            } else {\n                if (zRight[0]) {\n                    int res;\n                    rc = sqlite3OsAccess(db->pVfs, zRight, 1, &res);\n                    if (rc != 0 || res == 0) {\n                        sqlite3ErrorMsg(pParse, \"not a writable directory\");\n                        sqlite3_mutex_leave(sqlite3MutexAlloc(11));\n                        goto pragma_out;\n                    }\n                }\n                if (1 == 0 || (1 == 1 && db->temp_store <= 1) || (1 == 2 && db->temp_store == 1)) {\n                    invalidateTempStorage(pParse);\n                }\n                sqlite3_free(sqlite3_temp_directory);\n                if (zRight[0]) {\n                    sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zRight);\n                } else {\n                    sqlite3_temp_directory = 0;\n                }\n            }\n            sqlite3_mutex_leave(sqlite3MutexAlloc(11));\n            break;\n        }\n      case 25:\n        {\n            if (!zRight) {\n                Pager *pPager = sqlite3BtreePager(pDb->pBt);\n                char *proxy_file_path;\n                sqlite3_file *pFile = sqlite3PagerFile(pPager);\n                sqlite3OsFileControlHint(pFile, 2, &proxy_file_path);\n                returnSingleText(v, proxy_file_path);\n            } else {\n                Pager *pPager = sqlite3BtreePager(pDb->pBt);\n                sqlite3_file *pFile = sqlite3PagerFile(pPager);\n                int res;\n                if (zRight[0]) {\n                    res = sqlite3OsFileControl(pFile, 3, zRight);\n                } else {\n                }\n                if (res != 0) {\n                    sqlite3ErrorMsg(pParse, \"failed to set lock proxy file\");\n                    goto pragma_out;\n                }\n            }\n            break;\n        }\n      case 36:\n        {\n            if (!zRight) {\n                returnSingleInt(v, pDb->safety_level - 1);\n            } else {\n                if (!db->autoCommit) {\n                    sqlite3ErrorMsg(pParse, \"Safety level may not be changed inside a transaction\");\n                } else if (iDb != 1) {\n                    int iLevel = (getSafetyLevel(zRight, 0, 1) + 1) & 7;\n                    if (iLevel == 0)\n                        iLevel = 1;\n                    pDb->safety_level = iLevel;\n                    pDb->bSyncSet = 1;\n                    setAllPagerFlags(db);\n                }\n            }\n            break;\n        }\n      case 4:\n        {\n            if (zRight == 0) {\n                setPragmaResultColumnNames(v, pPragma);\n                returnSingleInt(v, (db->flags & pPragma->iArg) != 0);\n            } else {\n                u64 mask = pPragma->iArg;\n                if (db->autoCommit == 0) {\n                    mask &= ~(16384);\n                }\n                if (sqlite3GetBoolean(zRight, 0)) {\n                    db->flags |= mask;\n                } else {\n                    db->flags &= ~mask;\n                    if (mask == 524288)\n                        db->nDeferredImmCons = 0;\n                    if ((mask & 1) != 0 && sqlite3_stricmp(zRight, \"reset\") == 0) {\n                        sqlite3ResetAllSchemasOfConnection(db);\n                    }\n                }\n                sqlite3VdbeAddOp0(v, 166);\n                setAllPagerFlags(db);\n            }\n            break;\n        }\n      case 37:\n        if (zRight) {\n            Table *pTab;\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n            pTab = sqlite3LocateTable(pParse, 2, zRight, zDb);\n            if (pTab) {\n                int i, k;\n                int nHidden = 0;\n                Column *pCol;\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                pParse->nMem = 7;\n                sqlite3ViewGetColumnNames(pParse, pTab);\n                for (i = 0 , pCol = pTab->aCol; i < pTab->nCol; i++ , pCol++) {\n                    int isHidden = 0;\n                    const Expr *pColExpr;\n                    if (pCol->colFlags & 98) {\n                        if (pPragma->iArg == 0) {\n                            nHidden++;\n                            continue;\n                        }\n                        if (pCol->colFlags & 32) {\n                            isHidden = 2;\n                        } else if (pCol->colFlags & 64) {\n                            isHidden = 3;\n                        } else {\n                            assert(pCol->colFlags & 2);\n                            isHidden = 1;\n                        }\n                    }\n                    if ((pCol->colFlags & 1) == 0) {\n                        k = 0;\n                    } else if (pPk == 0) {\n                        k = 1;\n                    } else {\n                        for (k = 1; k <= pTab->nCol && pPk->aiColumn[k - 1] != i; k++) {\n                        }\n                    }\n                    pColExpr = sqlite3ColumnExpr(pTab, pCol);\n                    assert(pColExpr == 0 || pColExpr->op == 181 || isHidden >= 2);\n                    assert(pColExpr == 0 || !(((pColExpr)->flags & (2048)) != 0) || isHidden >= 2);\n                    sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? \"issisii\" : \"issisi\", i - nHidden, pCol->zCnName, sqlite3ColumnType(pCol, \"\"), pCol->notNull ? 1 : 0, (isHidden >= 2 || pColExpr == 0) ? 0 : pColExpr->u.zToken, k, isHidden);\n                }\n            }\n        }\n        break;\n      case 38:\n        {\n            int ii;\n            pParse->nMem = 6;\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n            for (ii = 0; ii < db->nDb; ii++) {\n                HashElem *k;\n                Hash *pHash;\n                int initNCol;\n                if (zDb && sqlite3_stricmp(zDb, db->aDb[ii].zDbSName) != 0)\n                    continue;\n                pHash = &db->aDb[ii].pSchema->tblHash;\n                initNCol = ((pHash)->count);\n                while (initNCol--)\n                    {\n                        for (k = ((pHash)->first); 1; k = ((k)->next)) {\n                            Table *pTab;\n                            if (k == 0) {\n                                initNCol = 0;\n                                break;\n                            }\n                            pTab = ((k)->data);\n                            if (pTab->nCol == 0) {\n                                char *zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\"\", pTab->zName);\n                                if (zSql) {\n                                    sqlite3_stmt *pDummy = 0;\n                                    (void)sqlite3_prepare(db, zSql, -1, &pDummy, 0);\n                                    (void)sqlite3_finalize(pDummy);\n                                    sqlite3DbFree(db, zSql);\n                                }\n                                if (db->mallocFailed) {\n                                    sqlite3ErrorMsg(db->pParse, \"out of memory\");\n                                    db->pParse->rc = 7;\n                                }\n                                pHash = &db->aDb[ii].pSchema->tblHash;\n                                break;\n                            }\n                        }\n                    }\n                for (k = ((pHash)->first); k; k = ((k)->next)) {\n                    Table *pTab = ((k)->data);\n                    const char *zType;\n                    if (zRight && sqlite3_stricmp(zRight, pTab->zName) != 0)\n                        continue;\n                    if (((pTab)->eTabType == 2)) {\n                        zType = \"view\";\n                    } else if (((pTab)->eTabType == 1)) {\n                        zType = \"virtual\";\n                    } else if (pTab->tabFlags & 4096) {\n                        zType = \"shadow\";\n                    } else {\n                        zType = \"table\";\n                    }\n                    sqlite3VdbeMultiLoad(v, 1, \"sssiii\", db->aDb[ii].zDbSName, sqlite3PreferredTableName(pTab->zName), zType, pTab->nCol, (pTab->tabFlags & 128) != 0, (pTab->tabFlags & 65536) != 0);\n                }\n            }\n        }\n        break;\n      case 20:\n        if (zRight) {\n            Index *pIdx;\n            Table *pTab;\n            pIdx = sqlite3FindIndex(db, zRight, zDb);\n            if (pIdx == 0) {\n                pTab = sqlite3LocateTable(pParse, 2, zRight, zDb);\n                if (pTab && !(((pTab)->tabFlags & 128) == 0)) {\n                    pIdx = sqlite3PrimaryKeyIndex(pTab);\n                }\n            }\n            if (pIdx) {\n                int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);\n                int i;\n                int mx;\n                if (pPragma->iArg) {\n                    mx = pIdx->nColumn;\n                    pParse->nMem = 6;\n                } else {\n                    mx = pIdx->nKeyCol;\n                    pParse->nMem = 3;\n                }\n                pTab = pIdx->pTable;\n                sqlite3CodeVerifySchema(pParse, iIdxDb);\n                assert(pParse->nMem <= pPragma->nPragCName);\n                for (i = 0; i < mx; i++) {\n                    i16 cnum = pIdx->aiColumn[i];\n                    sqlite3VdbeMultiLoad(v, 1, \"iisX\", i, cnum, cnum < 0 ? 0 : pTab->aCol[cnum].zCnName);\n                    if (pPragma->iArg) {\n                        sqlite3VdbeMultiLoad(v, 4, \"isiX\", pIdx->aSortOrder[i], pIdx->azColl[i], i < pIdx->nKeyCol);\n                    }\n                    sqlite3VdbeAddOp2(v, 84, 1, pParse->nMem);\n                }\n            }\n        }\n        break;\n      case 21:\n        if (zRight) {\n            Index *pIdx;\n            Table *pTab;\n            int i;\n            pTab = sqlite3FindTable(db, zRight, zDb);\n            if (pTab) {\n                int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                pParse->nMem = 5;\n                sqlite3CodeVerifySchema(pParse, iTabDb);\n                for (pIdx = pTab->pIndex , i = 0; pIdx; pIdx = pIdx->pNext , i++) {\n                    const char *azOrigin[] = {\"c\", \"u\", \"pk\"};\n                    sqlite3VdbeMultiLoad(v, 1, \"isisi\", i, pIdx->zName, ((pIdx)->onError != 0), azOrigin[pIdx->idxType], pIdx->pPartIdxWhere != 0);\n                }\n            }\n        }\n        break;\n      case 12:\n        {\n            int i;\n            pParse->nMem = 3;\n            for (i = 0; i < db->nDb; i++) {\n                if (db->aDb[i].pBt == 0)\n                    continue;\n                assert(db->aDb[i].zDbSName != 0);\n                sqlite3VdbeMultiLoad(v, 1, \"iss\", i, db->aDb[i].zDbSName, sqlite3BtreeGetFilename(db->aDb[i].pBt));\n            }\n        }\n        break;\n      case 9:\n        {\n            int i = 0;\n            HashElem *p;\n            pParse->nMem = 2;\n            for (p = ((&db->aCollSeq)->first); p; p = ((p)->next)) {\n                CollSeq *pColl = (CollSeq *)((p)->data);\n                sqlite3VdbeMultiLoad(v, 1, \"is\", i++, pColl->zName);\n            }\n        }\n        break;\n      case 17:\n        {\n            int i;\n            HashElem *j;\n            FuncDef *p;\n            int showInternFunc = (db->mDbFlags & 32) != 0;\n            pParse->nMem = 6;\n            for (i = 0; i < 23; i++) {\n                for (p = sqlite3BuiltinFunctions.a[i]; p; p = p->u.pHash) {\n                    assert(p->funcFlags & 8388608);\n                    pragmaFunclistLine(v, p, 1, showInternFunc);\n                }\n            }\n            for (j = ((&db->aFunc)->first); j; j = ((j)->next)) {\n                p = (FuncDef *)((j)->data);\n                assert((p->funcFlags & 8388608) == 0);\n                pragmaFunclistLine(v, p, 0, showInternFunc);\n            }\n        }\n        break;\n      case 29:\n        {\n            HashElem *j;\n            pParse->nMem = 1;\n            for (j = ((&db->aModule)->first); j; j = ((j)->next)) {\n                Module *pMod = (Module *)((j)->data);\n                sqlite3VdbeMultiLoad(v, 1, \"s\", pMod->zName);\n            }\n        }\n        break;\n      case 32:\n        {\n            int i;\n            for (i = 0; i < ((int)(sizeof (aPragmaName) / sizeof (aPragmaName[0]))); i++) {\n                sqlite3VdbeMultiLoad(v, 1, \"s\", aPragmaName[i].zName);\n            }\n        }\n        break;\n      case 16:\n        if (zRight) {\n            FKey *pFK;\n            Table *pTab;\n            pTab = sqlite3FindTable(db, zRight, zDb);\n            if (pTab && ((pTab)->eTabType == 0)) {\n                pFK = pTab->u.tab.pFKey;\n                if (pFK) {\n                    int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                    int i = 0;\n                    pParse->nMem = 8;\n                    sqlite3CodeVerifySchema(pParse, iTabDb);\n                    while (pFK)\n                        {\n                            int j;\n                            for (j = 0; j < pFK->nCol; j++) {\n                                sqlite3VdbeMultiLoad(v, 1, \"iissssss\", i, j, pFK->zTo, pTab->aCol[pFK->aCol[j].iFrom].zCnName, pFK->aCol[j].zCol, actionName(pFK->aAction[1]), actionName(pFK->aAction[0]), \"NONE\");\n                            }\n                            ++i;\n                            pFK = pFK->pNextFrom;\n                        }\n                }\n            }\n        }\n        break;\n      case 15:\n        {\n            FKey *pFK;\n            Table *pTab;\n            Table *pParent;\n            Index *pIdx;\n            int i;\n            int j;\n            HashElem *k;\n            int x;\n            int regResult;\n            int regRow;\n            int addrTop;\n            int addrOk;\n            int *aiCols;\n            regResult = pParse->nMem + 1;\n            pParse->nMem += 4;\n            regRow = ++pParse->nMem;\n            k = ((&db->aDb[iDb].pSchema->tblHash)->first);\n            while (k)\n                {\n                    if (zRight) {\n                        pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);\n                        k = 0;\n                    } else {\n                        pTab = (Table *)((k)->data);\n                        k = ((k)->next);\n                    }\n                    if (pTab == 0 || !((pTab)->eTabType == 0) || pTab->u.tab.pFKey == 0)\n                        continue;\n                    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                    zDb = db->aDb[iDb].zDbSName;\n                    sqlite3CodeVerifySchema(pParse, iDb);\n                    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n                    if (pTab->nCol + regRow > pParse->nMem)\n                        pParse->nMem = pTab->nCol + regRow;\n                    sqlite3OpenTable(pParse, 0, iDb, pTab, 112);\n                    sqlite3VdbeLoadString(v, regResult, pTab->zName);\n                    assert(((pTab)->eTabType == 0));\n                    for (i = 1 , pFK = pTab->u.tab.pFKey; pFK; i++ , pFK = pFK->pNextFrom) {\n                        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n                        if (pParent == 0)\n                            continue;\n                        pIdx = 0;\n                        sqlite3TableLock(pParse, iDb, pParent->tnum, 0, pParent->zName);\n                        x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);\n                        if (x == 0) {\n                            if (pIdx == 0) {\n                                sqlite3OpenTable(pParse, i, iDb, pParent, 112);\n                            } else {\n                                sqlite3VdbeAddOp3(v, 112, i, pIdx->tnum, iDb);\n                                sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n                            }\n                        } else {\n                            k = 0;\n                            break;\n                        }\n                    }\n                    assert(pParse->nErr > 0 || pFK == 0);\n                    if (pFK)\n                        break;\n                    if (pParse->nTab < i)\n                        pParse->nTab = i;\n                    addrTop = sqlite3VdbeAddOp1(v, 36, 0);\n                    ;\n                    assert(((pTab)->eTabType == 0));\n                    for (i = 1 , pFK = pTab->u.tab.pFKey; pFK; i++ , pFK = pFK->pNextFrom) {\n                        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n                        pIdx = 0;\n                        aiCols = 0;\n                        if (pParent) {\n                            x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);\n                            assert(x == 0 || db->mallocFailed);\n                        }\n                        addrOk = sqlite3VdbeMakeLabel(pParse);\n                        if (regRow + pFK->nCol > pParse->nMem)\n                            pParse->nMem = regRow + pFK->nCol;\n                        for (j = 0; j < pFK->nCol; j++) {\n                            int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow + j);\n                            sqlite3VdbeAddOp2(v, 50, regRow + j, addrOk);\n                            ;\n                        }\n                        if (pIdx) {\n                            sqlite3VdbeAddOp4(v, 96, regRow, pFK->nCol, 0, sqlite3IndexAffinityStr(db, pIdx), pFK->nCol);\n                            sqlite3VdbeAddOp4Int(v, 29, i, addrOk, regRow, pFK->nCol);\n                            ;\n                        } else if (pParent) {\n                            int jmp = sqlite3VdbeCurrentAddr(v) + 2;\n                            sqlite3VdbeAddOp3(v, 30, i, jmp, regRow);\n                            ;\n                            sqlite3VdbeGoto(v, addrOk);\n                            assert(pFK->nCol == 1 || db->mallocFailed);\n                        }\n                        if ((((pTab)->tabFlags & 128) == 0)) {\n                            sqlite3VdbeAddOp2(v, 135, 0, regResult + 1);\n                        } else {\n                            sqlite3VdbeAddOp2(v, 75, 0, regResult + 1);\n                        }\n                        sqlite3VdbeMultiLoad(v, regResult + 2, \"siX\", pFK->zTo, i - 1);\n                        sqlite3VdbeAddOp2(v, 84, regResult, 4);\n                        sqlite3VdbeResolveLabel(v, addrOk);\n                        sqlite3DbFree(db, aiCols);\n                    }\n                    sqlite3VdbeAddOp2(v, 39, 0, addrTop + 1);\n                    ;\n                    sqlite3VdbeJumpHere(v, addrTop);\n                }\n        }\n        break;\n      case 8:\n        {\n            if (zRight) {\n                sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));\n            }\n        }\n        break;\n      case 22:\n        {\n            int i, j, addr, mxErr;\n            Table *pObjTab = 0;\n            int isQuick = ((sqlite3UpperToLower[(unsigned char)(zLeft[0])]) == 'q');\n            assert(iDb >= 0);\n            assert(iDb == 0 || pId2->z);\n            if (pId2->z == 0)\n                iDb = -1;\n            pParse->nMem = 6;\n            mxErr = 100;\n            if (zRight) {\n                if (sqlite3GetInt32(zRight, &mxErr)) {\n                    if (mxErr <= 0) {\n                        mxErr = 100;\n                    }\n                } else {\n                    pObjTab = sqlite3LocateTable(pParse, 0, zRight, iDb >= 0 ? db->aDb[iDb].zDbSName : 0);\n                }\n            }\n            sqlite3VdbeAddOp2(v, 71, mxErr - 1, 1);\n            for (i = 0; i < db->nDb; i++) {\n                HashElem *x;\n                Hash *pTbls;\n                int *aRoot;\n                int cnt = 0;\n                int mxIdx = 0;\n                if (0 && i == 1)\n                    continue;\n                if (iDb >= 0 && i != iDb)\n                    continue;\n                sqlite3CodeVerifySchema(pParse, i);\n                assert(sqlite3SchemaMutexHeld(db, i, 0));\n                pTbls = &db->aDb[i].pSchema->tblHash;\n                for (cnt = 0 , x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx;\n                    int nIdx;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if ((((pTab)->tabFlags & 128) == 0))\n                        cnt++;\n                    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n                        cnt++;\n                    }\n                    if (nIdx > mxIdx)\n                        mxIdx = nIdx;\n                }\n                if (cnt == 0)\n                    continue;\n                if (pObjTab)\n                    cnt++;\n                aRoot = sqlite3DbMallocRawNN(db, sizeof(int) * (cnt + 1));\n                if (aRoot == 0)\n                    break;\n                cnt = 0;\n                if (pObjTab)\n                    aRoot[++cnt] = 0;\n                for (x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if ((((pTab)->tabFlags & 128) == 0))\n                        aRoot[++cnt] = pTab->tnum;\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        aRoot[++cnt] = pIdx->tnum;\n                    }\n                }\n                aRoot[0] = cnt;\n                pParse->nMem = ((pParse->nMem) > (8 + mxIdx) ? (pParse->nMem) : (8 + mxIdx));\n                sqlite3ClearTempRegCache(pParse);\n                sqlite3VdbeAddOp4(v, 155, 2, cnt, 1, (char *)aRoot, (-14));\n                sqlite3VdbeChangeP5(v, (u8)i);\n                addr = sqlite3VdbeAddOp1(v, 50, 2);\n                ;\n                sqlite3VdbeAddOp4(v, 117, 0, 3, 0, sqlite3MPrintf(db, \"*** in database %s ***\\n\", db->aDb[i].zDbSName), (-6));\n                sqlite3VdbeAddOp3(v, 111, 2, 3, 3);\n                integrityCheckResultRow(v);\n                sqlite3VdbeJumpHere(v, addr);\n                for (x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx, *pPk;\n                    Index *pPrior = 0;\n                    int loopTop;\n                    int iDataCur, iIdxCur;\n                    int r1 = -1;\n                    int bStrict;\n                    int r2;\n                    int mxCol;\n                    if (!((pTab)->eTabType == 0))\n                        continue;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if (isQuick || (((pTab)->tabFlags & 128) == 0)) {\n                        pPk = 0;\n                        r2 = 0;\n                    } else {\n                        pPk = sqlite3PrimaryKeyIndex(pTab);\n                        r2 = sqlite3GetTempRange(pParse, pPk->nKeyCol);\n                        sqlite3VdbeAddOp3(v, 75, 1, r2, r2 + pPk->nKeyCol - 1);\n                    }\n                    sqlite3OpenTableAndIndices(pParse, pTab, 112, 0, 1, 0, &iDataCur, &iIdxCur);\n                    sqlite3VdbeAddOp2(v, 71, 0, 7);\n                    for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                        sqlite3VdbeAddOp2(v, 71, 0, 8 + j);\n                    }\n                    assert(pParse->nMem >= 8 + j);\n                    assert(sqlite3NoTempsInRange(pParse, 1, 7 + j));\n                    sqlite3VdbeAddOp2(v, 36, iDataCur, 0);\n                    ;\n                    loopTop = sqlite3VdbeAddOp2(v, 86, 7, 1);\n                    mxCol = pTab->nCol - 1;\n                    while (mxCol >= 0 && ((pTab->aCol[mxCol].colFlags & 32) != 0 || pTab->iPKey == mxCol))\n                        mxCol--;\n                    if (mxCol >= 0) {\n                        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, mxCol, 3);\n                        sqlite3VdbeTypeofColumn(v, 3);\n                    }\n                    if (!isQuick) {\n                        if (pPk) {\n                            int a1;\n                            char *zErr;\n                            a1 = sqlite3VdbeAddOp4Int(v, 41, iDataCur, 0, r2, pPk->nKeyCol);\n                            ;\n                            sqlite3VdbeAddOp1(v, 50, r2);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"row not in PRIMARY KEY order for %s\", pTab->zName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, a1);\n                            sqlite3VdbeJumpHere(v, a1 + 1);\n                            for (j = 0; j < pPk->nKeyCol; j++) {\n                                sqlite3ExprCodeLoadIndexColumn(pParse, pPk, iDataCur, j, r2 + j);\n                            }\n                        }\n                    }\n                    bStrict = (pTab->tabFlags & 65536) != 0;\n                    for (j = 0; j < pTab->nCol; j++) {\n                        char *zErr;\n                        Column *pCol = pTab->aCol + j;\n                        int labelError;\n                        int labelOk;\n                        int p1, p3, p4;\n                        int doTypeCheck;\n                        if (j == pTab->iPKey)\n                            continue;\n                        if (bStrict) {\n                            doTypeCheck = pCol->eCType > 1;\n                        } else {\n                            doTypeCheck = pCol->affinity > 65;\n                        }\n                        if (pCol->notNull == 0 && !doTypeCheck)\n                            continue;\n                        p4 = 5;\n                        if (pCol->colFlags & 32) {\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n                            p1 = -1;\n                            p3 = 3;\n                        } else {\n                            if (pCol->iDflt) {\n                                sqlite3_value *pDfltValue = 0;\n                                sqlite3ValueFromExpr(db, sqlite3ColumnExpr(pTab, pCol), ((db)->enc), pCol->affinity, &pDfltValue);\n                                if (pDfltValue) {\n                                    p4 = sqlite3_value_type(pDfltValue);\n                                    sqlite3ValueFree(pDfltValue);\n                                }\n                            }\n                            p1 = iDataCur;\n                            if (!(((pTab)->tabFlags & 128) == 0)) {\n                                ;\n                                p3 = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), j);\n                            } else {\n                                p3 = sqlite3TableColumnToStorage(pTab, j);\n                                ;\n                            }\n                        }\n                        labelError = sqlite3VdbeMakeLabel(pParse);\n                        labelOk = sqlite3VdbeMakeLabel(pParse);\n                        if (pCol->notNull) {\n                            int jmp2 = sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 15);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName, pCol->zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            if (doTypeCheck) {\n                                sqlite3VdbeGoto(v, labelError);\n                                sqlite3VdbeJumpHere(v, jmp2);\n                            } else {\n                            }\n                        }\n                        if (bStrict && doTypeCheck) {\n                            static unsigned char aStdTypeMask[] = {31, 24, 17, 17, 19, 20};\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            assert(pCol->eCType >= 1 && pCol->eCType <= sizeof (aStdTypeMask));\n                            sqlite3VdbeChangeP5(v, aStdTypeMask[pCol->eCType - 1]);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"non-%s value in %s.%s\", sqlite3StdType[pCol->eCType - 1], pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        } else if (!bStrict && pCol->affinity == 66) {\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 28);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"NUMERIC value in %s.%s\", pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        } else if (!bStrict && pCol->affinity >= 67) {\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 27);\n                            ;\n                            if (p1 >= 0) {\n                                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n                            }\n                            sqlite3VdbeAddOp4(v, 96, 3, 1, 0, \"C\", (-1));\n                            sqlite3VdbeAddOp4Int(v, 18, -1, labelOk, 3, p4);\n                            sqlite3VdbeChangeP5(v, 28);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"TEXT value in %s.%s\", pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        }\n                        sqlite3VdbeResolveLabel(v, labelError);\n                        integrityCheckResultRow(v);\n                        sqlite3VdbeResolveLabel(v, labelOk);\n                    }\n                    if (pTab->pCheck && (db->flags & 512) == 0) {\n                        ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);\n                        if (db->mallocFailed == 0) {\n                            int addrCkFault = sqlite3VdbeMakeLabel(pParse);\n                            int addrCkOk = sqlite3VdbeMakeLabel(pParse);\n                            char *zErr;\n                            int k;\n                            pParse->iSelfTab = iDataCur + 1;\n                            for (k = pCheck->nExpr - 1; k > 0; k--) {\n                                sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);\n                            }\n                            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, 16);\n                            sqlite3VdbeResolveLabel(v, addrCkFault);\n                            pParse->iSelfTab = 0;\n                            zErr = sqlite3MPrintf(db, \"CHECK constraint failed in %s\", pTab->zName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeResolveLabel(v, addrCkOk);\n                        }\n                        sqlite3ExprListDelete(db, pCheck);\n                    }\n                    if (!isQuick) {\n                        for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                            int jmp2, jmp3, jmp4, jmp5;\n                            int ckUniq = sqlite3VdbeMakeLabel(pParse);\n                            if (pPk == pIdx)\n                                continue;\n                            r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3, pPrior, r1);\n                            pPrior = pIdx;\n                            sqlite3VdbeAddOp2(v, 86, 8 + j, 1);\n                            jmp2 = sqlite3VdbeAddOp4Int(v, 29, iIdxCur + j, ckUniq, r1, pIdx->nColumn);\n                            ;\n                            sqlite3VdbeLoadString(v, 3, \"row \");\n                            sqlite3VdbeAddOp3(v, 111, 7, 3, 3);\n                            sqlite3VdbeLoadString(v, 4, \" missing from index \");\n                            sqlite3VdbeAddOp3(v, 111, 4, 3, 3);\n                            jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);\n                            sqlite3VdbeAddOp3(v, 111, 4, 3, 3);\n                            jmp4 = integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, jmp2);\n                            if (((pIdx)->onError != 0)) {\n                                int uniqOk = sqlite3VdbeMakeLabel(pParse);\n                                int jmp6;\n                                int kk;\n                                for (kk = 0; kk < pIdx->nKeyCol; kk++) {\n                                    int iCol = pIdx->aiColumn[kk];\n                                    assert(iCol != (-1) && iCol < pTab->nCol);\n                                    if (iCol >= 0 && pTab->aCol[iCol].notNull)\n                                        continue;\n                                    sqlite3VdbeAddOp2(v, 50, r1 + kk, uniqOk);\n                                    ;\n                                }\n                                jmp6 = sqlite3VdbeAddOp1(v, 39, iIdxCur + j);\n                                ;\n                                sqlite3VdbeGoto(v, uniqOk);\n                                sqlite3VdbeJumpHere(v, jmp6);\n                                sqlite3VdbeAddOp4Int(v, 41, iIdxCur + j, uniqOk, r1, pIdx->nKeyCol);\n                                ;\n                                sqlite3VdbeLoadString(v, 3, \"non-unique entry in index \");\n                                sqlite3VdbeGoto(v, jmp5);\n                                sqlite3VdbeResolveLabel(v, uniqOk);\n                            }\n                            sqlite3VdbeJumpHere(v, jmp4);\n                            sqlite3ResolvePartIdxLabel(pParse, jmp3);\n                        }\n                    }\n                    sqlite3VdbeAddOp2(v, 39, iDataCur, loopTop);\n                    ;\n                    sqlite3VdbeJumpHere(v, loopTop - 1);\n                    if (!isQuick) {\n                        sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");\n                        for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                            if (pPk == pIdx)\n                                continue;\n                            sqlite3VdbeAddOp2(v, 98, iIdxCur + j, 3);\n                            addr = sqlite3VdbeAddOp3(v, 53, 8 + j, 0, 3);\n                            ;\n                            sqlite3VdbeChangeP5(v, 144);\n                            sqlite3VdbeLoadString(v, 4, pIdx->zName);\n                            sqlite3VdbeAddOp3(v, 111, 4, 2, 3);\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, addr);\n                        }\n                        if (pPk) {\n                            sqlite3ReleaseTempRange(pParse, r2, pPk->nKeyCol);\n                        }\n                    }\n                }\n            }\n            {\n                static const int iLn = 0;\n                static const VdbeOpList endCode[] = {{86, 1, 0, 0}, {60, 1, 4, 0}, {117, 0, 3, 0}, {84, 3, 1, 0}, {70, 0, 0, 0}, {117, 0, 3, 0}, {9, 0, 3, 0}};\n                VdbeOp *aOp;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (endCode) / sizeof (endCode[0]))), endCode, iLn);\n                if (aOp) {\n                    aOp[0].p2 = 1 - mxErr;\n                    aOp[2].p4type = (-1);\n                    aOp[2].p4.z = \"ok\";\n                    aOp[5].p4type = (-1);\n                    aOp[5].p4.z = (char *)sqlite3ErrStr(11);\n                }\n                sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v) - 2);\n            }\n        }\n        break;\n      case 14:\n        {\n            static const struct EncName {\n                char *zName;\n                u8 enc;\n            } encnames[] = {{\"UTF8\", 1}, {\"UTF-8\", 1}, {\"UTF-16le\", 2}, {\"UTF-16be\", 3}, {\"UTF16le\", 2}, {\"UTF16be\", 3}, {\"UTF-16\", 0}, {\"UTF16\", 0}, {0, 0}};\n            const struct EncName *pEnc;\n            if (!zRight) {\n                if (sqlite3ReadSchema(pParse))\n                    goto pragma_out;\n                assert(encnames[1].enc == 1);\n                assert(encnames[2].enc == 2);\n                assert(encnames[3].enc == 3);\n                returnSingleText(v, encnames[((pParse->db)->enc)].zName);\n            } else {\n                if ((db->mDbFlags & 64) == 0) {\n                    for (pEnc = &encnames[0]; pEnc->zName; pEnc++) {\n                        if (0 == sqlite3StrICmp(zRight, pEnc->zName)) {\n                            u8 enc = pEnc->enc ? pEnc->enc : 2;\n                            ((db)->aDb[0].pSchema->enc) = enc;\n                            sqlite3SetTextEncoding(db, enc);\n                            break;\n                        }\n                    }\n                    if (!pEnc->zName) {\n                        sqlite3ErrorMsg(pParse, \"unsupported encoding: %s\", zRight);\n                    }\n                }\n            }\n        }\n        break;\n      case 2:\n        {\n            int iCookie = pPragma->iArg;\n            sqlite3VdbeUsesBtree(v, iDb);\n            if (zRight && (pPragma->mPragFlg & 8) == 0) {\n                static const VdbeOpList setCookie[] = {{2, 0, 1, 0}, {100, 0, 0, 0}};\n                VdbeOp *aOp;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (setCookie) / sizeof (setCookie[0]))), setCookie, 0);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[1].p2 = iCookie;\n                aOp[1].p3 = sqlite3Atoi(zRight);\n                aOp[1].p5 = 1;\n            } else {\n                static const VdbeOpList readCookie[] = {{2, 0, 0, 0}, {99, 0, 1, 0}, {84, 1, 1, 0}};\n                VdbeOp *aOp;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (readCookie) / sizeof (readCookie[0]))), readCookie, 0);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[1].p3 = iCookie;\n                sqlite3VdbeReusable(v);\n            }\n        }\n        break;\n      case 10:\n        {\n            int i = 0;\n            const char *zOpt;\n            pParse->nMem = 1;\n            while ((zOpt = sqlite3_compileoption_get(i++)) != 0)\n                {\n                    sqlite3VdbeLoadString(v, 1, zOpt);\n                    sqlite3VdbeAddOp2(v, 84, 1, 1);\n                }\n            sqlite3VdbeReusable(v);\n        }\n        break;\n      case 43:\n        {\n            int iBt = (pId2->z ? iDb : (10 + 2));\n            int eMode = 0;\n            if (zRight) {\n                if (sqlite3StrICmp(zRight, \"full\") == 0) {\n                    eMode = 1;\n                } else if (sqlite3StrICmp(zRight, \"restart\") == 0) {\n                    eMode = 2;\n                } else if (sqlite3StrICmp(zRight, \"truncate\") == 0) {\n                    eMode = 3;\n                }\n            }\n            pParse->nMem = 3;\n            sqlite3VdbeAddOp3(v, 3, iBt, eMode, 1);\n            sqlite3VdbeAddOp2(v, 84, 1, 3);\n        }\n        break;\n      case 42:\n        {\n            if (zRight) {\n                sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));\n            }\n            returnSingleInt(v, db->xWalCallback == sqlite3WalDefaultHook ? ((int)(long)(db->pWalArg)) : 0);\n        }\n        break;\n      case 34:\n        {\n            sqlite3_db_release_memory(db);\n            break;\n        }\n      case 30:\n        {\n            int iDbLast;\n            int iTabCur;\n            HashElem *k;\n            Schema *pSchema;\n            Table *pTab;\n            Index *pIdx;\n            LogEst szThreshold;\n            char *zSubSql;\n            u32 opMask;\n            if (zRight) {\n                opMask = (u32)sqlite3Atoi(zRight);\n                if ((opMask & 2) == 0)\n                    break;\n            } else {\n                opMask = 65534;\n            }\n            iTabCur = pParse->nTab++;\n            for (iDbLast = zDb ? iDb : db->nDb - 1; iDb <= iDbLast; iDb++) {\n                if (iDb == 1)\n                    continue;\n                sqlite3CodeVerifySchema(pParse, iDb);\n                pSchema = db->aDb[iDb].pSchema;\n                for (k = ((&pSchema->tblHash)->first); k; k = ((k)->next)) {\n                    pTab = (Table *)((k)->data);\n                    if ((pTab->tabFlags & 256) == 0)\n                        continue;\n                    szThreshold = pTab->nRowLogEst + 46;\n                    assert(sqlite3LogEst(25) == 46);\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        if (!pIdx->hasStat1) {\n                            szThreshold = 0;\n                            break;\n                        }\n                    }\n                    if (szThreshold) {\n                        sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 112);\n                        sqlite3VdbeAddOp3(v, 33, iTabCur, sqlite3VdbeCurrentAddr(v) + 2 + (opMask & 1), szThreshold);\n                        ;\n                    }\n                    zSubSql = sqlite3MPrintf(db, \"ANALYZE \\\"%w\\\".\\\"%w\\\"\", db->aDb[iDb].zDbSName, pTab->zName);\n                    if (opMask & 1) {\n                        int r1 = sqlite3GetTempReg(pParse);\n                        sqlite3VdbeAddOp4(v, 117, 0, r1, 0, zSubSql, (-6));\n                        sqlite3VdbeAddOp2(v, 84, r1, 1);\n                    } else {\n                        sqlite3VdbeAddOp4(v, 148, 0, 0, 0, zSubSql, (-6));\n                    }\n                }\n            }\n            sqlite3VdbeAddOp0(v, 166);\n            break;\n        }\n      default:\n        {\n            assert(pPragma->ePragTyp == 5);\n            if (zRight) {\n                sqlite3_busy_timeout(db, sqlite3Atoi(zRight));\n            }\n            returnSingleInt(v, db->busyTimeout);\n            break;\n        }\n      case 35:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0) {\n                sqlite3_soft_heap_limit64(N);\n            }\n            returnSingleInt(v, sqlite3_soft_heap_limit64(-1));\n            break;\n        }\n      case 18:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0) {\n                sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);\n                if (N > 0 && (iPrior == 0 || iPrior > N))\n                    sqlite3_hard_heap_limit64(N);\n            }\n            returnSingleInt(v, sqlite3_hard_heap_limit64(-1));\n            break;\n        }\n      case 41:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0 && N >= 0) {\n                sqlite3_limit(db, 11, (int)(N & 2147483647));\n            }\n            returnSingleInt(v, sqlite3_limit(db, 11, -1));\n            break;\n        }\n      case 1:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0 && N >= 0) {\n                db->nAnalysisLimit = (int)(N & 2147483647);\n            }\n            returnSingleInt(v, db->nAnalysisLimit);\n            break;\n        }\n    }\n    if ((pPragma->mPragFlg & 4) && zRight) {\n        ;\n    }\n  pragma_out:\n    sqlite3DbFree(db, zLeft);\n    sqlite3DbFree(db, zRight);\n}\n"
        },
        {
            "id": "#23:25#sqlite3Insert",
            "gotos": 18,
            "labels": 2,
            "body": "{\n    sqlite3 *db;\n    Table *pTab;\n    int i, j;\n    Vdbe *v;\n    Index *pIdx;\n    int nColumn;\n    int nHidden = 0;\n    int iDataCur = 0;\n    int iIdxCur = 0;\n    int ipkColumn = -1;\n    int endOfLoop;\n    int srcTab = 0;\n    int addrInsTop = 0;\n    int addrCont = 0;\n    SelectDest dest;\n    int iDb;\n    u8 useTempTable = 0;\n    u8 appendFlag = 0;\n    u8 withoutRowid;\n    u8 bIdListInOrder;\n    ExprList *pList = 0;\n    int iRegStore;\n    int regFromSelect = 0;\n    int regAutoinc = 0;\n    int regRowCount = 0;\n    int regIns;\n    int regRowid;\n    int regData;\n    int *aRegIdx = 0;\n    int isView;\n    Trigger *pTrigger;\n    int tmask;\n    db = pParse->db;\n    assert(db->pParse == pParse);\n    if (pParse->nErr) {\n        goto insert_cleanup;\n    }\n    assert(db->mallocFailed == 0);\n    dest.iSDParm = 0;\n    if (pSelect && (pSelect->selFlags & 512) != 0 && pSelect->pPrior == 0) {\n        pList = pSelect->pEList;\n        pSelect->pEList = 0;\n        sqlite3SelectDelete(db, pSelect);\n        pSelect = 0;\n    }\n    assert(pTabList->nSrc == 1);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0) {\n        goto insert_cleanup;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iDb < db->nDb);\n    if (sqlite3AuthCheck(pParse, 18, pTab->zName, 0, db->aDb[iDb].zDbSName)) {\n        goto insert_cleanup;\n    }\n    withoutRowid = !(((pTab)->tabFlags & 128) == 0);\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 127, 0, &tmask);\n    isView = ((pTab)->eTabType == 2);\n    assert((pTrigger && tmask) || (pTrigger == 0 && tmask == 0));\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto insert_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, tmask)) {\n        goto insert_cleanup;\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0)\n        goto insert_cleanup;\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);\n    if (pColumn == 0 && pSelect != 0 && pTrigger == 0 && xferOptimization(pParse, pTab, pSelect, onError, iDb)) {\n        assert(!pTrigger);\n        assert(pList == 0);\n        goto insert_end;\n    }\n    regAutoinc = autoIncBegin(pParse, iDb, pTab);\n    regRowid = regIns = pParse->nMem + 1;\n    pParse->nMem += pTab->nCol + 1;\n    if (((pTab)->eTabType == 1)) {\n        regRowid++;\n        pParse->nMem++;\n    }\n    regData = regRowid + 1;\n    bIdListInOrder = (pTab->tabFlags & (1024 | 64)) == 0;\n    if (pColumn) {\n        assert(pColumn->eU4 != 2);\n        pColumn->eU4 = 1;\n        for (i = 0; i < pColumn->nId; i++) {\n            pColumn->a[i].u4.idx = -1;\n        }\n        for (i = 0; i < pColumn->nId; i++) {\n            for (j = 0; j < pTab->nCol; j++) {\n                if (sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zCnName) == 0) {\n                    pColumn->a[i].u4.idx = j;\n                    if (i != j)\n                        bIdListInOrder = 0;\n                    if (j == pTab->iPKey) {\n                        ipkColumn = i;\n                        assert(!withoutRowid);\n                    }\n                    if (pTab->aCol[j].colFlags & (64 | 32)) {\n                        sqlite3ErrorMsg(pParse, \"cannot INSERT into generated column \\\"%s\\\"\", pTab->aCol[j].zCnName);\n                        goto insert_cleanup;\n                    }\n                    break;\n                }\n            }\n            if (j >= pTab->nCol) {\n                if (sqlite3IsRowid(pColumn->a[i].zName) && !withoutRowid) {\n                    ipkColumn = i;\n                    bIdListInOrder = 0;\n                } else {\n                    sqlite3ErrorMsg(pParse, \"table %S has no column named %s\", pTabList->a, pColumn->a[i].zName);\n                    pParse->checkSchema = 1;\n                    goto insert_cleanup;\n                }\n            }\n        }\n    }\n    if (pSelect) {\n        int regYield;\n        int addrTop;\n        int rc;\n        regYield = ++pParse->nMem;\n        addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, addrTop);\n        sqlite3SelectDestInit(&dest, 13, regYield);\n        dest.iSdst = bIdListInOrder ? regData : 0;\n        dest.nSdst = pTab->nCol;\n        rc = sqlite3Select(pParse, pSelect, &dest);\n        regFromSelect = dest.iSdst;\n        assert(db->pParse == pParse);\n        if (rc || pParse->nErr)\n            goto insert_cleanup;\n        assert(db->mallocFailed == 0);\n        sqlite3VdbeEndCoroutine(v, regYield);\n        sqlite3VdbeJumpHere(v, addrTop - 1);\n        assert(pSelect->pEList);\n        nColumn = pSelect->pEList->nExpr;\n        if (pTrigger || readsTable(pParse, iDb, pTab)) {\n            useTempTable = 1;\n        }\n        if (useTempTable) {\n            int regRec;\n            int regTempRowid;\n            int addrL;\n            srcTab = pParse->nTab++;\n            regRec = sqlite3GetTempReg(pParse);\n            regTempRowid = sqlite3GetTempReg(pParse);\n            sqlite3VdbeAddOp2(v, 118, srcTab, nColumn);\n            addrL = sqlite3VdbeAddOp1(v, 12, dest.iSDParm);\n            ;\n            sqlite3VdbeAddOp3(v, 97, regFromSelect, nColumn, regRec);\n            sqlite3VdbeAddOp2(v, 127, srcTab, regTempRowid);\n            sqlite3VdbeAddOp3(v, 128, srcTab, regRec, regTempRowid);\n            sqlite3VdbeGoto(v, addrL);\n            sqlite3VdbeJumpHere(v, addrL);\n            sqlite3ReleaseTempReg(pParse, regRec);\n            sqlite3ReleaseTempReg(pParse, regTempRowid);\n        }\n    } else {\n        NameContext sNC;\n        memset(&sNC, 0, sizeof (sNC));\n        sNC.pParse = pParse;\n        srcTab = -1;\n        assert(useTempTable == 0);\n        if (pList) {\n            nColumn = pList->nExpr;\n            if (sqlite3ResolveExprListNames(&sNC, pList)) {\n                goto insert_cleanup;\n            }\n        } else {\n            nColumn = 0;\n        }\n    }\n    if (pColumn == 0 && nColumn > 0) {\n        ipkColumn = pTab->iPKey;\n        if (ipkColumn >= 0 && (pTab->tabFlags & 96) != 0) {\n            ;\n            ;\n            for (i = ipkColumn - 1; i >= 0; i--) {\n                if (pTab->aCol[i].colFlags & 96) {\n                    ;\n                    ;\n                    ipkColumn--;\n                }\n            }\n        }\n        assert(2 == 2);\n        assert(96 == 96);\n        assert(98 == (96 | 2));\n        if ((pTab->tabFlags & (96 | 2)) != 0) {\n            for (i = 0; i < pTab->nCol; i++) {\n                if (pTab->aCol[i].colFlags & 98)\n                    nHidden++;\n            }\n        }\n        if (nColumn != (pTab->nCol - nHidden)) {\n            sqlite3ErrorMsg(pParse, \"table %S has %d columns but %d values were supplied\", pTabList->a, pTab->nCol - nHidden, nColumn);\n            goto insert_cleanup;\n        }\n    }\n    if (pColumn != 0 && nColumn != pColumn->nId) {\n        sqlite3ErrorMsg(pParse, \"%d values for %d columns\", nColumn, pColumn->nId);\n        goto insert_cleanup;\n    }\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning) {\n        regRowCount = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, regRowCount);\n    }\n    if (!isView) {\n        int nIdx;\n        nIdx = sqlite3OpenTableAndIndices(pParse, pTab, 113, 0, -1, 0, &iDataCur, &iIdxCur);\n        aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int) * (nIdx + 2));\n        if (aRegIdx == 0) {\n            goto insert_cleanup;\n        }\n        for (i = 0 , pIdx = pTab->pIndex; i < nIdx; pIdx = pIdx->pNext , i++) {\n            assert(pIdx);\n            aRegIdx[i] = ++pParse->nMem;\n            pParse->nMem += pIdx->nColumn;\n        }\n        aRegIdx[i] = ++pParse->nMem;\n    }\n    if (pUpsert) {\n        Upsert *pNx;\n        if (((pTab)->eTabType == 1)) {\n            sqlite3ErrorMsg(pParse, \"UPSERT not implemented for virtual table \\\"%s\\\"\", pTab->zName);\n            goto insert_cleanup;\n        }\n        if (((pTab)->eTabType == 2)) {\n            sqlite3ErrorMsg(pParse, \"cannot UPSERT a view\");\n            goto insert_cleanup;\n        }\n        if (sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget)) {\n            goto insert_cleanup;\n        }\n        pTabList->a[0].iCursor = iDataCur;\n        pNx = pUpsert;\n        do {\n            pNx->pUpsertSrc = pTabList;\n            pNx->regData = regData;\n            pNx->iDataCur = iDataCur;\n            pNx->iIdxCur = iIdxCur;\n            if (pNx->pUpsertTarget) {\n                if (sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx)) {\n                    goto insert_cleanup;\n                }\n            }\n            pNx = pNx->pNextUpsert;\n        } while (pNx != 0);\n    }\n    if (useTempTable) {\n        addrInsTop = sqlite3VdbeAddOp1(v, 36, srcTab);\n        ;\n        addrCont = sqlite3VdbeCurrentAddr(v);\n    } else if (pSelect) {\n        ;\n        addrInsTop = addrCont = sqlite3VdbeAddOp1(v, 12, dest.iSDParm);\n        ;\n        if (ipkColumn >= 0) {\n            sqlite3VdbeAddOp2(v, 80, regFromSelect + ipkColumn, regRowid);\n        }\n    }\n    nHidden = 0;\n    iRegStore = regData;\n    assert(regData == regRowid + 1);\n    for (i = 0; i < pTab->nCol; i++ , iRegStore++) {\n        int k;\n        u32 colFlags;\n        assert(i >= nHidden);\n        if (i == pTab->iPKey) {\n            sqlite3VdbeAddOp1(v, 76, iRegStore);\n            continue;\n        }\n        if (((colFlags = pTab->aCol[i].colFlags) & 98) != 0) {\n            nHidden++;\n            if ((colFlags & 32) != 0) {\n                iRegStore--;\n                continue;\n            } else if ((colFlags & 64) != 0) {\n                if (tmask & 1) {\n                    sqlite3VdbeAddOp1(v, 76, iRegStore);\n                }\n                continue;\n            } else if (pColumn == 0) {\n                sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n                continue;\n            }\n        }\n        if (pColumn) {\n            assert(pColumn->eU4 == 1);\n            for (j = 0; j < pColumn->nId && pColumn->a[j].u4.idx != i; j++) {\n            }\n            if (j >= pColumn->nId) {\n                sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n                continue;\n            }\n            k = j;\n        } else if (nColumn == 0) {\n            sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n            continue;\n        } else {\n            k = i - nHidden;\n        }\n        if (useTempTable) {\n            sqlite3VdbeAddOp3(v, 94, srcTab, k, iRegStore);\n        } else if (pSelect) {\n            if (regFromSelect != regData) {\n                sqlite3VdbeAddOp2(v, 81, regFromSelect + k, iRegStore);\n            }\n        } else {\n            Expr *pX = pList->a[k].pExpr;\n            int y = sqlite3ExprCodeTarget(pParse, pX, iRegStore);\n            if (y != iRegStore) {\n                sqlite3VdbeAddOp2(v, (((pX)->flags & (4194304)) != 0) ? 80 : 81, y, iRegStore);\n            }\n        }\n    }\n    endOfLoop = sqlite3VdbeMakeLabel(pParse);\n    if (tmask & 1) {\n        int regCols = sqlite3GetTempRange(pParse, pTab->nCol + 1);\n        if (ipkColumn < 0) {\n            sqlite3VdbeAddOp2(v, 71, -1, regCols);\n        } else {\n            int addr1;\n            assert(!withoutRowid);\n            if (useTempTable) {\n                sqlite3VdbeAddOp3(v, 94, srcTab, ipkColumn, regCols);\n            } else {\n                assert(pSelect == 0);\n                sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);\n            }\n            addr1 = sqlite3VdbeAddOp1(v, 51, regCols);\n            ;\n            sqlite3VdbeAddOp2(v, 71, -1, regCols);\n            sqlite3VdbeJumpHere(v, addr1);\n            sqlite3VdbeAddOp1(v, 13, regCols);\n            ;\n        }\n        assert(pTab->nNVCol > 0);\n        sqlite3VdbeAddOp3(v, 80, regRowid + 1, regCols + 1, pTab->nNVCol - 1);\n        if (pTab->tabFlags & 96) {\n            ;\n            ;\n            sqlite3ComputeGeneratedColumns(pParse, regCols + 1, pTab);\n        }\n        if (!isView) {\n            sqlite3TableAffinity(v, pTab, regCols + 1);\n        }\n        sqlite3CodeRowTrigger(pParse, pTrigger, 127, 0, 1, pTab, regCols - pTab->nCol - 1, onError, endOfLoop);\n        sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol + 1);\n    }\n    if (!isView) {\n        if (((pTab)->eTabType == 1)) {\n            sqlite3VdbeAddOp2(v, 75, 0, regIns);\n        }\n        if (ipkColumn >= 0) {\n            if (useTempTable) {\n                sqlite3VdbeAddOp3(v, 94, srcTab, ipkColumn, regRowid);\n            } else if (pSelect) {\n            } else {\n                Expr *pIpk = pList->a[ipkColumn].pExpr;\n                if (pIpk->op == 121 && !((pTab)->eTabType == 1)) {\n                    sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n                    appendFlag = 1;\n                } else {\n                    sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);\n                }\n            }\n            if (!appendFlag) {\n                int addr1;\n                if (!((pTab)->eTabType == 1)) {\n                    addr1 = sqlite3VdbeAddOp1(v, 51, regRowid);\n                    ;\n                    sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n                    sqlite3VdbeJumpHere(v, addr1);\n                } else {\n                    addr1 = sqlite3VdbeCurrentAddr(v);\n                    sqlite3VdbeAddOp2(v, 50, regRowid, addr1 + 2);\n                    ;\n                }\n                sqlite3VdbeAddOp1(v, 13, regRowid);\n                ;\n            }\n        } else if (((pTab)->eTabType == 1) || withoutRowid) {\n            sqlite3VdbeAddOp2(v, 75, 0, regRowid);\n        } else {\n            sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n            appendFlag = 1;\n        }\n        autoIncStep(pParse, regAutoinc, regRowid);\n        if (pTab->tabFlags & 96) {\n            sqlite3ComputeGeneratedColumns(pParse, regRowid + 1, pTab);\n        }\n        if (((pTab)->eTabType == 1)) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            sqlite3VtabMakeWritable(pParse, pTab);\n            sqlite3VdbeAddOp4(v, 7, 1, pTab->nCol + 2, regIns, pVTab, (-11));\n            sqlite3VdbeChangeP5(v, onError == 11 ? 2 : onError);\n            sqlite3MayAbort(pParse);\n        } else {\n            int isReplace = 0;\n            int bUseSeek;\n            sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regIns, 0, ipkColumn >= 0, onError, endOfLoop, &isReplace, 0, pUpsert);\n            if (db->flags & 16384) {\n                sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);\n            }\n            bUseSeek = (isReplace == 0 || !sqlite3VdbeHasSubProgram(v));\n            sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regIns, aRegIdx, 0, appendFlag, bUseSeek);\n        }\n    }\n    if (regRowCount) {\n        sqlite3VdbeAddOp2(v, 86, regRowCount, 1);\n    }\n    if (pTrigger) {\n        sqlite3CodeRowTrigger(pParse, pTrigger, 127, 0, 2, pTab, regData - 2 - pTab->nCol, onError, endOfLoop);\n    }\n    sqlite3VdbeResolveLabel(v, endOfLoop);\n    if (useTempTable) {\n        sqlite3VdbeAddOp2(v, 39, srcTab, addrCont);\n        ;\n        sqlite3VdbeJumpHere(v, addrInsTop);\n        sqlite3VdbeAddOp1(v, 122, srcTab);\n    } else if (pSelect) {\n        sqlite3VdbeGoto(v, addrCont);\n        sqlite3VdbeJumpHere(v, addrInsTop);\n    }\n  insert_end:\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (regRowCount) {\n        sqlite3CodeChangeCount(v, regRowCount, \"rows inserted\");\n    }\n  insert_cleanup:\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprListDelete(db, pList);\n    sqlite3UpsertDelete(db, pUpsert);\n    sqlite3SelectDelete(db, pSelect);\n    sqlite3IdListDelete(db, pColumn);\n    if (aRegIdx)\n        sqlite3DbNNFreeNN(db, aRegIdx);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#124104:1#instrFunc",
            "gotos": 4,
            "labels": 2,
            "body": "{\n    const unsigned char *zHaystack;\n    const unsigned char *zNeedle;\n    int nHaystack;\n    int nNeedle;\n    int typeHaystack, typeNeedle;\n    int N = 1;\n    int isText;\n    unsigned char firstChar;\n    sqlite3_value *pC1 = 0;\n    sqlite3_value *pC2 = 0;\n    (void)(argc);\n    typeHaystack = sqlite3_value_type(argv[0]);\n    typeNeedle = sqlite3_value_type(argv[1]);\n    if (typeHaystack == 5 || typeNeedle == 5)\n        return;\n    nHaystack = sqlite3_value_bytes(argv[0]);\n    nNeedle = sqlite3_value_bytes(argv[1]);\n    if (nNeedle > 0) {\n        if (typeHaystack == 4 && typeNeedle == 4) {\n            zHaystack = sqlite3_value_blob(argv[0]);\n            zNeedle = sqlite3_value_blob(argv[1]);\n            isText = 0;\n        } else if (typeHaystack != 4 && typeNeedle != 4) {\n            zHaystack = sqlite3_value_text(argv[0]);\n            zNeedle = sqlite3_value_text(argv[1]);\n            isText = 1;\n        } else {\n            pC1 = sqlite3_value_dup(argv[0]);\n            zHaystack = sqlite3_value_text(pC1);\n            if (zHaystack == 0)\n                goto endInstrOOM;\n            nHaystack = sqlite3_value_bytes(pC1);\n            pC2 = sqlite3_value_dup(argv[1]);\n            zNeedle = sqlite3_value_text(pC2);\n            if (zNeedle == 0)\n                goto endInstrOOM;\n            nNeedle = sqlite3_value_bytes(pC2);\n            isText = 1;\n        }\n        if (zNeedle == 0 || (nHaystack && zHaystack == 0))\n            goto endInstrOOM;\n        firstChar = zNeedle[0];\n        while (nNeedle <= nHaystack && (zHaystack[0] != firstChar || memcmp(zHaystack, zNeedle, nNeedle) != 0))\n            {\n                N++;\n                do {\n                    nHaystack--;\n                    zHaystack++;\n                } while (isText && (zHaystack[0] & 192) == 128);\n            }\n        if (nNeedle > nHaystack)\n            N = 0;\n    }\n    sqlite3_result_int(context, N);\n  endInstr:\n    sqlite3_value_free(pC1);\n    sqlite3_value_free(pC2);\n    return;\n  endInstrOOM:\n    sqlite3_result_error_nomem(context);\n    goto endInstr;\n}\n"
        },
        {
            "id": "#23:25#sqlite3SrcListAppendFromTerm",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    SrcItem *pItem;\n    sqlite3 *db = pParse->db;\n    if (!p && pOnUsing != 0 && (pOnUsing->pOn || pOnUsing->pUsing)) {\n        sqlite3ErrorMsg(pParse, \"a JOIN clause is required before %s\", (pOnUsing->pOn ? \"ON\" : \"USING\"));\n        goto append_from_error;\n    }\n    p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);\n    if (p == 0) {\n        goto append_from_error;\n    }\n    assert(p->nSrc > 0);\n    pItem = &p->a[p->nSrc - 1];\n    assert((pTable == 0) == (pDatabase == 0));\n    assert(pItem->zName == 0 || pDatabase != 0);\n    if ((pParse->eParseMode >= 2) && pItem->zName) {\n        Token *pToken = ((pDatabase) && pDatabase->z) ? pDatabase : pTable;\n        sqlite3RenameTokenMap(pParse, pItem->zName, pToken);\n    }\n    assert(pAlias != 0);\n    if (pAlias->n) {\n        pItem->zAlias = sqlite3NameFromToken(db, pAlias);\n    }\n    if (pSubquery) {\n        pItem->pSelect = pSubquery;\n        if (pSubquery->selFlags & 2048) {\n            pItem->fg.isNestedFrom = 1;\n        }\n    }\n    assert(pOnUsing == 0 || pOnUsing->pOn == 0 || pOnUsing->pUsing == 0);\n    assert(pItem->fg.isUsing == 0);\n    if (pOnUsing == 0) {\n        pItem->u3.pOn = 0;\n    } else if (pOnUsing->pUsing) {\n        pItem->fg.isUsing = 1;\n        pItem->u3.pUsing = pOnUsing->pUsing;\n    } else {\n        pItem->u3.pOn = pOnUsing->pOn;\n    }\n    return p;\n  append_from_error:\n    assert(p == 0);\n    sqlite3ClearOnOrUsing(db, pOnUsing);\n    sqlite3SelectDelete(db, pSubquery);\n    return 0;\n}\n"
        },
        {
            "id": "#23:25#sqlite3DropIndex",
            "gotos": 6,
            "labels": 1,
            "body": "{\n    Index *pIndex;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    if (db->mallocFailed) {\n        goto exit_drop_index;\n    }\n    assert(pParse->nErr == 0);\n    assert(pName->nSrc == 1);\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto exit_drop_index;\n    }\n    pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);\n    if (pIndex == 0) {\n        if (!ifExists) {\n            sqlite3ErrorMsg(pParse, \"no such index: %S\", pName->a);\n        } else {\n            sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n            sqlite3ForceNotReadOnly(pParse);\n        }\n        pParse->checkSchema = 1;\n        goto exit_drop_index;\n    }\n    if (pIndex->idxType != 0) {\n        sqlite3ErrorMsg(pParse, \"index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped\", 0);\n        goto exit_drop_index;\n    }\n    iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n    {\n        int code = 10;\n        Table *pTab = pIndex->pTable;\n        const char *zDb = db->aDb[iDb].zDbSName;\n        const char *zTab = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n        if (sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)) {\n            goto exit_drop_index;\n        }\n        if (!0 && iDb == 1)\n            code = 12;\n        if (sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb)) {\n            goto exit_drop_index;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v) {\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        sqlite3NestedParse(pParse, \"DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='index'\", db->aDb[iDb].zDbSName, pIndex->zName);\n        sqlite3ClearStatTables(pParse, iDb, \"idx\", pIndex->zName);\n        sqlite3ChangeCookie(pParse, iDb);\n        destroyRootPage(pParse, pIndex->tnum, iDb);\n        sqlite3VdbeAddOp4(v, 152, iDb, 0, 0, pIndex->zName, 0);\n    }\n  exit_drop_index:\n    sqlite3SrcListDelete(db, pName);\n}\n"
        },
        {
            "id": "#23:25#sqlite3DropTable",
            "gotos": 10,
            "labels": 1,
            "body": "{\n    Table *pTab;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    if (db->mallocFailed) {\n        goto exit_drop_table;\n    }\n    assert(pParse->nErr == 0);\n    assert(pName->nSrc == 1);\n    if (sqlite3ReadSchema(pParse))\n        goto exit_drop_table;\n    if (noErr)\n        db->suppressErr++;\n    assert(isView == 0 || isView == 1);\n    pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);\n    if (noErr)\n        db->suppressErr--;\n    if (pTab == 0) {\n        if (noErr) {\n            sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n            sqlite3ForceNotReadOnly(pParse);\n        }\n        goto exit_drop_table;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iDb >= 0 && iDb < db->nDb);\n    if (((pTab)->eTabType == 1) && sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto exit_drop_table;\n    }\n    {\n        int code;\n        const char *zTab = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n        const char *zDb = db->aDb[iDb].zDbSName;\n        const char *zArg2 = 0;\n        if (sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)) {\n            goto exit_drop_table;\n        }\n        if (isView) {\n            if (!0 && iDb == 1) {\n                code = 15;\n            } else {\n                code = 17;\n            }\n        } else if (((pTab)->eTabType == 1)) {\n            code = 30;\n            zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;\n        } else {\n            if (!0 && iDb == 1) {\n                code = 13;\n            } else {\n                code = 11;\n            }\n        }\n        if (sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb)) {\n            goto exit_drop_table;\n        }\n        if (sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb)) {\n            goto exit_drop_table;\n        }\n    }\n    if (tableMayNotBeDropped(db, pTab)) {\n        sqlite3ErrorMsg(pParse, \"table %s may not be dropped\", pTab->zName);\n        goto exit_drop_table;\n    }\n    if (isView && !((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"use DROP TABLE to delete table %s\", pTab->zName);\n        goto exit_drop_table;\n    }\n    if (!isView && ((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"use DROP VIEW to delete view %s\", pTab->zName);\n        goto exit_drop_table;\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v) {\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        if (!isView) {\n            sqlite3ClearStatTables(pParse, iDb, \"tbl\", pTab->zName);\n            sqlite3FkDropTable(pParse, pName, pTab);\n        }\n        sqlite3CodeDropTable(pParse, pTab, iDb, isView);\n    }\n  exit_drop_table:\n    sqlite3SrcListDelete(db, pName);\n}\n"
        },
        {
            "id": "#23:25#sqlite3AddGenerated",
            "gotos": 5,
            "labels": 2,
            "body": "{\n    u8 eType = 32;\n    Table *pTab = pParse->pNewTable;\n    Column *pCol;\n    if (pTab == 0) {\n        goto generated_done;\n    }\n    pCol = &(pTab->aCol[pTab->nCol - 1]);\n    if ((pParse->eParseMode == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables cannot use computed columns\");\n        goto generated_done;\n    }\n    if (pCol->iDflt > 0)\n        goto generated_error;\n    if (pType) {\n        if (pType->n == 7 && sqlite3_strnicmp(\"virtual\", pType->z, 7) == 0) {\n        } else if (pType->n == 6 && sqlite3_strnicmp(\"stored\", pType->z, 6) == 0) {\n            eType = 64;\n        } else {\n            goto generated_error;\n        }\n    }\n    if (eType == 32)\n        pTab->nNVCol--;\n    pCol->colFlags |= eType;\n    assert(32 == 32);\n    assert(64 == 64);\n    pTab->tabFlags |= eType;\n    if (pCol->colFlags & 1) {\n        makeColumnPartOfPrimaryKey(pParse, pCol);\n    }\n    sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);\n    pExpr = 0;\n    goto generated_done;\n  generated_error:\n    sqlite3ErrorMsg(pParse, \"error in generated column \\\"%s\\\"\", pCol->zCnName);\n  generated_done:\n    sqlite3ExprDelete(pParse->db, pExpr);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#130964:12#sqlite3_exec",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    const char *zLeftover;\n    sqlite3_stmt *pStmt = 0;\n    char **azCols = 0;\n    int callbackIsInit;\n    if (!sqlite3SafetyCheckOk(db))\n        return sqlite3MisuseError(130977);\n    if (zSql == 0)\n        zSql = \"\";\n    sqlite3_mutex_enter(db->mutex);\n    sqlite3Error(db, 0);\n    while (rc == 0 && zSql[0])\n        {\n            int nCol = 0;\n            char **azVals = 0;\n            pStmt = 0;\n            rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);\n            assert(rc == 0 || pStmt == 0);\n            if (rc != 0) {\n                continue;\n            }\n            if (!pStmt) {\n                zSql = zLeftover;\n                continue;\n            }\n            callbackIsInit = 0;\n            while (1)\n                {\n                    int i;\n                    rc = sqlite3_step(pStmt);\n                    if (xCallback && (100 == rc || (101 == rc && !callbackIsInit && db->flags & 256))) {\n                        if (!callbackIsInit) {\n                            nCol = sqlite3_column_count(pStmt);\n                            azCols = sqlite3DbMallocRaw(db, (2 * nCol + 1) * sizeof(const char *));\n                            if (azCols == 0) {\n                                goto exec_out;\n                            }\n                            for (i = 0; i < nCol; i++) {\n                                azCols[i] = (char *)sqlite3_column_name(pStmt, i);\n                                assert(azCols[i] != 0);\n                            }\n                            callbackIsInit = 1;\n                        }\n                        if (rc == 100) {\n                            azVals = &azCols[nCol];\n                            for (i = 0; i < nCol; i++) {\n                                azVals[i] = (char *)sqlite3_column_text(pStmt, i);\n                                if (!azVals[i] && sqlite3_column_type(pStmt, i) != 5) {\n                                    sqlite3OomFault(db);\n                                    goto exec_out;\n                                }\n                            }\n                            azVals[i] = 0;\n                        }\n                        if (xCallback(pArg, nCol, azVals, azCols)) {\n                            rc = 4;\n                            sqlite3VdbeFinalize((Vdbe *)pStmt);\n                            pStmt = 0;\n                            sqlite3Error(db, 4);\n                            goto exec_out;\n                        }\n                    }\n                    if (rc != 100) {\n                        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);\n                        pStmt = 0;\n                        zSql = zLeftover;\n                        while ((sqlite3CtypeMap[(unsigned char)(zSql[0])] & 1))\n                            zSql++;\n                        break;\n                    }\n                }\n            sqlite3DbFree(db, azCols);\n            azCols = 0;\n        }\n  exec_out:\n    if (pStmt)\n        sqlite3VdbeFinalize((Vdbe *)pStmt);\n    sqlite3DbFree(db, azCols);\n    rc = sqlite3ApiExit(db, rc);\n    if (rc != 0 && pzErrMsg) {\n        *pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));\n        if (*pzErrMsg == 0) {\n            rc = 7;\n            sqlite3Error(db, 7);\n        }\n    } else if (pzErrMsg) {\n        *pzErrMsg = 0;\n    }\n    assert((rc & db->errMask) == rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#115852:1#attachFunc",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    int i;\n    int rc = 0;\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    const char *zName;\n    const char *zFile;\n    char *zPath = 0;\n    char *zErr = 0;\n    unsigned int flags;\n    Db *aNew;\n    Db *pNew;\n    char *zErrDyn = 0;\n    sqlite3_vfs *pVfs;\n    (void)(NotUsed);\n    zFile = (const char *)sqlite3_value_text(argv[0]);\n    zName = (const char *)sqlite3_value_text(argv[1]);\n    if (zFile == 0)\n        zFile = \"\";\n    if (zName == 0)\n        zName = \"\";\n    if ((db->init.reopenMemdb)) {\n        pVfs = sqlite3_vfs_find(\"memdb\");\n        if (pVfs == 0)\n            return;\n        pNew = &db->aDb[db->init.iDb];\n        if (pNew->pBt)\n            sqlite3BtreeClose(pNew->pBt);\n        pNew->pBt = 0;\n        pNew->pSchema = 0;\n        rc = sqlite3BtreeOpen(pVfs, \"x\\000\", db, &pNew->pBt, 0, 256);\n    } else {\n        if (db->nDb >= db->aLimit[7] + 2) {\n            zErrDyn = sqlite3MPrintf(db, \"too many attached databases - max %d\", db->aLimit[7]);\n            goto attach_error;\n        }\n        for (i = 0; i < db->nDb; i++) {\n            assert(zName);\n            if (sqlite3DbIsNamed(db, i, zName)) {\n                zErrDyn = sqlite3MPrintf(db, \"database %s is already in use\", zName);\n                goto attach_error;\n            }\n        }\n        if (db->aDb == db->aDbStatic) {\n            aNew = sqlite3DbMallocRawNN(db, sizeof (db->aDb[0]) * 3);\n            if (aNew == 0)\n                return;\n            memcpy(aNew, db->aDb, sizeof (db->aDb[0]) * 2);\n        } else {\n            aNew = sqlite3DbRealloc(db, db->aDb, sizeof (db->aDb[0]) * (db->nDb + 1));\n            if (aNew == 0)\n                return;\n        }\n        db->aDb = aNew;\n        pNew = &db->aDb[db->nDb];\n        memset(pNew, 0, sizeof (*pNew));\n        flags = db->openFlags;\n        rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);\n        if (rc != 0) {\n            if (rc == 7)\n                sqlite3OomFault(db);\n            sqlite3_result_error(context, zErr, -1);\n            sqlite3_free(zErr);\n            return;\n        }\n        assert(pVfs);\n        flags |= 256;\n        rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);\n        db->nDb++;\n        pNew->zDbSName = sqlite3DbStrDup(db, zName);\n    }\n    db->noSharedCache = 0;\n    if (rc == 19) {\n        rc = 1;\n        zErrDyn = sqlite3MPrintf(db, \"database is already attached\");\n    } else if (rc == 0) {\n        Pager *pPager;\n        pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);\n        if (!pNew->pSchema) {\n            rc = 7;\n        } else if (pNew->pSchema->file_format && pNew->pSchema->enc != ((db)->enc)) {\n            zErrDyn = sqlite3MPrintf(db, \"attached databases must use the same text encoding as main database\");\n            rc = 1;\n        }\n        sqlite3BtreeEnter(pNew->pBt);\n        pPager = sqlite3BtreePager(pNew->pBt);\n        sqlite3PagerLockingMode(pPager, db->dfltLockMode);\n        sqlite3BtreeSecureDelete(pNew->pBt, sqlite3BtreeSecureDelete(db->aDb[0].pBt, -1));\n        sqlite3BtreeSetPagerFlags(pNew->pBt, 3 | (db->flags & 56));\n        sqlite3BtreeLeave(pNew->pBt);\n    }\n    pNew->safety_level = 2 + 1;\n    if (rc == 0 && pNew->zDbSName == 0) {\n        rc = 7;\n    }\n    sqlite3_free_filename(zPath);\n    if (rc == 0) {\n        sqlite3BtreeEnterAll(db);\n        db->init.iDb = 0;\n        db->mDbFlags &= ~(16);\n        if (!(db->init.reopenMemdb)) {\n            rc = sqlite3Init(db, &zErrDyn);\n        }\n        sqlite3BtreeLeaveAll(db);\n        assert(zErrDyn == 0 || rc != 0);\n    }\n    if (rc) {\n        if (!(db->init.reopenMemdb)) {\n            int iDb = db->nDb - 1;\n            assert(iDb >= 2);\n            if (db->aDb[iDb].pBt) {\n                sqlite3BtreeClose(db->aDb[iDb].pBt);\n                db->aDb[iDb].pBt = 0;\n                db->aDb[iDb].pSchema = 0;\n            }\n            sqlite3ResetAllSchemasOfConnection(db);\n            db->nDb = iDb;\n            if (rc == 7 || rc == (10 | (12 << 8))) {\n                sqlite3OomFault(db);\n                sqlite3DbFree(db, zErrDyn);\n                zErrDyn = sqlite3MPrintf(db, \"out of memory\");\n            } else if (zErrDyn == 0) {\n                zErrDyn = sqlite3MPrintf(db, \"unable to open database: %s\", zFile);\n            }\n        }\n        goto attach_error;\n    }\n    return;\n  attach_error:\n    if (zErrDyn) {\n        sqlite3_result_error(context, zErrDyn, -1);\n        sqlite3DbFree(db, zErrDyn);\n    }\n    if (rc)\n        sqlite3_result_error_code(context, rc);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#132323:1#sqlite3LoadExtension",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    sqlite3_vfs *pVfs = db->pVfs;\n    void *handle;\n    sqlite3_loadext_entry xInit;\n    char *zErrmsg = 0;\n    const char *zEntry;\n    char *zAltEntry = 0;\n    void **aHandle;\n    u64 nMsg = strlen(zFile);\n    int ii;\n    int rc;\n    static const char *azEndings[] = {\"dylib\"};\n    if (pzErrMsg)\n        *pzErrMsg = 0;\n    if ((db->flags & 65536) == 0) {\n        if (pzErrMsg) {\n            *pzErrMsg = sqlite3_mprintf(\"not authorized\");\n        }\n        return 1;\n    }\n    zEntry = zProc ? zProc : \"sqlite3_extension_init\";\n    if (<recovery-expr>())\n        goto extension_not_found;\n    handle = sqlite3OsDlOpen(pVfs, zFile);\n    for (ii = 0; ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && handle == 0; ii++) {\n        char *zAltFile = sqlite3_mprintf(\"%s.%s\", zFile, azEndings[ii]);\n        if (zAltFile == 0)\n            return 7;\n        handle = sqlite3OsDlOpen(pVfs, zAltFile);\n        sqlite3_free(zAltFile);\n    }\n    if (handle == 0)\n        goto extension_not_found;\n    xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);\n    if (xInit == 0 && zProc == 0) {\n        int iFile, iEntry, c;\n        int ncFile = sqlite3Strlen30(zFile);\n        zAltEntry = sqlite3_malloc64(ncFile + 30);\n        if (zAltEntry == 0) {\n            sqlite3OsDlClose(pVfs, handle);\n            return 7;\n        }\n        memcpy(zAltEntry, \"sqlite3_\", 8);\n        for (iFile = ncFile - 1; iFile >= 0 && !((zFile[iFile]) == '/'); iFile--) {\n        }\n        iFile++;\n        if (sqlite3_strnicmp(zFile + iFile, \"lib\", 3) == 0)\n            iFile += 3;\n        for (iEntry = 8; (c = zFile[iFile]) != 0 && c != '.'; iFile++) {\n            if ((sqlite3CtypeMap[(unsigned char)(c)] & 2)) {\n                zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned int)c];\n            }\n        }\n        memcpy(zAltEntry + iEntry, \"_init\", 6);\n        zEntry = zAltEntry;\n        xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);\n    }\n    if (xInit == 0) {\n        if (pzErrMsg) {\n            nMsg += strlen(zEntry) + 300;\n            *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n            if (zErrmsg) {\n                assert(nMsg < 2147483647);\n                sqlite3_snprintf((int)nMsg, zErrmsg, \"no entry point [%s] in shared library [%s]\", zEntry, zFile);\n                sqlite3OsDlError(pVfs, nMsg - 1, zErrmsg);\n            }\n        }\n        sqlite3OsDlClose(pVfs, handle);\n        sqlite3_free(zAltEntry);\n        return 1;\n    }\n    sqlite3_free(zAltEntry);\n    rc = xInit(db, &zErrmsg, &sqlite3Apis);\n    if (rc) {\n        if (rc == (0 | (1 << 8)))\n            return 0;\n        if (pzErrMsg) {\n            *pzErrMsg = sqlite3_mprintf(\"error during initialization: %s\", zErrmsg);\n        }\n        sqlite3_free(zErrmsg);\n        sqlite3OsDlClose(pVfs, handle);\n        return 1;\n    }\n    aHandle = sqlite3DbMallocZero(db, sizeof (handle) * (db->nExtension + 1));\n    if (aHandle == 0) {\n        return 7;\n    }\n    if (db->nExtension > 0) {\n        memcpy(aHandle, db->aExtension, sizeof (handle) * db->nExtension);\n    }\n    sqlite3DbFree(db, db->aExtension);\n    db->aExtension = aHandle;\n    db->aExtension[db->nExtension++] = handle;\n    return 0;\n  extension_not_found:\n    if (pzErrMsg) {\n        nMsg += 300;\n        *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n        if (zErrmsg) {\n            assert(nMsg < 2147483647);\n            sqlite3OsDlError(pVfs, nMsg - 1, zErrmsg);\n        }\n    }\n    return 1;\n}\n"
        },
        {
            "id": "#23:25#sqlite3AddPrimaryKey",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    Table *pTab = pParse->pNewTable;\n    Column *pCol = 0;\n    int iCol = -1, i;\n    int nTerm;\n    if (pTab == 0)\n        goto primary_key_exit;\n    if (pTab->tabFlags & 4) {\n        sqlite3ErrorMsg(pParse, \"table \\\"%s\\\" has more than one primary key\", pTab->zName);\n        goto primary_key_exit;\n    }\n    pTab->tabFlags |= 4;\n    if (pList == 0) {\n        iCol = pTab->nCol - 1;\n        pCol = &pTab->aCol[iCol];\n        makeColumnPartOfPrimaryKey(pParse, pCol);\n        nTerm = 1;\n    } else {\n        nTerm = pList->nExpr;\n        for (i = 0; i < nTerm; i++) {\n            Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);\n            assert(pCExpr != 0);\n            sqlite3StringToId(pCExpr);\n            if (pCExpr->op == 59) {\n                const char *zCName;\n                assert(!(((pCExpr)->flags & (2048)) != 0));\n                zCName = pCExpr->u.zToken;\n                for (iCol = 0; iCol < pTab->nCol; iCol++) {\n                    if (sqlite3StrICmp(zCName, pTab->aCol[iCol].zCnName) == 0) {\n                        pCol = &pTab->aCol[iCol];\n                        makeColumnPartOfPrimaryKey(pParse, pCol);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (nTerm == 1 && pCol && pCol->eCType == 4 && sortOrder != 1) {\n        if ((pParse->eParseMode >= 2) && pList) {\n            Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[0].pExpr);\n            sqlite3RenameTokenRemap(pParse, &pTab->iPKey, pCExpr);\n        }\n        pTab->iPKey = iCol;\n        pTab->keyConf = (u8)onError;\n        assert(autoInc == 0 || autoInc == 1);\n        pTab->tabFlags |= autoInc * 8;\n        if (pList)\n            pParse->iPkSortOrder = pList->a[0].fg.sortFlags;\n        (void)sqlite3HasExplicitNulls(pParse, pList);\n    } else if (autoInc) {\n        sqlite3ErrorMsg(pParse, \"AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY\");\n    } else {\n        sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0, 2);\n        pList = 0;\n    }\n  primary_key_exit:\n    sqlite3ExprListDelete(pParse->db, pList);\n    return;\n}\n"
        },
        {
            "id": "#23:25#sqlite3ExprListAppendVector",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    sqlite3 *db = pParse->db;\n    int n;\n    int i;\n    int iFirst = pList ? pList->nExpr : 0;\n    if ((pColumns == 0))\n        goto vector_append_error;\n    if (pExpr == 0)\n        goto vector_append_error;\n    if (pExpr->op != 138 && pColumns->nId != (n = sqlite3ExprVectorSize(pExpr))) {\n        sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\", pColumns->nId, n);\n        goto vector_append_error;\n    }\n    for (i = 0; i < pColumns->nId; i++) {\n        Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i, pColumns->nId);\n        assert(pSubExpr != 0 || db->mallocFailed);\n        if (pSubExpr == 0)\n            continue;\n        pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);\n        if (pList) {\n            assert(pList->nExpr == iFirst + i + 1);\n            pList->a[pList->nExpr - 1].zEName = pColumns->a[i].zName;\n            pColumns->a[i].zName = 0;\n        }\n    }\n    if (!db->mallocFailed && pExpr->op == 138 && (pList != 0)) {\n        Expr *pFirst = pList->a[iFirst].pExpr;\n        assert(pFirst != 0);\n        assert(pFirst->op == 178);\n        pFirst->pRight = pExpr;\n        pExpr = 0;\n        pFirst->iTable = pColumns->nId;\n    }\n  vector_append_error:\n    sqlite3ExprUnmapAndDelete(pParse, pExpr);\n    sqlite3IdListDelete(db, pColumns);\n    return pList;\n}\n"
        },
        {
            "id": "#23:25#sqlite3AlterBeginAddColumn",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    Table *pNew;\n    Table *pTab;\n    int iDb;\n    int i;\n    int nAlloc;\n    sqlite3 *db = pParse->db;\n    assert(pParse->pNewTable == 0);\n    assert(sqlite3BtreeHoldsAllMutexes(db));\n    if (db->mallocFailed)\n        goto exit_begin_add_column;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_begin_add_column;\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables may not be altered\");\n        goto exit_begin_add_column;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"Cannot add a column to a view\");\n        goto exit_begin_add_column;\n    }\n    if (0 != isAlterableTable(pParse, pTab)) {\n        goto exit_begin_add_column;\n    }\n    sqlite3MayAbort(pParse);\n    assert(((pTab)->eTabType == 0));\n    assert(pTab->u.tab.addColOffset > 0);\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    pNew = (Table *)sqlite3DbMallocZero(db, sizeof(Table));\n    if (!pNew)\n        goto exit_begin_add_column;\n    pParse->pNewTable = pNew;\n    pNew->nTabRef = 1;\n    pNew->nCol = pTab->nCol;\n    assert(pNew->nCol > 0);\n    nAlloc = (((pNew->nCol - 1) / 8) * 8) + 8;\n    assert(nAlloc >= pNew->nCol && nAlloc % 8 == 0 && nAlloc - pNew->nCol < 8);\n    pNew->aCol = (Column *)sqlite3DbMallocZero(db, sizeof(Column) * nAlloc);\n    pNew->zName = sqlite3MPrintf(db, \"sqlite_altertab_%s\", pTab->zName);\n    if (!pNew->aCol || !pNew->zName) {\n        assert(db->mallocFailed);\n        goto exit_begin_add_column;\n    }\n    memcpy(pNew->aCol, pTab->aCol, sizeof(Column) * pNew->nCol);\n    for (i = 0; i < pNew->nCol; i++) {\n        Column *pCol = &pNew->aCol[i];\n        pCol->zCnName = sqlite3DbStrDup(db, pCol->zCnName);\n        pCol->hName = sqlite3StrIHash(pCol->zCnName);\n    }\n    assert(((pNew)->eTabType == 0));\n    pNew->u.tab.pDfltList = sqlite3ExprListDup(db, pTab->u.tab.pDfltList, 0);\n    pNew->pSchema = db->aDb[iDb].pSchema;\n    pNew->u.tab.addColOffset = pTab->u.tab.addColOffset;\n    pNew->nTabRef = 1;\n  exit_begin_add_column:\n    sqlite3SrcListDelete(db, pSrc);\n    return;\n}\n"
        },
        {
            "id": "#23:25#sqlite3AlterDropColumn",
            "gotos": 9,
            "labels": 1,
            "body": "{\n    sqlite3 *db = pParse->db;\n    Table *pTab;\n    int iDb;\n    const char *zDb;\n    char *zCol = 0;\n    int iCol;\n    assert(pParse->pNewTable == 0);\n    assert(sqlite3BtreeHoldsAllMutexes(db));\n    if ((db->mallocFailed))\n        goto exit_drop_column;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_drop_column;\n    if (0 != isAlterableTable(pParse, pTab))\n        goto exit_drop_column;\n    if (0 != isRealTable(pParse, pTab, 1))\n        goto exit_drop_column;\n    zCol = sqlite3NameFromToken(db, pName);\n    if (zCol == 0) {\n        assert(db->mallocFailed);\n        goto exit_drop_column;\n    }\n    iCol = sqlite3ColumnIndex(pTab, zCol);\n    if (iCol < 0) {\n        sqlite3ErrorMsg(pParse, \"no such column: \\\"%T\\\"\", pName);\n        goto exit_drop_column;\n    }\n    if (pTab->aCol[iCol].colFlags & (1 | 8)) {\n        sqlite3ErrorMsg(pParse, \"cannot drop %s column: \\\"%s\\\"\", (pTab->aCol[iCol].colFlags & 1) ? \"PRIMARY KEY\" : \"UNIQUE\", zCol);\n        goto exit_drop_column;\n    }\n    if (pTab->nCol <= 1) {\n        sqlite3ErrorMsg(pParse, \"cannot drop column \\\"%s\\\": no other columns exist\", zCol);\n        goto exit_drop_column;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iDb >= 0);\n    zDb = db->aDb[iDb].zDbSName;\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, zCol)) {\n        goto exit_drop_column;\n    }\n    renameTestSchema(pParse, zDb, iDb == 1, \"\", 0);\n    renameFixQuotes(pParse, zDb, iDb == 1);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_drop_column(%d, sql, %d) WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)\", zDb, iDb, iCol, pTab->zName);\n    renameReloadSchema(pParse, iDb, 2);\n    renameTestSchema(pParse, zDb, iDb == 1, \"after drop column\", 1);\n    if (pParse->nErr == 0 && (pTab->aCol[iCol].colFlags & 32) == 0) {\n        int i;\n        int addr;\n        int reg;\n        int regRec;\n        Index *pPk = 0;\n        int nField = 0;\n        int iCur;\n        Vdbe *v = sqlite3GetVdbe(pParse);\n        iCur = pParse->nTab++;\n        sqlite3OpenTable(pParse, iCur, iDb, pTab, 113);\n        addr = sqlite3VdbeAddOp1(v, 36, iCur);\n        ;\n        reg = ++pParse->nMem;\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp2(v, 135, iCur, reg);\n            pParse->nMem += pTab->nCol;\n        } else {\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n            pParse->nMem += pPk->nColumn;\n            for (i = 0; i < pPk->nKeyCol; i++) {\n                sqlite3VdbeAddOp3(v, 94, iCur, i, reg + i + 1);\n            }\n            nField = pPk->nKeyCol;\n        }\n        regRec = ++pParse->nMem;\n        for (i = 0; i < pTab->nCol; i++) {\n            if (i != iCol && (pTab->aCol[i].colFlags & 32) == 0) {\n                int regOut;\n                if (pPk) {\n                    int iPos = sqlite3TableColumnToIndex(pPk, i);\n                    int iColPos = sqlite3TableColumnToIndex(pPk, iCol);\n                    if (iPos < pPk->nKeyCol)\n                        continue;\n                    regOut = reg + 1 + iPos - (iPos > iColPos);\n                } else {\n                    regOut = reg + 1 + nField;\n                }\n                if (i == pTab->iPKey) {\n                    sqlite3VdbeAddOp2(v, 75, 0, regOut);\n                } else {\n                    sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOut);\n                }\n                nField++;\n            }\n        }\n        if (nField == 0) {\n            pParse->nMem++;\n            sqlite3VdbeAddOp2(v, 75, 0, reg + 1);\n            nField = 1;\n        }\n        sqlite3VdbeAddOp3(v, 97, reg + 1, nField, regRec);\n        if (pPk) {\n            sqlite3VdbeAddOp4Int(v, 138, iCur, regRec, reg + 1, pPk->nKeyCol);\n        } else {\n            sqlite3VdbeAddOp3(v, 128, iCur, regRec, reg);\n        }\n        sqlite3VdbeChangeP5(v, 2);\n        sqlite3VdbeAddOp2(v, 39, iCur, addr + 1);\n        ;\n        sqlite3VdbeJumpHere(v, addr);\n    }\n  exit_drop_column:\n    sqlite3DbFree(db, zCol);\n    sqlite3SrcListDelete(db, pSrc);\n}\n"
        },
        {
            "id": "#23:25#sqlite3AlterRenameTable",
            "gotos": 10,
            "labels": 1,
            "body": "{\n    int iDb;\n    char *zDb;\n    Table *pTab;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    int nTabName;\n    const char *zTabName;\n    Vdbe *v;\n    VTable *pVTab = 0;\n    if ((db->mallocFailed))\n        goto exit_rename_table;\n    assert(pSrc->nSrc == 1);\n    assert(sqlite3BtreeHoldsAllMutexes(pParse->db));\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_rename_table;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n    zDb = db->aDb[iDb].zDbSName;\n    zName = sqlite3NameFromToken(db, pName);\n    if (!zName)\n        goto exit_rename_table;\n    if (sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) || sqlite3IsShadowTableOf(db, pTab, zName)) {\n        sqlite3ErrorMsg(pParse, \"there is already another table or index with this name: %s\", zName);\n        goto exit_rename_table;\n    }\n    if (0 != isAlterableTable(pParse, pTab)) {\n        goto exit_rename_table;\n    }\n    if (0 != sqlite3CheckObjectName(pParse, zName, \"table\", zName)) {\n        goto exit_rename_table;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"view %s may not be altered\", pTab->zName);\n        goto exit_rename_table;\n    }\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0)) {\n        goto exit_rename_table;\n    }\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto exit_rename_table;\n    }\n    if (((pTab)->eTabType == 1)) {\n        pVTab = sqlite3GetVTable(db, pTab);\n        if (pVTab->pVtab->pModule->xRename == 0) {\n            pVTab = 0;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0) {\n        goto exit_rename_table;\n    }\n    sqlite3MayAbort(pParse);\n    zTabName = pTab->zName;\n    nTabName = sqlite3Utf8CharLen(zTabName, -1);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\", zDb, zDb, zTabName, zName, (iDb == 1), zTabName);\n    sqlite3NestedParse(pParse, \"UPDATE %Q.sqlite_master SET tbl_name = %Q, name = CASE WHEN type='table' THEN %Q WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X'      AND type='index' THEN 'sqlite_autoindex_' || %Q || substr(name,%d+18) ELSE name END WHERE tbl_name=%Q COLLATE nocase AND (type='table' OR type='index' OR type='trigger');\", zDb, zName, zName, zName, nTabName, zTabName);\n    if (sqlite3FindTable(db, \"sqlite_sequence\", zDb)) {\n        sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_sequence set name = %Q WHERE name = %Q\", zDb, zName, pTab->zName);\n    }\n    if (iDb != 1) {\n        sqlite3NestedParse(pParse, \"UPDATE sqlite_temp_schema SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), tbl_name = CASE WHEN tbl_name=%Q COLLATE nocase AND   sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) THEN %Q ELSE tbl_name END WHERE type IN ('view', 'trigger')\", zDb, zTabName, zName, zTabName, zDb, zName);\n    }\n    if (pVTab) {\n        int i = ++pParse->nMem;\n        sqlite3VdbeLoadString(v, i, zName);\n        sqlite3VdbeAddOp4(v, 176, i, 0, 0, (const char *)pVTab, (-11));\n    }\n    renameReloadSchema(pParse, iDb, 1);\n    renameTestSchema(pParse, zDb, iDb == 1, \"after rename\", 0);\n  exit_rename_table:\n    sqlite3SrcListDelete(db, pSrc);\n    sqlite3DbFree(db, zName);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#23552:1#parseTimezone",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int sgn = 0;\n    int nHr, nMn;\n    int c;\n    while ((sqlite3CtypeMap[(unsigned char)(*zDate)] & 1))\n        {\n            zDate++;\n        }\n    p->tz = 0;\n    c = *zDate;\n    if (c == '-') {\n        sgn = -1;\n    } else if (c == '+') {\n        sgn = +1;\n    } else if (c == 'Z' || c == 'z') {\n        zDate++;\n        goto zulu_time;\n    } else {\n        return c != 0;\n    }\n    zDate++;\n    if (getDigits(zDate, \"20b:20e\", &nHr, &nMn) != 2) {\n        return 1;\n    }\n    zDate += 5;\n    p->tz = sgn * (nMn + nHr * 60);\n  zulu_time:\n    while ((sqlite3CtypeMap[(unsigned char)(*zDate)] & 1))\n        {\n            zDate++;\n        }\n    p->tzSet = 1;\n    return *zDate != 0;\n}\n"
        },
        {
            "id": "#23:25#sqlite3ExprIfTrue",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    assert(jumpIfNull == 16 || jumpIfNull == 0);\n    if ((v == 0))\n        return;\n    if ((pExpr == 0))\n        return;\n    assert(!0);\n    op = pExpr->op;\n    switch (op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);\n            } else if (op == 44) {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            } else {\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            } else {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (op == 45) ? 53 : 52;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            assert(56 == 56);\n            ;\n            ;\n            assert(55 == 55);\n            ;\n            ;\n            assert(54 == 54);\n            ;\n            ;\n            assert(57 == 57);\n            ;\n            ;\n            assert(53 == 53);\n            ;\n            ;\n            ;\n            assert(52 == 52);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            assert(50 == 50);\n            ;\n            assert(51 == 51);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = jumpIfNull ? dest : destIfFalse;\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeGoto(v, dest);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 16, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
        },
        {
            "id": "#23:25#sqlite3ExprCodeTarget",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op;\n    int inReg = target;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    Expr tempX;\n    int p5 = 0;\n    assert(target > 0 && target <= pParse->nMem);\n    assert(v != 0);\n  expr_code_doover:\n    if (pExpr == 0) {\n        op = 121;\n    } else if (pParse->pIdxExpr != 0 && !(((pExpr)->flags & (8388608)) != 0) && (r1 = sqlite3IndexedExprLookup(pParse, pExpr, target)) >= 0) {\n        return r1;\n    } else {\n        assert(!0);\n        op = pExpr->op;\n    }\n    switch (op) {\n      case 169:\n        {\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            struct AggInfo_col *pCol;\n            assert(pAggInfo != 0);\n            assert(pExpr->iAgg >= 0 && pExpr->iAgg < pAggInfo->nColumn);\n            pCol = &pAggInfo->aCol[pExpr->iAgg];\n            if (!pAggInfo->directMode) {\n                assert(pCol->iMem > 0);\n                return pCol->iMem;\n            } else if (pAggInfo->useSortingIdx) {\n                Table *pTab = pCol->pTab;\n                sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pCol->iSorterColumn, target);\n                if (pCol->iColumn < 0) {\n                    ;\n                } else if ((pTab != 0)) {\n                    ;\n                    if (pTab->aCol[pCol->iColumn].affinity == 69) {\n                        sqlite3VdbeAddOp1(v, 87, target);\n                    }\n                }\n                return target;\n            }\n        }\n      case 167:\n        {\n            int iTab = pExpr->iTable;\n            int iReg;\n            if ((((pExpr)->flags & (32)) != 0)) {\n                int aff;\n                iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                assert(pExpr->y.pTab != 0);\n                aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n                if (aff > 65) {\n                    static const char zAff[] = \"B\\000C\\000D\\000E\";\n                    assert(65 == 'A');\n                    assert(66 == 'B');\n                    sqlite3VdbeAddOp4(v, 96, iReg, 1, 0, &zAff[(aff - 'B') * 2], (-1));\n                }\n                return iReg;\n            }\n            if (iTab < 0) {\n                if (pParse->iSelfTab < 0) {\n                    Column *pCol;\n                    Table *pTab;\n                    int iSrc;\n                    int iCol = pExpr->iColumn;\n                    assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                    pTab = pExpr->y.pTab;\n                    assert(pTab != 0);\n                    assert(iCol >= (-1));\n                    assert(iCol < pTab->nCol);\n                    if (iCol < 0) {\n                        return -1 - pParse->iSelfTab;\n                    }\n                    pCol = pTab->aCol + iCol;\n                    ;\n                    iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n                    if (pCol->colFlags & 96) {\n                        if (pCol->colFlags & 256) {\n                            sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zCnName);\n                            return 0;\n                        }\n                        pCol->colFlags |= 256;\n                        if (pCol->colFlags & 128) {\n                            sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc);\n                        }\n                        pCol->colFlags &= ~(256 | 128);\n                        return iSrc;\n                    } else if (pCol->affinity == 69) {\n                        sqlite3VdbeAddOp2(v, 81, iSrc, target);\n                        sqlite3VdbeAddOp1(v, 87, target);\n                        return target;\n                    } else {\n                        return iSrc;\n                    }\n                } else {\n                    iTab = pParse->iSelfTab - 1;\n                }\n            }\n            assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n            assert(pExpr->y.pTab != 0);\n            iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab, pExpr->iColumn, iTab, target, pExpr->op2);\n            return iReg;\n        }\n      case 155:\n        {\n            codeInteger(pParse, pExpr, 0, target);\n            return target;\n        }\n      case 170:\n        {\n            sqlite3VdbeAddOp2(v, 71, sqlite3ExprTruthValue(pExpr), target);\n            return target;\n        }\n      case 153:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            codeReal(v, pExpr->u.zToken, 0, target);\n            return target;\n        }\n      case 117:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n            return target;\n        }\n      default:\n        {\n            assert(op == 121 || op == 182 || pParse->db->mallocFailed);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            return target;\n        }\n      case 154:\n        {\n            int n;\n            const char *z;\n            char *zBlob;\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            assert(pExpr->u.zToken[0] == 'x' || pExpr->u.zToken[0] == 'X');\n            assert(pExpr->u.zToken[1] == '\\'');\n            z = &pExpr->u.zToken[2];\n            n = sqlite3Strlen30(z) - 1;\n            assert(z[n] == '\\'');\n            zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n            sqlite3VdbeAddOp4(v, 77, n / 2, target, 0, zBlob, (-6));\n            return target;\n        }\n      case 156:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            assert(pExpr->u.zToken != 0);\n            assert(pExpr->u.zToken[0] != 0);\n            sqlite3VdbeAddOp2(v, 78, pExpr->iColumn, target);\n            if (pExpr->u.zToken[1] != 0) {\n                const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n                assert(pExpr->u.zToken[0] == '?' || (z && !strcmp(pExpr->u.zToken, z)));\n                pParse->pVList[0] = 0;\n                sqlite3VdbeAppendP4(v, (char *)z, (-1));\n            }\n            return target;\n        }\n      case 176:\n        {\n            return pExpr->iTable;\n        }\n      case 36:\n        {\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            if (inReg != target) {\n                sqlite3VdbeAddOp2(v, 81, inReg, target);\n                inReg = target;\n            }\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            sqlite3VdbeAddOp2(v, 88, target, sqlite3AffinityType(pExpr->u.zToken, 0));\n            return inReg;\n        }\n      case 45:\n      case 171:\n        op = (op == 45) ? 53 : 52;\n        p5 = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            if (sqlite3ExprIsVector(pLeft)) {\n                codeVectorCompare(pParse, pExpr, target, op, p5);\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n                sqlite3VdbeAddOp2(v, 71, 1, inReg);\n                codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2, sqlite3VdbeCurrentAddr(v) + 2, p5, (((pExpr)->flags & (1024)) != 0));\n                assert(56 == 56);\n                ;\n                ;\n                assert(55 == 55);\n                ;\n                ;\n                assert(54 == 54);\n                ;\n                ;\n                assert(57 == 57);\n                ;\n                ;\n                assert(53 == 53);\n                ;\n                ;\n                assert(52 == 52);\n                ;\n                ;\n                if (p5 == 128) {\n                    sqlite3VdbeAddOp2(v, 71, 0, inReg);\n                } else {\n                    sqlite3VdbeAddOp3(v, 92, r1, inReg, r2);\n                }\n                ;\n                ;\n            }\n            break;\n        }\n      case 44:\n      case 43:\n      case 106:\n      case 108:\n      case 107:\n      case 110:\n      case 102:\n      case 103:\n      case 109:\n      case 104:\n      case 105:\n      case 111:\n        {\n            assert(44 == 44);\n            ;\n            assert(43 == 43);\n            ;\n            assert(106 == 106);\n            ;\n            assert(107 == 107);\n            ;\n            assert(110 == 110);\n            ;\n            assert(102 == 102);\n            ;\n            assert(103 == 103);\n            ;\n            assert(109 == 109);\n            ;\n            assert(104 == 104);\n            ;\n            assert(105 == 105);\n            ;\n            assert(111 == 111);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            sqlite3VdbeAddOp3(v, op, r2, r1, target);\n            ;\n            ;\n            break;\n        }\n      case 173:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            assert(pLeft);\n            if (pLeft->op == 155) {\n                codeInteger(pParse, pLeft, 1, target);\n                return target;\n            } else if (pLeft->op == 153) {\n                assert(!(((pExpr)->flags & (2048)) != 0));\n                codeReal(v, pLeft->u.zToken, 1, target);\n                return target;\n            } else {\n                tempX.op = 155;\n                tempX.flags = 2048 | 65536;\n                tempX.u.iValue = 0;\n                ;\n                r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n                sqlite3VdbeAddOp3(v, 107, r2, r1, target);\n                ;\n            }\n            break;\n        }\n      case 114:\n      case 19:\n        {\n            assert(114 == 114);\n            ;\n            assert(19 == 19);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            sqlite3VdbeAddOp2(v, op, r1, inReg);\n            break;\n        }\n      case 175:\n        {\n            int isTrue;\n            int bNormal;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            bNormal = pExpr->op2 == 45;\n            ;\n            ;\n            sqlite3VdbeAddOp4Int(v, 91, r1, inReg, !isTrue, isTrue ^ bNormal);\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            int addr;\n            assert(50 == 50);\n            ;\n            assert(51 == 51);\n            ;\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            addr = sqlite3VdbeAddOp1(v, op, r1);\n            ;\n            ;\n            sqlite3VdbeAddOp2(v, 71, 0, target);\n            sqlite3VdbeJumpHere(v, addr);\n            break;\n        }\n      case 168:\n        {\n            AggInfo *pInfo = pExpr->pAggInfo;\n            if (pInfo == 0 || (pExpr->iAgg < 0) || (pExpr->iAgg >= pInfo->nFunc)) {\n                assert(!(((pExpr)->flags & (2048)) != 0));\n                sqlite3ErrorMsg(pParse, \"misuse of aggregate: %#T()\", pExpr);\n            } else {\n                return pInfo->aFunc[pExpr->iAgg].iMem;\n            }\n            break;\n        }\n      case 172:\n        {\n            ExprList *pFarg;\n            int nFarg;\n            FuncDef *pDef;\n            const char *zId;\n            u32 constMask = 0;\n            int i;\n            sqlite3 *db = pParse->db;\n            u8 enc = ((db)->enc);\n            CollSeq *pColl = 0;\n            if ((((pExpr)->flags & (16777216)) != 0)) {\n                return pExpr->y.pWin->regResult;\n            }\n            if (((pParse)->okConstFactor) && sqlite3ExprIsConstantNotJoin(pExpr)) {\n                return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);\n            }\n            assert(!(((pExpr)->flags & (65536)) != 0));\n            assert((((pExpr)->flags & 4096) == 0));\n            pFarg = pExpr->x.pList;\n            nFarg = pFarg ? pFarg->nExpr : 0;\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            zId = pExpr->u.zToken;\n            pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n            if (pDef == 0 || pDef->xFinalize != 0) {\n                sqlite3ErrorMsg(pParse, \"unknown function: %#T()\", pExpr);\n                break;\n            }\n            if (pDef->funcFlags & 4194304) {\n                assert((pDef->funcFlags & 2097152) == 0);\n                assert((pDef->funcFlags & 524288) == 0);\n                return exprCodeInlineFunction(pParse, pFarg, ((int)(long)(pDef->pUserData)), target);\n            } else if (pDef->funcFlags & (524288 | 2097152)) {\n                sqlite3ExprFunctionUsable(pParse, pExpr, pDef);\n            }\n            for (i = 0; i < nFarg; i++) {\n                if (i < 32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr)) {\n                    ;\n                    constMask |= (((unsigned int)1) << (i));\n                }\n                if ((pDef->funcFlags & 32) != 0 && !pColl) {\n                    pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n                }\n            }\n            if (pFarg) {\n                if (constMask) {\n                    r1 = pParse->nMem + 1;\n                    pParse->nMem += nFarg;\n                } else {\n                    r1 = sqlite3GetTempRange(pParse, nFarg);\n                }\n                if ((pDef->funcFlags & (64 | 128)) != 0) {\n                    u8 exprOp;\n                    assert(nFarg == 1);\n                    assert(pFarg->a[0].pExpr != 0);\n                    exprOp = pFarg->a[0].pExpr->op;\n                    if (exprOp == 167 || exprOp == 169) {\n                        assert(64 == 64);\n                        assert(128 == 128);\n                        ;\n                        pFarg->a[0].pExpr->op2 = pDef->funcFlags & (64 | 128);\n                    }\n                }\n                sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, 1 | 2);\n            } else {\n                r1 = 0;\n            }\n            if (nFarg >= 2 && (((pExpr)->flags & (256)) != 0)) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n            } else if (nFarg > 0) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n            }\n            if (pDef->funcFlags & 32) {\n                if (!pColl)\n                    pColl = db->pDfltColl;\n                sqlite3VdbeAddOp4(v, 85, 0, 0, 0, (char *)pColl, (-2));\n            }\n            sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg, pDef, pExpr->op2);\n            if (nFarg) {\n                if (constMask == 0) {\n                    sqlite3ReleaseTempRange(pParse, r1, nFarg);\n                } else {\n                    ;\n                }\n            }\n            return target;\n        }\n      case 20:\n      case 138:\n        {\n            int nCol;\n            ;\n            ;\n            if (pParse->db->mallocFailed) {\n                return 0;\n            } else if (op == 138 && ((((pExpr)->flags & 4096) != 0)) && (nCol = pExpr->x.pSelect->pEList->nExpr) != 1) {\n                sqlite3SubselectError(pParse, nCol, 1);\n            } else {\n                return sqlite3CodeSubselect(pParse, pExpr);\n            }\n            break;\n        }\n      case 178:\n        {\n            int n;\n            Expr *pLeft = pExpr->pLeft;\n            if (pLeft->iTable == 0 || pParse->withinRJSubrtn > pLeft->op2) {\n                pLeft->iTable = sqlite3CodeSubselect(pParse, pLeft);\n                pLeft->op2 = pParse->withinRJSubrtn;\n            }\n            assert(pLeft->op == 138 || pLeft->op == 182);\n            n = sqlite3ExprVectorSize(pLeft);\n            if (pExpr->iTable != n) {\n                sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\", pExpr->iTable, n);\n            }\n            return pLeft->iTable + pExpr->iColumn;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = sqlite3VdbeMakeLabel(pParse);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            sqlite3VdbeAddOp2(v, 86, target, 0);\n            sqlite3VdbeResolveLabel(v, destIfNull);\n            return target;\n        }\n      case 48:\n        {\n            exprCodeBetween(pParse, pExpr, target, 0, 0);\n            return target;\n        }\n      case 113:\n        {\n            if (!(((pExpr)->flags & (512)) != 0) && (pExpr->pLeft) && pExpr->pLeft->op == 172) {\n                inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                if (inReg != target) {\n                    sqlite3VdbeAddOp2(v, 81, inReg, target);\n                    inReg = target;\n                }\n                sqlite3VdbeAddOp1(v, 179, inReg);\n                return inReg;\n            } else {\n                pExpr = pExpr->pLeft;\n                goto expr_code_doover;\n            }\n        }\n      case 181:\n      case 174:\n        {\n            pExpr = pExpr->pLeft;\n            goto expr_code_doover;\n        }\n      case 77:\n        {\n            Table *pTab;\n            int iCol;\n            int p1;\n            assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n            pTab = pExpr->y.pTab;\n            iCol = pExpr->iColumn;\n            p1 = pExpr->iTable * (pTab->nCol + 1) + 1 + sqlite3TableColumnToStorage(pTab, iCol);\n            assert(pExpr->iTable == 0 || pExpr->iTable == 1);\n            assert(iCol >= -1 && iCol < pTab->nCol);\n            assert(pTab->iPKey < 0 || iCol != pTab->iPKey);\n            assert(p1 >= 0 && p1 < (pTab->nCol * 2 + 2));\n            sqlite3VdbeAddOp2(v, 157, p1, target);\n            ;\n            if (iCol >= 0 && pTab->aCol[iCol].affinity == 69) {\n                sqlite3VdbeAddOp1(v, 87, target);\n            }\n            break;\n        }\n      case 177:\n        {\n            sqlite3ErrorMsg(pParse, \"row value misused\");\n            break;\n        }\n      case 179:\n        {\n            int addrINR;\n            u8 okConstFactor = pParse->okConstFactor;\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            if (pAggInfo) {\n                assert(pExpr->iAgg >= 0 && pExpr->iAgg < pAggInfo->nColumn);\n                if (!pAggInfo->directMode) {\n                    inReg = pAggInfo->aCol[pExpr->iAgg].iMem;\n                    break;\n                }\n                if (pExpr->pAggInfo->useSortingIdx) {\n                    sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pAggInfo->aCol[pExpr->iAgg].iSorterColumn, target);\n                    inReg = target;\n                    break;\n                }\n            }\n            addrINR = sqlite3VdbeAddOp1(v, 20, pExpr->iTable);\n            pParse->okConstFactor = 0;\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            pParse->okConstFactor = okConstFactor;\n            sqlite3VdbeJumpHere(v, addrINR);\n            sqlite3VdbeChangeP3(v, addrINR, inReg);\n            break;\n        }\n      case 157:\n        {\n            int endLabel;\n            int nextCase;\n            int nExpr;\n            int i;\n            ExprList *pEList;\n            struct ExprList_item *aListelem;\n            Expr opCompare;\n            Expr *pX;\n            Expr *pTest = 0;\n            Expr *pDel = 0;\n            sqlite3 *db = pParse->db;\n            assert((((pExpr)->flags & 4096) == 0) && pExpr->x.pList != 0);\n            assert(pExpr->x.pList->nExpr > 0);\n            pEList = pExpr->x.pList;\n            aListelem = pEList->a;\n            nExpr = pEList->nExpr;\n            endLabel = sqlite3VdbeMakeLabel(pParse);\n            if ((pX = pExpr->pLeft) != 0) {\n                pDel = sqlite3ExprDup(db, pX, 0);\n                if (db->mallocFailed) {\n                    sqlite3ExprDelete(db, pDel);\n                    break;\n                }\n                ;\n                exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n                ;\n                memset(&opCompare, 0, sizeof (opCompare));\n                opCompare.op = 53;\n                opCompare.pLeft = pDel;\n                pTest = &opCompare;\n                regFree1 = 0;\n            }\n            for (i = 0; i < nExpr - 1; i = i + 2) {\n                if (pX) {\n                    assert(pTest != 0);\n                    opCompare.pRight = aListelem[i].pExpr;\n                } else {\n                    pTest = aListelem[i].pExpr;\n                }\n                nextCase = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pTest, nextCase, 16);\n                ;\n                sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, target);\n                sqlite3VdbeGoto(v, endLabel);\n                sqlite3VdbeResolveLabel(v, nextCase);\n            }\n            if ((nExpr & 1) != 0) {\n                sqlite3ExprCode(pParse, pEList->a[nExpr - 1].pExpr, target);\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, target);\n            }\n            sqlite3ExprDelete(db, pDel);\n            setDoNotMergeFlagOnCopy(v);\n            sqlite3VdbeResolveLabel(v, endLabel);\n            break;\n        }\n      case 71:\n        {\n            assert(pExpr->affExpr == 1 || pExpr->affExpr == 2 || pExpr->affExpr == 3 || pExpr->affExpr == 4);\n            if (!pParse->pTriggerTab && !pParse->nested) {\n                sqlite3ErrorMsg(pParse, \"RAISE() may only be used within a trigger-program\");\n                return 0;\n            }\n            if (pExpr->affExpr == 2) {\n                sqlite3MayAbort(pParse);\n            }\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            if (pExpr->affExpr == 4) {\n                sqlite3VdbeAddOp4(v, 70, 0, 4, 0, pExpr->u.zToken, 0);\n                ;\n            } else {\n                sqlite3HaltConstraint(pParse, pParse->pTriggerTab ? (19 | (7 << 8)) : 1, pExpr->affExpr, pExpr->u.zToken, 0, 0);\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n    return inReg;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#77857:1#clearDatabasePage",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    MemPage *pPage;\n    int rc;\n    unsigned char *pCell;\n    int i;\n    int hdr;\n    CellInfo info;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    if (pgno > btreePagecount(pBt)) {\n        return sqlite3CorruptError(77872);\n    }\n    rc = getAndInitPage(pBt, pgno, &pPage, 0, 0);\n    if (rc)\n        return rc;\n    if ((pBt->openFlags & 4) == 0 && sqlite3PagerPageRefcount(pPage->pDbPage) != (1 + (pgno == 1))) {\n        rc = sqlite3CorruptError(77879);\n        goto cleardatabasepage_out;\n    }\n    hdr = pPage->hdrOffset;\n    for (i = 0; i < pPage->nCell; i++) {\n        pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (i)])[0] << 8 | (&(pPage)->aCellIdx[2 * (i)])[1])));\n        if (!pPage->leaf) {\n            rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell), 1, pnChange);\n            if (rc)\n                goto cleardatabasepage_out;\n        }\n        pPage->xParseCell(pPage, pCell, &info);\n        if (info.nLocal != info.nPayload) {\n            rc = clearCellOverflow(pPage, pCell, &info);\n        } else {\n            rc = 0;\n        }\n        ;\n        if (rc)\n            goto cleardatabasepage_out;\n    }\n    if (!pPage->leaf) {\n        rc = clearDatabasePage(pBt, sqlite3Get4byte(&pPage->aData[hdr + 8]), 1, pnChange);\n        if (rc)\n            goto cleardatabasepage_out;\n        if (pPage->intKey)\n            pnChange = 0;\n    }\n    if (pnChange) {\n        ;\n        *pnChange += pPage->nCell;\n    }\n    if (freePageFlag) {\n        freePage(pPage, &rc);\n    } else if ((rc = sqlite3PagerWrite(pPage->pDbPage)) == 0) {\n        zeroPage(pPage, pPage->aData[hdr] | 8);\n    }\n  cleardatabasepage_out:\n    releasePage(pPage);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#136870:1#sqlite3Prepare",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    int i;\n    Parse sParse;\n    memset((((char *)(&sParse)) + ((int)((char *)&((Parse *)0)->zErrMsg))), 0, (((int)((char *)&((Parse *)0)->aTempReg)) - ((int)((char *)&((Parse *)0)->zErrMsg))));\n    memset((((char *)(&sParse)) + ((int)((char *)&((Parse *)0)->sLastToken))), 0, (sizeof(Parse) - ((int)((char *)&((Parse *)0)->sLastToken))));\n    sParse.pOuterParse = db->pParse;\n    db->pParse = &sParse;\n    sParse.db = db;\n    sParse.pReprepare = pReprepare;\n    assert(ppStmt && *ppStmt == 0);\n    if (db->mallocFailed)\n        sqlite3ErrorMsg(&sParse, \"out of memory\");\n    assert(sqlite3_mutex_held(db->mutex));\n    if (prepFlags & 1) {\n        sParse.disableLookaside++;\n        db->lookaside.bDisable++;\n        db->lookaside.sz = 0;\n    }\n    sParse.prepFlags = prepFlags & 255;\n    if (!db->noSharedCache) {\n        for (i = 0; i < db->nDb; i++) {\n            Btree *pBt = db->aDb[i].pBt;\n            if (pBt) {\n                assert(sqlite3BtreeHoldsMutex(pBt));\n                rc = sqlite3BtreeSchemaLocked(pBt);\n                if (rc) {\n                    const char *zDb = db->aDb[i].zDbSName;\n                    sqlite3ErrorWithMsg(db, rc, \"database schema is locked: %s\", zDb);\n                    ;\n                    goto end_prepare;\n                }\n            }\n        }\n    }\n    if (db->pDisconnect)\n        sqlite3VtabUnlockList(db);\n    if (nBytes >= 0 && (nBytes == 0 || zSql[nBytes - 1] != 0)) {\n        char *zSqlCopy;\n        int mxLen = db->aLimit[1];\n        ;\n        ;\n        if (nBytes > mxLen) {\n            sqlite3ErrorWithMsg(db, 18, \"statement too long\");\n            rc = sqlite3ApiExit(db, 18);\n            goto end_prepare;\n        }\n        zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);\n        if (zSqlCopy) {\n            sqlite3RunParser(&sParse, zSqlCopy);\n            sParse.zTail = &zSql[sParse.zTail - zSqlCopy];\n            sqlite3DbFree(db, zSqlCopy);\n        } else {\n            sParse.zTail = &zSql[nBytes];\n        }\n    } else {\n        sqlite3RunParser(&sParse, zSql);\n    }\n    assert(0 == sParse.nQueryLoop);\n    if (pzTail) {\n        *pzTail = sParse.zTail;\n    }\n    if (db->init.busy == 0) {\n        sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail - zSql), prepFlags);\n    }\n    if (db->mallocFailed) {\n        sParse.rc = 7;\n        sParse.checkSchema = 0;\n    }\n    if (sParse.rc != 0 && sParse.rc != 101) {\n        if (sParse.checkSchema && db->init.busy == 0) {\n            schemaIsValid(&sParse);\n        }\n        if (sParse.pVdbe) {\n            sqlite3VdbeFinalize(sParse.pVdbe);\n        }\n        assert(0 == (*ppStmt));\n        rc = sParse.rc;\n        if (sParse.zErrMsg) {\n            sqlite3ErrorWithMsg(db, rc, \"%s\", sParse.zErrMsg);\n            sqlite3DbFree(db, sParse.zErrMsg);\n        } else {\n            sqlite3Error(db, rc);\n        }\n    } else {\n        assert(sParse.zErrMsg == 0);\n        *ppStmt = (sqlite3_stmt *)sParse.pVdbe;\n        rc = 0;\n        sqlite3ErrorClear(db);\n    }\n    while (sParse.pTriggerPrg)\n        {\n            TriggerPrg *pT = sParse.pTriggerPrg;\n            sParse.pTriggerPrg = pT->pNext;\n            sqlite3DbFree(db, pT);\n        }\n  end_prepare:\n    sqlite3ParseObjectReset(&sParse);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#60610:1#getPageNormal",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    PgHdr *pPg;\n    u8 noContent;\n    sqlite3_pcache_page *pBase;\n    assert(pPager->errCode == 0);\n    assert(pPager->eState >= 1);\n    assert(assert_pager_state(pPager));\n    assert(pPager->hasHeldSharedLock == 1);\n    if (pgno == 0)\n        return sqlite3CorruptError(60626);\n    pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);\n    if (pBase == 0) {\n        pPg = 0;\n        rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);\n        if (rc != 0)\n            goto pager_acquire_err;\n        if (pBase == 0) {\n            rc = 7;\n            goto pager_acquire_err;\n        }\n    }\n    pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);\n    assert(pPg == (*ppPage));\n    assert(pPg->pgno == pgno);\n    assert(pPg->pPager == pPager || pPg->pPager == 0);\n    noContent = (flags & 1) != 0;\n    if (pPg->pPager && !noContent) {\n        assert(pgno != ((pPager)->lckPgno));\n        pPager->aStat[0]++;\n        return 0;\n    } else {\n        if (pgno == ((pPager)->lckPgno)) {\n            rc = sqlite3CorruptError(60658);\n            goto pager_acquire_err;\n        }\n        pPg->pPager = pPager;\n        assert(!((pPager->fd)->pMethods != 0) || !pPager->memDb);\n        if (!((pPager->fd)->pMethods != 0) || pPager->dbSize < pgno || noContent) {\n            if (pgno > pPager->mxPgno) {\n                rc = 13;\n                goto pager_acquire_err;\n            }\n            if (noContent) {\n                sqlite3BeginBenignMalloc();\n                if (pgno <= pPager->dbOrigSize) {\n                    sqlite3BitvecSet(pPager->pInJournal, pgno);\n                    ;\n                }\n                addToSavepointBitvecs(pPager, pgno);\n                ;\n                sqlite3EndBenignMalloc();\n            }\n            memset(pPg->pData, 0, pPager->pageSize);\n            ;\n        } else {\n            assert(pPg->pPager == pPager);\n            pPager->aStat[1]++;\n            rc = readDbPage(pPg);\n            if (rc != 0) {\n                goto pager_acquire_err;\n            }\n        }\n        ;\n    }\n    return 0;\n  pager_acquire_err:\n    assert(rc != 0);\n    if (pPg) {\n        sqlite3PcacheDrop(pPg);\n    }\n    pagerUnlockIfUnused(pPager);\n    *ppPage = 0;\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#198464:1#jsonLookup",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    const char *zErr = 0;\n    JsonNode *pNode = 0;\n    char *zMsg;\n    if (zPath == 0)\n        return 0;\n    if (zPath[0] != '$') {\n        zErr = zPath;\n        goto lookup_err;\n    }\n    zPath++;\n    pNode = jsonLookupStep(pParse, 0, zPath, pApnd, &zErr);\n    if (zErr == 0)\n        return pNode;\n  lookup_err:\n    pParse->nErr++;\n    assert(zErr != 0 && pCtx != 0);\n    zMsg = jsonPathSyntaxError(zErr);\n    if (zMsg) {\n        sqlite3_result_error(pCtx, zMsg, -1);\n        sqlite3_free(zMsg);\n    } else {\n        sqlite3_result_error_nomem(pCtx);\n    }\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#103139:1#lookupName",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    int i, j;\n    int cnt = 0;\n    int cntTab = 0;\n    int nSubquery = 0;\n    sqlite3 *db = pParse->db;\n    SrcItem *pItem;\n    SrcItem *pMatch = 0;\n    NameContext *pTopNC = pNC;\n    Schema *pSchema = 0;\n    int eNewExprOp = 167;\n    Table *pTab = 0;\n    Column *pCol;\n    ExprList *pFJMatch = 0;\n    assert(pNC);\n    assert(zCol);\n    assert(zDb == 0 || zTab != 0);\n    assert(!(((pExpr)->flags & (65536 | 16384)) != 0));\n    pExpr->iTable = -1;\n    ;\n    if (zDb) {\n        ;\n        ;\n        if ((pNC->ncFlags & (2 | 4)) != 0) {\n            zDb = 0;\n        } else {\n            for (i = 0; i < db->nDb; i++) {\n                assert(db->aDb[i].zDbSName);\n                if (sqlite3StrICmp(db->aDb[i].zDbSName, zDb) == 0) {\n                    pSchema = db->aDb[i].pSchema;\n                    break;\n                }\n            }\n            if (i == db->nDb && sqlite3StrICmp(\"main\", zDb) == 0) {\n                pSchema = db->aDb[0].pSchema;\n                zDb = db->aDb[0].zDbSName;\n            }\n        }\n    }\n    assert(pNC && cnt == 0);\n    do {\n        ExprList *pEList;\n        SrcList *pSrcList = pNC->pSrcList;\n        if (pSrcList) {\n            for (i = 0 , pItem = pSrcList->a; i < pSrcList->nSrc; i++ , pItem++) {\n                u8 hCol;\n                pTab = pItem->pTab;\n                assert(pTab != 0 && pTab->zName != 0);\n                assert(pTab->nCol > 0 || pParse->nErr);\n                assert((int)pItem->fg.isNestedFrom == ((pItem->pSelect) != 0 && ((pItem->pSelect)->selFlags & 2048) != 0));\n                if (pItem->fg.isNestedFrom) {\n                    int hit = 0;\n                    assert(pItem->pSelect != 0);\n                    pEList = pItem->pSelect->pEList;\n                    assert(pEList != 0);\n                    assert(pEList->nExpr == pTab->nCol);\n                    for (j = 0; j < pEList->nExpr; j++) {\n                        if (!sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb)) {\n                            continue;\n                        }\n                        if (cnt > 0) {\n                            if (pItem->fg.isUsing == 0 || sqlite3IdListIndex(pItem->u3.pUsing, zCol) < 0) {\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else if ((pItem->fg.jointype & 16) == 0) {\n                                continue;\n                            } else if ((pItem->fg.jointype & 8) == 0) {\n                                cnt = 0;\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else {\n                                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                            }\n                        }\n                        cnt++;\n                        cntTab = 2;\n                        pMatch = pItem;\n                        pExpr->iColumn = j;\n                        pEList->a[j].fg.bUsed = 1;\n                        hit = 1;\n                        if (pEList->a[j].fg.bUsingTerm)\n                            break;\n                    }\n                    if (hit || zTab == 0)\n                        continue;\n                }\n                assert(zDb == 0 || zTab != 0);\n                if (zTab) {\n                    const char *zTabName;\n                    if (zDb) {\n                        if (pTab->pSchema != pSchema)\n                            continue;\n                        if (pSchema == 0 && strcmp(zDb, \"*\") != 0)\n                            continue;\n                    }\n                    zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;\n                    assert(zTabName != 0);\n                    if (sqlite3StrICmp(zTabName, zTab) != 0) {\n                        continue;\n                    }\n                    assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                    if ((pParse->eParseMode >= 2) && pItem->zAlias) {\n                        sqlite3RenameTokenRemap(pParse, 0, (void *)&pExpr->y.pTab);\n                    }\n                }\n                hCol = sqlite3StrIHash(zCol);\n                for (j = 0 , pCol = pTab->aCol; j < pTab->nCol; j++ , pCol++) {\n                    if (pCol->hName == hCol && sqlite3StrICmp(pCol->zCnName, zCol) == 0) {\n                        if (cnt > 0) {\n                            if (pItem->fg.isUsing == 0 || sqlite3IdListIndex(pItem->u3.pUsing, zCol) < 0) {\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else if ((pItem->fg.jointype & 16) == 0) {\n                                continue;\n                            } else if ((pItem->fg.jointype & 8) == 0) {\n                                cnt = 0;\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else {\n                                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                            }\n                        }\n                        cnt++;\n                        pMatch = pItem;\n                        pExpr->iColumn = j == pTab->iPKey ? -1 : (i16)j;\n                        if (pItem->fg.isNestedFrom) {\n                            sqlite3SrcItemColumnUsed(pItem, j);\n                        }\n                        break;\n                    }\n                }\n                if (0 == cnt && (((pTab)->tabFlags & 512) == 0)) {\n                    cntTab++;\n                    pMatch = pItem;\n                }\n            }\n            if (pMatch) {\n                pExpr->iTable = pMatch->iCursor;\n                assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                pExpr->y.pTab = pMatch->pTab;\n                if ((pMatch->fg.jointype & (8 | 64)) != 0) {\n                    (pExpr)->flags |= (2097152);\n                }\n                pSchema = pExpr->y.pTab->pSchema;\n            }\n        }\n        if (cnt == 0 && zDb == 0) {\n            pTab = 0;\n            if (pParse->pTriggerTab != 0) {\n                int op = pParse->eTriggerOp;\n                assert(op == 128 || op == 129 || op == 127);\n                if (pParse->bReturning) {\n                    if ((pNC->ncFlags & 1024) != 0 && (zTab == 0 || sqlite3StrICmp(zTab, pParse->pTriggerTab->zName) == 0)) {\n                        pExpr->iTable = op != 128;\n                        pTab = pParse->pTriggerTab;\n                    }\n                } else if (op != 128 && zTab && sqlite3StrICmp(\"new\", zTab) == 0) {\n                    pExpr->iTable = 1;\n                    pTab = pParse->pTriggerTab;\n                } else if (op != 127 && zTab && sqlite3StrICmp(\"old\", zTab) == 0) {\n                    pExpr->iTable = 0;\n                    pTab = pParse->pTriggerTab;\n                }\n            }\n            if ((pNC->ncFlags & 512) != 0 && zTab != 0) {\n                Upsert *pUpsert = pNC->uNC.pUpsert;\n                if (pUpsert && sqlite3StrICmp(\"excluded\", zTab) == 0) {\n                    pTab = pUpsert->pUpsertSrc->a[0].pTab;\n                    pExpr->iTable = 2;\n                }\n            }\n            if (pTab) {\n                int iCol;\n                u8 hCol = sqlite3StrIHash(zCol);\n                pSchema = pTab->pSchema;\n                cntTab++;\n                for (iCol = 0 , pCol = pTab->aCol; iCol < pTab->nCol; iCol++ , pCol++) {\n                    if (pCol->hName == hCol && sqlite3StrICmp(pCol->zCnName, zCol) == 0) {\n                        if (iCol == pTab->iPKey) {\n                            iCol = -1;\n                        }\n                        break;\n                    }\n                }\n                if (iCol >= pTab->nCol && sqlite3IsRowid(zCol) && (((pTab)->tabFlags & 512) == 0)) {\n                    iCol = -1;\n                }\n                if (iCol < pTab->nCol) {\n                    cnt++;\n                    pMatch = 0;\n                    if (pExpr->iTable == 2) {\n                        ;\n                        assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                        if ((pParse->eParseMode >= 2)) {\n                            pExpr->iColumn = iCol;\n                            pExpr->y.pTab = pTab;\n                            eNewExprOp = 167;\n                        } else {\n                            pExpr->iTable = pNC->uNC.pUpsert->regData + sqlite3TableColumnToStorage(pTab, iCol);\n                            eNewExprOp = 176;\n                        }\n                    } else {\n                        assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                        pExpr->y.pTab = pTab;\n                        if (pParse->bReturning) {\n                            eNewExprOp = 176;\n                            pExpr->op2 = 167;\n                            pExpr->iTable = pNC->uNC.iBaseReg + (pTab->nCol + 1) * pExpr->iTable + sqlite3TableColumnToStorage(pTab, iCol) + 1;\n                        } else {\n                            pExpr->iColumn = (i16)iCol;\n                            eNewExprOp = 77;\n                            if (iCol < 0) {\n                                pExpr->affExpr = 68;\n                            } else if (pExpr->iTable == 0) {\n                                ;\n                                ;\n                                pParse->oldmask |= (iCol >= 32 ? 4294967295U : (((u32)1) << iCol));\n                            } else {\n                                ;\n                                ;\n                                pParse->newmask |= (iCol >= 32 ? 4294967295U : (((u32)1) << iCol));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (cnt == 0 && cntTab == 1 && pMatch && (pNC->ncFlags & (32 | 8)) == 0 && sqlite3IsRowid(zCol) && ((((pMatch->pTab)->tabFlags & 512) == 0))) {\n            cnt = 1;\n            pExpr->iColumn = -1;\n            pExpr->affExpr = 68;\n        }\n        if (cnt == 0 && (pNC->ncFlags & 128) != 0 && zTab == 0) {\n            pEList = pNC->uNC.pEList;\n            assert(pEList != 0);\n            for (j = 0; j < pEList->nExpr; j++) {\n                char *zAs = pEList->a[j].zEName;\n                if (pEList->a[j].fg.eEName == 0 && sqlite3_stricmp(zAs, zCol) == 0) {\n                    Expr *pOrig;\n                    assert(pExpr->pLeft == 0 && pExpr->pRight == 0);\n                    assert((((pExpr)->flags & 4096) == 0) == 0 || pExpr->x.pList == 0);\n                    assert((((pExpr)->flags & 4096) != 0) == 0 || pExpr->x.pSelect == 0);\n                    pOrig = pEList->a[j].pExpr;\n                    if ((pNC->ncFlags & 1) == 0 && (((pOrig)->flags & (16)) != 0)) {\n                        sqlite3ErrorMsg(pParse, \"misuse of aliased aggregate %s\", zAs);\n                        return 2;\n                    }\n                    if ((((pOrig)->flags & (32768)) != 0) && ((pNC->ncFlags & 16384) == 0 || pNC != pTopNC)) {\n                        sqlite3ErrorMsg(pParse, \"misuse of aliased window function %s\", zAs);\n                        return 2;\n                    }\n                    if (sqlite3ExprVectorSize(pOrig) != 1) {\n                        sqlite3ErrorMsg(pParse, \"row value misused\");\n                        return 2;\n                    }\n                    resolveAlias(pParse, pEList, j, pExpr, nSubquery);\n                    cnt = 1;\n                    pMatch = 0;\n                    assert(zTab == 0 && zDb == 0);\n                    if ((pParse->eParseMode >= 2)) {\n                        sqlite3RenameTokenRemap(pParse, 0, (void *)pExpr);\n                    }\n                    goto lookupname_end;\n                }\n            }\n        }\n        if (cnt)\n            break;\n        pNC = pNC->pNext;\n        nSubquery++;\n    } while (pNC);\n    if (cnt == 0 && zTab == 0) {\n        assert(pExpr->op == 59);\n        if ((((pExpr)->flags & (128)) != 0) && areDoubleQuotedStringsEnabled(db, pTopNC)) {\n            sqlite3_log(28, \"double-quoted string literal: \\\"%w\\\"\", zCol);\n            pExpr->op = 117;\n            memset(&pExpr->y, 0, sizeof (pExpr->y));\n            return 1;\n        }\n        if (sqlite3ExprIdToTrueFalse(pExpr)) {\n            return 1;\n        }\n    }\n    assert(pFJMatch == 0 || cnt > 0);\n    assert(!(((pExpr)->flags & (4096 | 2048)) != 0));\n    if (cnt != 1) {\n        const char *zErr;\n        if (pFJMatch) {\n            if (pFJMatch->nExpr == cnt - 1) {\n                if ((((pExpr)->flags & (8388608)) != 0)) {\n                    (pExpr)->flags &= ~(8388608);\n                } else {\n                    sqlite3ExprDelete(db, pExpr->pLeft);\n                    pExpr->pLeft = 0;\n                    sqlite3ExprDelete(db, pExpr->pRight);\n                    pExpr->pRight = 0;\n                }\n                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                pExpr->op = 172;\n                pExpr->u.zToken = \"coalesce\";\n                pExpr->x.pList = pFJMatch;\n                cnt = 1;\n                goto lookupname_end;\n            } else {\n                sqlite3ExprListDelete(db, pFJMatch);\n                pFJMatch = 0;\n            }\n        }\n        zErr = cnt == 0 ? \"no such column\" : \"ambiguous column name\";\n        if (zDb) {\n            sqlite3ErrorMsg(pParse, \"%s: %s.%s.%s\", zErr, zDb, zTab, zCol);\n        } else if (zTab) {\n            sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zErr, zTab, zCol);\n        } else {\n            sqlite3ErrorMsg(pParse, \"%s: %s\", zErr, zCol);\n        }\n        sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);\n        pParse->checkSchema = 1;\n        pTopNC->nNcErr++;\n    }\n    assert(pFJMatch == 0);\n    if (!(((pExpr)->flags & ((65536 | 8388608))) != 0)) {\n        sqlite3ExprDelete(db, pExpr->pLeft);\n        pExpr->pLeft = 0;\n        sqlite3ExprDelete(db, pExpr->pRight);\n        pExpr->pRight = 0;\n        (pExpr)->flags |= (8388608);\n    }\n    if (pExpr->iColumn >= 0 && pMatch != 0) {\n        pMatch->colUsed |= sqlite3ExprColUsed(pExpr);\n    }\n    pExpr->op = eNewExprOp;\n  lookupname_end:\n    if (cnt == 1) {\n        assert(pNC != 0);\n        if (pParse->db->xAuth && (pExpr->op == 167 || pExpr->op == 77)) {\n            sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);\n        }\n        for (;;) {\n            assert(pTopNC != 0);\n            pTopNC->nRef++;\n            if (pTopNC == pNC)\n                break;\n            pTopNC = pTopNC->pNext;\n        }\n        return 1;\n    } else {\n        return 2;\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#116107:1#codeAttach",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    int rc;\n    NameContext sName;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int regArgs;\n    if (pParse->nErr)\n        goto attach_end;\n    memset(&sName, 0, sizeof(NameContext));\n    sName.pParse = pParse;\n    if (0 != resolveAttachExpr(&sName, pFilename) || 0 != resolveAttachExpr(&sName, pDbname) || 0 != resolveAttachExpr(&sName, pKey)) {\n        goto attach_end;\n    }\n    if ((pAuthArg)) {\n        char *zAuthArg;\n        if (pAuthArg->op == 117) {\n            assert(!(((pAuthArg)->flags & (2048)) != 0));\n            zAuthArg = pAuthArg->u.zToken;\n        } else {\n            zAuthArg = 0;\n        }\n        rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);\n        if (rc != 0) {\n            goto attach_end;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    regArgs = sqlite3GetTempRange(pParse, 4);\n    sqlite3ExprCode(pParse, pFilename, regArgs);\n    sqlite3ExprCode(pParse, pDbname, regArgs + 1);\n    sqlite3ExprCode(pParse, pKey, regArgs + 2);\n    assert(v || db->mallocFailed);\n    if (v) {\n        sqlite3VdbeAddFunctionCall(pParse, 0, regArgs + 3 - pFunc->nArg, regArgs + 3, pFunc->nArg, pFunc, 0);\n        sqlite3VdbeAddOp1(v, 166, (type == 24));\n    }\n  attach_end:\n    sqlite3ExprDelete(db, pFilename);\n    sqlite3ExprDelete(db, pDbname);\n    sqlite3ExprDelete(db, pKey);\n}\n"
        },
        {
            "id": "#23:25#sqlite3CreateForeignKey",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    sqlite3 *db = pParse->db;\n    FKey *pFKey = 0;\n    FKey *pNextTo;\n    Table *p = pParse->pNewTable;\n    i64 nByte;\n    int i;\n    int nCol;\n    char *z;\n    assert(pTo != 0);\n    if (p == 0 || (pParse->eParseMode == 1))\n        goto fk_end;\n    if (pFromCol == 0) {\n        int iCol = p->nCol - 1;\n        if ((iCol < 0))\n            goto fk_end;\n        if (pToCol && pToCol->nExpr != 1) {\n            sqlite3ErrorMsg(pParse, \"foreign key on %s should reference only one column of table %T\", p->aCol[iCol].zCnName, pTo);\n            goto fk_end;\n        }\n        nCol = 1;\n    } else if (pToCol && pToCol->nExpr != pFromCol->nExpr) {\n        sqlite3ErrorMsg(pParse, \"number of columns in foreign key does not match the number of columns in the referenced table\");\n        goto fk_end;\n    } else {\n        nCol = pFromCol->nExpr;\n    }\n    nByte = sizeof (*pFKey) + (nCol - 1) * sizeof (pFKey->aCol[0]) + pTo->n + 1;\n    if (pToCol) {\n        for (i = 0; i < pToCol->nExpr; i++) {\n            nByte += sqlite3Strlen30(pToCol->a[i].zEName) + 1;\n        }\n    }\n    pFKey = sqlite3DbMallocZero(db, nByte);\n    if (pFKey == 0) {\n        goto fk_end;\n    }\n    pFKey->pFrom = p;\n    assert(((p)->eTabType == 0));\n    pFKey->pNextFrom = p->u.tab.pFKey;\n    z = (char *)&pFKey->aCol[nCol];\n    pFKey->zTo = z;\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameTokenMap(pParse, (void *)z, pTo);\n    }\n    memcpy(z, pTo->z, pTo->n);\n    z[pTo->n] = 0;\n    sqlite3Dequote(z);\n    z += pTo->n + 1;\n    pFKey->nCol = nCol;\n    if (pFromCol == 0) {\n        pFKey->aCol[0].iFrom = p->nCol - 1;\n    } else {\n        for (i = 0; i < nCol; i++) {\n            int j;\n            for (j = 0; j < p->nCol; j++) {\n                if (sqlite3StrICmp(p->aCol[j].zCnName, pFromCol->a[i].zEName) == 0) {\n                    pFKey->aCol[i].iFrom = j;\n                    break;\n                }\n            }\n            if (j >= p->nCol) {\n                sqlite3ErrorMsg(pParse, \"unknown column \\\"%s\\\" in foreign key definition\", pFromCol->a[i].zEName);\n                goto fk_end;\n            }\n            if ((pParse->eParseMode >= 2)) {\n                sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zEName);\n            }\n        }\n    }\n    if (pToCol) {\n        for (i = 0; i < nCol; i++) {\n            int n = sqlite3Strlen30(pToCol->a[i].zEName);\n            pFKey->aCol[i].zCol = z;\n            if ((pParse->eParseMode >= 2)) {\n                sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zEName);\n            }\n            memcpy(z, pToCol->a[i].zEName, n);\n            z[n] = 0;\n            z += n + 1;\n        }\n    }\n    pFKey->isDeferred = 0;\n    pFKey->aAction[0] = (u8)(flags & 255);\n    pFKey->aAction[1] = (u8)((flags >> 8) & 255);\n    assert(sqlite3SchemaMutexHeld(db, 0, p->pSchema));\n    pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash, pFKey->zTo, (void *)pFKey);\n    if (pNextTo == pFKey) {\n        sqlite3OomFault(db);\n        goto fk_end;\n    }\n    if (pNextTo) {\n        assert(pNextTo->pPrevTo == 0);\n        pFKey->pNextTo = pNextTo;\n        pNextTo->pPrevTo = pFKey;\n    }\n    assert(((p)->eTabType == 0));\n    p->u.tab.pFKey = pFKey;\n    pFKey = 0;\n  fk_end:\n    sqlite3DbFree(db, pFKey);\n    sqlite3ExprListDelete(db, pFromCol);\n    sqlite3ExprListDelete(db, pToCol);\n}\n"
        },
        {
            "id": "#23:25#sqlite3VdbeExec",
            "gotos": 232,
            "labels": 21,
            "body": "{\n    Op *aOp = p->aOp;\n    Op *pOp = aOp;\n    int rc = 0;\n    sqlite3 *db = p->db;\n    u8 resetSchemaOnFault = 0;\n    u8 encoding = ((db)->enc);\n    int iCompare = 0;\n    u64 nVmStep = 0;\n    u64 nProgressLimit;\n    Mem *aMem = p->aMem;\n    Mem *pIn1 = 0;\n    Mem *pIn2 = 0;\n    Mem *pIn3 = 0;\n    Mem *pOut = 0;\n    assert(p->eVdbeState == 2);\n    sqlite3VdbeEnter(p);\n    if (db->xProgress) {\n        u32 iPrior = p->aCounter[4];\n        assert(0 < db->nProgressOps);\n        nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);\n    } else {\n        nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n    }\n    if (p->rc == 7) {\n        goto no_mem;\n    }\n    assert(p->rc == 0 || (p->rc & 255) == 5);\n    ;\n    p->rc = 0;\n    assert(p->bIsReader || p->readOnly != 0);\n    p->iCurrentTime = 0;\n    assert(p->explain == 0);\n    p->pResultSet = 0;\n    db->busyHandler.nBusy = 0;\n    if (__atomic_load_n((&db->u1.isInterrupted), 0))\n        goto abort_due_to_interrupt;\n    ;\n    for (pOp = &aOp[p->pc]; 1; pOp++) {\n        assert(rc == 0);\n        assert(pOp >= aOp && pOp < &aOp[p->nOp]);\n        nVmStep++;\n        switch (pOp->opcode) {\n          case 9:\n            {\n              jump_to_p2_and_check_for_interrupt:\n                pOp = &aOp[pOp->p2 - 1];\n              check_for_interrupt:\n                if (__atomic_load_n((&db->u1.isInterrupted), 0))\n                    goto abort_due_to_interrupt;\n                while (nVmStep >= nProgressLimit && db->xProgress != 0)\n                    {\n                        assert(db->nProgressOps != 0);\n                        nProgressLimit += db->nProgressOps;\n                        if (db->xProgress(db->pProgressArg)) {\n                            nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                            rc = 9;\n                            goto abort_due_to_error;\n                        }\n                    }\n                break;\n            }\n          case 10:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert((((pIn1)->flags & (32768 | 4096)) != 0) == 0);\n                ;\n                pIn1->flags = 4;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                goto jump_to_p2_and_check_for_interrupt;\n            }\n          case 67:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & 4) {\n                    if (pOp->p3) {\n                        ;\n                    }\n                    pOp = &aOp[pIn1->u.i];\n                } else if ((pOp->p3)) {\n                    ;\n                }\n                break;\n            }\n          case 11:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                assert(pOp->p2 >= 0 && pOp->p2 < p->nOp);\n                assert(pOp->p3 >= 0 && pOp->p3 < p->nOp);\n                pOut = &aMem[pOp->p1];\n                assert(!(((pOut)->flags & (32768 | 4096)) != 0));\n                pOut->u.i = pOp->p3 - 1;\n                pOut->flags = 4;\n                if (pOp->p2 == 0)\n                    break;\n              jump_to_p2:\n                assert(pOp->p2 > 0);\n                assert(pOp->p2 < p->nOp);\n                pOp = &aOp[pOp->p2 - 1];\n                break;\n            }\n          case 68:\n            {\n                VdbeOp *pCaller;\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags == 4);\n                assert(pIn1->u.i >= 0 && pIn1->u.i < p->nOp);\n                pCaller = &aOp[pIn1->u.i];\n                assert(pCaller->opcode == 12);\n                assert(pCaller->p2 >= 0 && pCaller->p2 < p->nOp);\n                pOp = &aOp[pCaller->p2 - 1];\n                pIn1->flags = 0;\n                break;\n            }\n          case 12:\n            {\n                int pcDest;\n                pIn1 = &aMem[pOp->p1];\n                assert((((pIn1)->flags & (32768 | 4096)) != 0) == 0);\n                pIn1->flags = 4;\n                pcDest = (int)pIn1->u.i;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                pOp = &aOp[pcDest];\n                break;\n            }\n          case 69:\n            {\n                pIn3 = &aMem[pOp->p3];\n                if ((pIn3->flags & 1) == 0)\n                    break;\n            }\n          case 70:\n            {\n                VdbeFrame *pFrame;\n                int pcx;\n                if (p->pFrame && pOp->p1 == 0) {\n                    pFrame = p->pFrame;\n                    p->pFrame = pFrame->pParent;\n                    p->nFrame--;\n                    sqlite3VdbeSetChanges(db, p->nChange);\n                    pcx = sqlite3VdbeFrameRestore(pFrame);\n                    if (pOp->p2 == 4) {\n                        pcx = p->aOp[pcx].p2 - 1;\n                    }\n                    aOp = p->aOp;\n                    aMem = p->aMem;\n                    pOp = &aOp[pcx];\n                    break;\n                }\n                p->rc = pOp->p1;\n                p->errorAction = (u8)pOp->p2;\n                assert(pOp->p5 <= 4);\n                if (p->rc) {\n                    if (pOp->p5) {\n                        static const char *const azType[] = {\"NOT NULL\", \"UNIQUE\", \"CHECK\", \"FOREIGN KEY\"};\n                        ;\n                        ;\n                        ;\n                        ;\n                        sqlite3VdbeError(p, \"%s constraint failed\", azType[pOp->p5 - 1]);\n                        if (pOp->p4.z) {\n                            p->zErrMsg = sqlite3MPrintf(db, \"%z: %s\", p->zErrMsg, pOp->p4.z);\n                        }\n                    } else {\n                        sqlite3VdbeError(p, \"%s\", pOp->p4.z);\n                    }\n                    pcx = (int)(pOp - aOp);\n                    sqlite3_log(pOp->p1, \"abort at %d in [%s]: %s\", pcx, p->zSql, p->zErrMsg);\n                }\n                rc = sqlite3VdbeHalt(p);\n                assert(rc == 5 || rc == 0 || rc == 1);\n                if (rc == 5) {\n                    p->rc = 5;\n                } else {\n                    assert(rc == 0 || (p->rc & 255) == 19);\n                    assert(rc == 0 || db->nDeferredCons > 0 || db->nDeferredImmCons > 0);\n                    rc = p->rc ? 1 : 101;\n                }\n                goto vdbe_return;\n            }\n          case 71:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = pOp->p1;\n                break;\n            }\n          case 72:\n            {\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p4.pI64 != 0);\n                pOut->u.i = *pOp->p4.pI64;\n                break;\n            }\n          case 153:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 8;\n                assert(!sqlite3IsNaN(*pOp->p4.pReal));\n                pOut->u.r = *pOp->p4.pReal;\n                break;\n            }\n          case 117:\n            {\n                assert(pOp->p4.z != 0);\n                pOut = out2Prerelease(p, pOp);\n                pOp->p1 = sqlite3Strlen30(pOp->p4.z);\n                if (encoding != 1) {\n                    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, 1, ((sqlite3_destructor_type)0));\n                    assert(rc == 0 || rc == 18);\n                    if (rc)\n                        goto too_big;\n                    if (0 != sqlite3VdbeChangeEncoding(pOut, encoding))\n                        goto no_mem;\n                    assert(pOut->szMalloc > 0 && pOut->zMalloc == pOut->z);\n                    assert((((pOut)->flags & (32768 | 4096)) != 0) == 0);\n                    pOut->szMalloc = 0;\n                    pOut->flags |= 8192;\n                    if (pOp->p4type == (-6)) {\n                        sqlite3DbFree(db, pOp->p4.z);\n                    }\n                    pOp->p4type = (-6);\n                    pOp->p4.z = pOut->z;\n                    pOp->p1 = pOut->n;\n                }\n                if (pOp->p1 > db->aLimit[0]) {\n                    goto too_big;\n                }\n                pOp->opcode = 73;\n                assert(rc == 0);\n            }\n          case 73:\n            {\n                assert(pOp->p4.z != 0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = pOp->p4.z;\n                pOut->n = pOp->p1;\n                pOut->enc = encoding;\n                ;\n                if (pOp->p3 > 0) {\n                    assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                    pIn3 = &aMem[pOp->p3];\n                    assert(pIn3->flags & 4);\n                    if (pIn3->u.i == pOp->p5)\n                        pOut->flags = 16 | 8192 | 512;\n                }\n                break;\n            }\n          case 74:\n          case 75:\n            {\n                int cnt;\n                u16 nullFlag;\n                pOut = out2Prerelease(p, pOp);\n                cnt = pOp->p3 - pOp->p2;\n                assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pOut->flags = nullFlag = pOp->p1 ? (1 | 256) : 1;\n                pOut->n = 0;\n                while (cnt > 0)\n                    {\n                        pOut++;\n                        ;\n                        sqlite3VdbeMemSetNull(pOut);\n                        pOut->flags = nullFlag;\n                        pOut->n = 0;\n                        cnt--;\n                    }\n                break;\n            }\n          case 76:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pOut = &aMem[pOp->p1];\n                pOut->flags = (pOut->flags & ~(0 | 63)) | 1;\n                break;\n            }\n          case 77:\n            {\n                assert(pOp->p1 <= 1000000000);\n                pOut = out2Prerelease(p, pOp);\n                if (pOp->p4.z == 0) {\n                    sqlite3VdbeMemSetZeroBlob(pOut, pOp->p1);\n                    if (sqlite3VdbeMemExpandBlob(pOut))\n                        goto no_mem;\n                } else {\n                    sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);\n                }\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 78:\n            {\n                Mem *pVar;\n                assert(pOp->p1 > 0 && pOp->p1 <= p->nVar);\n                assert(pOp->p4.z == 0 || pOp->p4.z == sqlite3VListNumToName(p->pVList, pOp->p1));\n                pVar = &p->aVar[pOp->p1 - 1];\n                if (sqlite3VdbeMemTooBig(pVar)) {\n                    goto too_big;\n                }\n                pOut = &aMem[pOp->p2];\n                if ((((pOut)->flags & (32768 | 4096)) != 0))\n                    sqlite3VdbeMemSetNull(pOut);\n                memcpy(pOut, pVar, ((int)((char *)&((Mem *)0)->db)));\n                pOut->flags &= ~(4096 | 16384);\n                pOut->flags |= 8192 | 64;\n                ;\n                break;\n            }\n          case 79:\n            {\n                int n;\n                int p1;\n                int p2;\n                n = pOp->p3;\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                assert(n > 0 && p1 > 0 && p2 > 0);\n                assert(p1 + n <= p2 || p2 + n <= p1);\n                pIn1 = &aMem[p1];\n                pOut = &aMem[p2];\n                do {\n                    assert(pOut <= &aMem[(p->nMem + 1 - p->nCursor)]);\n                    assert(pIn1 <= &aMem[(p->nMem + 1 - p->nCursor)]);\n                    assert(memIsValid(pIn1));\n                    ;\n                    sqlite3VdbeMemMove(pOut, pIn1);\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                    ;\n                    ;\n                    pIn1++;\n                    pOut++;\n                } while (--n);\n                break;\n            }\n          case 80:\n            {\n                int n;\n                n = pOp->p3;\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                assert(pOut != pIn1);\n                while (1)\n                    {\n                        ;\n                        sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                        if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                            goto no_mem;\n                        }\n                        ;\n                        if ((pOut->flags & 2048) != 0 && (pOp->p5 & 2) != 0) {\n                            pOut->flags &= ~2048;\n                        }\n                        ;\n                        if ((n--) == 0)\n                            break;\n                        pOut++;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 81:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                assert(pOut != pIn1);\n                sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                break;\n            }\n          case 82:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 4) != 0);\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);\n                break;\n            }\n          case 83:\n            {\n                if ((rc = sqlite3VdbeCheckFk(p, 0)) != 0) {\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 84:\n            {\n                assert(p->nResColumn == pOp->p2);\n                assert(pOp->p1 > 0 || (sqlite3Config.neverCorrupt == 0));\n                assert(pOp->p1 + pOp->p2 <= (p->nMem + 1 - p->nCursor) + 1);\n                p->cacheCtr = (p->cacheCtr + 2) | 1;\n                p->pResultSet = &aMem[pOp->p1];\n                if (db->mallocFailed)\n                    goto no_mem;\n                if (db->mTrace & 4) {\n                    db->trace.xV2(4, db->pTraceArg, p, 0);\n                }\n                p->pc = (int)(pOp - aOp) + 1;\n                rc = 100;\n                goto vdbe_return;\n            }\n          case 111:\n            {\n                i64 nByte;\n                u16 flags1;\n                u16 flags2;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                ;\n                assert(pIn1 != pOut);\n                flags1 = pIn1->flags;\n                ;\n                ;\n                if ((flags1 | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                if ((flags1 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn1, encoding, 0))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                } else if ((flags1 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn1))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                }\n                flags2 = pIn2->flags;\n                if ((flags2 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn2, encoding, 0))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                } else if ((flags2 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn2))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                }\n                nByte = pIn1->n + pIn2->n;\n                if (nByte > db->aLimit[0]) {\n                    goto too_big;\n                }\n                if (sqlite3VdbeMemGrow(pOut, (int)nByte + 2, pOut == pIn2)) {\n                    goto no_mem;\n                }\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 2);\n                if (pOut != pIn2) {\n                    memcpy(pOut->z, pIn2->z, pIn2->n);\n                    assert((pIn2->flags & 4096) == (flags2 & 4096));\n                    pIn2->flags = flags2;\n                }\n                memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);\n                assert((pIn1->flags & 4096) == (flags1 & 4096));\n                pIn1->flags = flags1;\n                if (encoding > 1)\n                    nByte &= ~1;\n                pOut->z[nByte] = 0;\n                pOut->z[nByte + 1] = 0;\n                pOut->flags |= 512;\n                pOut->n = (int)nByte;\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n            {\n                u16 type1;\n                u16 type2;\n                i64 iA;\n                i64 iB;\n                double rA;\n                double rB;\n                pIn1 = &aMem[pOp->p1];\n                type1 = pIn1->flags;\n                pIn2 = &aMem[pOp->p2];\n                type2 = pIn2->flags;\n                pOut = &aMem[pOp->p3];\n                if ((type1 & type2 & 4) != 0) {\n                  int_math:\n                    iA = pIn1->u.i;\n                    iB = pIn2->u.i;\n                    switch (pOp->opcode) {\n                      case 106:\n                        if (sqlite3AddInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 107:\n                        if (sqlite3SubInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 108:\n                        if (sqlite3MulInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 109:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1 && iB == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                                goto fp_math;\n                            iB /= iA;\n                            break;\n                        }\n                      default:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            iB %= iA;\n                            break;\n                        }\n                    }\n                    pOut->u.i = iB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                } else if (((type1 | type2) & 1) != 0) {\n                    goto arithmetic_result_is_null;\n                } else {\n                    type1 = numericType(pIn1);\n                    type2 = numericType(pIn2);\n                    if ((type1 & type2 & 4) != 0)\n                        goto int_math;\n                  fp_math:\n                    rA = sqlite3VdbeRealValue(pIn1);\n                    rB = sqlite3VdbeRealValue(pIn2);\n                    switch (pOp->opcode) {\n                      case 106:\n                        rB += rA;\n                        break;\n                      case 107:\n                        rB -= rA;\n                        break;\n                      case 108:\n                        rB *= rA;\n                        break;\n                      case 109:\n                        {\n                            if (rA == (double)0)\n                                goto arithmetic_result_is_null;\n                            rB /= rA;\n                            break;\n                        }\n                      default:\n                        {\n                            iA = sqlite3VdbeIntValue(pIn1);\n                            iB = sqlite3VdbeIntValue(pIn2);\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            rB = (double)(iB % iA);\n                            break;\n                        }\n                    }\n                    if (sqlite3IsNaN(rB)) {\n                        goto arithmetic_result_is_null;\n                    }\n                    pOut->u.r = rB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 8);\n                }\n                break;\n              arithmetic_result_is_null:\n                sqlite3VdbeMemSetNull(pOut);\n                break;\n            }\n          case 85:\n            {\n                assert(pOp->p4type == (-2));\n                if (pOp->p1) {\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);\n                }\n                break;\n            }\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n            {\n                i64 iA;\n                u64 uA;\n                i64 iB;\n                u8 op;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                if ((pIn1->flags | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                iA = sqlite3VdbeIntValue(pIn2);\n                iB = sqlite3VdbeIntValue(pIn1);\n                op = pOp->opcode;\n                if (op == 102) {\n                    iA &= iB;\n                } else if (op == 103) {\n                    iA |= iB;\n                } else if (iB != 0) {\n                    assert(op == 105 || op == 104);\n                    if (iB < 0) {\n                        assert(105 == 104 + 1);\n                        op = 2 * 104 + 1 - op;\n                        iB = iB > (-64) ? -iB : 64;\n                    }\n                    if (iB >= 64) {\n                        iA = (iA >= 0 || op == 104) ? 0 : -1;\n                    } else {\n                        memcpy(&uA, &iA, sizeof (uA));\n                        if (op == 104) {\n                            uA <<= iB;\n                        } else {\n                            uA >>= iB;\n                            if (iA < 0)\n                                uA |= ((((u64)4294967295U) << 32) | 4294967295U) << (64 - iB);\n                        }\n                        memcpy(&iA, &uA, sizeof (iA));\n                    }\n                }\n                pOut->u.i = iA;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 86:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn1->u.i += pOp->p2;\n                break;\n            }\n          case 13:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if ((pIn1->flags & 4) == 0) {\n                    applyAffinity(pIn1, 67, encoding);\n                    if ((pIn1->flags & 4) == 0) {\n                        ;\n                        if (pOp->p2 == 0) {\n                            rc = 20;\n                            goto abort_due_to_error;\n                        } else {\n                            goto jump_to_p2;\n                        }\n                    }\n                }\n                ;\n                ((pIn1)->flags = ((pIn1)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 87:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & (4 | 32)) {\n                    ;\n                    ;\n                    sqlite3VdbeMemRealify(pIn1);\n                    ;\n                }\n                break;\n            }\n          case 88:\n            {\n                assert(pOp->p2 >= 65 && pOp->p2 <= 69);\n                ;\n                ;\n                ;\n                ;\n                ;\n                pIn1 = &aMem[pOp->p1];\n                ;\n                rc = (((pIn1)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                ;\n                ;\n                break;\n            }\n          case 53:\n          case 52:\n          case 56:\n          case 55:\n          case 54:\n          case 57:\n            {\n                int res, res2;\n                char affinity;\n                u16 flags1;\n                u16 flags3;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                flags1 = pIn1->flags;\n                flags3 = pIn3->flags;\n                if ((flags1 & flags3 & 4) != 0) {\n                    assert((pOp->p5 & 71) != 66 || (sqlite3Config.neverCorrupt == 0));\n                    if (pIn3->u.i > pIn1->u.i) {\n                        if (sqlite3aGTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = +1;\n                    } else if (pIn3->u.i < pIn1->u.i) {\n                        if (sqlite3aLTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = -1;\n                    } else {\n                        if (sqlite3aEQb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = 0;\n                    }\n                    ;\n                    break;\n                }\n                if ((flags1 | flags3) & 1) {\n                    if (pOp->p5 & 128) {\n                        assert((flags1 & 256) == 0);\n                        assert((pOp->p5 & 16) == 0 || (sqlite3Config.neverCorrupt == 0));\n                        ;\n                        if ((flags1 & flags3 & 1) != 0 && (flags3 & 256) == 0) {\n                            res = 0;\n                        } else {\n                            res = ((flags3 & 1) ? -1 : +1);\n                        }\n                    } else {\n                        ;\n                        if (pOp->p5 & 16) {\n                            goto jump_to_p2;\n                        }\n                        iCompare = 1;\n                        break;\n                    }\n                } else {\n                    affinity = pOp->p5 & 71;\n                    if (affinity >= 67) {\n                        if ((flags1 | flags3) & 2) {\n                            if ((flags1 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn1, 0);\n                                ;\n                                flags3 = pIn3->flags;\n                            }\n                            if ((flags3 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn3, 0);\n                            }\n                        }\n                    } else if (affinity == 66) {\n                        if ((flags1 & 2) == 0 && (flags1 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn1, encoding, 1);\n                            ;\n                            flags1 = (pIn1->flags & ~3519) | (flags1 & 3519);\n                            if (pIn1 == pIn3)\n                                flags3 = flags1 | 2;\n                        }\n                        if ((flags3 & 2) == 0 && (flags3 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn3, encoding, 1);\n                            ;\n                            flags3 = (pIn3->flags & ~3519) | (flags3 & 3519);\n                        }\n                    }\n                    assert(pOp->p4type == (-2) || pOp->p4.pColl == 0);\n                    res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);\n                }\n                assert(53 == 52 + 1);\n                assert(54 == 52 + 2);\n                assert(55 == 52 + 3);\n                assert(56 == 52 + 4);\n                assert(57 == 52 + 5);\n                if (res < 0) {\n                    res2 = sqlite3aLTb[pOp->opcode];\n                } else if (res == 0) {\n                    res2 = sqlite3aEQb[pOp->opcode];\n                } else {\n                    res2 = sqlite3aGTb[pOp->opcode];\n                }\n                iCompare = res;\n                assert((pIn3->flags & 4096) == (flags3 & 4096));\n                pIn3->flags = flags3;\n                assert((pIn1->flags & 4096) == (flags1 & 4096));\n                pIn1->flags = flags1;\n                ;\n                if (res2) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 58:\n            {\n                ;\n                if (iCompare == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 89:\n            {\n                assert(pOp->p4type == (-14));\n                assert(pOp->p4.ai);\n                assert(pOp[1].opcode == 90);\n                assert(pOp[1].p5 & 1);\n                break;\n            }\n          case 90:\n            {\n                int n;\n                int i;\n                int p1;\n                int p2;\n                const KeyInfo *pKeyInfo;\n                u32 idx;\n                CollSeq *pColl;\n                int bRev;\n                u32 *aPermute;\n                if ((pOp->p5 & 1) == 0) {\n                    aPermute = 0;\n                } else {\n                    assert(pOp > aOp);\n                    assert(pOp[-1].opcode == 89);\n                    assert(pOp[-1].p4type == (-14));\n                    aPermute = pOp[-1].p4.ai + 1;\n                    assert(aPermute != 0);\n                }\n                n = pOp->p3;\n                pKeyInfo = pOp->p4.pKeyInfo;\n                assert(n > 0);\n                assert(pKeyInfo != 0);\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                for (i = 0; i < n; i++) {\n                    idx = aPermute ? aPermute[i] : (u32)i;\n                    assert(memIsValid(&aMem[p1 + idx]));\n                    assert(memIsValid(&aMem[p2 + idx]));\n                    ;\n                    ;\n                    assert(i < pKeyInfo->nKeyField);\n                    pColl = pKeyInfo->aColl[i];\n                    bRev = (pKeyInfo->aSortFlags[i] & 1);\n                    iCompare = sqlite3MemCompare(&aMem[p1 + idx], &aMem[p2 + idx], pColl);\n                    if (iCompare) {\n                        if ((pKeyInfo->aSortFlags[i] & 2) && ((aMem[p1 + idx].flags & 1) || (aMem[p2 + idx].flags & 1))) {\n                            iCompare = -iCompare;\n                        }\n                        if (bRev)\n                            iCompare = -iCompare;\n                        break;\n                    }\n                }\n                assert(pOp[1].opcode == 14);\n                break;\n            }\n          case 14:\n            {\n                assert(pOp > aOp && pOp[-1].opcode == 90);\n                if (iCompare < 0) {\n                    ;\n                    pOp = &aOp[pOp->p1 - 1];\n                } else if (iCompare == 0) {\n                    ;\n                    pOp = &aOp[pOp->p2 - 1];\n                } else {\n                    ;\n                    pOp = &aOp[pOp->p3 - 1];\n                }\n                break;\n            }\n          case 44:\n          case 43:\n            {\n                int v1;\n                int v2;\n                v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);\n                v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);\n                if (pOp->opcode == 44) {\n                    static const unsigned char and_logic[] = {0, 0, 0, 0, 1, 2, 0, 2, 2};\n                    v1 = and_logic[v1 * 3 + v2];\n                } else {\n                    static const unsigned char or_logic[] = {0, 1, 2, 1, 1, 1, 2, 1, 2};\n                    v1 = or_logic[v1 * 3 + v2];\n                }\n                pOut = &aMem[pOp->p3];\n                if (v1 == 2) {\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                } else {\n                    pOut->u.i = v1;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                }\n                break;\n            }\n          case 91:\n            {\n                assert(pOp->p4type == (-3));\n                assert(pOp->p4.i == 0 || pOp->p4.i == 1);\n                assert(pOp->p3 == 0 || pOp->p3 == 1);\n                sqlite3VdbeMemSetInt64(&aMem[pOp->p2], sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);\n                break;\n            }\n          case 19:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                if ((pIn1->flags & 1) == 0) {\n                    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1, 0));\n                } else {\n                    sqlite3VdbeMemSetNull(pOut);\n                }\n                break;\n            }\n          case 114:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetNull(pOut);\n                if ((pIn1->flags & 1) == 0) {\n                    pOut->flags = 4;\n                    pOut->u.i = ~sqlite3VdbeIntValue(pIn1);\n                }\n                break;\n            }\n          case 15:\n            {\n                u32 iAddr;\n                assert(p->aOp[0].opcode == 8);\n                if (p->pFrame) {\n                    iAddr = (int)(pOp - p->aOp);\n                    if ((p->pFrame->aOnce[iAddr / 8] & (1 << (iAddr & 7))) != 0) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    p->pFrame->aOnce[iAddr / 8] |= 1 << (iAddr & 7);\n                } else {\n                    if (p->aOp[0].p1 == pOp->p1) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                }\n                ;\n                pOp->p1 = p->aOp[0].p1;\n                break;\n            }\n          case 16:\n            {\n                int c;\n                c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 17:\n            {\n                int c;\n                c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 50:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) != 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 18:\n            {\n                VdbeCursor *pC;\n                u16 typeMask;\n                u32 serialType;\n                assert(pOp->p1 >= (-1) && pOp->p1 < p->nCursor);\n                assert(pOp->p1 >= 0 || (pOp->p3 >= 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor)));\n                if (pOp->p1 >= 0) {\n                    pC = p->apCsr[pOp->p1];\n                    assert(pC != 0);\n                    assert(pOp->p3 >= 0);\n                    if (pOp->p3 < pC->nHdrParsed) {\n                        serialType = pC->aType[pOp->p3];\n                        if (serialType >= 12) {\n                            if (serialType & 1) {\n                                typeMask = 4;\n                            } else {\n                                typeMask = 8;\n                            }\n                        } else {\n                            static const unsigned char aMask[] = {16, 1, 1, 1, 1, 1, 1, 2, 1, 1, 16, 16};\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            typeMask = aMask[serialType];\n                        }\n                    } else {\n                        typeMask = 1 << (pOp->p4.i - 1);\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                    }\n                } else {\n                    assert(memIsValid(&aMem[pOp->p3]));\n                    typeMask = 1 << (sqlite3_value_type((sqlite3_value *)&aMem[pOp->p3]) - 1);\n                    ;\n                    ;\n                    ;\n                    ;\n                    ;\n                }\n                ;\n                if (typeMask & pOp->p5) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 92:\n            {\n                if ((aMem[pOp->p1].flags & 1) != 0 || (aMem[pOp->p3].flags & 1) != 0) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p2);\n                } else {\n                    sqlite3VdbeMemSetInt64(aMem + pOp->p2, 0);\n                }\n                break;\n            }\n          case 51:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 20:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if ((pC) && pC->nullRow) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p3);\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 94:\n            {\n                u32 p2;\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 *aOffset;\n                int len;\n                int i;\n                Mem *pDest;\n                Mem sMem;\n                const u8 *zData;\n                const u8 *zHdr;\n                const u8 *zEndHdr;\n                u64 offset64;\n                u32 t;\n                Mem *pReg;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pC = p->apCsr[pOp->p1];\n                p2 = (u32)pOp->p2;\n              op_column_restart:\n                assert(pC != 0);\n                assert(p2 < (u32)pC->nField || (pC->eCurType == 3 && pC->seekResult == 0));\n                aOffset = pC->aOffset;\n                assert(aOffset == pC->aType + pC->nField);\n                assert(pC->eCurType != 2);\n                assert(pC->eCurType != 3 || pC->nullRow);\n                assert(pC->eCurType != 1);\n                if (pC->cacheStatus != p->cacheCtr) {\n                    if (pC->nullRow) {\n                        if (pC->eCurType == 3 && pC->seekResult > 0) {\n                            pReg = &aMem[pC->seekResult];\n                            assert(pReg->flags & 16);\n                            assert(memIsValid(pReg));\n                            pC->payloadSize = pC->szRow = pReg->n;\n                            pC->aRow = (u8 *)pReg->z;\n                        } else {\n                            pDest = &aMem[pOp->p3];\n                            ;\n                            sqlite3VdbeMemSetNull(pDest);\n                            goto op_column_out;\n                        }\n                    } else {\n                        pCrsr = pC->uc.pCursor;\n                        if (pC->deferredMoveto) {\n                            u32 iMap;\n                            assert(!pC->isEphemeral);\n                            if (pC->ub.aAltMap && (iMap = pC->ub.aAltMap[1 + p2]) > 0) {\n                                pC = pC->pAltCursor;\n                                p2 = iMap - 1;\n                                goto op_column_restart;\n                            }\n                            rc = sqlite3VdbeFinishMoveto(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                        } else if (sqlite3BtreeCursorHasMoved(pCrsr)) {\n                            rc = sqlite3VdbeHandleMovedCursor(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                            goto op_column_restart;\n                        }\n                        assert(pC->eCurType == 0);\n                        assert(pCrsr);\n                        assert(sqlite3BtreeCursorIsValid(pCrsr));\n                        pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);\n                        pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &pC->szRow);\n                        assert(pC->szRow <= pC->payloadSize);\n                        assert(pC->szRow <= 65536);\n                    }\n                    pC->cacheStatus = p->cacheCtr;\n                    if ((aOffset[0] = pC->aRow[0]) < 128) {\n                        pC->iHdrOffset = 1;\n                    } else {\n                        pC->iHdrOffset = sqlite3GetVarint32(pC->aRow, aOffset);\n                    }\n                    pC->nHdrParsed = 0;\n                    if (pC->szRow < aOffset[0]) {\n                        pC->aRow = 0;\n                        pC->szRow = 0;\n                        if (aOffset[0] > 98307 || aOffset[0] > pC->payloadSize) {\n                            goto op_column_corrupt;\n                        }\n                    } else {\n                        zData = pC->aRow;\n                        assert(pC->nHdrParsed <= p2);\n                        ;\n                        goto op_column_read_header;\n                    }\n                } else if (sqlite3BtreeCursorHasMoved(pC->uc.pCursor)) {\n                    rc = sqlite3VdbeHandleMovedCursor(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    goto op_column_restart;\n                }\n                if (pC->nHdrParsed <= p2) {\n                    if (pC->iHdrOffset < aOffset[0]) {\n                        if (pC->aRow == 0) {\n                            memset(&sMem, 0, sizeof (sMem));\n                            rc = sqlite3VdbeMemFromBtreeZeroOffset(pC->uc.pCursor, aOffset[0], &sMem);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                            zData = (u8 *)sMem.z;\n                        } else {\n                            zData = pC->aRow;\n                        }\n                      op_column_read_header:\n                        i = pC->nHdrParsed;\n                        offset64 = aOffset[i];\n                        zHdr = zData + pC->iHdrOffset;\n                        zEndHdr = zData + aOffset[0];\n                        ;\n                        do {\n                            if ((pC->aType[i] = t = zHdr[0]) < 128) {\n                                zHdr++;\n                                offset64 += sqlite3VdbeOneByteSerialTypeLen(t);\n                            } else {\n                                zHdr += sqlite3GetVarint32(zHdr, &t);\n                                pC->aType[i] = t;\n                                offset64 += sqlite3VdbeSerialTypeLen(t);\n                            }\n                            aOffset[++i] = (u32)(offset64 & 4294967295U);\n                        } while ((u32)i <= p2 && zHdr < zEndHdr);\n                        if ((zHdr >= zEndHdr && (zHdr > zEndHdr || offset64 != pC->payloadSize)) || (offset64 > pC->payloadSize)) {\n                            if (aOffset[0] == 0) {\n                                i = 0;\n                                zHdr = zEndHdr;\n                            } else {\n                                if (pC->aRow == 0)\n                                    sqlite3VdbeMemRelease(&sMem);\n                                goto op_column_corrupt;\n                            }\n                        }\n                        pC->nHdrParsed = i;\n                        pC->iHdrOffset = (u32)(zHdr - zData);\n                        if (pC->aRow == 0)\n                            sqlite3VdbeMemRelease(&sMem);\n                    } else {\n                        t = 0;\n                    }\n                    if (pC->nHdrParsed <= p2) {\n                        pDest = &aMem[pOp->p3];\n                        ;\n                        if (pOp->p4type == (-10)) {\n                            sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, 8192);\n                        } else {\n                            sqlite3VdbeMemSetNull(pDest);\n                        }\n                        goto op_column_out;\n                    }\n                } else {\n                    t = pC->aType[p2];\n                }\n                assert(p2 < pC->nHdrParsed);\n                assert(rc == 0);\n                pDest = &aMem[pOp->p3];\n                ;\n                assert(sqlite3VdbeCheckMemInvariants(pDest));\n                if ((((pDest)->flags & (32768 | 4096)) != 0)) {\n                    sqlite3VdbeMemSetNull(pDest);\n                }\n                assert(t == pC->aType[p2]);\n                if (pC->szRow >= aOffset[p2 + 1]) {\n                    zData = pC->aRow + aOffset[p2];\n                    if (t < 12) {\n                        sqlite3VdbeSerialGet(zData, t, pDest);\n                    } else {\n                        static const u16 aFlag[] = {16, 2 | 512};\n                        pDest->n = len = (t - 12) / 2;\n                        pDest->enc = encoding;\n                        if (pDest->szMalloc < len + 2) {\n                            if (len > db->aLimit[0])\n                                goto too_big;\n                            pDest->flags = 1;\n                            if (sqlite3VdbeMemGrow(pDest, len + 2, 0))\n                                goto no_mem;\n                        } else {\n                            pDest->z = pDest->zMalloc;\n                        }\n                        memcpy(pDest->z, zData, len);\n                        pDest->z[len] = 0;\n                        pDest->z[len + 1] = 0;\n                        pDest->flags = aFlag[t & 1];\n                    }\n                } else {\n                    pDest->enc = encoding;\n                    if (((pOp->p5 & (64 | 128)) != 0 && ((t >= 12 && (t & 1) == 0) || (pOp->p5 & 128) != 0)) || (len = sqlite3VdbeSerialTypeLen(t)) == 0) {\n                        sqlite3VdbeSerialGet((u8 *)sqlite3CtypeMap, t, pDest);\n                    } else {\n                        if (len > db->aLimit[0])\n                            goto too_big;\n                        rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, aOffset[p2], len, pDest);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        sqlite3VdbeSerialGet((const u8 *)pDest->z, t, pDest);\n                        pDest->flags &= ~16384;\n                    }\n                }\n              op_column_out:\n                ;\n                ;\n                break;\n              op_column_corrupt:\n                if (aOp[0].p3 > 0) {\n                    pOp = &aOp[aOp[0].p3 - 1];\n                    break;\n                } else {\n                    rc = sqlite3CorruptError(92699);\n                    goto abort_due_to_error;\n                }\n            }\n          case 95:\n            {\n                Table *pTab;\n                Column *aCol;\n                int i;\n                assert(pOp->p4type == (-5));\n                pTab = pOp->p4.pTab;\n                assert(pTab->tabFlags & 65536);\n                assert(pTab->nNVCol == pOp->p2);\n                aCol = pTab->aCol;\n                pIn1 = &aMem[pOp->p1];\n                for (i = 0; i < pTab->nCol; i++) {\n                    if (aCol[i].colFlags & 96) {\n                        if (aCol[i].colFlags & 32)\n                            continue;\n                        if (pOp->p3) {\n                            pIn1++;\n                            continue;\n                        }\n                    }\n                    assert(pIn1 < &aMem[pOp->p1 + pOp->p2]);\n                    applyAffinity(pIn1, aCol[i].affinity, encoding);\n                    if ((pIn1->flags & 1) == 0) {\n                        switch (aCol[i].eCType) {\n                          case 2:\n                            {\n                                if ((pIn1->flags & 16) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 4:\n                          case 3:\n                            {\n                                if ((pIn1->flags & 4) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 6:\n                            {\n                                if ((pIn1->flags & 2) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 5:\n                            {\n                                ;\n                                ;\n                                if (pIn1->flags & 4) {\n                                    ;\n                                    ;\n                                    ;\n                                    ;\n                                    if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                        pIn1->flags |= 32;\n                                        pIn1->flags &= ~4;\n                                    } else {\n                                        pIn1->u.r = (double)pIn1->u.i;\n                                        pIn1->flags |= 8;\n                                        pIn1->flags &= ~4;\n                                    }\n                                } else if ((pIn1->flags & (8 | 32)) == 0) {\n                                    goto vdbe_type_error;\n                                }\n                                break;\n                            }\n                          default:\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    ;\n                    pIn1++;\n                }\n                assert(pIn1 == &aMem[pOp->p1 + pOp->p2]);\n                break;\n              vdbe_type_error:\n                sqlite3VdbeError(p, \"cannot store %s value in %s column %s.%s\", vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType - 1], pTab->zName, aCol[i].zCnName);\n                rc = (19 | (12 << 8));\n                goto abort_due_to_error;\n            }\n          case 96:\n            {\n                const char *zAffinity;\n                zAffinity = pOp->p4.z;\n                assert(zAffinity != 0);\n                assert(pOp->p2 > 0);\n                assert(zAffinity[pOp->p2] == 0);\n                pIn1 = &aMem[pOp->p1];\n                while (1)\n                    {\n                        assert(pIn1 <= &p->aMem[(p->nMem + 1 - p->nCursor)]);\n                        assert(zAffinity[0] == 64 || memIsValid(pIn1));\n                        applyAffinity(pIn1, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pIn1->flags & 4) != 0) {\n                            ;\n                            ;\n                            ;\n                            ;\n                            if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                pIn1->flags |= 32;\n                                pIn1->flags &= ~4;\n                            } else {\n                                pIn1->u.r = (double)pIn1->u.i;\n                                pIn1->flags |= 8;\n                                pIn1->flags &= ~4;\n                            }\n                        }\n                        ;\n                        zAffinity++;\n                        if (zAffinity[0] == 0)\n                            break;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 97:\n            {\n                Mem *pRec;\n                u64 nData;\n                int nHdr;\n                i64 nByte;\n                i64 nZero;\n                int nVarint;\n                u32 serial_type;\n                Mem *pData0;\n                Mem *pLast;\n                int nField;\n                char *zAffinity;\n                u32 len;\n                u8 *zHdr;\n                u8 *zPayload;\n                nData = 0;\n                nHdr = 0;\n                nZero = 0;\n                nField = pOp->p1;\n                zAffinity = pOp->p4.z;\n                assert(nField > 0 && pOp->p2 > 0 && pOp->p2 + nField <= (p->nMem + 1 - p->nCursor) + 1);\n                pData0 = &aMem[nField];\n                nField = pOp->p2;\n                pLast = &pData0[nField - 1];\n                assert(pOp->p3 < pOp->p1 || pOp->p3 >= pOp->p1 + pOp->p2);\n                pOut = &aMem[pOp->p3];\n                ;\n                assert(pData0 <= pLast);\n                if (zAffinity) {\n                    pRec = pData0;\n                    do {\n                        applyAffinity(pRec, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pRec->flags & 4)) {\n                            pRec->flags |= 32;\n                            pRec->flags &= ~(4);\n                        }\n                        ;\n                        zAffinity++;\n                        pRec++;\n                        assert(zAffinity[0] == 0 || pRec <= pLast);\n                    } while (zAffinity[0]);\n                }\n                pRec = pLast;\n                do {\n                    assert(memIsValid(pRec));\n                    if (pRec->flags & 1) {\n                        if (pRec->flags & 1024) {\n                            assert(pOp->p5 == 109 || (sqlite3Config.neverCorrupt == 0));\n                            pRec->uTemp = 10;\n                        } else {\n                            pRec->uTemp = 0;\n                        }\n                        nHdr++;\n                    } else if (pRec->flags & (4 | 32)) {\n                        i64 i = pRec->u.i;\n                        u64 uu;\n                        ;\n                        ;\n                        if (i < 0) {\n                            uu = ~i;\n                        } else {\n                            uu = i;\n                        }\n                        nHdr++;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        if (uu <= 127) {\n                            if ((i & 1) == i && p->minWriteFileFormat >= 4) {\n                                pRec->uTemp = 8 + (u32)uu;\n                            } else {\n                                nData++;\n                                pRec->uTemp = 1;\n                            }\n                        } else if (uu <= 32767) {\n                            nData += 2;\n                            pRec->uTemp = 2;\n                        } else if (uu <= 8388607) {\n                            nData += 3;\n                            pRec->uTemp = 3;\n                        } else if (uu <= 2147483647) {\n                            nData += 4;\n                            pRec->uTemp = 4;\n                        } else if (uu <= 140737488355327LL) {\n                            nData += 6;\n                            pRec->uTemp = 5;\n                        } else {\n                            nData += 8;\n                            if (pRec->flags & 32) {\n                                pRec->u.r = (double)pRec->u.i;\n                                pRec->flags &= ~32;\n                                pRec->flags |= 8;\n                                pRec->uTemp = 7;\n                            } else {\n                                pRec->uTemp = 6;\n                            }\n                        }\n                    } else if (pRec->flags & 8) {\n                        nHdr++;\n                        nData += 8;\n                        pRec->uTemp = 7;\n                    } else {\n                        assert(db->mallocFailed || pRec->flags & (2 | 16));\n                        assert(pRec->n >= 0);\n                        len = (u32)pRec->n;\n                        serial_type = (len * 2) + 12 + ((pRec->flags & 2) != 0);\n                        if (pRec->flags & 1024) {\n                            serial_type += pRec->u.nZero * 2;\n                            if (nData) {\n                                if (sqlite3VdbeMemExpandBlob(pRec))\n                                    goto no_mem;\n                                len += pRec->u.nZero;\n                            } else {\n                                nZero += pRec->u.nZero;\n                            }\n                        }\n                        nData += len;\n                        nHdr += sqlite3VarintLen(serial_type);\n                        pRec->uTemp = serial_type;\n                    }\n                    if (pRec == pData0)\n                        break;\n                    pRec--;\n                } while (1);\n                ;\n                ;\n                if (nHdr <= 126) {\n                    nHdr += 1;\n                } else {\n                    nVarint = sqlite3VarintLen(nHdr);\n                    nHdr += nVarint;\n                    if (nVarint < sqlite3VarintLen(nHdr))\n                        nHdr++;\n                }\n                nByte = nHdr + nData;\n                if (nByte + nZero <= pOut->szMalloc) {\n                    pOut->z = pOut->zMalloc;\n                } else {\n                    if (nByte + nZero > db->aLimit[0]) {\n                        goto too_big;\n                    }\n                    if (sqlite3VdbeMemClearAndResize(pOut, (int)nByte)) {\n                        goto no_mem;\n                    }\n                }\n                pOut->n = (int)nByte;\n                pOut->flags = 16;\n                if (nZero) {\n                    pOut->u.nZero = nZero;\n                    pOut->flags |= 1024;\n                }\n                ;\n                zHdr = (u8 *)pOut->z;\n                zPayload = zHdr + nHdr;\n                if (nHdr < 128) {\n                    *(zHdr++) = nHdr;\n                } else {\n                    zHdr += sqlite3PutVarint(zHdr, nHdr);\n                }\n                assert(pData0 <= pLast);\n                pRec = pData0;\n                while (1)\n                    {\n                        serial_type = pRec->uTemp;\n                        if (serial_type <= 7) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type == 0) {\n                            } else {\n                                u64 v;\n                                u32 i;\n                                if (serial_type == 7) {\n                                    assert(sizeof (v) == sizeof (pRec->u.r));\n                                    memcpy(&v, &pRec->u.r, sizeof (v));\n                                    ;\n                                } else {\n                                    v = pRec->u.i;\n                                }\n                                len = i = sqlite3SmallTypeSizes[serial_type];\n                                assert(i > 0);\n                                while (1)\n                                    {\n                                        zPayload[--i] = (u8)(v & 255);\n                                        if (i == 0)\n                                            break;\n                                        v >>= 8;\n                                    }\n                                zPayload += len;\n                            }\n                        } else if (serial_type < 128) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type >= 14 && pRec->n > 0) {\n                                assert(pRec->z != 0);\n                                memcpy(zPayload, pRec->z, pRec->n);\n                                zPayload += pRec->n;\n                            }\n                        } else {\n                            zHdr += sqlite3PutVarint(zHdr, serial_type);\n                            if (pRec->n) {\n                                assert(pRec->z != 0);\n                                memcpy(zPayload, pRec->z, pRec->n);\n                                zPayload += pRec->n;\n                            }\n                        }\n                        if (pRec == pLast)\n                            break;\n                        pRec++;\n                    }\n                assert(nHdr == (int)(zHdr - (u8 *)pOut->z));\n                assert(nByte == (int)(zPayload - (u8 *)pOut->z));\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                ;\n                break;\n            }\n          case 98:\n            {\n                i64 nEntry;\n                BtCursor *pCrsr;\n                assert(p->apCsr[pOp->p1]->eCurType == 0);\n                pCrsr = p->apCsr[pOp->p1]->uc.pCursor;\n                assert(pCrsr);\n                if (pOp->p3) {\n                    nEntry = sqlite3BtreeRowCountEst(pCrsr);\n                } else {\n                    nEntry = 0;\n                    rc = sqlite3BtreeCount(db, pCrsr, &nEntry);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = nEntry;\n                goto check_for_interrupt;\n            }\n          case 0:\n            {\n                int p1;\n                char *zName;\n                int nName;\n                Savepoint *pNew;\n                Savepoint *pSavepoint;\n                Savepoint *pTmp;\n                int iSavepoint;\n                int ii;\n                p1 = pOp->p1;\n                zName = pOp->p4.z;\n                assert(db->pSavepoint == 0 || db->autoCommit == 0);\n                assert(p1 == 0 || p1 == 1 || p1 == 2);\n                assert(db->pSavepoint || db->isTransactionSavepoint == 0);\n                assert(checkSavepointCount(db));\n                assert(p->bIsReader);\n                if (p1 == 0) {\n                    if (db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot open savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        nName = sqlite3Strlen30(zName);\n                        assert(db->autoCommit == 0 || db->nVTrans == 0);\n                        rc = sqlite3VtabSavepoint(db, 0, db->nStatement + db->nSavepoint);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint) + nName + 1);\n                        if (pNew) {\n                            pNew->zName = (char *)&pNew[1];\n                            memcpy(pNew->zName, zName, nName + 1);\n                            if (db->autoCommit) {\n                                db->autoCommit = 0;\n                                db->isTransactionSavepoint = 1;\n                            } else {\n                                db->nSavepoint++;\n                            }\n                            pNew->pNext = db->pSavepoint;\n                            db->pSavepoint = pNew;\n                            pNew->nDeferredCons = db->nDeferredCons;\n                            pNew->nDeferredImmCons = db->nDeferredImmCons;\n                        }\n                    }\n                } else {\n                    assert(p1 == 1 || p1 == 2);\n                    iSavepoint = 0;\n                    for (pSavepoint = db->pSavepoint; pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName); pSavepoint = pSavepoint->pNext) {\n                        iSavepoint++;\n                    }\n                    if (!pSavepoint) {\n                        sqlite3VdbeError(p, \"no such savepoint: %s\", zName);\n                        rc = 1;\n                    } else if (db->nVdbeWrite > 0 && p1 == 1) {\n                        sqlite3VdbeError(p, \"cannot release savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        int isTransaction = pSavepoint->pNext == 0 && db->isTransactionSavepoint;\n                        if (isTransaction && p1 == 1) {\n                            if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                                goto vdbe_return;\n                            }\n                            db->autoCommit = 1;\n                            if (sqlite3VdbeHalt(p) == 5) {\n                                p->pc = (int)(pOp - aOp);\n                                db->autoCommit = 0;\n                                p->rc = rc = 5;\n                                goto vdbe_return;\n                            }\n                            rc = p->rc;\n                            if (rc) {\n                                db->autoCommit = 0;\n                            } else {\n                                db->isTransactionSavepoint = 0;\n                            }\n                        } else {\n                            int isSchemaChange;\n                            iSavepoint = db->nSavepoint - iSavepoint - 1;\n                            if (p1 == 2) {\n                                isSchemaChange = (db->mDbFlags & 1) != 0;\n                                for (ii = 0; ii < db->nDb; ii++) {\n                                    rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt, (4 | (2 << 8)), isSchemaChange == 0);\n                                    if (rc != 0)\n                                        goto abort_due_to_error;\n                                }\n                            } else {\n                                assert(p1 == 1);\n                                isSchemaChange = 0;\n                            }\n                            for (ii = 0; ii < db->nDb; ii++) {\n                                rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);\n                                if (rc != 0) {\n                                    goto abort_due_to_error;\n                                }\n                            }\n                            if (isSchemaChange) {\n                                sqlite3ExpirePreparedStatements(db, 0);\n                                sqlite3ResetAllSchemasOfConnection(db);\n                                db->mDbFlags |= 1;\n                            }\n                        }\n                        if (rc)\n                            goto abort_due_to_error;\n                        while (db->pSavepoint != pSavepoint)\n                            {\n                                pTmp = db->pSavepoint;\n                                db->pSavepoint = pTmp->pNext;\n                                sqlite3DbFree(db, pTmp);\n                                db->nSavepoint--;\n                            }\n                        if (p1 == 1) {\n                            assert(pSavepoint == db->pSavepoint);\n                            db->pSavepoint = pSavepoint->pNext;\n                            sqlite3DbFree(db, pSavepoint);\n                            if (!isTransaction) {\n                                db->nSavepoint--;\n                            }\n                        } else {\n                            assert(p1 == 2);\n                            db->nDeferredCons = pSavepoint->nDeferredCons;\n                            db->nDeferredImmCons = pSavepoint->nDeferredImmCons;\n                        }\n                        if (!isTransaction || p1 == 2) {\n                            rc = sqlite3VtabSavepoint(db, p1, iSavepoint);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                if (p->eVdbeState == 3) {\n                    rc = 101;\n                    goto vdbe_return;\n                }\n                break;\n            }\n          case 1:\n            {\n                int desiredAutoCommit;\n                int iRollback;\n                desiredAutoCommit = pOp->p1;\n                iRollback = pOp->p2;\n                assert(desiredAutoCommit == 1 || desiredAutoCommit == 0);\n                assert(desiredAutoCommit == 1 || iRollback == 0);\n                assert(db->nVdbeActive > 0);\n                assert(p->bIsReader);\n                if (desiredAutoCommit != db->autoCommit) {\n                    if (iRollback) {\n                        assert(desiredAutoCommit == 1);\n                        sqlite3RollbackAll(db, (4 | (2 << 8)));\n                        db->autoCommit = 1;\n                    } else if (desiredAutoCommit && db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot commit transaction - SQL statements in progress\");\n                        rc = 5;\n                        goto abort_due_to_error;\n                    } else if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                        goto vdbe_return;\n                    } else {\n                        db->autoCommit = (u8)desiredAutoCommit;\n                    }\n                    if (sqlite3VdbeHalt(p) == 5) {\n                        p->pc = (int)(pOp - aOp);\n                        db->autoCommit = (u8)(1 - desiredAutoCommit);\n                        p->rc = rc = 5;\n                        goto vdbe_return;\n                    }\n                    sqlite3CloseSavepoints(db);\n                    if (p->rc == 0) {\n                        rc = 101;\n                    } else {\n                        rc = 1;\n                    }\n                    goto vdbe_return;\n                } else {\n                    sqlite3VdbeError(p, (!desiredAutoCommit) ? \"cannot start a transaction within a transaction\" : ((iRollback) ? \"cannot rollback - no transaction is active\" : \"cannot commit - no transaction is active\"));\n                    rc = 1;\n                    goto abort_due_to_error;\n                }\n                assert(0);\n            }\n          case 2:\n            {\n                Btree *pBt;\n                Db *pDb;\n                int iMeta = 0;\n                assert(p->bIsReader);\n                assert(p->readOnly == 0 || pOp->p2 == 0);\n                assert(pOp->p2 >= 0 && pOp->p2 <= 2);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(rc == 0);\n                if (pOp->p2 && (db->flags & (1048576 | ((u64)(2) << 32))) != 0) {\n                    if (db->flags & 1048576) {\n                        rc = 8;\n                    } else {\n                        rc = 11;\n                    }\n                    goto abort_due_to_error;\n                }\n                pDb = &db->aDb[pOp->p1];\n                pBt = pDb->pBt;\n                if (pBt) {\n                    rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, &iMeta);\n                    ;\n                    ;\n                    if (rc != 0) {\n                        if ((rc & 255) == 5) {\n                            p->pc = (int)(pOp - aOp);\n                            p->rc = rc;\n                            goto vdbe_return;\n                        }\n                        goto abort_due_to_error;\n                    }\n                    if (p->usesStmtJournal && pOp->p2 && (db->autoCommit == 0 || db->nVdbeRead > 1)) {\n                        assert(sqlite3BtreeTxnState(pBt) == 2);\n                        if (p->iStatement == 0) {\n                            assert(db->nStatement >= 0 && db->nSavepoint >= 0);\n                            db->nStatement++;\n                            p->iStatement = db->nSavepoint + db->nStatement;\n                        }\n                        rc = sqlite3VtabSavepoint(db, 0, p->iStatement - 1);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);\n                        }\n                        p->nStmtDefCons = db->nDeferredCons;\n                        p->nStmtDefImmCons = db->nDeferredImmCons;\n                    }\n                }\n                assert(pOp->p5 == 0 || pOp->p4type == (-3));\n                if (rc == 0 && pOp->p5 && (iMeta != pOp->p3 || pDb->pSchema->iGeneration != pOp->p4.i)) {\n                    sqlite3DbFree(db, p->zErrMsg);\n                    p->zErrMsg = sqlite3DbStrDup(db, \"database schema has changed\");\n                    if (db->aDb[pOp->p1].pSchema->schema_cookie != iMeta) {\n                        sqlite3ResetOneSchema(db, pOp->p1);\n                    }\n                    p->expired = 1;\n                    rc = 17;\n                    p->changeCntOn = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 99:\n            {\n                int iMeta;\n                int iDb;\n                int iCookie;\n                assert(p->bIsReader);\n                iDb = pOp->p1;\n                iCookie = pOp->p3;\n                assert(pOp->p3 < 16);\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert(db->aDb[iDb].pBt != 0);\n                assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = iMeta;\n                break;\n            }\n          case 100:\n            {\n                Db *pDb;\n                ;\n                assert(pOp->p2 < 16);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pDb = &db->aDb[pOp->p1];\n                assert(pDb->pBt != 0);\n                assert(sqlite3SchemaMutexHeld(db, pOp->p1, 0));\n                rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);\n                if (pOp->p2 == 1) {\n                    *(u32 *)&pDb->pSchema->schema_cookie = *(u32 *)&pOp->p3 - pOp->p5;\n                    db->mDbFlags |= 1;\n                    sqlite3FkClearTriggerCache(db, pOp->p1);\n                } else if (pOp->p2 == 2) {\n                    pDb->pSchema->file_format = pOp->p3;\n                }\n                if (pOp->p1 == 1) {\n                    sqlite3ExpirePreparedStatements(db, 0);\n                    p->expired = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 101:\n            {\n                int nField;\n                KeyInfo *pKeyInfo;\n                u32 p2;\n                int iDb;\n                int wrFlag;\n                Btree *pX;\n                VdbeCursor *pCur;\n                Db *pDb;\n                assert(pOp->p5 == 0 || pOp->p5 == 2);\n                assert(pOp->p4type == (-8));\n                pCur = p->apCsr[pOp->p1];\n                if (pCur && pCur->pgnoRoot == (u32)pOp->p2) {\n                    assert(pCur->iDb == pOp->p3);\n                    assert(pCur->eCurType == 0);\n                    sqlite3BtreeClearCursor(pCur->uc.pCursor);\n                    goto open_cursor_set_hints;\n                }\n              case 112:\n              case 113:\n                assert(pOp->opcode == 113 || pOp->p5 == 0 || pOp->p5 == 2);\n                assert(p->bIsReader);\n                assert(pOp->opcode == 112 || pOp->opcode == 101 || p->readOnly == 0);\n                if (p->expired == 1) {\n                    rc = (4 | (2 << 8));\n                    goto abort_due_to_error;\n                }\n                nField = 0;\n                pKeyInfo = 0;\n                p2 = (u32)pOp->p2;\n                iDb = pOp->p3;\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                pDb = &db->aDb[iDb];\n                pX = pDb->pBt;\n                assert(pX != 0);\n                if (pOp->opcode == 113) {\n                    assert(8 == 8);\n                    wrFlag = 4 | (pOp->p5 & 8);\n                    assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n                    if (pDb->pSchema->file_format < p->minWriteFileFormat) {\n                        p->minWriteFileFormat = pDb->pSchema->file_format;\n                    }\n                } else {\n                    wrFlag = 0;\n                }\n                if (pOp->p5 & 16) {\n                    assert(p2 > 0);\n                    assert(p2 <= (u32)(p->nMem + 1 - p->nCursor));\n                    assert(pOp->opcode == 113);\n                    pIn2 = &aMem[p2];\n                    assert(memIsValid(pIn2));\n                    assert((pIn2->flags & 4) != 0);\n                    sqlite3VdbeMemIntegerify(pIn2);\n                    p2 = (int)pIn2->u.i;\n                    assert(p2 >= 2);\n                }\n                if (pOp->p4type == (-8)) {\n                    pKeyInfo = pOp->p4.pKeyInfo;\n                    assert(pKeyInfo->enc == ((db)->enc));\n                    assert(pKeyInfo->db == db);\n                    nField = pKeyInfo->nAllField;\n                } else if (pOp->p4type == (-3)) {\n                    nField = pOp->p4.i;\n                }\n                assert(pOp->p1 >= 0);\n                assert(nField >= 0);\n                ;\n                pCur = allocateCursor(p, pOp->p1, nField, 0);\n                if (pCur == 0)\n                    goto no_mem;\n                pCur->iDb = iDb;\n                pCur->nullRow = 1;\n                pCur->isOrdered = 1;\n                pCur->pgnoRoot = p2;\n                rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);\n                pCur->pKeyInfo = pKeyInfo;\n                pCur->isTable = pOp->p4type != (-8);\n              open_cursor_set_hints:\n                assert(1 == 1);\n                assert(2 == 2);\n                ;\n                ;\n                sqlite3BtreeCursorHintFlags(pCur->uc.pCursor, (pOp->p5 & (1 | 2)));\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 115:\n            {\n                VdbeCursor *pOrig;\n                VdbeCursor *pCx;\n                pOrig = p->apCsr[pOp->p2];\n                assert(pOrig);\n                assert(pOrig->isEphemeral);\n                pCx = allocateCursor(p, pOp->p1, pOrig->nField, 0);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->isEphemeral = 1;\n                pCx->pKeyInfo = pOrig->pKeyInfo;\n                pCx->isTable = pOrig->isTable;\n                pCx->pgnoRoot = pOrig->pgnoRoot;\n                pCx->isOrdered = pOrig->isOrdered;\n                pCx->ub.pBtx = pOrig->ub.pBtx;\n                pCx->noReuse = 1;\n                pOrig->noReuse = 1;\n                rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pCx->pKeyInfo, pCx->uc.pCursor);\n                assert(rc == 0);\n                break;\n            }\n          case 116:\n          case 118:\n            {\n                VdbeCursor *pCx;\n                KeyInfo *pKeyInfo;\n                static const int vfsFlags = 2 | 4 | 16 | 8 | 1024;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p2 >= 0);\n                if (pOp->p3 > 0) {\n                    assert(pOp->p2 == 0);\n                    assert(pOp->opcode == 118);\n                    assert(aMem[pOp->p3].flags & 1);\n                    aMem[pOp->p3].n = 0;\n                    aMem[pOp->p3].z = \"\";\n                }\n                pCx = p->apCsr[pOp->p1];\n                if (pCx && !pCx->noReuse && (pOp->p2 <= pCx->nField)) {\n                    assert(pCx->isEphemeral);\n                    pCx->seqCount = 0;\n                    pCx->cacheStatus = 0;\n                    rc = sqlite3BtreeClearTable(pCx->ub.pBtx, pCx->pgnoRoot, 0);\n                } else {\n                    pCx = allocateCursor(p, pOp->p1, pOp->p2, 0);\n                    if (pCx == 0)\n                        goto no_mem;\n                    pCx->isEphemeral = 1;\n                    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->ub.pBtx, 1 | 4 | pOp->p5, vfsFlags);\n                    if (rc == 0) {\n                        rc = sqlite3BtreeBeginTrans(pCx->ub.pBtx, 1, 0);\n                        if (rc == 0) {\n                            if ((pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo) != 0) {\n                                assert(pOp->p4type == (-8));\n                                rc = sqlite3BtreeCreateTable(pCx->ub.pBtx, &pCx->pgnoRoot, 2 | pOp->p5);\n                                if (rc == 0) {\n                                    assert(pCx->pgnoRoot == 1 + 1);\n                                    assert(pKeyInfo->db == db);\n                                    assert(pKeyInfo->enc == ((db)->enc));\n                                    rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pKeyInfo, pCx->uc.pCursor);\n                                }\n                                pCx->isTable = 0;\n                            } else {\n                                pCx->pgnoRoot = 1;\n                                rc = sqlite3BtreeCursor(pCx->ub.pBtx, 1, 4, 0, pCx->uc.pCursor);\n                                pCx->isTable = 1;\n                            }\n                        }\n                        pCx->isOrdered = (pOp->p5 != 8);\n                        if (rc) {\n                            sqlite3BtreeClose(pCx->ub.pBtx);\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pCx->nullRow = 1;\n                break;\n            }\n          case 119:\n            {\n                VdbeCursor *pCx;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p2 >= 0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p2, 1);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->pKeyInfo = pOp->p4.pKeyInfo;\n                assert(pCx->pKeyInfo->db == db);\n                assert(pCx->pKeyInfo->enc == ((db)->enc));\n                rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 120:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                if ((pC->seqCount++) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 121:\n            {\n                VdbeCursor *pCx;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p3 >= 0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p3, 3);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->seekResult = pOp->p2;\n                pCx->isTable = 1;\n                pCx->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                assert(pOp->p5 == 0);\n                break;\n            }\n          case 122:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);\n                p->apCsr[pOp->p1] = 0;\n                break;\n            }\n          case 21:\n          case 22:\n          case 23:\n          case 24:\n            {\n                int res;\n                int oc;\n                VdbeCursor *pC;\n                UnpackedRecord r;\n                int nField;\n                i64 iKey;\n                int eqOnly;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p2 != 0);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(22 == 21 + 1);\n                assert(23 == 21 + 2);\n                assert(24 == 21 + 3);\n                assert(pC->isOrdered);\n                assert(pC->uc.pCursor != 0);\n                oc = pOp->opcode;\n                eqOnly = 0;\n                pC->nullRow = 0;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pC->isTable) {\n                    u16 flags3, newType;\n                    assert(sqlite3BtreeCursorHasHint(pC->uc.pCursor, 2) == 0 || (sqlite3Config.neverCorrupt == 0));\n                    pIn3 = &aMem[pOp->p3];\n                    flags3 = pIn3->flags;\n                    if ((flags3 & (4 | 8 | 32 | 2)) == 2) {\n                        applyNumericAffinity(pIn3, 0);\n                    }\n                    iKey = sqlite3VdbeIntValue(pIn3);\n                    newType = pIn3->flags;\n                    pIn3->flags = flags3;\n                    if ((newType & (4 | 32)) == 0) {\n                        int c;\n                        if ((newType & 8) == 0) {\n                            if ((newType & 1) || oc >= 23) {\n                                ;\n                                goto jump_to_p2;\n                            } else {\n                                rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                                if (rc != 0)\n                                    goto abort_due_to_error;\n                                goto seek_not_found;\n                            }\n                        }\n                        c = sqlite3IntFloatCompare(iKey, pIn3->u.r);\n                        if (c > 0) {\n                            assert(23 == (24 - 1));\n                            assert(21 == (22 - 1));\n                            assert((22 & 1) == (24 & 1));\n                            if ((oc & 1) == (24 & 1))\n                                oc--;\n                        } else if (c < 0) {\n                            assert(22 == (21 + 1));\n                            assert(24 == (23 + 1));\n                            assert((21 & 1) == (23 & 1));\n                            if ((oc & 1) == (21 & 1))\n                                oc++;\n                        }\n                    }\n                    rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)iKey, 0, &res);\n                    pC->movetoTarget = iKey;\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                } else {\n                    if (sqlite3BtreeCursorHasHint(pC->uc.pCursor, 2)) {\n                        eqOnly = 1;\n                        assert(pOp->opcode == 23 || pOp->opcode == 22);\n                        assert(pOp[1].opcode == 42 || pOp[1].opcode == 41);\n                        assert(pOp->opcode == 23 || pOp[1].opcode == 42);\n                        assert(pOp->opcode == 22 || pOp[1].opcode == 41);\n                        assert(pOp[1].p1 == pOp[0].p1);\n                        assert(pOp[1].p2 == pOp[0].p2);\n                        assert(pOp[1].p3 == pOp[0].p3);\n                        assert(pOp[1].p4.i == pOp[0].p4.i);\n                    }\n                    nField = pOp->p4.i;\n                    assert(pOp->p4type == (-3));\n                    assert(nField > 0);\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.nField = (u16)nField;\n                    r.default_rc = ((1 & (oc - 21)) ? -1 : +1);\n                    assert(oc != 24 || r.default_rc == -1);\n                    assert(oc != 22 || r.default_rc == -1);\n                    assert(oc != 23 || r.default_rc == +1);\n                    assert(oc != 21 || r.default_rc == +1);\n                    r.aMem = &aMem[pOp->p3];\n                    r.eqSeen = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &res);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (eqOnly && r.eqSeen == 0) {\n                        assert(res != 0);\n                        goto seek_not_found;\n                    }\n                }\n                if (oc >= 23) {\n                    assert(oc == 23 || oc == 24);\n                    if (res < 0 || (res == 0 && oc == 24)) {\n                        res = 0;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = 0;\n                    }\n                } else {\n                    assert(oc == 21 || oc == 22);\n                    if (res > 0 || (res == 0 && oc == 21)) {\n                        res = 0;\n                        rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = sqlite3BtreeEof(pC->uc.pCursor);\n                    }\n                }\n              seek_not_found:\n                assert(pOp->p2 > 0);\n                ;\n                if (res) {\n                    goto jump_to_p2;\n                } else if (eqOnly) {\n                    assert(pOp[1].opcode == 42 || pOp[1].opcode == 41);\n                    pOp++;\n                }\n                break;\n            }\n          case 124:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nStep;\n                UnpackedRecord r;\n                assert(pOp[1].opcode == 23);\n                assert(pOp->p2 >= (int)(pOp - aOp) + 2);\n                assert(pOp->p1 > 0);\n                pC = p->apCsr[pOp[1].p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(!pC->isTable);\n                if (!sqlite3BtreeCursorIsValidNN(pC->uc.pCursor)) {\n                    break;\n                }\n                nStep = pOp->p1;\n                assert(nStep >= 1);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp[1].p4.i;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp[1].p3];\n                res = 0;\n                while (1)\n                    {\n                        rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res > 0 && pOp->p5 == 0) {\n                          seekscan_search_fail:\n                            ;\n                            pOp++;\n                            goto jump_to_p2;\n                        }\n                        if (res >= 0) {\n                            ;\n                            goto jump_to_p2;\n                            break;\n                        }\n                        if (nStep <= 0) {\n                            ;\n                            break;\n                        }\n                        nStep--;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc) {\n                            if (rc == 101) {\n                                rc = 0;\n                                goto seekscan_search_fail;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    }\n                break;\n            }\n          case 125:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pOp->p3 >= pOp->p2);\n                if (pC->seekHit < pOp->p2) {\n                    pC->seekHit = pOp->p2;\n                } else if (pC->seekHit > pOp->p3) {\n                    pC->seekHit = pOp->p3;\n                }\n                break;\n            }\n          case 25:\n            {\n                VdbeCursor *pCur;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pCur = p->apCsr[pOp->p1];\n                ;\n                if (pCur == 0 || pCur->nullRow) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                break;\n            }\n          case 26:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                if (pC->seekHit >= pOp->p4.i)\n                    break;\n            }\n          case 27:\n          case 28:\n          case 29:\n            {\n                int alreadyExists;\n                int ii;\n                VdbeCursor *pC;\n                UnpackedRecord *pIdxKey;\n                UnpackedRecord r;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p4type == (-3));\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                r.aMem = &aMem[pOp->p3];\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->isTable == 0);\n                r.nField = (u16)pOp->p4.i;\n                if (r.nField > 0) {\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &pC->seekResult);\n                } else {\n                    assert(r.aMem->flags & 16);\n                    assert(pOp->opcode != 27);\n                    rc = (((r.aMem)->flags & 1024) ? sqlite3VdbeMemExpandBlob(r.aMem) : 0);\n                    assert(rc == 0 || rc == 7);\n                    if (rc)\n                        goto no_mem;\n                    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);\n                    if (pIdxKey == 0)\n                        goto no_mem;\n                    sqlite3VdbeRecordUnpack(pC->pKeyInfo, r.aMem->n, r.aMem->z, pIdxKey);\n                    pIdxKey->default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, pIdxKey, &pC->seekResult);\n                    sqlite3DbFreeNN(db, pIdxKey);\n                }\n                if (rc != 0) {\n                    goto abort_due_to_error;\n                }\n                alreadyExists = (pC->seekResult == 0);\n                pC->nullRow = 1 - alreadyExists;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pOp->opcode == 29) {\n                    ;\n                    if (alreadyExists)\n                        goto jump_to_p2;\n                } else {\n                    if (!alreadyExists) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    if (pOp->opcode == 27) {\n                        for (ii = 0; ii < r.nField; ii++) {\n                            if (r.aMem[ii].flags & 1) {\n                                ;\n                                goto jump_to_p2;\n                            }\n                        }\n                    }\n                    ;\n                    if (pOp->opcode == 26) {\n                        pC->seekHit = pOp->p4.i;\n                    }\n                }\n                break;\n            }\n          case 30:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                u64 iKey;\n                pIn3 = &aMem[pOp->p3];\n                ;\n                ;\n                ;\n                ;\n                if ((pIn3->flags & (4 | 32)) == 0) {\n                    Mem x = pIn3[0];\n                    applyAffinity(&x, 67, encoding);\n                    if ((x.flags & 4) == 0)\n                        goto jump_to_p2;\n                    iKey = x.u.i;\n                    goto notExistsWithKey;\n                }\n              case 31:\n                pIn3 = &aMem[pOp->p3];\n                assert((pIn3->flags & 4) != 0 || pOp->opcode == 30);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                iKey = pIn3->u.i;\n              notExistsWithKey:\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isTable);\n                assert(pC->eCurType == 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr != 0);\n                res = 0;\n                rc = sqlite3BtreeTableMoveto(pCrsr, iKey, 0, &res);\n                assert(rc == 0 || res == 0);\n                pC->movetoTarget = iKey;\n                pC->nullRow = 0;\n                pC->cacheStatus = 0;\n                pC->deferredMoveto = 0;\n                ;\n                pC->seekResult = res;\n                if (res != 0) {\n                    assert(rc == 0);\n                    if (pOp->p2 == 0) {\n                        rc = sqlite3CorruptError(94942);\n                    } else {\n                        goto jump_to_p2;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 126:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(p->apCsr[pOp->p1] != 0);\n                assert(p->apCsr[pOp->p1]->eCurType != 2);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = p->apCsr[pOp->p1]->seqCount++;\n                break;\n            }\n          case 127:\n            {\n                i64 v;\n                VdbeCursor *pC;\n                int res;\n                int cnt;\n                Mem *pMem;\n                VdbeFrame *pFrame;\n                v = 0;\n                res = 0;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isTable);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                {\n                    assert(pC->isTable);\n                    if (!pC->useRandomRowid) {\n                        rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                        if (rc != 0) {\n                            goto abort_due_to_error;\n                        }\n                        if (res) {\n                            v = 1;\n                        } else {\n                            assert(sqlite3BtreeCursorIsValid(pC->uc.pCursor));\n                            v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                            if (v >= (i64)((((u64)2147483647) << 32) | (u64)4294967295U)) {\n                                pC->useRandomRowid = 1;\n                            } else {\n                                v++;\n                            }\n                        }\n                    }\n                    if (pOp->p3) {\n                        assert(pOp->p3 > 0);\n                        if (p->pFrame) {\n                            for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                                ;\n                            assert(pOp->p3 <= pFrame->nMem);\n                            pMem = &pFrame->aMem[pOp->p3];\n                        } else {\n                            assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                            pMem = &aMem[pOp->p3];\n                            ;\n                        }\n                        assert(memIsValid(pMem));\n                        ;\n                        sqlite3VdbeMemIntegerify(pMem);\n                        assert((pMem->flags & 4) != 0);\n                        if (pMem->u.i == (i64)((((u64)2147483647) << 32) | (u64)4294967295U) || pC->useRandomRowid) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        if (v < pMem->u.i + 1) {\n                            v = pMem->u.i + 1;\n                        }\n                        pMem->u.i = v;\n                    }\n                    if (pC->useRandomRowid) {\n                        assert(pOp->p3 == 0);\n                        cnt = 0;\n                        do {\n                            sqlite3_randomness(sizeof (v), &v);\n                            v &= ((i64)((((u64)2147483647) << 32) | (u64)4294967295U) >> 1);\n                            v++;\n                        } while (((rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)v, 0, &res)) == 0) && (res == 0) && (++cnt < 100));\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res == 0) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        assert(v > 0);\n                    }\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 128:\n            {\n                Mem *pData;\n                Mem *pKey;\n                VdbeCursor *pC;\n                int seekResult;\n                const char *zDb;\n                Table *pTab;\n                BtreePayload x;\n                pData = &aMem[pOp->p2];\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(memIsValid(pData));\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->uc.pCursor != 0);\n                assert((pOp->p5 & 64) || pC->isTable);\n                assert(pOp->p4type == (-5) || pOp->p4type >= (-1));\n                ;\n                ;\n                pKey = &aMem[pOp->p3];\n                assert(pKey->flags & 4);\n                assert(memIsValid(pKey));\n                ;\n                x.nKey = pKey->u.i;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    assert(pC->iDb >= 0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    assert((pOp->p5 & 64) || (((pTab)->tabFlags & 128) == 0));\n                } else {\n                    pTab = 0;\n                    zDb = 0;\n                }\n                if (pOp->p5 & 1)\n                    p->nChange++;\n                if (pOp->p5 & 32)\n                    db->lastRowid = x.nKey;\n                assert((pData->flags & (16 | 2)) != 0 || pData->n == 0);\n                x.pData = pData->z;\n                x.nData = pData->n;\n                seekResult = ((pOp->p5 & 16) ? pC->seekResult : 0);\n                if (pData->flags & 1024) {\n                    x.nZero = pData->u.nZero;\n                } else {\n                    x.nZero = 0;\n                }\n                x.pKey = 0;\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), seekResult);\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pTab) {\n                    assert(db->xUpdateCallback != 0);\n                    assert(pTab->aCol != 0);\n                    db->xUpdateCallback(db->pUpdateArg, (pOp->p5 & 4) ? 23 : 18, zDb, pTab->zName, x.nKey);\n                }\n                break;\n            }\n          case 129:\n            {\n                VdbeCursor *pDest;\n                VdbeCursor *pSrc;\n                i64 iKey;\n                assert(pOp[1].opcode == 128 || pOp[1].opcode == 138);\n                assert(pOp[1].opcode == 128 || pOp->p3 == 0);\n                assert(pOp[1].opcode == 138 || pOp->p3 > 0);\n                assert(pOp[1].p5 & 128);\n                pDest = p->apCsr[pOp->p1];\n                pSrc = p->apCsr[pOp->p2];\n                iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;\n                rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 130:\n            {\n                VdbeCursor *pC;\n                const char *zDb;\n                Table *pTab;\n                int opflags;\n                opflags = pOp->p2;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->deferredMoveto == 0);\n                ;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    assert(pC->iDb >= 0);\n                    assert(pOp->p4.pTab != 0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    if ((pOp->p5 & 2) != 0 && pC->isTable) {\n                        pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                    }\n                } else {\n                    zDb = 0;\n                    pTab = 0;\n                }\n                assert((pOp->p5 & ~(2 | 4)) == 0);\n                assert(2 == 2);\n                assert(4 == 4);\n                rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (opflags & 1) {\n                    p->nChange++;\n                    if (db->xUpdateCallback && (pTab != 0) && (((pTab)->tabFlags & 128) == 0)) {\n                        db->xUpdateCallback(db->pUpdateArg, 9, zDb, pTab->zName, pC->movetoTarget);\n                        assert(pC->iDb >= 0);\n                    }\n                }\n                break;\n            }\n          case 131:\n            {\n                sqlite3VdbeSetChanges(db, p->nChange);\n                p->nChange = 0;\n                break;\n            }\n          case 132:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nKeyCol;\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                assert(pOp->p4type == (-3));\n                pIn3 = &aMem[pOp->p3];\n                nKeyCol = pOp->p4.i;\n                res = 0;\n                rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n            ;\n          case 133:\n            {\n                VdbeCursor *pC;\n                pOut = &aMem[pOp->p2];\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                rc = sqlite3VdbeSorterRowkey(pC, pOut);\n                assert(rc != 0 || (pOut->flags & 16));\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                if (rc)\n                    goto abort_due_to_error;\n                p->apCsr[pOp->p3]->cacheStatus = 0;\n                break;\n            }\n          case 134:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 n;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(((pC)->eCurType == 1) == 0);\n                assert(pC->nullRow == 0);\n                assert(pC->uc.pCursor != 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pC->deferredMoveto == 0);\n                assert(sqlite3BtreeCursorIsValid(pCrsr));\n                n = sqlite3BtreePayloadSize(pCrsr);\n                if (n > (u32)db->aLimit[0]) {\n                    goto too_big;\n                }\n                ;\n                rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut);\n                if (rc)\n                    goto abort_due_to_error;\n                if (!pOp->p3)\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                ;\n                ;\n                ;\n                break;\n            }\n          case 135:\n            {\n                VdbeCursor *pC;\n                i64 v;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType != 3 || pC->nullRow);\n                if (pC->nullRow) {\n                    pOut->flags = 1;\n                    break;\n                } else if (pC->deferredMoveto) {\n                    v = pC->movetoTarget;\n                } else if (pC->eCurType == 2) {\n                    assert(pC->uc.pVCur != 0);\n                    pVtab = pC->uc.pVCur->pVtab;\n                    pModule = pVtab->pModule;\n                    assert(pModule->xRowid);\n                    rc = pModule->xRowid(pC->uc.pVCur, &v);\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else {\n                    assert(pC->eCurType == 0);\n                    assert(pC->uc.pCursor != 0);\n                    rc = sqlite3VdbeCursorRestore(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (pC->nullRow) {\n                        pOut->flags = 1;\n                        break;\n                    }\n                    v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 136:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if (pC == 0) {\n                    pC = allocateCursor(p, pOp->p1, 1, 3);\n                    if (pC == 0)\n                        goto no_mem;\n                    pC->seekResult = 0;\n                    pC->isTable = 1;\n                    pC->noReuse = 1;\n                    pC->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                }\n                pC->nullRow = 1;\n                pC->cacheStatus = 0;\n                if (pC->eCurType == 0) {\n                    assert(pC->uc.pCursor != 0);\n                    sqlite3BtreeClearCursor(pC->uc.pCursor);\n                }\n                break;\n            }\n          case 137:\n          case 32:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                pCrsr = pC->uc.pCursor;\n                res = 0;\n                assert(pCrsr != 0);\n                if (pOp->opcode == 137) {\n                    assert(pOp->p2 == 0);\n                    pC->seekResult = -1;\n                    if (sqlite3BtreeCursorIsValidNN(pCrsr)) {\n                        break;\n                    }\n                }\n                rc = sqlite3BtreeLast(pCrsr, &res);\n                pC->nullRow = (u8)res;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pOp->p2 > 0) {\n                    ;\n                    if (res)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 33:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                i64 sz;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr);\n                rc = sqlite3BtreeFirst(pCrsr, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    sz = sqlite3BtreeRowCountEst(pCrsr);\n                    if ((sz >= 0) && sqlite3LogEst((u64)sz) < pOp->p3)\n                        res = 1;\n                }\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 34:\n          case 35:\n            {\n                p->aCounter[2]++;\n            }\n          case 36:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(((pC)->eCurType == 1) == (pOp->opcode == 34));\n                res = 1;\n                if (((pC)->eCurType == 1)) {\n                    rc = sqlite3VdbeSorterRewind(pC, &res);\n                } else {\n                    assert(pC->eCurType == 0);\n                    pCrsr = pC->uc.pCursor;\n                    assert(pCrsr);\n                    rc = sqlite3BtreeFirst(pCrsr, &res);\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pC->nullRow = (u8)res;\n                assert(pOp->p2 > 0 && pOp->p2 < p->nOp);\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 37:\n            {\n                VdbeCursor *pC;\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                rc = sqlite3VdbeSorterNext(db, pC);\n                goto next_tail;\n              case 38:\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0 || pOp->p5 == 1 || pOp->p5 == 3);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->eCurType == 0);\n                assert(<recovery-expr>(pC) == 21 || <recovery-expr>(pC) == 22 || <recovery-expr>(pC) == 32 || <recovery-expr>(pC) == 26 || <recovery-expr>(pC) == 136);\n                rc = sqlite3BtreePrevious(pC->uc.pCursor, pOp->p3);\n                goto next_tail;\n              case 39:\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0 || pOp->p5 == 1 || pOp->p5 == 3);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->eCurType == 0);\n                assert(<recovery-expr>(pC) == 24 || <recovery-expr>(pC) == 23 || <recovery-expr>(pC) == 36 || <recovery-expr>(pC) == 29 || <recovery-expr>(pC) == 136 || <recovery-expr>(pC) == 30 || <recovery-expr>(pC) == 26);\n                rc = sqlite3BtreeNext(pC->uc.pCursor, pOp->p3);\n              next_tail:\n                pC->cacheStatus = 0;\n                ;\n                if (rc == 0) {\n                    pC->nullRow = 0;\n                    p->aCounter[pOp->p5]++;\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                if (rc != 101)\n                    goto abort_due_to_error;\n                rc = 0;\n                pC->nullRow = 1;\n                goto check_for_interrupt;\n            }\n          case 138:\n            {\n                VdbeCursor *pC;\n                BtreePayload x;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                ;\n                assert(pC != 0);\n                assert(!((pC)->eCurType == 1));\n                pIn2 = &aMem[pOp->p2];\n                assert((pIn2->flags & 16) || (pOp->p5 & 128));\n                if (pOp->p5 & 1)\n                    p->nChange++;\n                assert(pC->eCurType == 0);\n                assert(pC->isTable == 0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                x.nKey = pIn2->n;\n                x.pKey = pIn2->z;\n                x.aMem = aMem + pOp->p3;\n                x.nMem = (u16)pOp->p4.i;\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), ((pOp->p5 & 16) ? pC->seekResult : 0));\n                assert(pC->deferredMoveto == 0);\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 139:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                ;\n                assert(pC != 0);\n                assert(((pC)->eCurType == 1));\n                pIn2 = &aMem[pOp->p2];\n                assert(pIn2->flags & 16);\n                assert(pC->isTable == 0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeSorterWrite(pC, pIn2);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 140:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                UnpackedRecord r;\n                assert(pOp->p3 > 0);\n                assert(pOp->p2 > 0 && pOp->p2 + pOp->p3 <= (p->nMem + 1 - p->nCursor) + 1);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                ;\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr != 0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p3;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp->p2];\n                rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    rc = sqlite3BtreeDelete(pCrsr, 4);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else if (pOp->p5 && !sqlite3WritableSchema(db)) {\n                    rc = sqlite3ReportError((11 | (3 << 8)), 96007, \"index corruption\");\n                    goto abort_due_to_error;\n                }\n                assert(pC->deferredMoveto == 0);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                break;\n            }\n          case 141:\n          case 142:\n            {\n                VdbeCursor *pC;\n                VdbeCursor *pTabCur;\n                i64 rowid;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0 || ((pC)->eCurType == 3 && (pC)->nullRow && (pC)->seekResult == 0));\n                assert(pC->uc.pCursor != 0);\n                assert(pC->isTable == 0 || ((pC)->eCurType == 3 && (pC)->nullRow && (pC)->seekResult == 0));\n                assert(pC->deferredMoveto == 0);\n                assert(!pC->nullRow || pOp->opcode == 142);\n                rc = sqlite3VdbeCursorRestore(pC);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                if (!pC->nullRow) {\n                    rowid = 0;\n                    rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (pOp->opcode == 141) {\n                        assert(pOp->p3 >= 0 && pOp->p3 < p->nCursor);\n                        pTabCur = p->apCsr[pOp->p3];\n                        assert(pTabCur != 0);\n                        assert(pTabCur->eCurType == 0);\n                        assert(pTabCur->uc.pCursor != 0);\n                        assert(pTabCur->isTable);\n                        pTabCur->nullRow = 0;\n                        pTabCur->movetoTarget = rowid;\n                        pTabCur->deferredMoveto = 1;\n                        pTabCur->cacheStatus = 0;\n                        assert(pOp->p4type == (-14) || pOp->p4.ai == 0);\n                        assert(!pTabCur->isEphemeral);\n                        pTabCur->ub.aAltMap = pOp->p4.ai;\n                        assert(!pC->isEphemeral);\n                        pTabCur->pAltCursor = pC;\n                    } else {\n                        pOut = out2Prerelease(p, pOp);\n                        pOut->u.i = rowid;\n                    }\n                } else {\n                    assert(pOp->opcode == 142);\n                    sqlite3VdbeMemSetNull(&aMem[pOp->p2]);\n                }\n                break;\n            }\n          case 143:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if (pC->deferredMoveto) {\n                    rc = sqlite3VdbeFinishMoveto(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 40:\n          case 41:\n          case 42:\n          case 45:\n            {\n                VdbeCursor *pC;\n                int res;\n                UnpackedRecord r;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isOrdered);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pOp->p4type == (-3));\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p4.i;\n                if (pOp->opcode < 42) {\n                    assert(pOp->opcode == 40 || pOp->opcode == 41);\n                    r.default_rc = -1;\n                } else {\n                    assert(pOp->opcode == 45 || pOp->opcode == 42);\n                    r.default_rc = 0;\n                }\n                r.aMem = &aMem[pOp->p3];\n                {\n                    i64 nCellKey = 0;\n                    BtCursor *pCur;\n                    Mem m;\n                    assert(pC->eCurType == 0);\n                    pCur = pC->uc.pCursor;\n                    assert(sqlite3BtreeCursorIsValid(pCur));\n                    nCellKey = sqlite3BtreePayloadSize(pCur);\n                    if (nCellKey <= 0 || nCellKey > 2147483647) {\n                        rc = sqlite3CorruptError(96212);\n                        goto abort_due_to_error;\n                    }\n                    sqlite3VdbeMemInit(&m, db, 0);\n                    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n                    if (rc)\n                        goto abort_due_to_error;\n                    res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);\n                    sqlite3VdbeMemReleaseMalloc(&m);\n                }\n                assert((40 & 1) == (42 & 1) && (45 & 1) == (41 & 1));\n                if ((pOp->opcode & 1) == (42 & 1)) {\n                    assert(pOp->opcode == 40 || pOp->opcode == 42);\n                    res = -res;\n                } else {\n                    assert(pOp->opcode == 45 || pOp->opcode == 41);\n                    res++;\n                }\n                ;\n                assert(rc == 0);\n                if (res > 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 144:\n            {\n                int iMoved;\n                int iDb;\n                ;\n                assert(p->readOnly == 0);\n                assert(pOp->p1 > 1);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                if (db->nVdbeRead > db->nVDestroy + 1) {\n                    rc = 6;\n                    p->errorAction = 2;\n                    goto abort_due_to_error;\n                } else {\n                    iDb = pOp->p3;\n                    assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                    iMoved = 0;\n                    rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);\n                    pOut->flags = 4;\n                    pOut->u.i = iMoved;\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (iMoved != 0) {\n                        sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);\n                        assert(resetSchemaOnFault == 0 || resetSchemaOnFault == iDb + 1);\n                        resetSchemaOnFault = iDb + 1;\n                    }\n                }\n                break;\n            }\n          case 145:\n            {\n                i64 nChange;\n                ;\n                nChange = 0;\n                assert(p->readOnly == 0);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p2))) != 0));\n                rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, (u32)pOp->p1, &nChange);\n                if (pOp->p3) {\n                    p->nChange += nChange;\n                    if (pOp->p3 > 0) {\n                        assert(memIsValid(&aMem[pOp->p3]));\n                        ;\n                        aMem[pOp->p3].u.i += nChange;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 146:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                if (((pC)->eCurType == 1)) {\n                    sqlite3VdbeSorterReset(db, pC->uc.pSorter);\n                } else {\n                    assert(pC->eCurType == 0);\n                    assert(pC->isEphemeral);\n                    rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 147:\n            {\n                Pgno pgno;\n                Db *pDb;\n                ;\n                pOut = out2Prerelease(p, pOp);\n                pgno = 0;\n                assert(pOp->p3 == 1 || pOp->p3 == 2);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pDb = &db->aDb[pOp->p1];\n                assert(pDb->pBt != 0);\n                rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, pOp->p3);\n                if (rc)\n                    goto abort_due_to_error;\n                pOut->u.i = pgno;\n                break;\n            }\n          case 148:\n            {\n                ;\n                db->nSqlExec++;\n                rc = sqlite3_exec(db, pOp->p4.z, 0, 0, 0);\n                db->nSqlExec--;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 149:\n            {\n                int iDb;\n                const char *zSchema;\n                char *zSql;\n                InitData initData;\n                iDb = pOp->p1;\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert((((db)->aDb[iDb].pSchema->schemaFlags & (1)) == (1)) || db->mallocFailed || ((sqlite3Config.neverCorrupt == 0) && (db->flags & 134217728) != 0));\n                if (pOp->p4.z == 0) {\n                    sqlite3SchemaClear(db->aDb[iDb].pSchema);\n                    db->mDbFlags &= ~16;\n                    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, pOp->p5);\n                    db->mDbFlags |= 1;\n                    p->expired = 0;\n                } else {\n                    zSchema = \"sqlite_master\";\n                    initData.db = db;\n                    initData.iDb = iDb;\n                    initData.pzErrMsg = &p->zErrMsg;\n                    initData.mInitFlags = 0;\n                    initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);\n                    zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".%s WHERE %s ORDER BY rowid\", db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);\n                    if (zSql == 0) {\n                        rc = 7;\n                    } else {\n                        assert(db->init.busy == 0);\n                        db->init.busy = 1;\n                        initData.rc = 0;\n                        initData.nInitRow = 0;\n                        assert(!db->mallocFailed);\n                        rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n                        if (rc == 0)\n                            rc = initData.rc;\n                        if (rc == 0 && initData.nInitRow == 0) {\n                            rc = sqlite3CorruptError(96464);\n                        }\n                        sqlite3DbFreeNN(db, zSql);\n                        db->init.busy = 0;\n                    }\n                }\n                if (rc) {\n                    sqlite3ResetAllSchemasOfConnection(db);\n                    if (rc == 7) {\n                        goto no_mem;\n                    }\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 150:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                rc = sqlite3AnalysisLoad(db, pOp->p1);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 151:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 152:\n            {\n                ;\n                sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 154:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 155:\n            {\n                int nRoot;\n                Pgno *aRoot;\n                int nErr;\n                char *z;\n                Mem *pnErr;\n                assert(p->bIsReader);\n                nRoot = pOp->p2;\n                aRoot = pOp->p4.ai;\n                assert(nRoot > 0);\n                assert(aRoot[0] == (Pgno)nRoot);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pnErr = &aMem[pOp->p3];\n                assert((pnErr->flags & 4) != 0);\n                assert((pnErr->flags & (2 | 16)) == 0);\n                pIn1 = &aMem[pOp->p1];\n                assert(pOp->p5 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p5))) != 0));\n                z = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot, (int)pnErr->u.i + 1, &nErr);\n                sqlite3VdbeMemSetNull(pIn1);\n                if (nErr == 0) {\n                    assert(z == 0);\n                } else if (z == 0) {\n                    goto no_mem;\n                } else {\n                    pnErr->u.i -= nErr - 1;\n                    sqlite3VdbeMemSetStr(pIn1, z, -1, 1, sqlite3_free);\n                }\n                ;\n                sqlite3VdbeChangeEncoding(pIn1, encoding);\n                goto check_for_interrupt;\n            }\n          case 156:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                assert((pIn2->flags & 4) != 0);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                assert(sqlite3VdbeMemIsRowSet(pIn1));\n                sqlite3RowSetInsert((RowSet *)pIn1->z, pIn2->u.i);\n                break;\n            }\n          case 46:\n            {\n                i64 val;\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 16) == 0 || sqlite3VdbeMemIsRowSet(pIn1));\n                if ((pIn1->flags & 16) == 0 || sqlite3RowSetNext((RowSet *)pIn1->z, &val) == 0) {\n                    sqlite3VdbeMemSetNull(pIn1);\n                    ;\n                    goto jump_to_p2_and_check_for_interrupt;\n                } else {\n                    ;\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);\n                }\n                goto check_for_interrupt;\n            }\n          case 47:\n            {\n                int iSet;\n                int exists;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                iSet = pOp->p4.i;\n                assert(pIn3->flags & 4);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                assert(sqlite3VdbeMemIsRowSet(pIn1));\n                assert(pOp->p4type == (-3));\n                assert(iSet == -1 || iSet >= 0);\n                if (iSet) {\n                    exists = sqlite3RowSetTest((RowSet *)pIn1->z, iSet, pIn3->u.i);\n                    ;\n                    if (exists)\n                        goto jump_to_p2;\n                }\n                if (iSet >= 0) {\n                    sqlite3RowSetInsert((RowSet *)pIn1->z, pIn3->u.i);\n                }\n                break;\n            }\n          case 48:\n            {\n                int nMem;\n                int nByte;\n                Mem *pRt;\n                Mem *pMem;\n                Mem *pEnd;\n                VdbeFrame *pFrame;\n                SubProgram *pProgram;\n                void *t;\n                pProgram = pOp->p4.pProgram;\n                pRt = &aMem[pOp->p3];\n                assert(pProgram->nOp > 0);\n                if (pOp->p5) {\n                    t = pProgram->token;\n                    for (pFrame = p->pFrame; pFrame && pFrame->token != t; pFrame = pFrame->pParent)\n                        ;\n                    if (pFrame)\n                        break;\n                }\n                if (p->nFrame >= db->aLimit[10]) {\n                    rc = 1;\n                    sqlite3VdbeError(p, \"too many levels of trigger recursion\");\n                    goto abort_due_to_error;\n                }\n                if ((pRt->flags & 16) == 0) {\n                    nMem = pProgram->nMem + pProgram->nCsr;\n                    assert(nMem > 0);\n                    if (pProgram->nCsr == 0)\n                        nMem++;\n                    nByte = (((sizeof(VdbeFrame)) + 7) & ~7) + nMem * sizeof(Mem) + pProgram->nCsr * sizeof(VdbeCursor *) + (pProgram->nOp + 7) / 8;\n                    pFrame = sqlite3DbMallocZero(db, nByte);\n                    if (!pFrame) {\n                        goto no_mem;\n                    }\n                    sqlite3VdbeMemRelease(pRt);\n                    pRt->flags = 16 | 4096;\n                    pRt->z = (char *)pFrame;\n                    pRt->n = nByte;\n                    pRt->xDel = sqlite3VdbeFrameMemDel;\n                    pFrame->v = p;\n                    pFrame->nChildMem = nMem;\n                    pFrame->nChildCsr = pProgram->nCsr;\n                    pFrame->pc = (int)(pOp - aOp);\n                    pFrame->aMem = p->aMem;\n                    pFrame->nMem = p->nMem;\n                    pFrame->apCsr = p->apCsr;\n                    pFrame->nCursor = p->nCursor;\n                    pFrame->aOp = p->aOp;\n                    pFrame->nOp = p->nOp;\n                    pFrame->token = pProgram->token;\n                    pEnd = &((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)])[pFrame->nChildMem];\n                    for (pMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]); pMem != pEnd; pMem++) {\n                        pMem->flags = 0;\n                        pMem->db = db;\n                    }\n                } else {\n                    pFrame = (VdbeFrame *)pRt->z;\n                    assert(pRt->xDel == sqlite3VdbeFrameMemDel);\n                    assert(pProgram->nMem + pProgram->nCsr == pFrame->nChildMem || (pProgram->nCsr == 0 && pProgram->nMem + 1 == pFrame->nChildMem));\n                    assert(pProgram->nCsr == pFrame->nChildCsr);\n                    assert((int)(pOp - aOp) == pFrame->pc);\n                }\n                p->nFrame++;\n                pFrame->pParent = p->pFrame;\n                pFrame->lastRowid = db->lastRowid;\n                pFrame->nChange = p->nChange;\n                pFrame->nDbChange = p->db->nChange;\n                assert(pFrame->pAuxData == 0);\n                pFrame->pAuxData = p->pAuxData;\n                p->pAuxData = 0;\n                p->nChange = 0;\n                p->pFrame = pFrame;\n                p->aMem = aMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]);\n                p->nMem = pFrame->nChildMem;\n                p->nCursor = (u16)pFrame->nChildCsr;\n                p->apCsr = (VdbeCursor **)&aMem[p->nMem];\n                pFrame->aOnce = (u8 *)&p->apCsr[pProgram->nCsr];\n                memset(pFrame->aOnce, 0, (pProgram->nOp + 7) / 8);\n                p->aOp = aOp = pProgram->aOp;\n                p->nOp = pProgram->nOp;\n                pOp = &aOp[-1];\n                goto check_for_interrupt;\n            }\n          case 157:\n            {\n                VdbeFrame *pFrame;\n                Mem *pIn;\n                pOut = out2Prerelease(p, pOp);\n                pFrame = p->pFrame;\n                pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];\n                sqlite3VdbeMemShallowCopy(pOut, pIn, 16384);\n                break;\n            }\n          case 158:\n            {\n                if (db->flags & 524288) {\n                    db->nDeferredImmCons += pOp->p2;\n                } else if (pOp->p1) {\n                    db->nDeferredCons += pOp->p2;\n                } else {\n                    p->nFkConstraint += pOp->p2;\n                }\n                break;\n            }\n          case 49:\n            {\n                if (pOp->p1) {\n                    ;\n                    if (db->nDeferredCons == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                } else {\n                    ;\n                    if (p->nFkConstraint == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 159:\n            {\n                VdbeFrame *pFrame;\n                if (p->pFrame) {\n                    for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                        ;\n                    pIn1 = &pFrame->aMem[pOp->p1];\n                } else {\n                    pIn1 = &aMem[pOp->p1];\n                }\n                assert(memIsValid(pIn1));\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn2 = &aMem[pOp->p2];\n                sqlite3VdbeMemIntegerify(pIn2);\n                if (pIn1->u.i < pIn2->u.i) {\n                    pIn1->u.i = pIn2->u.i;\n                }\n                break;\n            }\n          case 59:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                ;\n                if (pIn1->u.i > 0) {\n                    pIn1->u.i -= pOp->p3;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 160:\n            {\n                i64 x;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                assert(pIn1->flags & 4);\n                assert(pIn3->flags & 4);\n                x = pIn1->u.i;\n                if (x <= 0 || sqlite3AddInt64(&x, pIn3->u.i > 0 ? pIn3->u.i : 0)) {\n                    pOut->u.i = -1;\n                } else {\n                    pOut->u.i = x;\n                }\n                break;\n            }\n          case 60:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                ;\n                if (pIn1->u.i) {\n                    if (pIn1->u.i > 0)\n                        pIn1->u.i--;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 61:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                if (pIn1->u.i > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                    pIn1->u.i--;\n                ;\n                if (pIn1->u.i == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 161:\n          case 162:\n            {\n                int n;\n                sqlite3_context *pCtx;\n                assert(pOp->p4type == (-7));\n                n = pOp->p5;\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                assert(n == 0 || (pOp->p2 > 0 && pOp->p2 + n <= (p->nMem + 1 - p->nCursor) + 1));\n                assert(pOp->p3 < pOp->p2 || pOp->p3 >= pOp->p2 + n);\n                pCtx = sqlite3DbMallocRawNN(db, n * sizeof(sqlite3_value *) + (sizeof (pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value *)));\n                if (pCtx == 0)\n                    goto no_mem;\n                pCtx->pMem = 0;\n                pCtx->pOut = (Mem *)&(pCtx->argv[n]);\n                sqlite3VdbeMemInit(pCtx->pOut, db, 1);\n                pCtx->pFunc = pOp->p4.pFunc;\n                pCtx->iOp = (int)(pOp - aOp);\n                pCtx->pVdbe = p;\n                pCtx->skipFlag = 0;\n                pCtx->isError = 0;\n                pCtx->enc = encoding;\n                pCtx->argc = n;\n                pOp->p4type = (-15);\n                pOp->p4.pCtx = pCtx;\n                assert(pOp->p1 == (pOp->opcode == 161));\n                pOp->opcode = 163;\n            }\n          case 163:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                Mem *pMem;\n                assert(pOp->p4type == (-15));\n                pCtx = pOp->p4.pCtx;\n                pMem = &aMem[pOp->p3];\n                if (pCtx->pMem != pMem) {\n                    pCtx->pMem = pMem;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                pMem->n++;\n                assert(pCtx->pOut->flags == 1);\n                assert(pCtx->isError == 0);\n                assert(pCtx->skipFlag == 0);\n                if (pOp->p1) {\n                    (pCtx->pFunc->xInverse)(pCtx, pCtx->argc, pCtx->argv);\n                } else\n                    (pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pCtx->pOut));\n                        rc = pCtx->isError;\n                    }\n                    if (pCtx->skipFlag) {\n                        assert(pOp[-1].opcode == 85);\n                        i = pOp[-1].p1;\n                        if (i)\n                            sqlite3VdbeMemSetInt64(&aMem[i], 1);\n                        pCtx->skipFlag = 0;\n                    }\n                    sqlite3VdbeMemRelease(pCtx->pOut);\n                    pCtx->pOut->flags = 1;\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                assert(pCtx->pOut->flags == 1);\n                assert(pCtx->skipFlag == 0);\n                break;\n            }\n          case 164:\n          case 165:\n            {\n                Mem *pMem;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                assert(pOp->p3 == 0 || pOp->opcode == 164);\n                pMem = &aMem[pOp->p1];\n                assert((pMem->flags & ~(1 | 32768)) == 0);\n                if (pOp->p3) {\n                    ;\n                    rc = sqlite3VdbeMemAggValue(pMem, &aMem[pOp->p3], pOp->p4.pFunc);\n                    pMem = &aMem[pOp->p3];\n                } else {\n                    rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);\n                }\n                if (rc) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pMem));\n                    goto abort_due_to_error;\n                }\n                sqlite3VdbeChangeEncoding(pMem, encoding);\n                ;\n                break;\n            }\n          case 3:\n            {\n                int i;\n                int aRes[3];\n                Mem *pMem;\n                assert(p->readOnly == 0);\n                aRes[0] = 0;\n                aRes[1] = aRes[2] = -1;\n                assert(pOp->p2 == 0 || pOp->p2 == 1 || pOp->p2 == 2 || pOp->p2 == 3);\n                rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);\n                if (rc) {\n                    if (rc != 5)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    aRes[0] = 1;\n                }\n                for (i = 0 , pMem = &aMem[pOp->p3]; i < 3; i++ , pMem++) {\n                    sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);\n                }\n                break;\n            }\n            ;\n          case 4:\n            {\n                Btree *pBt;\n                Pager *pPager;\n                int eNew;\n                int eOld;\n                const char *zFilename;\n                pOut = out2Prerelease(p, pOp);\n                eNew = pOp->p3;\n                assert(eNew == 0 || eNew == 3 || eNew == 1 || eNew == 2 || eNew == 4 || eNew == 5 || eNew == (-1));\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert(p->readOnly == 0);\n                pBt = db->aDb[pOp->p1].pBt;\n                pPager = sqlite3BtreePager(pBt);\n                eOld = sqlite3PagerGetJournalMode(pPager);\n                if (eNew == (-1))\n                    eNew = eOld;\n                assert(sqlite3BtreeHoldsMutex(pBt));\n                if (!sqlite3PagerOkToChangeJournalMode(pPager))\n                    eNew = eOld;\n                zFilename = sqlite3PagerFilename(pPager, 1);\n                if (eNew == 5 && (sqlite3Strlen30(zFilename) == 0 || !sqlite3PagerWalSupported(pPager))) {\n                    eNew = eOld;\n                }\n                if ((eNew != eOld) && (eOld == 5 || eNew == 5)) {\n                    if (!db->autoCommit || db->nVdbeRead > 1) {\n                        rc = 1;\n                        sqlite3VdbeError(p, \"cannot change %s wal mode from within a transaction\", (eNew == 5 ? \"into\" : \"out of\"));\n                        goto abort_due_to_error;\n                    } else {\n                        if (eOld == 5) {\n                            rc = sqlite3PagerCloseWal(pPager, db);\n                            if (rc == 0) {\n                                sqlite3PagerSetJournalMode(pPager, eNew);\n                            }\n                        } else if (eOld == 4) {\n                            sqlite3PagerSetJournalMode(pPager, 2);\n                        }\n                        assert(sqlite3BtreeTxnState(pBt) != 2);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeSetVersion(pBt, (eNew == 5 ? 2 : 1));\n                        }\n                    }\n                }\n                if (rc)\n                    eNew = eOld;\n                eNew = sqlite3PagerSetJournalMode(pPager, eNew);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = (char *)sqlite3JournalModename(eNew);\n                pOut->n = sqlite3Strlen30(pOut->z);\n                pOut->enc = 1;\n                sqlite3VdbeChangeEncoding(pOut, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 5:\n            {\n                assert(p->readOnly == 0);\n                rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1, pOp->p2 ? &aMem[pOp->p2] : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 62:\n            {\n                Btree *pBt;\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pBt = db->aDb[pOp->p1].pBt;\n                rc = sqlite3BtreeIncrVacuum(pBt);\n                ;\n                if (rc) {\n                    if (rc != 101)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 166:\n            {\n                assert(pOp->p2 == 0 || pOp->p2 == 1);\n                if (!pOp->p1) {\n                    sqlite3ExpirePreparedStatements(db, pOp->p2);\n                } else {\n                    p->expired = pOp->p2 + 1;\n                }\n                break;\n            }\n          case 167:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                sqlite3BtreeCursorPin(pC->uc.pCursor);\n                break;\n            }\n          case 168:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                sqlite3BtreeCursorUnpin(pC->uc.pCursor);\n                break;\n            }\n          case 169:\n            {\n                u8 isWriteLock = (u8)pOp->p3;\n                if (isWriteLock || 0 == (db->flags & 1024)) {\n                    int p1 = pOp->p1;\n                    assert(p1 >= 0 && p1 < db->nDb);\n                    assert((((p->btreeMask) & (((yDbMask)1) << (p1))) != 0));\n                    assert(isWriteLock == 0 || isWriteLock == 1);\n                    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);\n                    if (rc) {\n                        if ((rc & 255) == 6) {\n                            const char *z = pOp->p4.z;\n                            sqlite3VdbeError(p, \"database table is locked: %s\", z);\n                        }\n                        goto abort_due_to_error;\n                    }\n                }\n                break;\n            }\n          case 170:\n            {\n                VTable *pVTab;\n                pVTab = pOp->p4.pVtab;\n                rc = sqlite3VtabBegin(db, pVTab);\n                if (pVTab)\n                    sqlite3VtabImportErrmsg(p, pVTab->pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 171:\n            {\n                Mem sMem;\n                const char *zTab;\n                memset(&sMem, 0, sizeof (sMem));\n                sMem.db = db;\n                assert((aMem[pOp->p2].flags & 2) != 0);\n                assert((aMem[pOp->p2].flags & 8192) != 0);\n                rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);\n                assert(rc == 0);\n                zTab = (const char *)sqlite3_value_text(&sMem);\n                assert(zTab || db->mallocFailed);\n                if (zTab) {\n                    rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);\n                }\n                sqlite3VdbeMemRelease(&sMem);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 172:\n            {\n                db->nVDestroy++;\n                rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);\n                db->nVDestroy--;\n                assert(p->errorAction == 2 && p->usesStmtJournal);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 173:\n            {\n                VdbeCursor *pCur;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                assert(p->bIsReader);\n                pCur = 0;\n                pVCur = 0;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                rc = pModule->xOpen(pVtab, &pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                pVCur->pVtab = pVtab;\n                pCur = allocateCursor(p, pOp->p1, 0, 2);\n                if (pCur) {\n                    pCur->uc.pVCur = pVCur;\n                    pVtab->nRef++;\n                } else {\n                    assert(db->mallocFailed);\n                    pModule->xClose(pVCur);\n                    goto no_mem;\n                }\n                break;\n            }\n          case 174:\n            {\n                VdbeCursor *pC;\n                ValueList *pRhs;\n                pC = p->apCsr[pOp->p1];\n                pRhs = sqlite3_malloc64(sizeof (*pRhs));\n                if (pRhs == 0)\n                    goto no_mem;\n                pRhs->pCsr = pC->uc.pCursor;\n                pRhs->pOut = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                sqlite3VdbeMemSetPointer(pOut, pRhs, \"ValueList\", sqlite3_free);\n                break;\n            }\n          case 6:\n            {\n                int nArg;\n                int iQuery;\n                const sqlite3_module *pModule;\n                Mem *pQuery;\n                Mem *pArgc;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                VdbeCursor *pCur;\n                int res;\n                int i;\n                Mem **apArg;\n                pQuery = &aMem[pOp->p3];\n                pArgc = &pQuery[1];\n                pCur = p->apCsr[pOp->p1];\n                assert(memIsValid(pQuery));\n                ;\n                assert(pCur != 0);\n                assert(pCur->eCurType == 2);\n                pVCur = pCur->uc.pVCur;\n                pVtab = pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert((pQuery->flags & 4) != 0 && pArgc->flags == 4);\n                nArg = (int)pArgc->u.i;\n                iQuery = (int)pQuery->u.i;\n                apArg = p->apArg;\n                for (i = 0; i < nArg; i++) {\n                    apArg[i] = &pArgc[i + 1];\n                }\n                rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pVCur);\n                pCur->nullRow = 0;\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 175:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                Mem *pDest;\n                sqlite3_context sContext;\n                VdbeCursor *pCur = p->apCsr[pOp->p1];\n                assert(pCur != 0);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pDest = &aMem[pOp->p3];\n                ;\n                if (pCur->nullRow) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    break;\n                }\n                assert(pCur->eCurType == 2);\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert(pModule->xColumn);\n                memset(&sContext, 0, sizeof (sContext));\n                sContext.pOut = pDest;\n                sContext.enc = encoding;\n                assert(pOp->p5 == 1 || pOp->p5 == 0);\n                if (pOp->p5 & 1) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    pDest->flags = 1 | 1024;\n                    pDest->u.nZero = 0;\n                } else {\n                    ((pDest)->flags = ((pDest)->flags & ~(3519 | 1024)) | 1);\n                }\n                rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (sContext.isError > 0) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pDest));\n                    rc = sContext.isError;\n                }\n                sqlite3VdbeChangeEncoding(pDest, encoding);\n                ;\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 63:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int res;\n                VdbeCursor *pCur;\n                pCur = p->apCsr[pOp->p1];\n                assert(pCur != 0);\n                assert(pCur->eCurType == 2);\n                if (pCur->nullRow) {\n                    break;\n                }\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert(pModule->xNext);\n                rc = pModule->xNext(pCur->uc.pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pCur->uc.pVCur);\n                ;\n                if (!res) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                goto check_for_interrupt;\n            }\n          case 176:\n            {\n                sqlite3_vtab *pVtab;\n                Mem *pName;\n                int isLegacy;\n                isLegacy = (db->flags & 67108864);\n                db->flags |= 67108864;\n                pVtab = pOp->p4.pVtab->pVtab;\n                pName = &aMem[pOp->p1];\n                assert(pVtab->pModule->xRename);\n                assert(memIsValid(pName));\n                assert(p->readOnly == 0);\n                ;\n                assert(pName->flags & 2);\n                ;\n                ;\n                ;\n                rc = sqlite3VdbeChangeEncoding(pName, 1);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = pVtab->pModule->xRename(pVtab, pName->z);\n                if (isLegacy == 0)\n                    db->flags &= ~(u64)67108864;\n                sqlite3VtabImportErrmsg(p, pVtab);\n                p->expired = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 7:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int nArg;\n                int i;\n                sqlite_int64 rowid = 0;\n                Mem **apArg;\n                Mem *pX;\n                assert(pOp->p2 == 1 || pOp->p5 == 3 || pOp->p5 == 1 || pOp->p5 == 2 || pOp->p5 == 4 || pOp->p5 == 5);\n                assert(p->readOnly == 0);\n                if (db->mallocFailed)\n                    goto no_mem;\n                ;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                nArg = pOp->p2;\n                assert(pOp->p4type == (-11));\n                if ((pModule->xUpdate)) {\n                    u8 vtabOnConflict = db->vtabOnConflict;\n                    apArg = p->apArg;\n                    pX = &aMem[pOp->p3];\n                    for (i = 0; i < nArg; i++) {\n                        assert(memIsValid(pX));\n                        ;\n                        apArg[i] = pX;\n                        pX++;\n                    }\n                    db->vtabOnConflict = pOp->p5;\n                    rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);\n                    db->vtabOnConflict = vtabOnConflict;\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc == 0 && pOp->p1) {\n                        assert(nArg > 1 && apArg[0] && (apArg[0]->flags & 1));\n                        db->lastRowid = rowid;\n                    }\n                    if ((rc & 255) == 19 && pOp->p4.pVtab->bConstraint) {\n                        if (pOp->p5 == 4) {\n                            rc = 0;\n                        } else {\n                            p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5);\n                        }\n                    } else {\n                        p->nChange++;\n                    }\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 177:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);\n                break;\n            }\n          case 178:\n            {\n                unsigned int newMax;\n                Btree *pBt;\n                pOut = out2Prerelease(p, pOp);\n                pBt = db->aDb[pOp->p1].pBt;\n                newMax = 0;\n                if (pOp->p3) {\n                    newMax = sqlite3BtreeLastPage(pBt);\n                    if (newMax < (unsigned int)pOp->p3)\n                        newMax = (unsigned int)pOp->p3;\n                }\n                pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);\n                break;\n            }\n          case 65:\n          case 66:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                assert(pOp->p4type == (-15));\n                pCtx = pOp->p4.pCtx;\n                pOut = &aMem[pOp->p3];\n                if (pCtx->pOut != pOut) {\n                    pCtx->pVdbe = p;\n                    pCtx->pOut = pOut;\n                    pCtx->enc = encoding;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                assert(pCtx->pVdbe == p);\n                ;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                assert(pCtx->isError == 0);\n                (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pOut));\n                        rc = pCtx->isError;\n                    }\n                    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                assert((pOut->flags & 2) == 0 || pOut->enc == encoding || db->mallocFailed);\n                assert(!sqlite3VdbeMemTooBig(pOut));\n                ;\n                ;\n                break;\n            }\n          case 179:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn1->flags &= ~2048;\n                break;\n            }\n          case 180:\n            {\n                u64 h;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 16);\n                assert(pIn1->n > 0);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                pIn1->z[h / 8] |= 1 << (h & 7);\n                break;\n            }\n          case 64:\n            {\n                u64 h;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 16) != 0);\n                assert(pIn1->n >= 1);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                if ((pIn1->z[h / 8] & (1 << (h & 7))) == 0) {\n                    ;\n                    p->aCounter[8]++;\n                    goto jump_to_p2;\n                } else {\n                    p->aCounter[7]++;\n                    ;\n                }\n                break;\n            }\n          case 181:\n          case 8:\n            {\n                int i;\n                char *zTrace;\n                assert(pOp->p4.z == 0 || strncmp(pOp->p4.z, \"-- \", 3) == 0);\n                assert(pOp == p->aOp || pOp->opcode == 181);\n                if ((db->mTrace & (1 | 64)) != 0 && p->minWriteFileFormat != 254 && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0) {\n                    if (db->mTrace & 64) {\n                        char *z = sqlite3VdbeExpandSql(p, zTrace);\n                        db->trace.xLegacy(db->pTraceArg, z);\n                        sqlite3_free(z);\n                    } else if (db->nVdbeExec > 1) {\n                        char *z = sqlite3MPrintf(db, \"-- %s\", zTrace);\n                        (void)db->trace.xV2(1, db->pTraceArg, p, z);\n                        sqlite3DbFree(db, z);\n                    } else {\n                        (void)db->trace.xV2(1, db->pTraceArg, p, zTrace);\n                    }\n                }\n                assert(pOp->p2 > 0);\n                if (pOp->p1 >= sqlite3Config.iOnceResetThreshold) {\n                    if (pOp->opcode == 181)\n                        break;\n                    for (i = 1; i < p->nOp; i++) {\n                        if (p->aOp[i].opcode == 15)\n                            p->aOp[i].p1 = 0;\n                    }\n                    pOp->p1 = 0;\n                }\n                pOp->p1++;\n                p->aCounter[6]++;\n                goto jump_to_p2;\n            }\n          default:\n            {\n                assert(pOp->opcode == 184 || pOp->opcode == 185);\n                break;\n            }\n        }\n    }\n  abort_due_to_error:\n    if (db->mallocFailed) {\n        rc = 7;\n    } else if (rc == (10 | (33 << 8))) {\n        rc = sqlite3CorruptError(98408);\n    }\n    assert(rc);\n    if (p->zErrMsg == 0 && rc != (10 | (12 << 8))) {\n        sqlite3VdbeError(p, \"%s\", sqlite3ErrStr(rc));\n    }\n    p->rc = rc;\n    sqlite3SystemError(db, rc);\n    ;\n    sqlite3_log(rc, \"statement aborts at %d: [%s] %s\", (int)(pOp - aOp), p->zSql, p->zErrMsg);\n    if (p->eVdbeState == 2)\n        sqlite3VdbeHalt(p);\n    if (rc == (10 | (12 << 8)))\n        sqlite3OomFault(db);\n    if (rc == 11 && db->autoCommit == 0) {\n        db->flags |= ((u64)(2) << 32);\n    }\n    rc = 1;\n    if (resetSchemaOnFault > 0) {\n        sqlite3ResetOneSchema(db, resetSchemaOnFault - 1);\n    }\n  vdbe_return:\n    while (nVmStep >= nProgressLimit && db->xProgress != 0)\n        {\n            nProgressLimit += db->nProgressOps;\n            if (db->xProgress(db->pProgressArg)) {\n                nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                rc = 9;\n                goto abort_due_to_error;\n            }\n        }\n    p->aCounter[4] += (int)nVmStep;\n    sqlite3VdbeLeave(p);\n    return rc;\n  too_big:\n    sqlite3VdbeError(p, \"string or blob too big\");\n    rc = 18;\n    goto abort_due_to_error;\n  no_mem:\n    sqlite3OomFault(db);\n    sqlite3VdbeError(p, \"out of memory\");\n    rc = 7;\n    goto abort_due_to_error;\n  abort_due_to_interrupt:\n    assert(__atomic_load_n((&db->u1.isInterrupted), 0));\n    rc = 9;\n    goto abort_due_to_error;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#116045:1#detachFunc",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    const char *zName = (const char *)sqlite3_value_text(argv[0]);\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    int i;\n    Db *pDb = 0;\n    HashElem *pEntry;\n    char zErr[128];\n    (void)(NotUsed);\n    if (zName == 0)\n        zName = \"\";\n    for (i = 0; i < db->nDb; i++) {\n        pDb = &db->aDb[i];\n        if (pDb->pBt == 0)\n            continue;\n        if (sqlite3DbIsNamed(db, i, zName))\n            break;\n    }\n    if (i >= db->nDb) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"no such database: %s\", zName);\n        goto detach_error;\n    }\n    if (i < 2) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"cannot detach database %s\", zName);\n        goto detach_error;\n    }\n    if (sqlite3BtreeTxnState(pDb->pBt) != 0 || sqlite3BtreeIsInBackup(pDb->pBt)) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"database %s is locked\", zName);\n        goto detach_error;\n    }\n    assert(db->aDb[1].pSchema);\n    pEntry = ((&db->aDb[1].pSchema->trigHash)->first);\n    while (pEntry)\n        {\n            Trigger *pTrig = (Trigger *)((pEntry)->data);\n            if (pTrig->pTabSchema == pDb->pSchema) {\n                pTrig->pTabSchema = pTrig->pSchema;\n            }\n            pEntry = ((pEntry)->next);\n        }\n    sqlite3BtreeClose(pDb->pBt);\n    pDb->pBt = 0;\n    pDb->pSchema = 0;\n    sqlite3CollapseDatabaseArray(db);\n    return;\n  detach_error:\n    sqlite3_result_error(context, zErr, -1);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#57614:1#pager_delsuper",
            "gotos": 8,
            "labels": 1,
            "body": "{\n    sqlite3_vfs *pVfs = pPager->pVfs;\n    int rc;\n    sqlite3_file *pSuper;\n    sqlite3_file *pJournal;\n    char *zSuperJournal = 0;\n    i64 nSuperJournal;\n    char *zJournal;\n    char *zSuperPtr;\n    char *zFree = 0;\n    int nSuperPtr;\n    pSuper = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);\n    if (!pSuper) {\n        rc = 7;\n        pJournal = 0;\n    } else {\n        const int flags = (1 | 16384);\n        rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, 0);\n        pJournal = (sqlite3_file *)(((u8 *)pSuper) + pVfs->szOsFile);\n    }\n    if (rc != 0)\n        goto delsuper_out;\n    rc = sqlite3OsFileSize(pSuper, &nSuperJournal);\n    if (rc != 0)\n        goto delsuper_out;\n    nSuperPtr = pVfs->mxPathname + 1;\n    zFree = sqlite3Malloc(4 + nSuperJournal + nSuperPtr + 2);\n    if (!zFree) {\n        rc = 7;\n        goto delsuper_out;\n    }\n    zFree[0] = zFree[1] = zFree[2] = zFree[3] = 0;\n    zSuperJournal = &zFree[4];\n    zSuperPtr = &zSuperJournal[nSuperJournal + 2];\n    rc = sqlite3OsRead(pSuper, zSuperJournal, (int)nSuperJournal, 0);\n    if (rc != 0)\n        goto delsuper_out;\n    zSuperJournal[nSuperJournal] = 0;\n    zSuperJournal[nSuperJournal + 1] = 0;\n    zJournal = zSuperJournal;\n    while ((zJournal - zSuperJournal) < nSuperJournal)\n        {\n            int exists;\n            rc = sqlite3OsAccess(pVfs, zJournal, 0, &exists);\n            if (rc != 0) {\n                goto delsuper_out;\n            }\n            if (exists) {\n                int c;\n                int flags = (1 | 16384);\n                rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);\n                if (rc != 0) {\n                    goto delsuper_out;\n                }\n                rc = readSuperJournal(pJournal, zSuperPtr, nSuperPtr);\n                sqlite3OsClose(pJournal);\n                if (rc != 0) {\n                    goto delsuper_out;\n                }\n                c = zSuperPtr[0] != 0 && strcmp(zSuperPtr, zSuper) == 0;\n                if (c) {\n                    goto delsuper_out;\n                }\n            }\n            zJournal += (sqlite3Strlen30(zJournal) + 1);\n        }\n    sqlite3OsClose(pSuper);\n    rc = sqlite3OsDelete(pVfs, zSuper, 0);\n  delsuper_out:\n    sqlite3_free(zFree);\n    if (pSuper) {\n        sqlite3OsClose(pSuper);\n        assert(!((pJournal)->pMethods != 0));\n        sqlite3_free(pSuper);\n    }\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#88299:12#sqlite3_set_auxdata",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    AuxData *pAuxData;\n    Vdbe *pVdbe = pCtx->pVdbe;\n    assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));\n    assert(pVdbe != 0);\n    for (pAuxData = pVdbe->pAuxData; pAuxData; pAuxData = pAuxData->pNextAux) {\n        if (pAuxData->iAuxArg == iArg && (pAuxData->iAuxOp == pCtx->iOp || iArg < 0)) {\n            break;\n        }\n    }\n    if (pAuxData == 0) {\n        pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));\n        if (!pAuxData)\n            goto failed;\n        pAuxData->iAuxOp = pCtx->iOp;\n        pAuxData->iAuxArg = iArg;\n        pAuxData->pNextAux = pVdbe->pAuxData;\n        pVdbe->pAuxData = pAuxData;\n        if (pCtx->isError == 0)\n            pCtx->isError = -1;\n    } else if (pAuxData->xDeleteAux) {\n        pAuxData->xDeleteAux(pAuxData->pAux);\n    }\n    pAuxData->pAux = pAux;\n    pAuxData->xDeleteAux = xDelete;\n    return;\n  failed:\n    if (xDelete) {\n        xDelete(pAux);\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#113019:1#renameColumnFunc",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    RenameCtx sCtx;\n    const char *zSql = (const char *)sqlite3_value_text(argv[0]);\n    const char *zDb = (const char *)sqlite3_value_text(argv[3]);\n    const char *zTable = (const char *)sqlite3_value_text(argv[4]);\n    int iCol = sqlite3_value_int(argv[5]);\n    const char *zNew = (const char *)sqlite3_value_text(argv[6]);\n    int bQuote = sqlite3_value_int(argv[7]);\n    int bTemp = sqlite3_value_int(argv[8]);\n    const char *zOld;\n    int rc;\n    Parse sParse;\n    Walker sWalker;\n    Index *pIdx;\n    int i;\n    Table *pTab;\n    sqlite3_xauth xAuth = db->xAuth;\n    (void)(NotUsed);\n    if (zSql == 0)\n        return;\n    if (zTable == 0)\n        return;\n    if (zNew == 0)\n        return;\n    if (iCol < 0)\n        return;\n    sqlite3BtreeEnterAll(db);\n    pTab = sqlite3FindTable(db, zTable, zDb);\n    if (pTab == 0 || iCol >= pTab->nCol) {\n        sqlite3BtreeLeaveAll(db);\n        return;\n    }\n    zOld = pTab->aCol[iCol].zCnName;\n    memset(&sCtx, 0, sizeof (sCtx));\n    sCtx.iCol = ((iCol == pTab->iPKey) ? -1 : iCol);\n    db->xAuth = 0;\n    rc = renameParseSql(&sParse, zDb, db, zSql, bTemp);\n    memset(&sWalker, 0, sizeof(Walker));\n    sWalker.pParse = &sParse;\n    sWalker.xExprCallback = renameColumnExprCb;\n    sWalker.xSelectCallback = renameColumnSelectCb;\n    sWalker.u.pRename = &sCtx;\n    sCtx.pTab = pTab;\n    if (rc != 0)\n        goto renameColumnFunc_done;\n    if (sParse.pNewTable) {\n        if (((sParse.pNewTable)->eTabType == 2)) {\n            Select *pSelect = sParse.pNewTable->u.view.pSelect;\n            pSelect->selFlags &= ~2097152;\n            sParse.rc = 0;\n            sqlite3SelectPrep(&sParse, pSelect, 0);\n            rc = (db->mallocFailed ? 7 : sParse.rc);\n            if (rc == 0) {\n                sqlite3WalkSelect(&sWalker, pSelect);\n            }\n            if (rc != 0)\n                goto renameColumnFunc_done;\n        } else if (((sParse.pNewTable)->eTabType == 0)) {\n            int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);\n            FKey *pFKey;\n            sCtx.pTab = sParse.pNewTable;\n            if (bFKOnly == 0) {\n                if (iCol < sParse.pNewTable->nCol) {\n                    renameTokenFind(&sParse, &sCtx, (void *)sParse.pNewTable->aCol[iCol].zCnName);\n                }\n                if (sCtx.iCol < 0) {\n                    renameTokenFind(&sParse, &sCtx, (void *)&sParse.pNewTable->iPKey);\n                }\n                sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);\n                for (pIdx = sParse.pNewTable->pIndex; pIdx; pIdx = pIdx->pNext) {\n                    sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n                }\n                for (pIdx = sParse.pNewIndex; pIdx; pIdx = pIdx->pNext) {\n                    sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n                }\n                for (i = 0; i < sParse.pNewTable->nCol; i++) {\n                    Expr *pExpr = sqlite3ColumnExpr(sParse.pNewTable, &sParse.pNewTable->aCol[i]);\n                    sqlite3WalkExpr(&sWalker, pExpr);\n                }\n            }\n            assert(((sParse.pNewTable)->eTabType == 0));\n            for (pFKey = sParse.pNewTable->u.tab.pFKey; pFKey; pFKey = pFKey->pNextFrom) {\n                for (i = 0; i < pFKey->nCol; i++) {\n                    if (bFKOnly == 0 && pFKey->aCol[i].iFrom == iCol) {\n                        renameTokenFind(&sParse, &sCtx, (void *)&pFKey->aCol[i]);\n                    }\n                    if (0 == sqlite3_stricmp(pFKey->zTo, zTable) && 0 == sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)) {\n                        renameTokenFind(&sParse, &sCtx, (void *)pFKey->aCol[i].zCol);\n                    }\n                }\n            }\n        }\n    } else if (sParse.pNewIndex) {\n        sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);\n        sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n    } else {\n        TriggerStep *pStep;\n        rc = renameResolveTrigger(&sParse);\n        if (rc != 0)\n            goto renameColumnFunc_done;\n        for (pStep = sParse.pNewTrigger->step_list; pStep; pStep = pStep->pNext) {\n            if (pStep->zTarget) {\n                Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);\n                if (pTarget == pTab) {\n                    if (pStep->pUpsert) {\n                        ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;\n                        renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);\n                    }\n                    renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);\n                    renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);\n                }\n            }\n        }\n        if (sParse.pTriggerTab == pTab) {\n            renameColumnIdlistNames(&sParse, &sCtx, sParse.pNewTrigger->pColumns, zOld);\n        }\n        renameWalkTrigger(&sWalker, sParse.pNewTrigger);\n    }\n    assert(rc == 0);\n    rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);\n  renameColumnFunc_done:\n    if (rc != 0) {\n        if (rc == 1 && sqlite3WritableSchema(db)) {\n            sqlite3_result_value(context, argv[0]);\n        } else if (sParse.zErrMsg) {\n            renameColumnParseError(context, \"\", argv[1], argv[2], &sParse);\n        } else {\n            sqlite3_result_error_code(context, rc);\n        }\n    }\n    renameParseCleanup(&sParse);\n    renameTokenFree(db, sCtx.pList);\n    db->xAuth = xAuth;\n    sqlite3BtreeLeaveAll(db);\n}\n"
        },
        {
            "id": "#23:25#sqlite3AlterRenameColumn",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    sqlite3 *db = pParse->db;\n    Table *pTab;\n    int iCol;\n    char *zOld = 0;\n    char *zNew = 0;\n    const char *zDb;\n    int iSchema;\n    int bQuote;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_rename_column;\n    if (0 != isAlterableTable(pParse, pTab))\n        goto exit_rename_column;\n    if (0 != isRealTable(pParse, pTab, 0))\n        goto exit_rename_column;\n    iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iSchema >= 0);\n    zDb = db->aDb[iSchema].zDbSName;\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0)) {\n        goto exit_rename_column;\n    }\n    zOld = sqlite3NameFromToken(db, pOld);\n    if (!zOld)\n        goto exit_rename_column;\n    for (iCol = 0; iCol < pTab->nCol; iCol++) {\n        if (0 == sqlite3StrICmp(pTab->aCol[iCol].zCnName, zOld))\n            break;\n    }\n    if (iCol == pTab->nCol) {\n        sqlite3ErrorMsg(pParse, \"no such column: \\\"%T\\\"\", pOld);\n        goto exit_rename_column;\n    }\n    renameTestSchema(pParse, zDb, iSchema == 1, \"\", 0);\n    renameFixQuotes(pParse, zDb, iSchema == 1);\n    sqlite3MayAbort(pParse);\n    zNew = sqlite3NameFromToken(db, pNew);\n    if (!zNew)\n        goto exit_rename_column;\n    assert(pNew->n > 0);\n    bQuote = (sqlite3CtypeMap[(unsigned char)(pNew->z[0])] & 128);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'  AND (type != 'index' OR tbl_name = %Q)\", zDb, zDb, pTab->zName, iCol, zNew, bQuote, iSchema == 1, pTab->zName);\n    sqlite3NestedParse(pParse, \"UPDATE temp.sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) WHERE type IN ('trigger', 'view')\", zDb, pTab->zName, iCol, zNew, bQuote);\n    renameReloadSchema(pParse, iSchema, 1);\n    renameTestSchema(pParse, zDb, iSchema == 1, \"after rename\", 1);\n  exit_rename_column:\n    sqlite3SrcListDelete(db, pSrc);\n    sqlite3DbFree(db, zOld);\n    sqlite3DbFree(db, zNew);\n    return;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#86779:1#vdbeRecordCompareString",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    const u8 *aKey1 = (const u8 *)pKey1;\n    int serial_type;\n    int res;\n    assert(pPKey2->aMem[0].flags & 2);\n    assert(pPKey2->aMem[0].n == pPKey2->n);\n    assert(pPKey2->aMem[0].z == pPKey2->u.z);\n    ;\n    serial_type = (signed char)(aKey1[1]);\n  vrcs_restart:\n    if (serial_type < 12) {\n        if (serial_type < 0) {\n            sqlite3GetVarint32(&aKey1[1], (u32 *)&serial_type);\n            if (serial_type >= 12)\n                goto vrcs_restart;\n            assert((sqlite3Config.neverCorrupt == 0));\n        }\n        res = pPKey2->r1;\n    } else if (!(serial_type & 1)) {\n        res = pPKey2->r2;\n    } else {\n        int nCmp;\n        int nStr;\n        int szHdr = aKey1[0];\n        nStr = (serial_type - 12) / 2;\n        if ((szHdr + nStr) > nKey1) {\n            pPKey2->errCode = (u8)sqlite3CorruptError(86810);\n            return 0;\n        }\n        nCmp = ((pPKey2->n) < (nStr) ? (pPKey2->n) : (nStr));\n        res = memcmp(&aKey1[szHdr], pPKey2->u.z, nCmp);\n        if (res > 0) {\n            res = pPKey2->r2;\n        } else if (res < 0) {\n            res = pPKey2->r1;\n        } else {\n            res = nStr - pPKey2->n;\n            if (res == 0) {\n                if (pPKey2->nField > 1) {\n                    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n                } else {\n                    res = pPKey2->default_rc;\n                    pPKey2->eqSeen = 1;\n                }\n            } else if (res > 0) {\n                res = pPKey2->r2;\n            } else {\n                res = pPKey2->r1;\n            }\n        }\n    }\n    assert(vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res) || (sqlite3Config.neverCorrupt == 0) || pPKey2->pKeyInfo->db->mallocFailed);\n    return res;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#71246:1#lockBtree",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    int rc;\n    MemPage *pPage1;\n    u32 nPage;\n    u32 nPageFile = 0;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(pBt->pPage1 == 0);\n    rc = sqlite3PagerSharedLock(pBt->pPager);\n    if (rc != 0)\n        return rc;\n    rc = btreeGetPage(pBt, 1, &pPage1, 0);\n    if (rc != 0)\n        return rc;\n    nPage = sqlite3Get4byte(28 + (u8 *)pPage1->aData);\n    sqlite3PagerPagecount(pBt->pPager, (int *)&nPageFile);\n    if (nPage == 0 || memcmp(24 + (u8 *)pPage1->aData, 92 + (u8 *)pPage1->aData, 4) != 0) {\n        nPage = nPageFile;\n    }\n    if ((pBt->db->flags & 33554432) != 0) {\n        nPage = 0;\n    }\n    if (nPage > 0) {\n        u32 pageSize;\n        u32 usableSize;\n        u8 *page1 = pPage1->aData;\n        rc = 26;\n        if (memcmp(page1, zMagicHeader, 16) != 0) {\n            goto page1_init_failed;\n        }\n        if (page1[18] > 2) {\n            pBt->btsFlags |= 1;\n        }\n        if (page1[19] > 2) {\n            goto page1_init_failed;\n        }\n        if (page1[19] == 2 && (pBt->btsFlags & 32) == 0) {\n            int isOpen = 0;\n            rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);\n            if (rc != 0) {\n                goto page1_init_failed;\n            } else {\n                ;\n                if (isOpen == 0) {\n                    releasePageOne(pPage1);\n                    return 0;\n                }\n            }\n            rc = 26;\n        } else {\n            ;\n        }\n        if (memcmp(&page1[21], \"@  \", 3) != 0) {\n            goto page1_init_failed;\n        }\n        pageSize = (page1[16] << 8) | (page1[17] << 16);\n        if (((pageSize - 1) & pageSize) != 0 || pageSize > 65536 || pageSize <= 256) {\n            goto page1_init_failed;\n        }\n        pBt->btsFlags |= 2;\n        assert((pageSize & 7) == 0);\n        usableSize = pageSize - page1[20];\n        if ((u32)pageSize != pBt->pageSize) {\n            releasePageOne(pPage1);\n            pBt->usableSize = usableSize;\n            pBt->pageSize = pageSize;\n            freeTempSpace(pBt);\n            rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, pageSize - usableSize);\n            return rc;\n        }\n        if (nPage > nPageFile) {\n            if (sqlite3WritableSchema(pBt->db) == 0) {\n                rc = sqlite3CorruptError(71371);\n                goto page1_init_failed;\n            } else {\n                nPage = nPageFile;\n            }\n        }\n        if (usableSize < 480) {\n            goto page1_init_failed;\n        }\n        pBt->pageSize = pageSize;\n        pBt->usableSize = usableSize;\n        pBt->autoVacuum = (sqlite3Get4byte(&page1[36 + 4 * 4]) ? 1 : 0);\n        pBt->incrVacuum = (sqlite3Get4byte(&page1[36 + 7 * 4]) ? 1 : 0);\n    }\n    pBt->maxLocal = (u16)((pBt->usableSize - 12) * 64 / 255 - 23);\n    pBt->minLocal = (u16)((pBt->usableSize - 12) * 32 / 255 - 23);\n    pBt->maxLeaf = (u16)(pBt->usableSize - 35);\n    pBt->minLeaf = (u16)((pBt->usableSize - 12) * 32 / 255 - 23);\n    if (pBt->maxLocal > 127) {\n        pBt->max1bytePayload = 127;\n    } else {\n        pBt->max1bytePayload = (u8)pBt->maxLocal;\n    }\n    assert(pBt->maxLeaf + 23 <= ((int)(pBt->pageSize - 8)));\n    pBt->pPage1 = pPage1;\n    pBt->nPage = nPage;\n    return 0;\n  page1_init_failed:\n    releasePageOne(pPage1);\n    pBt->pPage1 = 0;\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3VdbeIdxRowid",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    i64 nCellKey = 0;\n    int rc;\n    u32 szHdr;\n    u32 typeRowid;\n    u32 lenRowid;\n    Mem m, v;\n    assert(sqlite3BtreeCursorIsValid(pCur));\n    nCellKey = sqlite3BtreePayloadSize(pCur);\n    assert((nCellKey & ((((u64)1) << 32) - 1)) == (u64)nCellKey);\n    sqlite3VdbeMemInit(&m, db, 0);\n    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n    if (rc) {\n        return rc;\n    }\n    szHdr = (u32)*((u8 *)m.z);\n    if (szHdr >= 128)\n        sqlite3GetVarint32(((u8 *)m.z), (u32 *)&(szHdr));\n    ;\n    ;\n    ;\n    assert(m.n >= 0);\n    if ((szHdr < 3 || szHdr > (unsigned int)m.n)) {\n        goto idx_rowid_corruption;\n    }\n    typeRowid = (u32)*((u8 *)&m.z[szHdr - 1]);\n    if (typeRowid >= 128)\n        sqlite3GetVarint32(((u8 *)&m.z[szHdr - 1]), (u32 *)&(typeRowid));\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    if ((typeRowid < 1 || typeRowid > 9 || typeRowid == 7)) {\n        goto idx_rowid_corruption;\n    }\n    lenRowid = sqlite3SmallTypeSizes[typeRowid];\n    ;\n    if (((u32)m.n < szHdr + lenRowid)) {\n        goto idx_rowid_corruption;\n    }\n    sqlite3VdbeSerialGet((u8 *)&m.z[m.n - lenRowid], typeRowid, &v);\n    *rowid = v.u.i;\n    sqlite3VdbeMemReleaseMalloc(&m);\n    return 0;\n  idx_rowid_corruption:\n    ;\n    sqlite3VdbeMemReleaseMalloc(&m);\n    return sqlite3CorruptError(86968);\n}\n"
        },
        {
            "id": "#23:25#sqlite3InitOne",
            "gotos": 5,
            "labels": 2,
            "body": "{\n    int rc;\n    int i;\n    int size;\n    Db *pDb;\n    const char *azArg[6];\n    int meta[5];\n    InitData initData;\n    const char *zSchemaTabName;\n    int openedTransaction = 0;\n    int mask = ((db->mDbFlags & 64) | ~64);\n    assert((db->mDbFlags & 16) == 0);\n    assert(iDb >= 0 && iDb < db->nDb);\n    assert(db->aDb[iDb].pSchema);\n    assert(sqlite3_mutex_held(db->mutex));\n    assert(iDb == 1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt));\n    db->init.busy = 1;\n    azArg[0] = \"table\";\n    azArg[1] = zSchemaTabName = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n    azArg[2] = azArg[1];\n    azArg[3] = \"1\";\n    azArg[4] = \"CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)\";\n    azArg[5] = 0;\n    initData.db = db;\n    initData.iDb = iDb;\n    initData.rc = 0;\n    initData.pzErrMsg = pzErrMsg;\n    initData.mInitFlags = mFlags;\n    initData.nInitRow = 0;\n    initData.mxPage = 0;\n    sqlite3InitCallback(&initData, 5, (char **)azArg, 0);\n    db->mDbFlags &= mask;\n    if (initData.rc) {\n        rc = initData.rc;\n        goto error_out;\n    }\n    pDb = &db->aDb[iDb];\n    if (pDb->pBt == 0) {\n        assert(iDb == 1);\n        (db)->aDb[1].pSchema->schemaFlags |= (1);\n        rc = 0;\n        goto error_out;\n    }\n    sqlite3BtreeEnter(pDb->pBt);\n    if (sqlite3BtreeTxnState(pDb->pBt) == 0) {\n        rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, 0);\n        if (rc != 0) {\n            sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));\n            goto initone_error_out;\n        }\n        openedTransaction = 1;\n    }\n    for (i = 0; i < ((int)(sizeof (meta) / sizeof (meta[0]))); i++) {\n        sqlite3BtreeGetMeta(pDb->pBt, i + 1, (u32 *)&meta[i]);\n    }\n    if ((db->flags & 33554432) != 0) {\n        memset(meta, 0, sizeof (meta));\n    }\n    pDb->pSchema->schema_cookie = meta[1 - 1];\n    if (meta[5 - 1]) {\n        if (iDb == 0 && (db->mDbFlags & 64) == 0) {\n            u8 encoding;\n            encoding = (u8)meta[5 - 1] & 3;\n            if (encoding == 0)\n                encoding = 1;\n            sqlite3SetTextEncoding(db, encoding);\n        } else {\n            if ((meta[5 - 1] & 3) != ((db)->enc)) {\n                sqlite3SetString(pzErrMsg, db, \"attached databases must use the same text encoding as main database\");\n                rc = 1;\n                goto initone_error_out;\n            }\n        }\n    }\n    pDb->pSchema->enc = ((db)->enc);\n    if (pDb->pSchema->cache_size == 0) {\n        size = sqlite3AbsInt32(meta[3 - 1]);\n        if (size == 0) {\n            size = -2000;\n        }\n        pDb->pSchema->cache_size = size;\n        sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    pDb->pSchema->file_format = (u8)meta[2 - 1];\n    if (pDb->pSchema->file_format == 0) {\n        pDb->pSchema->file_format = 1;\n    }\n    if (pDb->pSchema->file_format > 4) {\n        sqlite3SetString(pzErrMsg, db, \"unsupported file format\");\n        rc = 1;\n        goto initone_error_out;\n    }\n    if (iDb == 0 && meta[2 - 1] >= 4) {\n        db->flags &= ~(u64)2;\n    }\n    assert(db->init.busy);\n    initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);\n    {\n        char *zSql;\n        zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".%s ORDER BY rowid\", db->aDb[iDb].zDbSName, zSchemaTabName);\n        {\n            sqlite3_xauth xAuth;\n            xAuth = db->xAuth;\n            db->xAuth = 0;\n            rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n            db->xAuth = xAuth;\n        }\n        if (rc == 0)\n            rc = initData.rc;\n        sqlite3DbFree(db, zSql);\n        if (rc == 0) {\n            sqlite3AnalysisLoad(db, iDb);\n        }\n    }\n    assert(pDb == &(db->aDb[iDb]));\n    if (db->mallocFailed) {\n        rc = 7;\n        sqlite3ResetAllSchemasOfConnection(db);\n        pDb = &db->aDb[iDb];\n    } else if (rc == 0 || ((db->flags & 134217728) && rc != 7)) {\n        (db)->aDb[iDb].pSchema->schemaFlags |= (1);\n        rc = 0;\n    }\n  initone_error_out:\n    if (openedTransaction) {\n        sqlite3BtreeCommit(pDb->pBt);\n    }\n    sqlite3BtreeLeave(pDb->pBt);\n  error_out:\n    if (rc) {\n        if (rc == 7 || rc == (10 | (12 << 8))) {\n            sqlite3OomFault(db);\n        }\n        sqlite3ResetOneSchema(db, iDb);\n    }\n    db->init.busy = 0;\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#78461:1#checkTreePage",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    MemPage *pPage = 0;\n    int i;\n    int rc;\n    int depth = -1, d2;\n    int pgno;\n    int nFrag;\n    int hdr;\n    int cellStart;\n    int nCell;\n    int doCoverageCheck = 1;\n    int keyCanBeEqual = 1;\n    u8 *data;\n    u8 *pCell;\n    u8 *pCellIdx;\n    BtShared *pBt;\n    u32 pc;\n    u32 usableSize;\n    u32 contentOffset;\n    u32 *heap = 0;\n    u32 x, prev = 0;\n    const char *saved_zPfx = pCheck->zPfx;\n    int saved_v1 = pCheck->v1;\n    int saved_v2 = pCheck->v2;\n    u8 savedIsInit = 0;\n    pBt = pCheck->pBt;\n    usableSize = pBt->usableSize;\n    if (iPage == 0)\n        return 0;\n    if (checkRef(pCheck, iPage))\n        return 0;\n    pCheck->zPfx = \"Page %u: \";\n    pCheck->v1 = iPage;\n    if ((rc = btreeGetPage(pBt, iPage, &pPage, 0)) != 0) {\n        checkAppendMsg(pCheck, \"unable to get the page. error code=%d\", rc);\n        goto end_of_check;\n    }\n    savedIsInit = pPage->isInit;\n    pPage->isInit = 0;\n    if ((rc = btreeInitPage(pPage)) != 0) {\n        assert(rc == 11);\n        checkAppendMsg(pCheck, \"btreeInitPage() returns error code %d\", rc);\n        goto end_of_check;\n    }\n    if ((rc = btreeComputeFreeSpace(pPage)) != 0) {\n        assert(rc == 11);\n        checkAppendMsg(pCheck, \"free space corruption\", rc);\n        goto end_of_check;\n    }\n    data = pPage->aData;\n    hdr = pPage->hdrOffset;\n    pCheck->zPfx = \"On tree page %u cell %d: \";\n    contentOffset = (((((int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1])) - 1) & 65535) + 1);\n    assert(contentOffset <= usableSize);\n    nCell = ((&data[hdr + 3])[0] << 8 | (&data[hdr + 3])[1]);\n    assert(pPage->nCell == nCell);\n    cellStart = hdr + 12 - 4 * pPage->leaf;\n    assert(pPage->aCellIdx == &data[cellStart]);\n    pCellIdx = &data[cellStart + 2 * (nCell - 1)];\n    if (!pPage->leaf) {\n        pgno = sqlite3Get4byte(&data[hdr + 8]);\n        if (pBt->autoVacuum) {\n            pCheck->zPfx = \"On page %u at right child: \";\n            checkPtrmap(pCheck, pgno, 5, iPage);\n        }\n        depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n        keyCanBeEqual = 0;\n    } else {\n        heap = pCheck->heap;\n        heap[0] = 0;\n    }\n    for (i = nCell - 1; i >= 0 && pCheck->mxErr; i--) {\n        CellInfo info;\n        pCheck->v2 = i;\n        assert(pCellIdx == &data[cellStart + i * 2]);\n        pc = ((pCellIdx)[0] << 8 | (pCellIdx)[1]);\n        pCellIdx -= 2;\n        if (pc < contentOffset || pc > usableSize - 4) {\n            checkAppendMsg(pCheck, \"Offset %d out of range %d..%d\", pc, contentOffset, usableSize - 4);\n            doCoverageCheck = 0;\n            continue;\n        }\n        pCell = &data[pc];\n        pPage->xParseCell(pPage, pCell, &info);\n        if (pc + info.nSize > usableSize) {\n            checkAppendMsg(pCheck, \"Extends off end of page\");\n            doCoverageCheck = 0;\n            continue;\n        }\n        if (pPage->intKey) {\n            if (keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey)) {\n                checkAppendMsg(pCheck, \"Rowid %lld out of order\", info.nKey);\n            }\n            maxKey = info.nKey;\n            keyCanBeEqual = 0;\n        }\n        if (info.nPayload > info.nLocal) {\n            u32 nPage;\n            Pgno pgnoOvfl;\n            assert(pc + info.nSize - 4 <= usableSize);\n            nPage = (info.nPayload - info.nLocal + usableSize - 5) / (usableSize - 4);\n            pgnoOvfl = sqlite3Get4byte(&pCell[info.nSize - 4]);\n            if (pBt->autoVacuum) {\n                checkPtrmap(pCheck, pgnoOvfl, 3, iPage);\n            }\n            checkList(pCheck, 0, pgnoOvfl, nPage);\n        }\n        if (!pPage->leaf) {\n            pgno = sqlite3Get4byte(pCell);\n            if (pBt->autoVacuum) {\n                checkPtrmap(pCheck, pgno, 5, iPage);\n            }\n            d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n            keyCanBeEqual = 0;\n            if (d2 != depth) {\n                checkAppendMsg(pCheck, \"Child page depth differs\");\n                depth = d2;\n            }\n        } else {\n            btreeHeapInsert(heap, (pc << 16) | (pc + info.nSize - 1));\n        }\n    }\n    *piMinKey = maxKey;\n    pCheck->zPfx = 0;\n    if (doCoverageCheck && pCheck->mxErr > 0) {\n        if (!pPage->leaf) {\n            heap = pCheck->heap;\n            heap[0] = 0;\n            for (i = nCell - 1; i >= 0; i--) {\n                u32 size;\n                pc = ((&data[cellStart + i * 2])[0] << 8 | (&data[cellStart + i * 2])[1]);\n                size = pPage->xCellSize(pPage, &data[pc]);\n                btreeHeapInsert(heap, (pc << 16) | (pc + size - 1));\n            }\n        }\n        i = ((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);\n        while (i > 0)\n            {\n                int size, j;\n                assert((u32)i <= usableSize - 4);\n                size = ((&data[i + 2])[0] << 8 | (&data[i + 2])[1]);\n                assert((u32)(i + size) <= usableSize);\n                btreeHeapInsert(heap, (((u32)i) << 16) | (i + size - 1));\n                j = ((&data[i])[0] << 8 | (&data[i])[1]);\n                assert(j == 0 || j > i + size);\n                assert((u32)j <= usableSize - 4);\n                i = j;\n            }\n        nFrag = 0;\n        prev = contentOffset - 1;\n        while (btreeHeapPull(heap, &x))\n            {\n                if ((prev & 65535) >= (x >> 16)) {\n                    checkAppendMsg(pCheck, \"Multiple uses for byte %u of page %u\", x >> 16, iPage);\n                    break;\n                } else {\n                    nFrag += (x >> 16) - (prev & 65535) - 1;\n                    prev = x;\n                }\n            }\n        nFrag += usableSize - (prev & 65535) - 1;\n        if (heap[0] == 0 && nFrag != data[hdr + 7]) {\n            checkAppendMsg(pCheck, \"Fragmentation of %d bytes reported as %d on page %u\", nFrag, data[hdr + 7], iPage);\n        }\n    }\n  end_of_check:\n    if (!doCoverageCheck)\n        pPage->isInit = savedIsInit;\n    releasePage(pPage);\n    pCheck->zPfx = saved_zPfx;\n    pCheck->v1 = saved_v1;\n    pCheck->v2 = saved_v2;\n    return depth + 1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#156370:1#constructAutomaticIndex",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    int nKeyCol;\n    WhereTerm *pTerm;\n    WhereTerm *pWCEnd;\n    Index *pIdx;\n    Vdbe *v;\n    int addrInit;\n    Table *pTable;\n    int addrTop;\n    int regRecord;\n    int n;\n    int i;\n    int mxBitCol;\n    CollSeq *pColl;\n    WhereLoop *pLoop;\n    char *zNotUsed;\n    Bitmask idxCols;\n    Bitmask extraCols;\n    u8 sentWarning = 0;\n    Expr *pPartial = 0;\n    int iContinue = 0;\n    SrcItem *pTabItem;\n    int addrCounter = 0;\n    int regBase;\n    v = pParse->pVdbe;\n    assert(v != 0);\n    addrInit = sqlite3VdbeAddOp0(v, 15);\n    ;\n    nKeyCol = 0;\n    pTable = pSrc->pTab;\n    pWCEnd = &pWC->a[pWC->nTerm];\n    pLoop = pLevel->pWLoop;\n    idxCols = 0;\n    for (pTerm = pWC->a; pTerm < pWCEnd; pTerm++) {\n        Expr *pExpr = pTerm->pExpr;\n        if ((pTerm->wtFlags & 2) == 0 && sqlite3ExprIsTableConstraint(pExpr, pSrc)) {\n            pPartial = sqlite3ExprAnd(pParse, pPartial, sqlite3ExprDup(pParse->db, pExpr, 0));\n        }\n        if (termCanDriveIndex(pTerm, pSrc, notReady)) {\n            int iCol;\n            Bitmask cMask;\n            assert((pTerm->eOperator & (512 | 1024)) == 0);\n            iCol = pTerm->u.x.leftColumn;\n            cMask = iCol >= ((int)(sizeof(Bitmask) * 8)) ? (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)) : (((Bitmask)1) << (iCol));\n            ;\n            ;\n            if (!sentWarning) {\n                sqlite3_log((28 | (1 << 8)), \"automatic index on %s(%s)\", pTable->zName, pTable->aCol[iCol].zCnName);\n                sentWarning = 1;\n            }\n            if ((idxCols & cMask) == 0) {\n                if (whereLoopResize(pParse->db, pLoop, nKeyCol + 1)) {\n                    goto end_auto_index_create;\n                }\n                pLoop->aLTerm[nKeyCol++] = pTerm;\n                idxCols |= cMask;\n            }\n        }\n    }\n    assert(nKeyCol > 0 || pParse->db->mallocFailed);\n    pLoop->u.btree.nEq = pLoop->nLTerm = nKeyCol;\n    pLoop->wsFlags = 1 | 64 | 512 | 16384;\n    extraCols = pSrc->colUsed & (~idxCols | (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)));\n    mxBitCol = ((((int)(sizeof(Bitmask) * 8)) - 1) < (pTable->nCol) ? (((int)(sizeof(Bitmask) * 8)) - 1) : (pTable->nCol));\n    ;\n    ;\n    for (i = 0; i < mxBitCol; i++) {\n        if (extraCols & (((Bitmask)1) << (i)))\n            nKeyCol++;\n    }\n    if (pSrc->colUsed & (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1))) {\n        nKeyCol += pTable->nCol - ((int)(sizeof(Bitmask) * 8)) + 1;\n    }\n    pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol + 1, 0, &zNotUsed);\n    if (pIdx == 0)\n        goto end_auto_index_create;\n    pLoop->u.btree.pIndex = pIdx;\n    pIdx->zName = \"auto-index\";\n    pIdx->pTable = pTable;\n    n = 0;\n    idxCols = 0;\n    for (pTerm = pWC->a; pTerm < pWCEnd; pTerm++) {\n        if (termCanDriveIndex(pTerm, pSrc, notReady)) {\n            int iCol;\n            Bitmask cMask;\n            assert((pTerm->eOperator & (512 | 1024)) == 0);\n            iCol = pTerm->u.x.leftColumn;\n            cMask = iCol >= ((int)(sizeof(Bitmask) * 8)) ? (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)) : (((Bitmask)1) << (iCol));\n            ;\n            ;\n            if ((idxCols & cMask) == 0) {\n                Expr *pX = pTerm->pExpr;\n                idxCols |= cMask;\n                pIdx->aiColumn[n] = pTerm->u.x.leftColumn;\n                pColl = sqlite3ExprCompareCollSeq(pParse, pX);\n                assert(pColl != 0 || pParse->nErr > 0);\n                pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;\n                n++;\n            }\n        }\n    }\n    assert((u32)n == pLoop->u.btree.nEq);\n    for (i = 0; i < mxBitCol; i++) {\n        if (extraCols & (((Bitmask)1) << (i))) {\n            pIdx->aiColumn[n] = i;\n            pIdx->azColl[n] = sqlite3StrBINARY;\n            n++;\n        }\n    }\n    if (pSrc->colUsed & (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1))) {\n        for (i = ((int)(sizeof(Bitmask) * 8)) - 1; i < pTable->nCol; i++) {\n            pIdx->aiColumn[n] = i;\n            pIdx->azColl[n] = sqlite3StrBINARY;\n            n++;\n        }\n    }\n    assert(n == nKeyCol);\n    pIdx->aiColumn[n] = (-1);\n    pIdx->azColl[n] = sqlite3StrBINARY;\n    assert(pLevel->iIdxCur >= 0);\n    pLevel->iIdxCur = pParse->nTab++;\n    sqlite3VdbeAddOp2(v, 116, pLevel->iIdxCur, nKeyCol + 1);\n    sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n    ;\n    if ((((pParse->db)->dbOptFlags & (524288)) == 0)) {\n        pLevel->regFilter = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 77, 10000, pLevel->regFilter);\n    }\n    pTabItem = &pWC->pWInfo->pTabList->a[pLevel->iFrom];\n    if (pTabItem->fg.viaCoroutine) {\n        int regYield = pTabItem->regReturn;\n        addrCounter = sqlite3VdbeAddOp2(v, 71, 0, 0);\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, pTabItem->addrFillSub);\n        addrTop = sqlite3VdbeAddOp1(v, 12, regYield);\n        ;\n        ;\n    } else {\n        addrTop = sqlite3VdbeAddOp1(v, 36, pLevel->iTabCur);\n        ;\n    }\n    if (pPartial) {\n        iContinue = sqlite3VdbeMakeLabel(pParse);\n        sqlite3ExprIfFalse(pParse, pPartial, iContinue, 16);\n        pLoop->wsFlags |= 131072;\n    }\n    regRecord = sqlite3GetTempReg(pParse);\n    regBase = sqlite3GenerateIndexKey(pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0);\n    if (pLevel->regFilter) {\n        sqlite3VdbeAddOp4Int(v, 180, pLevel->regFilter, 0, regBase, pLoop->u.btree.nEq);\n    }\n    sqlite3VdbeAddOp2(v, 138, pLevel->iIdxCur, regRecord);\n    sqlite3VdbeChangeP5(v, 16);\n    if (pPartial)\n        sqlite3VdbeResolveLabel(v, iContinue);\n    if (pTabItem->fg.viaCoroutine) {\n        sqlite3VdbeChangeP2(v, addrCounter, regBase + n);\n        ;\n        assert(pLevel->iIdxCur > 0);\n        translateColumnToCopy(pParse, addrTop, pLevel->iTabCur, pTabItem->regResult, pLevel->iIdxCur);\n        sqlite3VdbeGoto(v, addrTop);\n        pTabItem->fg.viaCoroutine = 0;\n    } else {\n        sqlite3VdbeAddOp2(v, 39, pLevel->iTabCur, addrTop + 1);\n        ;\n        sqlite3VdbeChangeP5(v, 3);\n    }\n    sqlite3VdbeJumpHere(v, addrTop);\n    sqlite3ReleaseTempReg(pParse, regRecord);\n    sqlite3VdbeJumpHere(v, addrInit);\n  end_auto_index_create:\n    sqlite3ExprDelete(pParse->db, pPartial);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#41240:1#unixOpenSharedMemory",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    struct unixShm *p = 0;\n    struct unixShmNode *pShmNode;\n    int rc = 0;\n    unixInodeInfo *pInode;\n    char *zShm;\n    int nShmFilename;\n    p = sqlite3_malloc64(sizeof (*p));\n    if (p == 0)\n        return 7;\n    memset(p, 0, sizeof (*p));\n    assert(pDbFd->pShm == 0);\n    assert(unixFileMutexNotheld(pDbFd));\n    unixEnterMutex();\n    pInode = pDbFd->pInode;\n    pShmNode = pInode->pShmNode;\n    if (pShmNode == 0) {\n        struct stat sStat;\n        const char *zBasePath = pDbFd->zPath;\n        if (((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pDbFd->h, &<recovery-expr>())) {\n            rc = (10 | (7 << 8));\n            goto shm_open_err;\n        }\n        nShmFilename = 6 + (int)strlen(zBasePath);\n        pShmNode = sqlite3_malloc64(sizeof (*pShmNode) + nShmFilename);\n        if (pShmNode == 0) {\n            rc = 7;\n            goto shm_open_err;\n        }\n        memset(pShmNode, 0, sizeof (*pShmNode) + nShmFilename);\n        zShm = pShmNode->zFilename = (char *)&pShmNode[1];\n        sqlite3_snprintf(nShmFilename, zShm, \"%s-shm\", zBasePath);\n        ;\n        pShmNode->hShm = -1;\n        pDbFd->pInode->pShmNode = pShmNode;\n        pShmNode->pInode = pDbFd->pInode;\n        if (sqlite3Config.bCoreMutex) {\n            pShmNode->pShmMutex = sqlite3_mutex_alloc(0);\n            if (pShmNode->pShmMutex == 0) {\n                rc = 7;\n                goto shm_open_err;\n            }\n        }\n        if (pInode->bProcessLock == 0) {\n            if (0 == sqlite3_uri_boolean(pDbFd->zPath, \"readonly_shm\", 0)) {\n            }\n            if (pShmNode->hShm < 0) {\n                if (pShmNode->hShm < 0) {\n                    rc = unixLogErrorAtLine(sqlite3CantopenError(41316), \"open\", zShm, 41316);\n                    goto shm_open_err;\n                }\n                pShmNode->isReadonly = 1;\n            }\n            <recovery-expr>()(pShmNode->hShm, <recovery-expr>().st_uid, <recovery-expr>().st_gid);\n            rc = unixLockSharedMemory(pDbFd, pShmNode);\n            if (rc != 0 && rc != (8 | (5 << 8)))\n                goto shm_open_err;\n        }\n    }\n    p->pShmNode = pShmNode;\n    pShmNode->nRef++;\n    pDbFd->pShm = p;\n    unixLeaveMutex();\n    sqlite3_mutex_enter(pShmNode->pShmMutex);\n    p->pNext = pShmNode->pFirst;\n    pShmNode->pFirst = p;\n    sqlite3_mutex_leave(pShmNode->pShmMutex);\n    return rc;\n  shm_open_err:\n    unixShmPurge(pDbFd);\n    sqlite3_free(p);\n    unixLeaveMutex();\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#82738:1#resolveP2Values",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int nMaxArgs = *pMaxFuncArgs;\n    Op *pOp;\n    Parse *pParse = p->pParse;\n    int *aLabel = pParse->aLabel;\n    p->readOnly = 1;\n    p->bIsReader = 0;\n    pOp = &p->aOp[p->nOp - 1];\n    assert(p->aOp[0].opcode == 8);\n    while (1)\n        {\n            if (pOp->opcode <= 64) {\n                switch (pOp->opcode) {\n                  case 2:\n                    {\n                        if (pOp->p2 != 0)\n                            p->readOnly = 0;\n                    }\n                  case 1:\n                  case 0:\n                    {\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 3:\n                  case 5:\n                  case 4:\n                    {\n                        p->readOnly = 0;\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 8:\n                    {\n                        assert(pOp->p2 >= 0);\n                        goto resolve_p2_values_loop_exit;\n                    }\n                  case 7:\n                    {\n                        if (pOp->p2 > nMaxArgs)\n                            nMaxArgs = pOp->p2;\n                        break;\n                    }\n                  case 6:\n                    {\n                        int n;\n                        assert((pOp - p->aOp) >= 3);\n                        assert(pOp[-1].opcode == 71);\n                        n = pOp[-1].p1;\n                        if (n > nMaxArgs)\n                            nMaxArgs = n;\n                    }\n                  default:\n                    {\n                        if (pOp->p2 < 0) {\n                            assert((sqlite3OpcodeProperty[pOp->opcode] & 1) != 0);\n                            assert((~(pOp->p2)) < -pParse->nLabel);\n                            pOp->p2 = aLabel[(~(pOp->p2))];\n                        }\n                        break;\n                    }\n                }\n                assert((sqlite3OpcodeProperty[pOp->opcode] & 1) == 0 || pOp->p2 >= 0);\n            }\n            assert(pOp > p->aOp);\n            pOp--;\n        }\n  resolve_p2_values_loop_exit:\n    if (aLabel) {\n        sqlite3DbNNFreeNN(p->db, pParse->aLabel);\n        pParse->aLabel = 0;\n    }\n    pParse->nLabel = 0;\n    *pMaxFuncArgs = nMaxArgs;\n    assert(p->bIsReader != 0 || (p->btreeMask) == 0);\n}\n"
        },
        {
            "id": "#23:25#sqlite3ParseUri",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    unsigned int flags = *pFlags;\n    const char *zVfs = zDefaultVfs;\n    char *zFile;\n    char c;\n    int nUri = sqlite3Strlen30(zUri);\n    assert(*pzErrMsg == 0);\n    if (((flags & 64) || sqlite3Config.bOpenUri) && nUri >= 5 && memcmp(zUri, \"file:\", 5) == 0) {\n        char *zOpt;\n        int eState;\n        int iIn;\n        int iOut = 0;\n        u64 nByte = nUri + 8;\n        flags |= 64;\n        for (iIn = 0; iIn < nUri; iIn++)\n            nByte += (zUri[iIn] == '&');\n        zFile = sqlite3_malloc64(nByte);\n        if (!zFile)\n            return 7;\n        memset(zFile, 0, 4);\n        zFile += 4;\n        iIn = 5;\n        if (zUri[5] == '/' && zUri[6] == '/') {\n            iIn = 7;\n            while (zUri[iIn] && zUri[iIn] != '/')\n                iIn++;\n            if (iIn != 7 && (iIn != 16 || memcmp(\"localhost\", &zUri[7], 9))) {\n                *pzErrMsg = sqlite3_mprintf(\"invalid uri authority: %.*s\", iIn - 7, &zUri[7]);\n                rc = 1;\n                goto parse_uri_out;\n            }\n        }\n        eState = 0;\n        while ((c = zUri[iIn]) != 0 && c != '#')\n            {\n                iIn++;\n                if (c == '%' && (sqlite3CtypeMap[(unsigned char)(zUri[iIn])] & 8) && (sqlite3CtypeMap[(unsigned char)(zUri[iIn + 1])] & 8)) {\n                    int octet = (sqlite3HexToInt(zUri[iIn++]) << 4);\n                    octet += sqlite3HexToInt(zUri[iIn++]);\n                    assert(octet >= 0 && octet < 256);\n                    if (octet == 0) {\n                        while ((c = zUri[iIn]) != 0 && c != '#' && (eState != 0 || c != '?') && (eState != 1 || (c != '=' && c != '&')) && (eState != 2 || c != '&'))\n                            {\n                                iIn++;\n                            }\n                        continue;\n                    }\n                    c = octet;\n                } else if (eState == 1 && (c == '&' || c == '=')) {\n                    if (zFile[iOut - 1] == 0) {\n                        while (zUri[iIn] && zUri[iIn] != '#' && zUri[iIn - 1] != '&')\n                            iIn++;\n                        continue;\n                    }\n                    if (c == '&') {\n                        zFile[iOut++] = '\\x00';\n                    } else {\n                        eState = 2;\n                    }\n                    c = 0;\n                } else if ((eState == 0 && c == '?') || (eState == 2 && c == '&')) {\n                    c = 0;\n                    eState = 1;\n                }\n                zFile[iOut++] = c;\n            }\n        if (eState == 1)\n            zFile[iOut++] = '\\x00';\n        memset(zFile + iOut, 0, 4);\n        zOpt = &zFile[sqlite3Strlen30(zFile) + 1];\n        while (zOpt[0])\n            {\n                int nOpt = sqlite3Strlen30(zOpt);\n                char *zVal = &zOpt[nOpt + 1];\n                int nVal = sqlite3Strlen30(zVal);\n                if (nOpt == 3 && memcmp(\"vfs\", zOpt, 3) == 0) {\n                    zVfs = zVal;\n                } else {\n                    struct OpenMode {\n                        const char *z;\n                        int mode;\n                    } *aMode = 0;\n                    char *zModeType = 0;\n                    int mask = 0;\n                    int limit = 0;\n                    if (nOpt == 5 && memcmp(\"cache\", zOpt, 5) == 0) {\n                        static struct OpenMode aCacheMode[] = {{\"shared\", 131072}, {\"private\", 262144}, {0, 0}};\n                        mask = 131072 | 262144;\n                        aMode = aCacheMode;\n                        limit = mask;\n                        zModeType = \"cache\";\n                    }\n                    if (nOpt == 4 && memcmp(\"mode\", zOpt, 4) == 0) {\n                        static struct OpenMode aOpenMode[] = {{\"ro\", 1}, {\"rw\", 2}, {\"rwc\", 2 | 4}, {\"memory\", 128}, {0, 0}};\n                        mask = 1 | 2 | 4 | 128;\n                        aMode = aOpenMode;\n                        limit = mask & flags;\n                        zModeType = \"access\";\n                    }\n                    if (aMode) {\n                        int i;\n                        int mode = 0;\n                        for (i = 0; aMode[i].z; i++) {\n                            const char *z = aMode[i].z;\n                            if (nVal == sqlite3Strlen30(z) && 0 == memcmp(zVal, z, nVal)) {\n                                mode = aMode[i].mode;\n                                break;\n                            }\n                        }\n                        if (mode == 0) {\n                            *pzErrMsg = sqlite3_mprintf(\"no such %s mode: %s\", zModeType, zVal);\n                            rc = 1;\n                            goto parse_uri_out;\n                        }\n                        if ((mode & ~128) > limit) {\n                            *pzErrMsg = sqlite3_mprintf(\"%s mode not allowed: %s\", zModeType, zVal);\n                            rc = 3;\n                            goto parse_uri_out;\n                        }\n                        flags = (flags & ~mask) | mode;\n                    }\n                }\n                zOpt = &zVal[nVal + 1];\n            }\n    } else {\n        zFile = sqlite3_malloc64(nUri + 8);\n        if (!zFile)\n            return 7;\n        memset(zFile, 0, 4);\n        zFile += 4;\n        if (nUri) {\n            memcpy(zFile, zUri, nUri);\n        }\n        memset(zFile + nUri, 0, 4);\n        flags &= ~64;\n    }\n    *ppVfs = sqlite3_vfs_find(zVfs);\n    if (*ppVfs == 0) {\n        *pzErrMsg = sqlite3_mprintf(\"no such vfs: %s\", zVfs);\n        rc = 1;\n    }\n  parse_uri_out:\n    if (rc != 0) {\n        sqlite3_free_filename(zFile);\n        zFile = 0;\n    }\n    *pFlags = flags;\n    *pzFile = zFile;\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#81496:1#valueFromExpr",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    int op;\n    char *zVal = 0;\n    sqlite3_value *pVal = 0;\n    int negInt = 1;\n    const char *zNeg = \"\";\n    int rc = 0;\n    assert(pExpr != 0);\n    while ((op = pExpr->op) == 174 || op == 181)\n        pExpr = pExpr->pLeft;\n    if (op == 176)\n        op = pExpr->op2;\n    assert((pExpr->flags & 65536) == 0 || pCtx == 0);\n    if (op == 36) {\n        u8 aff;\n        assert(!(((pExpr)->flags & (2048)) != 0));\n        aff = sqlite3AffinityType(pExpr->u.zToken, 0);\n        rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);\n        ;\n        if (*ppVal) {\n            sqlite3VdbeMemCast(*ppVal, aff, enc);\n            sqlite3ValueApplyAffinity(*ppVal, affinity, enc);\n        }\n        return rc;\n    }\n    if (op == 173 && (pExpr->pLeft->op == 155 || pExpr->pLeft->op == 153)) {\n        pExpr = pExpr->pLeft;\n        op = pExpr->op;\n        negInt = -1;\n        zNeg = \"-\";\n    }\n    if (op == 117 || op == 153 || op == 155) {\n        pVal = valueNew(db, pCtx);\n        if (pVal == 0)\n            goto no_mem;\n        if ((((pExpr)->flags & (2048)) != 0)) {\n            sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue * negInt);\n        } else {\n            zVal = sqlite3MPrintf(db, \"%s%s\", zNeg, pExpr->u.zToken);\n            if (zVal == 0)\n                goto no_mem;\n            sqlite3ValueSetStr(pVal, -1, zVal, 1, ((sqlite3_destructor_type)sqlite3OomClear));\n        }\n        if ((op == 155 || op == 153) && affinity == 65) {\n            sqlite3ValueApplyAffinity(pVal, 67, 1);\n        } else {\n            sqlite3ValueApplyAffinity(pVal, affinity, 1);\n        }\n        assert((pVal->flags & 32) == 0);\n        if (pVal->flags & (4 | 32 | 8)) {\n            ;\n            ;\n            pVal->flags &= ~2;\n        }\n        if (enc != 1) {\n            rc = sqlite3VdbeChangeEncoding(pVal, enc);\n        }\n    } else if (op == 173) {\n        if (0 == valueFromExpr(db, pExpr->pLeft, enc, affinity, &pVal, pCtx) && pVal != 0) {\n            sqlite3VdbeMemNumerify(pVal);\n            if (pVal->flags & 8) {\n                pVal->u.r = -pVal->u.r;\n            } else if (pVal->u.i == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) {\n                pVal->u.r = -(double)(((i64)-1) - (4294967295U | (((i64)2147483647) << 32)));\n                ((pVal)->flags = ((pVal)->flags & ~(3519 | 1024)) | 8);\n            } else {\n                pVal->u.i = -pVal->u.i;\n            }\n            sqlite3ValueApplyAffinity(pVal, affinity, enc);\n        }\n    } else if (op == 121) {\n        pVal = valueNew(db, pCtx);\n        if (pVal == 0)\n            goto no_mem;\n        sqlite3VdbeMemSetNull(pVal);\n    } else if (op == 154) {\n        int nVal;\n        assert(!(((pExpr)->flags & (2048)) != 0));\n        assert(pExpr->u.zToken[0] == 'x' || pExpr->u.zToken[0] == 'X');\n        assert(pExpr->u.zToken[1] == '\\'');\n        pVal = valueNew(db, pCtx);\n        if (!pVal)\n            goto no_mem;\n        zVal = &pExpr->u.zToken[2];\n        nVal = sqlite3Strlen30(zVal) - 1;\n        assert(zVal[nVal] == '\\'');\n        sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal / 2, 0, ((sqlite3_destructor_type)sqlite3OomClear));\n    } else if (op == 170) {\n        assert(!(((pExpr)->flags & (2048)) != 0));\n        pVal = valueNew(db, pCtx);\n        if (pVal) {\n            pVal->flags = 4;\n            pVal->u.i = pExpr->u.zToken[4] == 0;\n        }\n    }\n    *ppVal = pVal;\n    return rc;\n  no_mem:\n    sqlite3OomFault(db);\n    sqlite3DbFree(db, zVal);\n    assert(*ppVal == 0);\n    assert(pCtx == 0);\n    sqlite3ValueFree(pVal);\n    return 7;\n}\n"
        },
        {
            "id": "#23:25#sqlite3StartTable",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    Table *pTable;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    Vdbe *v;\n    int iDb;\n    Token *pName;\n    if (db->init.busy && db->init.newTnum == 1) {\n        iDb = db->init.iDb;\n        zName = sqlite3DbStrDup(db, ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"));\n        pName = pName1;\n    } else {\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0)\n            return;\n        if (!0 && isTemp && pName2->n > 0 && iDb != 1) {\n            sqlite3ErrorMsg(pParse, \"temporary table name must be unqualified\");\n            return;\n        }\n        if (!0 && isTemp)\n            iDb = 1;\n        zName = sqlite3NameFromToken(db, pName);\n        if ((pParse->eParseMode >= 2)) {\n            sqlite3RenameTokenMap(pParse, (void *)zName, pName);\n        }\n    }\n    pParse->sNameToken = *pName;\n    if (zName == 0)\n        return;\n    if (sqlite3CheckObjectName(pParse, zName, isView ? \"view\" : \"table\", zName)) {\n        goto begin_table_error;\n    }\n    if (db->init.iDb == 1)\n        isTemp = 1;\n    assert(isTemp == 0 || isTemp == 1);\n    assert(isView == 0 || isView == 1);\n    {\n        static const u8 aCode[] = {2, 4, 8, 6};\n        char *zDb = db->aDb[iDb].zDbSName;\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (isTemp == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto begin_table_error;\n        }\n        if (!isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp + 2 * isView], zName, 0, zDb)) {\n            goto begin_table_error;\n        }\n    }\n    if (!(pParse->eParseMode != 0)) {\n        char *zDb = db->aDb[iDb].zDbSName;\n        if (0 != sqlite3ReadSchema(pParse)) {\n            goto begin_table_error;\n        }\n        pTable = sqlite3FindTable(db, zName, zDb);\n        if (pTable) {\n            if (!noErr) {\n                sqlite3ErrorMsg(pParse, \"%s %T already exists\", (((pTable)->eTabType == 2) ? \"view\" : \"table\"), pName);\n            } else {\n                assert(!db->init.busy || (sqlite3Config.neverCorrupt == 0));\n                sqlite3CodeVerifySchema(pParse, iDb);\n                sqlite3ForceNotReadOnly(pParse);\n            }\n            goto begin_table_error;\n        }\n        if (sqlite3FindIndex(db, zName, zDb) != 0) {\n            sqlite3ErrorMsg(pParse, \"there is already an index named %s\", zName);\n            goto begin_table_error;\n        }\n    }\n    pTable = sqlite3DbMallocZero(db, sizeof(Table));\n    if (pTable == 0) {\n        assert(db->mallocFailed);\n        pParse->rc = 7;\n        pParse->nErr++;\n        goto begin_table_error;\n    }\n    pTable->zName = zName;\n    pTable->iPKey = -1;\n    pTable->pSchema = db->aDb[iDb].pSchema;\n    pTable->nTabRef = 1;\n    pTable->nRowLogEst = 200;\n    assert(200 == sqlite3LogEst(1048576));\n    assert(pParse->pNewTable == 0);\n    pParse->pNewTable = pTable;\n    if (!db->init.busy && (v = sqlite3GetVdbe(pParse)) != 0) {\n        int addr1;\n        int fileFormat;\n        int reg1, reg2, reg3;\n        static const char nullRow[] = {6, 0, 0, 0, 0, 0};\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        if (isVirtual) {\n            sqlite3VdbeAddOp0(v, 170);\n        }\n        reg1 = pParse->regRowid = ++pParse->nMem;\n        reg2 = pParse->regRoot = ++pParse->nMem;\n        reg3 = ++pParse->nMem;\n        sqlite3VdbeAddOp3(v, 99, iDb, reg3, 2);\n        sqlite3VdbeUsesBtree(v, iDb);\n        addr1 = sqlite3VdbeAddOp1(v, 16, reg3);\n        ;\n        fileFormat = (db->flags & 2) != 0 ? 1 : 4;\n        sqlite3VdbeAddOp3(v, 100, iDb, 2, fileFormat);\n        sqlite3VdbeAddOp3(v, 100, iDb, 5, ((db)->enc));\n        sqlite3VdbeJumpHere(v, addr1);\n        if (isView || isVirtual) {\n            sqlite3VdbeAddOp2(v, 71, 0, reg2);\n        } else {\n            assert(!pParse->bReturning);\n            pParse->u1.addrCrTab = sqlite3VdbeAddOp3(v, 147, iDb, reg2, 1);\n        }\n        sqlite3OpenSchemaTable(pParse, iDb);\n        sqlite3VdbeAddOp2(v, 127, 0, reg1);\n        sqlite3VdbeAddOp4(v, 77, 6, reg3, 0, nullRow, (-1));\n        sqlite3VdbeAddOp3(v, 128, 0, reg3, reg1);\n        sqlite3VdbeChangeP5(v, 8);\n        sqlite3VdbeAddOp0(v, 122);\n    }\n    return;\n  begin_table_error:\n    pParse->checkSchema = 1;\n    sqlite3DbFree(db, zName);\n    return;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#176177:12#sqlite3_table_column_metadata",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    int rc;\n    char *zErrMsg = 0;\n    Table *pTab = 0;\n    Column *pCol = 0;\n    int iCol = 0;\n    const char *zDataType = 0;\n    const char *zCollSeq = 0;\n    int notnull = 0;\n    int primarykey = 0;\n    int autoinc = 0;\n    sqlite3_mutex_enter(db->mutex);\n    sqlite3BtreeEnterAll(db);\n    rc = sqlite3Init(db, &zErrMsg);\n    if (0 != rc) {\n        goto error_out;\n    }\n    pTab = sqlite3FindTable(db, zTableName, zDbName);\n    if (!pTab || ((pTab)->eTabType == 2)) {\n        pTab = 0;\n        goto error_out;\n    }\n    if (zColumnName == 0) {\n    } else {\n        for (iCol = 0; iCol < pTab->nCol; iCol++) {\n            pCol = &pTab->aCol[iCol];\n            if (0 == sqlite3StrICmp(pCol->zCnName, zColumnName)) {\n                break;\n            }\n        }\n        if (iCol == pTab->nCol) {\n            if ((((pTab)->tabFlags & 128) == 0) && sqlite3IsRowid(zColumnName)) {\n                iCol = pTab->iPKey;\n                pCol = iCol >= 0 ? &pTab->aCol[iCol] : 0;\n            } else {\n                pTab = 0;\n                goto error_out;\n            }\n        }\n    }\n    if (pCol) {\n        zDataType = sqlite3ColumnType(pCol, 0);\n        zCollSeq = sqlite3ColumnColl(pCol);\n        notnull = pCol->notNull != 0;\n        primarykey = (pCol->colFlags & 1) != 0;\n        autoinc = pTab->iPKey == iCol && (pTab->tabFlags & 8) != 0;\n    } else {\n        zDataType = \"INTEGER\";\n        primarykey = 1;\n    }\n    if (!zCollSeq) {\n        zCollSeq = sqlite3StrBINARY;\n    }\n  error_out:\n    sqlite3BtreeLeaveAll(db);\n    if (pzDataType)\n        *pzDataType = zDataType;\n    if (pzCollSeq)\n        *pzCollSeq = zCollSeq;\n    if (pNotNull)\n        *pNotNull = notnull;\n    if (pPrimaryKey)\n        *pPrimaryKey = primarykey;\n    if (pAutoinc)\n        *pAutoinc = autoinc;\n    if (0 == rc && !pTab) {\n        sqlite3DbFree(db, zErrMsg);\n        zErrMsg = sqlite3MPrintf(db, \"no such table column: %s.%s\", zTableName, zColumnName);\n        rc = 1;\n    }\n    sqlite3ErrorWithMsg(db, rc, (zErrMsg ? \"%s\" : 0), zErrMsg);\n    sqlite3DbFree(db, zErrMsg);\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#197703:1#jsonReturn",
            "gotos": 5,
            "labels": 2,
            "body": "{\n    switch (pNode->eType) {\n      default:\n        {\n            assert(pNode->eType == 0);\n            sqlite3_result_null(pCtx);\n            break;\n        }\n      case 1:\n        {\n            sqlite3_result_int(pCtx, 1);\n            break;\n        }\n      case 2:\n        {\n            sqlite3_result_int(pCtx, 0);\n            break;\n        }\n      case 3:\n        {\n            sqlite3_int64 i = 0;\n            const char *z;\n            assert(pNode->eU == 1);\n            z = pNode->u.zJContent;\n            if (z[0] == '-') {\n                z++;\n            }\n            while (z[0] >= '0' && z[0] <= '9')\n                {\n                    unsigned int v = *(z++) - '0';\n                    if (i >= (4294967295U | (((i64)2147483647) << 32)) / 10) {\n                        if (i > (4294967295U | (((i64)2147483647) << 32)) / 10)\n                            goto int_as_real;\n                        if (z[0] >= '0' && z[0] <= '9')\n                            goto int_as_real;\n                        if (v == 9)\n                            goto int_as_real;\n                        if (v == 8) {\n                            if (pNode->u.zJContent[0] == '-') {\n                                sqlite3_result_int64(pCtx, (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))));\n                                goto int_done;\n                            } else {\n                                goto int_as_real;\n                            }\n                        }\n                    }\n                    i = i * 10 + v;\n                }\n            if (pNode->u.zJContent[0] == '-') {\n                i = -i;\n            }\n            sqlite3_result_int64(pCtx, i);\n          int_done:\n            break;\n          int_as_real:\n            ;\n        }\n      case 4:\n        {\n            double r;\n            const char *z;\n            assert(pNode->eU == 1);\n            z = pNode->u.zJContent;\n            sqlite3AtoF(z, &r, sqlite3Strlen30(z), 1);\n            sqlite3_result_double(pCtx, r);\n            break;\n        }\n      case 5:\n        {\n            assert((pNode->jnFlags & 1) == 0);\n            if ((pNode->jnFlags & 2) == 0) {\n                assert(pNode->eU == 1);\n                sqlite3_result_text(pCtx, pNode->u.zJContent + 1, pNode->n - 2, ((sqlite3_destructor_type)-1));\n            } else {\n                u32 i;\n                u32 n = pNode->n;\n                const char *z;\n                char *zOut;\n                u32 j;\n                assert(pNode->eU == 1);\n                z = pNode->u.zJContent;\n                zOut = sqlite3_malloc(n + 1);\n                if (zOut == 0) {\n                    sqlite3_result_error_nomem(pCtx);\n                    break;\n                }\n                for (i = 1 , j = 0; i < n - 1; i++) {\n                    char c = z[i];\n                    if (c != '\\\\') {\n                        zOut[j++] = c;\n                    } else {\n                        c = z[++i];\n                        if (c == 'u') {\n                            u32 v = jsonHexToInt4(z + i + 1);\n                            i += 4;\n                            if (v == 0)\n                                break;\n                            if (v <= 127) {\n                                zOut[j++] = (char)v;\n                            } else if (v <= 2047) {\n                                zOut[j++] = (char)(192 | (v >> 6));\n                                zOut[j++] = 128 | (v & 63);\n                            } else {\n                                u32 vlo;\n                                if ((v & 64512) == 55296 && i < n - 6 && z[i + 1] == '\\\\' && z[i + 2] == 'u' && ((vlo = jsonHexToInt4(z + i + 3)) & 64512) == 56320) {\n                                    v = ((v & 1023) << 10) + (vlo & 1023) + 65536;\n                                    i += 6;\n                                    zOut[j++] = 240 | (v >> 18);\n                                    zOut[j++] = 128 | ((v >> 12) & 63);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                } else {\n                                    zOut[j++] = 224 | (v >> 12);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                }\n                            }\n                        } else {\n                            if (c == 'b') {\n                                c = '\\b';\n                            } else if (c == 'f') {\n                                c = '\\f';\n                            } else if (c == 'n') {\n                                c = '\\n';\n                            } else if (c == 'r') {\n                                c = '\\r';\n                            } else if (c == 't') {\n                                c = '\\t';\n                            }\n                            zOut[j++] = c;\n                        }\n                    }\n                }\n                zOut[j] = 0;\n                sqlite3_result_text(pCtx, zOut, j, sqlite3_free);\n            }\n            break;\n        }\n      case 6:\n      case 7:\n        {\n            jsonReturnJson(pNode, pCtx, aReplace);\n            break;\n        }\n    }\n}\n"
        },
        {
            "id": "#23:25#sqlite3VdbeMultiLoad",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int i;\n    char c;\n    for (i = 0; (c = zTypes[i]) != 0; i++) {\n        if (c == 's') {\n            const char *z;\n            sqlite3VdbeAddOp4(p, z == 0 ? 75 : 117, 0, iDest + i, 0, z, 0);\n        } else if (c == 'i') {\n        } else {\n            goto skip_op_resultrow;\n        }\n    }\n    sqlite3VdbeAddOp2(p, 84, iDest, i);\n  skip_op_resultrow:\n    ;\n}\n"
        },
        {
            "id": "#23:25#sqlite3BitvecBuiltinTest",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    Bitvec *pBitvec = 0;\n    unsigned char *pV = 0;\n    int rc = -1;\n    int i, nx, pc, op;\n    void *pTmpSpace;\n    pBitvec = sqlite3BitvecCreate(sz);\n    pV = sqlite3MallocZero((sz + 7) / 8 + 1);\n    pTmpSpace = sqlite3_malloc64(512);\n    if (pBitvec == 0 || pV == 0 || pTmpSpace == 0)\n        goto bitvec_end;\n    sqlite3BitvecSet(0, 1);\n    sqlite3BitvecClear(0, 1, pTmpSpace);\n    pc = i = 0;\n    while ((op = aOp[pc]) != 0)\n        {\n            switch (op) {\n              case 1:\n              case 2:\n              case 5:\n                {\n                    nx = 4;\n                    i = aOp[pc + 2] - 1;\n                    aOp[pc + 2] += aOp[pc + 3];\n                    break;\n                }\n              case 3:\n              case 4:\n              default:\n                {\n                    nx = 2;\n                    sqlite3_randomness(sizeof (i), &i);\n                    break;\n                }\n            }\n            if ((--aOp[pc + 1]) > 0)\n                nx = 0;\n            pc += nx;\n            i = (i & 2147483647) % sz;\n            if ((op & 1) != 0) {\n                pV[(i + 1) >> 3] |= (1 << ((i + 1) & 7));\n                if (op != 5) {\n                    if (sqlite3BitvecSet(pBitvec, i + 1))\n                        goto bitvec_end;\n                }\n            } else {\n                pV[(i + 1) >> 3] &= ~(1 << ((i + 1) & 7));\n                sqlite3BitvecClear(pBitvec, i + 1, pTmpSpace);\n            }\n        }\n    rc = sqlite3BitvecTest(0, 0) + sqlite3BitvecTest(pBitvec, sz + 1) + sqlite3BitvecTest(pBitvec, 0) + (sqlite3BitvecSize(pBitvec) - sz);\n    for (i = 1; i <= sz; i++) {\n        if (((pV[i >> 3] & (1 << (i & 7))) != 0) != sqlite3BitvecTest(pBitvec, i)) {\n            rc = i;\n            break;\n        }\n    }\n  bitvec_end:\n    sqlite3_free(pTmpSpace);\n    sqlite3_free(pV);\n    sqlite3BitvecDestroy(pBitvec);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3BtreeCopyFile",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int rc;\n    sqlite3_file *pFd;\n    sqlite3_backup b;\n    sqlite3BtreeEnter(pTo);\n    sqlite3BtreeEnter(pFrom);\n    assert(sqlite3BtreeTxnState(pTo) == 2);\n    pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));\n    if (pFd->pMethods) {\n        i64 nByte = sqlite3BtreeGetPageSize(pFrom) * (i64)sqlite3BtreeLastPage(pFrom);\n        rc = sqlite3OsFileControl(pFd, 11, &nByte);\n        if (rc == 12)\n            rc = 0;\n        if (rc)\n            goto copy_finished;\n    }\n    memset(&b, 0, sizeof (b));\n    b.pSrcDb = pFrom->db;\n    b.pSrc = pFrom;\n    b.pDest = pTo;\n    b.iNext = 1;\n    sqlite3_backup_step(&b, 2147483647);\n    assert(b.rc != 0);\n    rc = sqlite3_backup_finish(&b);\n    if (rc == 0) {\n        pTo->pBt->btsFlags &= ~2;\n    } else {\n        sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));\n    }\n    assert(sqlite3BtreeTxnState(pTo) != 2);\n  copy_finished:\n    sqlite3BtreeLeave(pFrom);\n    sqlite3BtreeLeave(pTo);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3VdbeMemTranslate",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    sqlite3_int64 len;\n    unsigned char *zOut;\n    unsigned char *zIn;\n    unsigned char *zTerm;\n    unsigned char *z;\n    unsigned int c;\n    assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));\n    assert(pMem->flags & 2);\n    assert(pMem->enc != desiredEnc);\n    assert(pMem->enc != 0);\n    assert(pMem->n >= 0);\n    if (pMem->enc != 1 && desiredEnc != 1) {\n        u8 temp;\n        int rc;\n        rc = sqlite3VdbeMemMakeWriteable(pMem);\n        if (rc != 0) {\n            assert(rc == 7);\n            return 7;\n        }\n        zIn = (u8 *)pMem->z;\n        zTerm = &zIn[pMem->n & ~1];\n        while (zIn < zTerm)\n            {\n                temp = *zIn;\n                *zIn = *(zIn + 1);\n                zIn++;\n                *zIn++ = temp;\n            }\n        pMem->enc = desiredEnc;\n        goto translate_out;\n    }\n    if (desiredEnc == 1) {\n        pMem->n &= ~1;\n        len = 2 * (sqlite3_int64)pMem->n + 1;\n    } else {\n        len = 2 * (sqlite3_int64)pMem->n + 2;\n    }\n    zIn = (u8 *)pMem->z;\n    zTerm = &zIn[pMem->n];\n    zOut = sqlite3DbMallocRaw(pMem->db, len);\n    if (!zOut) {\n        return 7;\n    }\n    z = zOut;\n    if (pMem->enc == 1) {\n        if (desiredEnc == 2) {\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    if (c >= 192) {\n                        c = sqlite3Utf8Trans1[c - 192];\n                        while (zIn != zTerm && (*zIn & 192) == 128)\n                            {\n                                c = (c << 6) + (63 & *(zIn++));\n                            }\n                        if (c < 128 || (c & 4294965248U) == 55296 || (c & 4294967294U) == 65534) {\n                            c = 65533;\n                        }\n                    }\n                    ;\n                    {\n                        if (c <= 65535) {\n                            *z++ = (u8)(c & 255);\n                            *z++ = (u8)((c >> 8) & 255);\n                        } else {\n                            *z++ = (u8)(((c >> 10) & 63) + (((c - 65536) >> 10) & 192));\n                            *z++ = (u8)(216 + (((c - 65536) >> 18) & 3));\n                            *z++ = (u8)(c & 255);\n                            *z++ = (u8)(220 + ((c >> 8) & 3));\n                        }\n                    }\n                    ;\n                }\n        } else {\n            assert(desiredEnc == 3);\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    if (c >= 192) {\n                        c = sqlite3Utf8Trans1[c - 192];\n                        while (zIn != zTerm && (*zIn & 192) == 128)\n                            {\n                                c = (c << 6) + (63 & *(zIn++));\n                            }\n                        if (c < 128 || (c & 4294965248U) == 55296 || (c & 4294967294U) == 65534) {\n                            c = 65533;\n                        }\n                    }\n                    ;\n                    {\n                        if (c <= 65535) {\n                            *z++ = (u8)((c >> 8) & 255);\n                            *z++ = (u8)(c & 255);\n                        } else {\n                            *z++ = (u8)(216 + (((c - 65536) >> 18) & 3));\n                            *z++ = (u8)(((c >> 10) & 63) + (((c - 65536) >> 10) & 192));\n                            *z++ = (u8)(220 + ((c >> 8) & 3));\n                            *z++ = (u8)(c & 255);\n                        }\n                    }\n                    ;\n                }\n        }\n        pMem->n = (int)(z - zOut);\n        *z++ = 0;\n    } else {\n        assert(desiredEnc == 1);\n        if (pMem->enc == 2) {\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    c += (*(zIn++)) << 8;\n                    if (c >= 55296 && c < 57344) {\n                        if (zIn < zTerm) {\n                            int c2 = (*zIn++);\n                            c2 += ((*zIn++) << 8);\n                            c = (c2 & 1023) + ((c & 63) << 10) + (((c & 960) + 64) << 10);\n                        }\n                    }\n                    {\n                        if (c < 128) {\n                            *z++ = (u8)(c & 255);\n                        } else if (c < 2048) {\n                            *z++ = 192 + (u8)((c >> 6) & 31);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else if (c < 65536) {\n                            *z++ = 224 + (u8)((c >> 12) & 15);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else {\n                            *z++ = 240 + (u8)((c >> 18) & 7);\n                            *z++ = 128 + (u8)((c >> 12) & 63);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        }\n                    }\n                    ;\n                }\n        } else {\n            while (zIn < zTerm)\n                {\n                    c = (*(zIn++)) << 8;\n                    c += *(zIn++);\n                    if (c >= 55296 && c < 57344) {\n                        if (zIn < zTerm) {\n                            int c2 = ((*zIn++) << 8);\n                            c2 += (*zIn++);\n                            c = (c2 & 1023) + ((c & 63) << 10) + (((c & 960) + 64) << 10);\n                        }\n                    }\n                    {\n                        if (c < 128) {\n                            *z++ = (u8)(c & 255);\n                        } else if (c < 2048) {\n                            *z++ = 192 + (u8)((c >> 6) & 31);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else if (c < 65536) {\n                            *z++ = 224 + (u8)((c >> 12) & 15);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else {\n                            *z++ = 240 + (u8)((c >> 18) & 7);\n                            *z++ = 128 + (u8)((c >> 12) & 63);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        }\n                    }\n                    ;\n                }\n        }\n        pMem->n = (int)(z - zOut);\n    }\n    *z = 0;\n    assert((pMem->n + (desiredEnc == 1 ? 1 : 2)) <= len);\n    c = 2 | 512 | (pMem->flags & (63 | 2048));\n    sqlite3VdbeMemRelease(pMem);\n    pMem->flags = c;\n    pMem->enc = desiredEnc;\n    pMem->z = (char *)zOut;\n    pMem->zMalloc = pMem->z;\n    pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z);\n  translate_out:\n    return 0;\n}\n"
        },
        {
            "id": "#23:25#sqlite3WhereBegin",
            "gotos": 9,
            "labels": 1,
            "body": "{\n    int nByteWInfo;\n    int nTabList;\n    WhereInfo *pWInfo;\n    Vdbe *v = pParse->pVdbe;\n    Bitmask notReady;\n    WhereLoopBuilder sWLB;\n    WhereMaskSet *pMaskSet;\n    WhereLevel *pLevel;\n    WhereLoop *pLoop;\n    int ii;\n    sqlite3 *db;\n    int rc;\n    u8 bFordelete = 0;\n    assert((wctrlFlags & 8) == 0 || ((wctrlFlags & 4) != 0 && (wctrlFlags & 32) == 0));\n    assert((wctrlFlags & 32) == 0 || (wctrlFlags & 16384) == 0);\n    db = pParse->db;\n    memset(&sWLB, 0, sizeof (sWLB));\n    ;\n    if (pOrderBy && pOrderBy->nExpr >= ((int)(sizeof(Bitmask) * 8)))\n        pOrderBy = 0;\n    ;\n    if (pTabList->nSrc > ((int)(sizeof(Bitmask) * 8))) {\n        sqlite3ErrorMsg(pParse, \"at most %d tables in a join\", ((int)(sizeof(Bitmask) * 8)));\n        return 0;\n    }\n    nTabList = (wctrlFlags & 32) ? 1 : pTabList->nSrc;\n    nByteWInfo = (sizeof(WhereInfo) + (nTabList - 1) * sizeof(WhereLevel));\n    pWInfo = sqlite3DbMallocRawNN(db, nByteWInfo + sizeof(WhereLoop));\n    if (db->mallocFailed) {\n        sqlite3DbFree(db, pWInfo);\n        pWInfo = 0;\n        goto whereBeginError;\n    }\n    pWInfo->pParse = pParse;\n    pWInfo->pTabList = pTabList;\n    pWInfo->pOrderBy = pOrderBy;\n    pWInfo->pResultSet = pResultSet;\n    pWInfo->aiCurOnePass[0] = pWInfo->aiCurOnePass[1] = -1;\n    pWInfo->nLevel = nTabList;\n    pWInfo->iBreak = pWInfo->iContinue = sqlite3VdbeMakeLabel(pParse);\n    pWInfo->wctrlFlags = wctrlFlags;\n    pWInfo->iLimit = iAuxArg;\n    pWInfo->savedNQueryLoop = pParse->nQueryLoop;\n    pWInfo->pSelect = pSelect;\n    memset(&pWInfo->nOBSat, 0, ((int)((char *)&((WhereInfo *)0)->sWC)) - ((int)((char *)&((WhereInfo *)0)->nOBSat)));\n    memset(&pWInfo->a[0], 0, sizeof(WhereLoop) + nTabList * sizeof(WhereLevel));\n    assert(pWInfo->eOnePass == 0);\n    pMaskSet = &pWInfo->sMaskSet;\n    pMaskSet->n = 0;\n    pMaskSet->ix[0] = -99;\n    sWLB.pWInfo = pWInfo;\n    sWLB.pWC = &pWInfo->sWC;\n    sWLB.pNew = (WhereLoop *)(((char *)pWInfo) + nByteWInfo);\n    assert(((((char *)(sWLB.pNew) - (char *)0) & 7) == 0));\n    whereLoopInit(sWLB.pNew);\n    sqlite3WhereClauseInit(&pWInfo->sWC, pWInfo);\n    sqlite3WhereSplit(&pWInfo->sWC, pWhere, 44);\n    if (nTabList == 0) {\n        if (pOrderBy)\n            pWInfo->nOBSat = pOrderBy->nExpr;\n        if ((wctrlFlags & 256) != 0 && (((db)->dbOptFlags & (16)) == 0)) {\n            pWInfo->eDistinct = 1;\n        }\n        sqlite3VdbeExplain(pParse, 0, \"SCAN CONSTANT ROW\");\n    } else {\n        ii = 0;\n        do {\n            createMask(pMaskSet, pTabList->a[ii].iCursor);\n            sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);\n        } while ((++ii) < pTabList->nSrc);\n    }\n    sqlite3WhereExprAnalyze(pTabList, &pWInfo->sWC);\n    if (pSelect && pSelect->pLimit) {\n        sqlite3WhereAddLimit(&pWInfo->sWC, pSelect);\n    }\n    if (pParse->nErr)\n        goto whereBeginError;\n    for (ii = 0; ii < sWLB.pWC->nBase; ii++) {\n        WhereTerm *pT = &sWLB.pWC->a[ii];\n        if (pT->wtFlags & 2)\n            continue;\n        if (pT->prereqAll == 0 && (nTabList == 0 || exprIsDeterministic(pT->pExpr))) {\n            sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, 16);\n            pT->wtFlags |= 4;\n        }\n    }\n    if (wctrlFlags & 256) {\n        if ((((db)->dbOptFlags & (16)) != 0)) {\n            wctrlFlags &= ~256;\n            pWInfo->wctrlFlags &= ~256;\n        } else if (isDistinctRedundant(pParse, pTabList, &pWInfo->sWC, pResultSet)) {\n            pWInfo->eDistinct = 1;\n        } else if (pOrderBy == 0) {\n            pWInfo->wctrlFlags |= 128;\n            pWInfo->pOrderBy = pResultSet;\n        }\n    }\n    if (nTabList != 1 || whereShortCut(&sWLB) == 0) {\n        rc = whereLoopAddAll(&sWLB);\n        if (rc)\n            goto whereBeginError;\n        ;\n        wherePathSolver(pWInfo, 0);\n        if (db->mallocFailed)\n            goto whereBeginError;\n        if (pWInfo->pOrderBy) {\n            wherePathSolver(pWInfo, pWInfo->nRowOut + 1);\n            if (db->mallocFailed)\n                goto whereBeginError;\n        }\n    }\n    if (pWInfo->pOrderBy == 0 && (db->flags & 4096) != 0) {\n        pWInfo->revMask = ((Bitmask)-1);\n    }\n    if (pParse->nErr) {\n        goto whereBeginError;\n    }\n    assert(db->mallocFailed == 0);\n    notReady = ~(Bitmask)0;\n    if (pWInfo->nLevel >= 2 && pResultSet != 0 && 0 == (wctrlFlags & 1024) && (((db)->dbOptFlags & (256)) == 0)) {\n        notReady = whereOmitNoopJoin(pWInfo, notReady);\n        nTabList = pWInfo->nLevel;\n        assert(nTabList > 0);\n    }\n    if (pWInfo->nLevel >= 2 && (((db)->dbOptFlags & (524288)) == 0)) {\n        whereCheckIfBloomFilterIsUseful(pWInfo);\n    }\n    pWInfo->pParse->nQueryLoop += pWInfo->nRowOut;\n    assert((wctrlFlags & 4) == 0 || pWInfo->nLevel == 1);\n    if ((wctrlFlags & 4) != 0) {\n        int wsFlags = pWInfo->a[0].pWLoop->wsFlags;\n        int bOnerow = (wsFlags & 4096) != 0;\n        assert(!(wsFlags & 1024) || ((pTabList->a[0].pTab)->eTabType == 1));\n        if (bOnerow || (0 != (wctrlFlags & 8) && !((pTabList->a[0].pTab)->eTabType == 1) && (0 == (wsFlags & 8192) || (wctrlFlags & 16)))) {\n            pWInfo->eOnePass = bOnerow ? 1 : 2;\n            if ((((pTabList->a[0].pTab)->tabFlags & 128) == 0) && (wsFlags & 64)) {\n                if (wctrlFlags & 8) {\n                    bFordelete = 8;\n                }\n                pWInfo->a[0].pWLoop->wsFlags = (wsFlags & ~64);\n            }\n        }\n    }\n    for (ii = 0 , pLevel = pWInfo->a; ii < nTabList; ii++ , pLevel++) {\n        Table *pTab;\n        int iDb;\n        SrcItem *pTabItem;\n        pTabItem = &pTabList->a[pLevel->iFrom];\n        pTab = pTabItem->pTab;\n        iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        pLoop = pLevel->pWLoop;\n        if ((pTab->tabFlags & 16384) != 0 || ((pTab)->eTabType == 2)) {\n        } else if ((pLoop->wsFlags & 1024) != 0) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            int iCur = pTabItem->iCursor;\n            sqlite3VdbeAddOp4(v, 173, iCur, 0, 0, pVTab, (-11));\n        } else if (((pTab)->eTabType == 1)) {\n        } else if (((pLoop->wsFlags & 64) == 0 && (wctrlFlags & 32) == 0) || (pTabItem->fg.jointype & (64 | 16)) != 0) {\n            int op = 112;\n            if (pWInfo->eOnePass != 0) {\n                op = 113;\n                pWInfo->aiCurOnePass[0] = pTabItem->iCursor;\n            }\n            ;\n            sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);\n            assert(pTabItem->iCursor == pLevel->iTabCur);\n            ;\n            ;\n            if (pWInfo->eOnePass == 0 && pTab->nCol < ((int)(sizeof(Bitmask) * 8)) && (pTab->tabFlags & (96 | 128)) == 0 && (pLoop->wsFlags & (16384 | 4194304)) == 0) {\n                Bitmask b = pTabItem->colUsed;\n                int n = 0;\n                for (; b; b = b >> 1 , n++) {\n                }\n                sqlite3VdbeChangeP4(v, -1, ((void *)(long)(n)), (-3));\n                assert(n <= pTab->nCol);\n            }\n            {\n                sqlite3VdbeChangeP5(v, bFordelete);\n            }\n        } else {\n            sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n        }\n        if (pLoop->wsFlags & 512) {\n            Index *pIx = pLoop->u.btree.pIndex;\n            int iIndexCur;\n            int op = 112;\n            assert(iAuxArg != 0 || (pWInfo->wctrlFlags & 4) == 0);\n            if (!(((pTab)->tabFlags & 128) == 0) && ((pIx)->idxType == 2) && (wctrlFlags & 32) != 0) {\n                iIndexCur = pLevel->iTabCur;\n                op = 0;\n            } else if (pWInfo->eOnePass != 0) {\n                Index *pJ = pTabItem->pTab->pIndex;\n                iIndexCur = iAuxArg;\n                assert(wctrlFlags & 4);\n                while ((pJ) && pJ != pIx)\n                    {\n                        iIndexCur++;\n                        pJ = pJ->pNext;\n                    }\n                op = 113;\n                pWInfo->aiCurOnePass[1] = iIndexCur;\n            } else if (iAuxArg && (wctrlFlags & 32) != 0) {\n                iIndexCur = iAuxArg;\n                op = 101;\n            } else {\n                iIndexCur = pParse->nTab++;\n                if (pIx->bHasExpr && (((db)->dbOptFlags & (16777216)) == 0)) {\n                    whereAddIndexedExpr(pParse, pIx, iIndexCur, pTabItem);\n                }\n            }\n            pLevel->iIdxCur = iIndexCur;\n            assert(pIx != 0);\n            assert(pIx->pSchema == pTab->pSchema);\n            assert(iIndexCur >= 0);\n            if (op) {\n                sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);\n                sqlite3VdbeSetP4KeyInfo(pParse, pIx);\n                if ((pLoop->wsFlags & 15) != 0 && (pLoop->wsFlags & (2 | 32768)) == 0 && (pLoop->wsFlags & 524288) == 0 && (pLoop->wsFlags & 1048576) == 0 && (pWInfo->wctrlFlags & 1) == 0 && pWInfo->eDistinct != 2) {\n                    sqlite3VdbeChangeP5(v, 2);\n                }\n                ;\n            }\n        }\n        if (iDb >= 0)\n            sqlite3CodeVerifySchema(pParse, iDb);\n        if ((pTabItem->fg.jointype & 16) != 0 && (pLevel->pRJ = sqlite3WhereMalloc(pWInfo, sizeof(WhereRightJoin))) != 0) {\n            WhereRightJoin *pRJ = pLevel->pRJ;\n            pRJ->iMatch = pParse->nTab++;\n            pRJ->regBloom = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 77, 65536, pRJ->regBloom);\n            pRJ->regReturn = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 75, 0, pRJ->regReturn);\n            assert(pTab == pTabItem->pTab);\n            if ((((pTab)->tabFlags & 128) == 0)) {\n                KeyInfo *pInfo;\n                sqlite3VdbeAddOp2(v, 118, pRJ->iMatch, 1);\n                pInfo = sqlite3KeyInfoAlloc(pParse->db, 1, 0);\n                if (pInfo) {\n                    pInfo->aColl[0] = 0;\n                    pInfo->aSortFlags[0] = 0;\n                    sqlite3VdbeAppendP4(v, pInfo, (-8));\n                }\n            } else {\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                sqlite3VdbeAddOp2(v, 118, pRJ->iMatch, pPk->nKeyCol);\n                sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n            }\n            pLoop->wsFlags &= ~64;\n            pWInfo->nOBSat = 0;\n            pWInfo->eDistinct = 3;\n        }\n    }\n    pWInfo->iTop = sqlite3VdbeCurrentAddr(v);\n    if (db->mallocFailed)\n        goto whereBeginError;\n    for (ii = 0; ii < nTabList; ii++) {\n        int addrExplain;\n        int wsFlags;\n        SrcItem *pSrc;\n        if (pParse->nErr)\n            goto whereBeginError;\n        pLevel = &pWInfo->a[ii];\n        wsFlags = pLevel->pWLoop->wsFlags;\n        pSrc = &pTabList->a[pLevel->iFrom];\n        if (pSrc->fg.isMaterialized) {\n            if (pSrc->fg.isCorrelated) {\n                sqlite3VdbeAddOp2(v, 10, pSrc->regReturn, pSrc->addrFillSub);\n            } else {\n                int iOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n                sqlite3VdbeAddOp2(v, 10, pSrc->regReturn, pSrc->addrFillSub);\n                sqlite3VdbeJumpHere(v, iOnce);\n            }\n        }\n        if ((wsFlags & (16384 | 4194304)) != 0) {\n            if ((wsFlags & 16384) != 0) {\n                constructAutomaticIndex(pParse, &pWInfo->sWC, &pTabList->a[pLevel->iFrom], notReady, pLevel);\n            } else {\n                sqlite3ConstructBloomFilter(pWInfo, ii, pLevel, notReady);\n            }\n            if (db->mallocFailed)\n                goto whereBeginError;\n        }\n        addrExplain = sqlite3WhereExplainOneScan(pParse, pTabList, pLevel, wctrlFlags);\n        pLevel->addrBody = sqlite3VdbeCurrentAddr(v);\n        notReady = sqlite3WhereCodeOneLoopStart(pParse, v, pWInfo, ii, pLevel, notReady);\n        pWInfo->iContinue = pLevel->addrCont;\n        if ((wsFlags & 8192) == 0 && (wctrlFlags & 32) == 0) {\n            ((void)addrExplain);\n        }\n    }\n    ;\n    pWInfo->iEndWhere = sqlite3VdbeCurrentAddr(v);\n    return pWInfo;\n  whereBeginError:\n    if (pWInfo) {\n        pParse->nQueryLoop = pWInfo->savedNQueryLoop;\n        whereInfoFree(db, pWInfo);\n    }\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#75933:1#balance_nonroot",
            "gotos": 15,
            "labels": 1,
            "body": "{\n    BtShared *pBt;\n    int nMaxCells = 0;\n    int nNew = 0;\n    int nOld;\n    int i, j, k;\n    int nxDiv;\n    int rc = 0;\n    u16 leafCorrection;\n    int leafData;\n    int usableSpace;\n    int pageFlags;\n    int iSpace1 = 0;\n    int iOvflSpace = 0;\n    int szScratch;\n    MemPage *apOld[3];\n    MemPage *apNew[5];\n    u8 *pRight;\n    u8 *apDiv[2];\n    int cntNew[5];\n    int cntOld[5];\n    int szNew[5];\n    u8 *aSpace1;\n    Pgno pgno;\n    u8 abDone[5];\n    Pgno aPgno[5];\n    CellArray b;\n    memset(abDone, 0, sizeof (abDone));\n    memset(&b, 0, sizeof (b));\n    pBt = pParent->pBt;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(sqlite3PagerIswriteable(pParent->pDbPage));\n    assert(pParent->nOverflow == 0 || pParent->nOverflow == 1);\n    assert(pParent->nOverflow == 0 || pParent->aiOvfl[0] == iParentIdx);\n    if (!aOvflSpace) {\n        return 7;\n    }\n    assert(pParent->nFree >= 0);\n    i = pParent->nOverflow + pParent->nCell;\n    if (i < 2) {\n        nxDiv = 0;\n    } else {\n        assert(bBulk == 0 || bBulk == 1);\n        if (iParentIdx == 0) {\n            nxDiv = 0;\n        } else if (iParentIdx == i) {\n            nxDiv = i - 2 + bBulk;\n        } else {\n            nxDiv = iParentIdx - 1;\n        }\n        i = 2 - bBulk;\n    }\n    nOld = i + 1;\n    if ((i + nxDiv - pParent->nOverflow) == pParent->nCell) {\n        pRight = &pParent->aData[pParent->hdrOffset + 8];\n    } else {\n        pRight = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[0] << 8 | (&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[1])));\n    }\n    pgno = sqlite3Get4byte(pRight);\n    while (1)\n        {\n            if (rc == 0) {\n                rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);\n            }\n            if (rc) {\n                memset(apOld, 0, (i + 1) * sizeof(MemPage *));\n                goto balance_cleanup;\n            }\n            if (apOld[i]->nFree < 0) {\n                rc = btreeComputeFreeSpace(apOld[i]);\n                if (rc) {\n                    memset(apOld, 0, (i) * sizeof(MemPage *));\n                    goto balance_cleanup;\n                }\n            }\n            nMaxCells += apOld[i]->nCell + ((int)(sizeof (pParent->apOvfl) / sizeof (pParent->apOvfl[0])));\n            if ((i--) == 0)\n                break;\n            if (pParent->nOverflow && i + nxDiv == pParent->aiOvfl[0]) {\n                apDiv[i] = pParent->apOvfl[0];\n                pgno = sqlite3Get4byte(apDiv[i]);\n                szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\n                pParent->nOverflow = 0;\n            } else {\n                apDiv[i] = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[0] << 8 | (&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[1])));\n                pgno = sqlite3Get4byte(apDiv[i]);\n                szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\n                if (pBt->btsFlags & 12) {\n                    int iOff;\n                    iOff = ((int)(long)(apDiv[i])) - ((int)(long)(pParent->aData));\n                    if ((iOff + szNew[i]) <= (int)pBt->usableSize) {\n                        memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);\n                        apDiv[i] = &aOvflSpace[apDiv[i] - pParent->aData];\n                    }\n                }\n                dropCell(pParent, i + nxDiv - pParent->nOverflow, szNew[i], &rc);\n            }\n        }\n    nMaxCells = (nMaxCells + 3) & ~3;\n    szScratch = nMaxCells * sizeof(u8 *) + nMaxCells * sizeof(u16) + pBt->pageSize;\n    assert(szScratch <= 7 * (int)pBt->pageSize);\n    b.apCell = sqlite3DbMallocRaw(0, szScratch);\n    if (b.apCell == 0) {\n        rc = 7;\n        goto balance_cleanup;\n    }\n    b.szCell = (u16 *)&b.apCell[nMaxCells];\n    aSpace1 = (u8 *)&b.szCell[nMaxCells];\n    assert(((((char *)(aSpace1) - (char *)0) & 7) == 0));\n    b.pRef = apOld[0];\n    leafCorrection = b.pRef->leaf * 4;\n    leafData = b.pRef->intKeyLeaf;\n    for (i = 0; i < nOld; i++) {\n        MemPage *pOld = apOld[i];\n        int limit = pOld->nCell;\n        u8 *aData = pOld->aData;\n        u16 maskPage = pOld->maskPage;\n        u8 *piCell = aData + pOld->cellOffset;\n        u8 *piEnd;\n        if (pOld->aData[0] != apOld[0]->aData[0]) {\n            rc = sqlite3CorruptError(76127);\n            goto balance_cleanup;\n        }\n        memset(&b.szCell[b.nCell], 0, sizeof (b.szCell[0]) * (limit + pOld->nOverflow));\n        if (pOld->nOverflow > 0) {\n            if ((limit < pOld->aiOvfl[0])) {\n                rc = sqlite3CorruptError(76151);\n                goto balance_cleanup;\n            }\n            limit = pOld->aiOvfl[0];\n            for (j = 0; j < limit; j++) {\n                b.apCell[b.nCell] = aData + (maskPage & ((piCell)[0] << 8 | (piCell)[1]));\n                piCell += 2;\n                b.nCell++;\n            }\n            for (k = 0; k < pOld->nOverflow; k++) {\n                assert(k == 0 || pOld->aiOvfl[k - 1] + 1 == pOld->aiOvfl[k]);\n                b.apCell[b.nCell] = pOld->apOvfl[k];\n                b.nCell++;\n            }\n        }\n        piEnd = aData + pOld->cellOffset + 2 * pOld->nCell;\n        while (piCell < piEnd)\n            {\n                assert(b.nCell < nMaxCells);\n                b.apCell[b.nCell] = aData + (maskPage & ((piCell)[0] << 8 | (piCell)[1]));\n                piCell += 2;\n                b.nCell++;\n            }\n        cntOld[i] = b.nCell;\n        if (i < nOld - 1 && !leafData) {\n            u16 sz = (u16)szNew[i];\n            u8 *pTemp;\n            assert(b.nCell < nMaxCells);\n            b.szCell[b.nCell] = sz;\n            pTemp = &aSpace1[iSpace1];\n            iSpace1 += sz;\n            assert(sz <= pBt->maxLocal + 23);\n            assert(iSpace1 <= (int)pBt->pageSize);\n            memcpy(pTemp, apDiv[i], sz);\n            b.apCell[b.nCell] = pTemp + leafCorrection;\n            assert(leafCorrection == 0 || leafCorrection == 4);\n            b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;\n            if (!pOld->leaf) {\n                assert(leafCorrection == 0);\n                assert(pOld->hdrOffset == 0 || (sqlite3Config.neverCorrupt == 0));\n                memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);\n            } else {\n                assert(leafCorrection == 4);\n                while (b.szCell[b.nCell] < 4)\n                    {\n                        assert(b.szCell[b.nCell] == 3 || (sqlite3Config.neverCorrupt == 0));\n                        assert(b.apCell[b.nCell] == &aSpace1[iSpace1 - 3] || (sqlite3Config.neverCorrupt == 0));\n                        aSpace1[iSpace1++] = 0;\n                        b.szCell[b.nCell]++;\n                    }\n            }\n            b.nCell++;\n        }\n    }\n    usableSpace = pBt->usableSize - 12 + leafCorrection;\n    for (i = k = 0; i < nOld; i++ , k++) {\n        MemPage *p = apOld[i];\n        b.apEnd[k] = p->aDataEnd;\n        b.ixNx[k] = cntOld[i];\n        if (k && b.ixNx[k] == b.ixNx[k - 1]) {\n            k--;\n        }\n        if (!leafData) {\n            k++;\n            b.apEnd[k] = pParent->aDataEnd;\n            b.ixNx[k] = cntOld[i] + 1;\n        }\n        assert(p->nFree >= 0);\n        szNew[i] = usableSpace - p->nFree;\n        for (j = 0; j < p->nOverflow; j++) {\n            szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);\n        }\n        cntNew[i] = cntOld[i];\n    }\n    k = nOld;\n    for (i = 0; i < k; i++) {\n        int sz;\n        while (szNew[i] > usableSpace)\n            {\n                if (i + 1 >= k) {\n                    k = i + 2;\n                    if (k > 3 + 2) {\n                        rc = sqlite3CorruptError(76252);\n                        goto balance_cleanup;\n                    }\n                    szNew[k - 1] = 0;\n                    cntNew[k - 1] = b.nCell;\n                }\n                sz = 2 + cachedCellSize(&b, cntNew[i] - 1);\n                szNew[i] -= sz;\n                if (!leafData) {\n                    if (cntNew[i] < b.nCell) {\n                        sz = 2 + cachedCellSize(&b, cntNew[i]);\n                    } else {\n                        sz = 0;\n                    }\n                }\n                szNew[i + 1] += sz;\n                cntNew[i]--;\n            }\n        while (cntNew[i] < b.nCell)\n            {\n                sz = 2 + cachedCellSize(&b, cntNew[i]);\n                if (szNew[i] + sz > usableSpace)\n                    break;\n                szNew[i] += sz;\n                cntNew[i]++;\n                if (!leafData) {\n                    if (cntNew[i] < b.nCell) {\n                        sz = 2 + cachedCellSize(&b, cntNew[i]);\n                    } else {\n                        sz = 0;\n                    }\n                }\n                szNew[i + 1] -= sz;\n            }\n        if (cntNew[i] >= b.nCell) {\n            k = i + 1;\n        } else if (cntNew[i] <= (i > 0 ? cntNew[i - 1] : 0)) {\n            rc = sqlite3CorruptError(76285);\n            goto balance_cleanup;\n        }\n    }\n    for (i = k - 1; i > 0; i--) {\n        int szRight = szNew[i];\n        int szLeft = szNew[i - 1];\n        int r;\n        int d;\n        r = cntNew[i - 1] - 1;\n        d = r + 1 - leafData;\n        (void)cachedCellSize(&b, d);\n        do {\n            assert(d < nMaxCells);\n            assert(r < nMaxCells);\n            (void)cachedCellSize(&b, r);\n            if (szRight != 0 && (bBulk || szRight + b.szCell[d] + 2 > szLeft - (b.szCell[r] + (i == k - 1 ? 0 : 2)))) {\n                break;\n            }\n            szRight += b.szCell[d] + 2;\n            szLeft -= b.szCell[r] + 2;\n            cntNew[i - 1] = r;\n            r--;\n            d--;\n        } while (r >= 0);\n        szNew[i] = szRight;\n        szNew[i - 1] = szLeft;\n        if (cntNew[i - 1] <= (i > 1 ? cntNew[i - 2] : 0)) {\n            rc = sqlite3CorruptError(76327);\n            goto balance_cleanup;\n        }\n    }\n    assert(cntNew[0] > 0 || (pParent->pgno == 1 && pParent->nCell == 0) || (sqlite3Config.neverCorrupt == 0));\n    ;\n    pageFlags = apOld[0]->aData[0];\n    for (i = 0; i < k; i++) {\n        MemPage *pNew;\n        if (i < nOld) {\n            pNew = apNew[i] = apOld[i];\n            apOld[i] = 0;\n            rc = sqlite3PagerWrite(pNew->pDbPage);\n            nNew++;\n            if (sqlite3PagerPageRefcount(pNew->pDbPage) != 1 + (i == (iParentIdx - nxDiv)) && rc == 0) {\n                rc = sqlite3CorruptError(76360);\n            }\n            if (rc)\n                goto balance_cleanup;\n        } else {\n            assert(i > 0);\n            rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);\n            if (rc)\n                goto balance_cleanup;\n            zeroPage(pNew, pageFlags);\n            apNew[i] = pNew;\n            nNew++;\n            cntOld[i] = b.nCell;\n            if ((pBt->autoVacuum)) {\n                ptrmapPut(pBt, pNew->pgno, 5, pParent->pgno, &rc);\n                if (rc != 0) {\n                    goto balance_cleanup;\n                }\n            }\n        }\n    }\n    for (i = 0; i < nNew; i++) {\n        aPgno[i] = apNew[i]->pgno;\n        assert(apNew[i]->pDbPage->flags & 4);\n        assert(apNew[i]->pDbPage->flags & 2);\n    }\n    for (i = 0; i < nNew - 1; i++) {\n        int iB = i;\n        for (j = i + 1; j < nNew; j++) {\n            if (apNew[j]->pgno < apNew[iB]->pgno)\n                iB = j;\n        }\n        if (iB != i) {\n            Pgno pgnoA = apNew[i]->pgno;\n            Pgno pgnoB = apNew[iB]->pgno;\n            Pgno pgnoTemp = (sqlite3PendingByte / pBt->pageSize) + 1;\n            u16 fgA = apNew[i]->pDbPage->flags;\n            u16 fgB = apNew[iB]->pDbPage->flags;\n            sqlite3PagerRekey(apNew[i]->pDbPage, pgnoTemp, fgB);\n            sqlite3PagerRekey(apNew[iB]->pDbPage, pgnoA, fgA);\n            sqlite3PagerRekey(apNew[i]->pDbPage, pgnoB, fgB);\n            apNew[i]->pgno = pgnoB;\n            apNew[iB]->pgno = pgnoA;\n        }\n    }\n    ;\n    assert(sqlite3PagerIswriteable(pParent->pDbPage));\n    assert(nNew >= 1 && nNew <= ((int)(sizeof (apNew) / sizeof (apNew[0]))));\n    assert(apNew[nNew - 1] != 0);\n    sqlite3Put4byte(pRight, apNew[nNew - 1]->pgno);\n    if ((pageFlags & 8) == 0 && nOld != nNew) {\n        MemPage *pOld = (nNew > nOld ? apNew : apOld)[nOld - 1];\n        memcpy(&apNew[nNew - 1]->aData[8], &pOld->aData[8], 4);\n    }\n    if ((pBt->autoVacuum)) {\n        MemPage *pOld;\n        MemPage *pNew = pOld = apNew[0];\n        int cntOldNext = pNew->nCell + pNew->nOverflow;\n        int iNew = 0;\n        int iOld = 0;\n        for (i = 0; i < b.nCell; i++) {\n            u8 *pCell = b.apCell[i];\n            while (i == cntOldNext)\n                {\n                    iOld++;\n                    assert(iOld < nNew || iOld < nOld);\n                    assert(iOld >= 0 && iOld < 3);\n                    pOld = iOld < nNew ? apNew[iOld] : apOld[iOld];\n                    cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;\n                }\n            if (i == cntNew[iNew]) {\n                pNew = apNew[++iNew];\n                if (!leafData)\n                    continue;\n            }\n            if (iOld >= nNew || pNew->pgno != aPgno[iOld] || !(((uptr)(pCell) >= (uptr)(pOld->aData)) && ((uptr)(pCell) < (uptr)(pOld->aDataEnd)))) {\n                if (!leafCorrection) {\n                    ptrmapPut(pBt, sqlite3Get4byte(pCell), 5, pNew->pgno, &rc);\n                }\n                if (cachedCellSize(&b, i) > pNew->minLocal) {\n                    ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);\n                }\n                if (rc)\n                    goto balance_cleanup;\n            }\n        }\n    }\n    for (i = 0; i < nNew - 1; i++) {\n        u8 *pCell;\n        u8 *pTemp;\n        int sz;\n        u8 *pSrcEnd;\n        MemPage *pNew = apNew[i];\n        j = cntNew[i];\n        assert(j < nMaxCells);\n        assert(b.apCell[j] != 0);\n        pCell = b.apCell[j];\n        sz = b.szCell[j] + leafCorrection;\n        pTemp = &aOvflSpace[iOvflSpace];\n        if (!pNew->leaf) {\n            memcpy(&pNew->aData[8], pCell, 4);\n        } else if (leafData) {\n            CellInfo info;\n            j--;\n            pNew->xParseCell(pNew, b.apCell[j], &info);\n            pCell = pTemp;\n            sz = 4 + sqlite3PutVarint(&pCell[4], info.nKey);\n            pTemp = 0;\n        } else {\n            pCell -= 4;\n            if (b.szCell[j] == 4) {\n                assert(leafCorrection == 4);\n                sz = pParent->xCellSize(pParent, pCell);\n            }\n        }\n        iOvflSpace += sz;\n        assert(sz <= pBt->maxLocal + 23);\n        assert(iOvflSpace <= (int)pBt->pageSize);\n        for (k = 0; b.ixNx[k] <= j && (k < 3 * 2); k++) {\n        }\n        pSrcEnd = b.apEnd[k];\n        if ((((uptr)(pSrcEnd) >= (uptr)(pCell)) && ((uptr)(pSrcEnd) < (uptr)(pCell + sz)))) {\n            rc = sqlite3CorruptError(76560);\n            goto balance_cleanup;\n        }\n        insertCell(pParent, nxDiv + i, pCell, sz, pTemp, pNew->pgno, &rc);\n        if (rc != 0)\n            goto balance_cleanup;\n        assert(sqlite3PagerIswriteable(pParent->pDbPage));\n    }\n    for (i = 1 - nNew; i < nNew; i++) {\n        int iPg = i < 0 ? -i : i;\n        assert(iPg >= 0 && iPg < nNew);\n        if (abDone[iPg])\n            continue;\n        if (i >= 0 || cntOld[iPg - 1] >= cntNew[iPg - 1]) {\n            int iNew;\n            int iOld;\n            int nNewCell;\n            assert(iPg == 0 || cntOld[iPg - 1] >= cntNew[iPg - 1] || abDone[iPg - 1]);\n            assert(cntNew[iPg] >= cntOld[iPg] || abDone[iPg + 1]);\n            if (iPg == 0) {\n                iNew = iOld = 0;\n                nNewCell = cntNew[0];\n            } else {\n                iOld = iPg < nOld ? (cntOld[iPg - 1] + !leafData) : b.nCell;\n                iNew = cntNew[iPg - 1] + !leafData;\n                nNewCell = cntNew[iPg] - iNew;\n            }\n            rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);\n            if (rc)\n                goto balance_cleanup;\n            abDone[iPg]++;\n            apNew[iPg]->nFree = usableSpace - szNew[iPg];\n            assert(apNew[iPg]->nOverflow == 0);\n            assert(apNew[iPg]->nCell == nNewCell);\n        }\n    }\n    assert(memcmp(abDone, \"\\001\\001\\001\\001\\001\", nNew) == 0);\n    assert(nOld > 0);\n    assert(nNew > 0);\n    if (isRoot && pParent->nCell == 0 && pParent->hdrOffset <= apNew[0]->nFree) {\n        assert(nNew == 1 || (sqlite3Config.neverCorrupt == 0));\n        rc = defragmentPage(apNew[0], -1);\n        ;\n        assert(apNew[0]->nFree == ((((((int)((&apNew[0]->aData[5])[0] << 8 | (&apNew[0]->aData[5])[1])) - 1) & 65535) + 1) - apNew[0]->cellOffset - apNew[0]->nCell * 2) || rc != 0);\n        copyNodeContent(apNew[0], pParent, &rc);\n        freePage(apNew[0], &rc);\n    } else if ((pBt->autoVacuum) && !leafCorrection) {\n        for (i = 0; i < nNew; i++) {\n            u32 key = sqlite3Get4byte(&apNew[i]->aData[8]);\n            ptrmapPut(pBt, key, 5, apNew[i]->pgno, &rc);\n        }\n    }\n    assert(pParent->isInit);\n    ;\n    for (i = nNew; i < nOld; i++) {\n        freePage(apOld[i], &rc);\n    }\n  balance_cleanup:\n    sqlite3DbFree(0, b.apCell);\n    for (i = 0; i < nOld; i++) {\n        releasePage(apOld[i]);\n    }\n    for (i = 0; i < nNew; i++) {\n        releasePage(apNew[i]);\n    }\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#74635:1#freePage2",
            "gotos": 9,
            "labels": 1,
            "body": "{\n    MemPage *pTrunk = 0;\n    Pgno iTrunk = 0;\n    MemPage *pPage1 = pBt->pPage1;\n    MemPage *pPage;\n    int rc;\n    u32 nFree;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert((sqlite3Config.neverCorrupt == 0) || iPage > 1);\n    assert(!pMemPage || pMemPage->pgno == iPage);\n    if (iPage < 2 || iPage > pBt->nPage) {\n        return sqlite3CorruptError(74648);\n    }\n    if (pMemPage) {\n        pPage = pMemPage;\n        sqlite3PagerRef(pPage->pDbPage);\n    } else {\n        pPage = btreePageLookup(pBt, iPage);\n    }\n    rc = sqlite3PagerWrite(pPage1->pDbPage);\n    if (rc)\n        goto freepage_out;\n    nFree = sqlite3Get4byte(&pPage1->aData[36]);\n    sqlite3Put4byte(&pPage1->aData[36], nFree + 1);\n    if (pBt->btsFlags & 4) {\n        if ((!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0)) != 0)) || ((rc = sqlite3PagerWrite(pPage->pDbPage)) != 0)) {\n            goto freepage_out;\n        }\n        memset(pPage->aData, 0, pPage->pBt->pageSize);\n    }\n    if ((pBt->autoVacuum)) {\n        ptrmapPut(pBt, iPage, 2, 0, &rc);\n        if (rc)\n            goto freepage_out;\n    }\n    if (nFree != 0) {\n        u32 nLeaf;\n        iTrunk = sqlite3Get4byte(&pPage1->aData[32]);\n        if (iTrunk > btreePagecount(pBt)) {\n            rc = sqlite3CorruptError(74695);\n            goto freepage_out;\n        }\n        rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);\n        if (rc != 0) {\n            goto freepage_out;\n        }\n        nLeaf = sqlite3Get4byte(&pTrunk->aData[4]);\n        assert(pBt->usableSize > 32);\n        if (nLeaf > (u32)pBt->usableSize / 4 - 2) {\n            rc = sqlite3CorruptError(74706);\n            goto freepage_out;\n        }\n        if (nLeaf < (u32)pBt->usableSize / 4 - 8) {\n            rc = sqlite3PagerWrite(pTrunk->pDbPage);\n            if (rc == 0) {\n                sqlite3Put4byte(&pTrunk->aData[4], nLeaf + 1);\n                sqlite3Put4byte(&pTrunk->aData[8 + nLeaf * 4], iPage);\n                if (pPage && (pBt->btsFlags & 4) == 0) {\n                    sqlite3PagerDontWrite(pPage->pDbPage);\n                }\n                rc = btreeSetHasContent(pBt, iPage);\n            }\n            ;\n            goto freepage_out;\n        }\n    }\n    if (pPage == 0 && 0 != (rc = btreeGetPage(pBt, iPage, &pPage, 0))) {\n        goto freepage_out;\n    }\n    rc = sqlite3PagerWrite(pPage->pDbPage);\n    if (rc != 0) {\n        goto freepage_out;\n    }\n    sqlite3Put4byte(pPage->aData, iTrunk);\n    sqlite3Put4byte(&pPage->aData[4], 0);\n    sqlite3Put4byte(&pPage1->aData[32], iPage);\n    ;\n  freepage_out:\n    if (pPage) {\n        pPage->isInit = 0;\n    }\n    releasePage(pPage);\n    releasePage(pTrunk);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#87902:1#sqlite3Step",
            "gotos": 2,
            "labels": 2,
            "body": "{\n    sqlite3 *db;\n    int rc;\n    assert(p);\n    db = p->db;\n    if (p->eVdbeState != 2) {\n      restart_step:\n        if (p->eVdbeState == 1) {\n            if (p->expired) {\n                p->rc = 17;\n                rc = 1;\n                if ((p->prepFlags & 128) != 0) {\n                    rc = sqlite3VdbeTransferError(p);\n                }\n                goto end_of_step;\n            }\n            if (db->nVdbeActive == 0) {\n                __atomic_store_n((&db->u1.isInterrupted), (0), 0);\n            }\n            assert(db->nVdbeWrite > 0 || db->autoCommit == 0 || (db->nDeferredCons == 0 && db->nDeferredImmCons == 0));\n            if ((db->mTrace & (2 | 128)) != 0 && !db->init.busy && p->zSql) {\n                sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);\n            } else {\n                assert(p->startTime == 0);\n            }\n            db->nVdbeActive++;\n            if (p->readOnly == 0)\n                db->nVdbeWrite++;\n            if (p->bIsReader)\n                db->nVdbeRead++;\n            p->pc = 0;\n            p->eVdbeState = 2;\n        } else if ((p->eVdbeState == 3)) {\n            sqlite3_reset((sqlite3_stmt *)p);\n            assert(p->eVdbeState == 1);\n            goto restart_step;\n        }\n    }\n    if (p->explain) {\n        rc = sqlite3VdbeList(p);\n    } else {\n        db->nVdbeExec++;\n        rc = sqlite3VdbeExec(p);\n        db->nVdbeExec--;\n    }\n    if (rc == 100) {\n        assert(p->rc == 0);\n        assert(db->mallocFailed == 0);\n        db->errCode = 100;\n        return 100;\n    } else {\n        if (((p)->startTime) > 0) {\n            invokeProfileCallback(db, p);\n        }\n        ;\n        if (rc == 101 && db->autoCommit) {\n            assert(p->rc == 0);\n            p->rc = doWalCallbacks(db);\n            if (p->rc != 0) {\n                rc = 1;\n            }\n        } else if (rc != 101 && (p->prepFlags & 128) != 0) {\n            rc = sqlite3VdbeTransferError(p);\n        }\n    }\n    db->errCode = rc;\n    if (7 == sqlite3ApiExit(p->db, p->rc)) {\n        p->rc = 7;\n        if ((p->prepFlags & 128) != 0)\n            rc = p->rc;\n    }\n  end_of_step:\n    assert((p->prepFlags & 128) != 0 || rc == 100 || rc == 101 || rc == 1 || (rc & 255) == 5 || rc == 21);\n    return (rc & db->errMask);\n}\n"
        },
        {
            "id": "#23:25#sqlite3BtreeIndexMoveto",
            "gotos": 6,
            "labels": 2,
            "body": "{\n    int rc;\n    RecordCompare xRecordCompare;\n    assert(cursorOwnsBtShared(pCur));\n    assert(sqlite3_mutex_held(pCur->pBtree->db->mutex));\n    assert(pRes);\n    assert(pCur->pKeyInfo != 0);\n    xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);\n    pIdxKey->errCode = 0;\n    assert(pIdxKey->default_rc == 1 || pIdxKey->default_rc == 0 || pIdxKey->default_rc == -1);\n    if (pCur->eState == 0 && pCur->pPage->leaf && cursorOnLastPage(pCur)) {\n        int c;\n        if (pCur->ix == pCur->pPage->nCell - 1 && (c = indexCellCompare(pCur, pCur->ix, pIdxKey, xRecordCompare)) <= 0 && pIdxKey->errCode == 0) {\n            *pRes = c;\n            return 0;\n        }\n        if (pCur->iPage > 0 && indexCellCompare(pCur, 0, pIdxKey, xRecordCompare) <= 0 && pIdxKey->errCode == 0) {\n            pCur->curFlags &= ~4;\n            if (!pCur->pPage->isInit) {\n                return sqlite3CorruptError(73922);\n            }\n            goto bypass_moveto_root;\n        }\n        pIdxKey->errCode = 0;\n    }\n    rc = moveToRoot(pCur);\n    if (rc) {\n        if (rc == 16) {\n            assert(pCur->pgnoRoot == 0 || pCur->pPage->nCell == 0);\n            *pRes = -1;\n            return 0;\n        }\n        return rc;\n    }\n  bypass_moveto_root:\n    assert(pCur->pPage);\n    assert(pCur->pPage->isInit);\n    assert(pCur->eState == 0);\n    assert(pCur->pPage->nCell > 0);\n    assert(pCur->curIntKey == 0);\n    assert(pIdxKey != 0);\n    for (;;) {\n        int lwr, upr, idx, c;\n        Pgno chldPg;\n        MemPage *pPage = pCur->pPage;\n        u8 *pCell;\n        assert(pPage->nCell > 0);\n        assert(pPage->intKey == 0);\n        lwr = 0;\n        upr = pPage->nCell - 1;\n        idx = upr >> 1;\n        for (;;) {\n            int nCell;\n            pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n            nCell = pCell[0];\n            if (nCell <= pPage->max1bytePayload) {\n                ;\n                c = xRecordCompare(nCell, (void *)&pCell[1], pIdxKey);\n            } else if (!(pCell[1] & 128) && (nCell = ((nCell & 127) << 7) + pCell[1]) <= pPage->maxLocal) {\n                ;\n                c = xRecordCompare(nCell, (void *)&pCell[2], pIdxKey);\n            } else {\n                void *pCellKey;\n                u8 *const pCellBody = pCell - pPage->childPtrSize;\n                const int nOverrun = 18;\n                pPage->xParseCell(pPage, pCellBody, &pCur->info);\n                nCell = (int)pCur->info.nKey;\n                ;\n                ;\n                ;\n                ;\n                if (nCell < 2 || nCell / pCur->pBt->usableSize > pCur->pBt->nPage) {\n                    rc = sqlite3CorruptError(74009);\n                    goto moveto_index_finish;\n                }\n                pCellKey = sqlite3Malloc(nCell + nOverrun);\n                if (pCellKey == 0) {\n                    rc = 7;\n                    goto moveto_index_finish;\n                }\n                pCur->ix = (u16)idx;\n                rc = accessPayload(pCur, 0, nCell, (unsigned char *)pCellKey, 0);\n                memset(((u8 *)pCellKey) + nCell, 0, nOverrun);\n                pCur->curFlags &= ~4;\n                if (rc) {\n                    sqlite3_free(pCellKey);\n                    goto moveto_index_finish;\n                }\n                c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);\n                sqlite3_free(pCellKey);\n            }\n            assert((pIdxKey->errCode != 11 || c == 0) && (pIdxKey->errCode != 7 || pCur->pBtree->db->mallocFailed));\n            if (c < 0) {\n                lwr = idx + 1;\n            } else if (c > 0) {\n                upr = idx - 1;\n            } else {\n                assert(c == 0);\n                *pRes = 0;\n                rc = 0;\n                pCur->ix = (u16)idx;\n                if (pIdxKey->errCode)\n                    rc = sqlite3CorruptError(74041);\n                goto moveto_index_finish;\n            }\n            if (lwr > upr)\n                break;\n            assert(lwr + upr >= 0);\n            idx = (lwr + upr) >> 1;\n        }\n        assert(lwr == upr + 1 || (pPage->intKey && !pPage->leaf));\n        assert(pPage->isInit);\n        if (pPage->leaf) {\n            assert(pCur->ix < pCur->pPage->nCell || (sqlite3Config.neverCorrupt == 0));\n            pCur->ix = (u16)idx;\n            *pRes = c;\n            rc = 0;\n            goto moveto_index_finish;\n        }\n        if (lwr >= pPage->nCell) {\n            chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset + 8]);\n        } else {\n            chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (lwr)])[0] << 8 | (&(pPage)->aCellIdx[2 * (lwr)])[1]))));\n        }\n        pCur->ix = (u16)lwr;\n        rc = moveToChild(pCur, chldPg);\n        if (rc)\n            break;\n    }\n  moveto_index_finish:\n    pCur->info.nSize = 0;\n    assert((pCur->curFlags & 4) == 0);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3PagerOpen",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    u8 *pPtr;\n    Pager *pPager = 0;\n    int rc = 0;\n    int tempFile = 0;\n    int memDb = 0;\n    int memJM = 0;\n    int readOnly = 0;\n    int journalFileSize;\n    char *zPathname = 0;\n    int nPathname = 0;\n    int useJournal = (flags & 1) == 0;\n    int pcacheSize = sqlite3PcacheSize();\n    u32 szPageDflt = 4096;\n    const char *zUri = 0;\n    int nUriByte = 1;\n    int nUri = 0;\n    journalFileSize = (((sqlite3JournalSize(pVfs)) + 7) & ~7);\n    *ppPager = 0;\n    if (flags & 2) {\n        memDb = 1;\n        if (zFilename && zFilename[0]) {\n            zPathname = sqlite3DbStrDup(0, zFilename);\n            if (zPathname == 0)\n                return 7;\n            nPathname = sqlite3Strlen30(zPathname);\n            zFilename = 0;\n        }\n    }\n    if (zFilename && zFilename[0]) {\n        const char *z;\n        nPathname = pVfs->mxPathname + 1;\n        zPathname = sqlite3DbMallocRaw(0, nPathname * 2);\n        if (zPathname == 0) {\n            return 7;\n        }\n        zPathname[0] = 0;\n        rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);\n        if (rc != 0) {\n            if (rc == (0 | (2 << 8))) {\n                if (vfsFlags & 16777216) {\n                    rc = (14 | (6 << 8));\n                } else {\n                    rc = 0;\n                }\n            }\n        }\n        nPathname = sqlite3Strlen30(zPathname);\n        z = zUri = &zFilename[sqlite3Strlen30(zFilename) + 1];\n        while (*z)\n            {\n                z += strlen(z) + 1;\n                z += strlen(z) + 1;\n                nUri++;\n            }\n        nUriByte = (int)(&z[1] - zUri);\n        assert(nUriByte >= 1);\n        if (rc == 0 && nPathname + 8 > pVfs->mxPathname) {\n            rc = sqlite3CantopenError(59883);\n        }\n        if (rc != 0) {\n            sqlite3DbFree(0, zPathname);\n            return rc;\n        }\n    }\n    pPtr = (u8 *)sqlite3MallocZero((((sizeof (*pPager)) + 7) & ~7) + (((pcacheSize) + 7) & ~7) + (((pVfs->szOsFile) + 7) & ~7) + journalFileSize * 2 + sizeof (pPager) + 4 + nPathname + 1 + nUriByte + nPathname + 8 + 1 + nPathname + 4 + 1 + 3);\n    assert(((((char *)(((void *)(long)(journalFileSize))) - (char *)0) & 7) == 0));\n    if (!pPtr) {\n        sqlite3DbFree(0, zPathname);\n        return 7;\n    }\n    pPager = (Pager *)pPtr;\n    pPtr += (((sizeof (*pPager)) + 7) & ~7);\n    pPager->pPCache = (PCache *)pPtr;\n    pPtr += (((pcacheSize) + 7) & ~7);\n    pPager->fd = (sqlite3_file *)pPtr;\n    pPtr += (((pVfs->szOsFile) + 7) & ~7);\n    pPager->sjfd = (sqlite3_file *)pPtr;\n    pPtr += journalFileSize;\n    pPager->jfd = (sqlite3_file *)pPtr;\n    pPtr += journalFileSize;\n    assert(((((char *)(pPager->jfd) - (char *)0) & 7) == 0));\n    memcpy(pPtr, &pPager, sizeof (pPager));\n    pPtr += sizeof (pPager);\n    pPtr += 4;\n    pPager->zFilename = (char *)pPtr;\n    if (nPathname > 0) {\n        memcpy(pPtr, zPathname, nPathname);\n        pPtr += nPathname + 1;\n        if (zUri) {\n            memcpy(pPtr, zUri, nUriByte);\n            pPtr += nUriByte;\n        } else {\n            pPtr++;\n        }\n    }\n    if (nPathname > 0) {\n        pPager->zJournal = (char *)pPtr;\n        memcpy(pPtr, zPathname, nPathname);\n        pPtr += nPathname;\n        memcpy(pPtr, \"-journal\", 8);\n        pPtr += 8 + 1;\n    } else {\n        pPager->zJournal = 0;\n    }\n    if (nPathname > 0) {\n        pPager->zWal = (char *)pPtr;\n        memcpy(pPtr, zPathname, nPathname);\n        pPtr += nPathname;\n        memcpy(pPtr, \"-wal\", 4);\n        pPtr += 4 + 1;\n    } else {\n        pPager->zWal = 0;\n    }\n    (void)pPtr;\n    if (nPathname)\n        sqlite3DbFree(0, zPathname);\n    pPager->pVfs = pVfs;\n    pPager->vfsFlags = vfsFlags;\n    if (zFilename && zFilename[0]) {\n        int fout = 0;\n        rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);\n        assert(!memDb);\n        pPager->memVfs = memJM = (fout & 128) != 0;\n        readOnly = (fout & 1) != 0;\n        if (rc == 0) {\n            int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);\n            if (!readOnly) {\n                setSectorSize(pPager);\n                assert(4096 <= 8192);\n                if (szPageDflt < pPager->sectorSize) {\n                    if (pPager->sectorSize > 8192) {\n                        szPageDflt = 8192;\n                    } else {\n                        szPageDflt = (u32)pPager->sectorSize;\n                    }\n                }\n            }\n            pPager->noLock = sqlite3_uri_boolean(pPager->zFilename, \"nolock\", 0);\n            if ((iDc & 8192) != 0 || sqlite3_uri_boolean(pPager->zFilename, \"immutable\", 0)) {\n                vfsFlags |= 1;\n                goto act_like_temp_file;\n            }\n        }\n    } else {\n      act_like_temp_file:\n        tempFile = 1;\n        pPager->eState = 1;\n        pPager->eLock = 4;\n        pPager->noLock = 1;\n        readOnly = (vfsFlags & 1);\n    }\n    if (rc == 0) {\n        assert(pPager->memDb == 0);\n        rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);\n        ;\n    }\n    if (rc == 0) {\n        nExtra = (((nExtra) + 7) & ~7);\n        assert(nExtra >= 8 && nExtra < 1000);\n        rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb, !memDb ? pagerStress : 0, (void *)pPager, pPager->pPCache);\n    }\n    if (rc != 0) {\n        sqlite3OsClose(pPager->fd);\n        sqlite3PageFree(pPager->pTmpSpace);\n        sqlite3_free(pPager);\n        return rc;\n    }\n    ;\n    pPager->useJournal = (u8)useJournal;\n    pPager->mxPgno = 1073741823;\n    pPager->tempFile = (u8)tempFile;\n    assert(tempFile == 0 || tempFile == 1);\n    assert(1 == 1);\n    pPager->exclusiveMode = (u8)tempFile;\n    pPager->changeCountDone = pPager->tempFile;\n    pPager->memDb = (u8)memDb;\n    pPager->readOnly = (u8)readOnly;\n    assert(useJournal || pPager->tempFile);\n    pPager->noSync = pPager->tempFile;\n    if (pPager->noSync) {\n        assert(pPager->fullSync == 0);\n        assert(pPager->extraSync == 0);\n        assert(pPager->syncFlags == 0);\n        assert(pPager->walSyncFlags == 0);\n    } else {\n        pPager->fullSync = 1;\n        pPager->extraSync = 0;\n        pPager->syncFlags = 2;\n        pPager->walSyncFlags = 2 | (2 << 2);\n    }\n    pPager->nExtra = (u16)nExtra;\n    pPager->journalSizeLimit = -1;\n    assert(((pPager->fd)->pMethods != 0) || tempFile);\n    setSectorSize(pPager);\n    if (!useJournal) {\n        pPager->journalMode = 2;\n    } else if (memDb || memJM) {\n        pPager->journalMode = 4;\n    }\n    pPager->xReiniter = xReinit;\n    setGetterMethod(pPager);\n    *ppPager = pPager;\n    return 0;\n}\n"
        },
        {
            "id": "#23:25#sqlite3BtreeTableMoveto",
            "gotos": 2,
            "labels": 2,
            "body": "{\n    int rc;\n    assert(cursorOwnsBtShared(pCur));\n    assert(sqlite3_mutex_held(pCur->pBtree->db->mutex));\n    assert(pRes);\n    assert(pCur->pKeyInfo == 0);\n    assert(pCur->eState != 0 || pCur->curIntKey != 0);\n    if (pCur->eState == 0 && (pCur->curFlags & 2) != 0) {\n        if (pCur->info.nKey == intKey) {\n            *pRes = 0;\n            return 0;\n        }\n        if (pCur->info.nKey < intKey) {\n            if ((pCur->curFlags & 8) != 0) {\n                *pRes = -1;\n                return 0;\n            }\n            if (pCur->info.nKey + 1 == intKey) {\n                *pRes = 0;\n                rc = sqlite3BtreeNext(pCur, 0);\n                if (rc == 0) {\n                    getCellInfo(pCur);\n                    if (pCur->info.nKey == intKey) {\n                        return 0;\n                    }\n                } else if (rc != 101) {\n                    return rc;\n                }\n            }\n        }\n    }\n    rc = moveToRoot(pCur);\n    if (rc) {\n        if (rc == 16) {\n            assert(pCur->pgnoRoot == 0 || pCur->pPage->nCell == 0);\n            *pRes = -1;\n            return 0;\n        }\n        return rc;\n    }\n    assert(pCur->pPage);\n    assert(pCur->pPage->isInit);\n    assert(pCur->eState == 0);\n    assert(pCur->pPage->nCell > 0);\n    assert(pCur->iPage == 0 || pCur->apPage[0]->intKey == pCur->curIntKey);\n    assert(pCur->curIntKey);\n    for (;;) {\n        int lwr, upr, idx, c;\n        Pgno chldPg;\n        MemPage *pPage = pCur->pPage;\n        u8 *pCell;\n        assert(pPage->nCell > 0);\n        assert(pPage->intKey);\n        lwr = 0;\n        upr = pPage->nCell - 1;\n        assert(biasRight == 0 || biasRight == 1);\n        idx = upr >> (1 - biasRight);\n        for (;;) {\n            i64 nCellKey;\n            pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n            if (pPage->intKeyLeaf) {\n                while (128 <= *(pCell++))\n                    {\n                        if (pCell >= pPage->aDataEnd) {\n                            return sqlite3CorruptError(73726);\n                        }\n                    }\n            }\n            sqlite3GetVarint(pCell, (u64 *)&nCellKey);\n            if (nCellKey < intKey) {\n                lwr = idx + 1;\n                if (lwr > upr) {\n                    c = -1;\n                    break;\n                }\n            } else if (nCellKey > intKey) {\n                upr = idx - 1;\n                if (lwr > upr) {\n                    c = +1;\n                    break;\n                }\n            } else {\n                assert(nCellKey == intKey);\n                pCur->ix = (u16)idx;\n                if (!pPage->leaf) {\n                    lwr = idx;\n                    goto moveto_table_next_layer;\n                } else {\n                    pCur->curFlags |= 2;\n                    pCur->info.nKey = nCellKey;\n                    pCur->info.nSize = 0;\n                    *pRes = 0;\n                    return 0;\n                }\n            }\n            assert(lwr + upr >= 0);\n            idx = (lwr + upr) >> 1;\n        }\n        assert(lwr == upr + 1 || !pPage->leaf);\n        assert(pPage->isInit);\n        if (pPage->leaf) {\n            assert(pCur->ix < pCur->pPage->nCell);\n            pCur->ix = (u16)idx;\n            *pRes = c;\n            rc = 0;\n            goto moveto_table_finish;\n        }\n      moveto_table_next_layer:\n        if (lwr >= pPage->nCell) {\n            chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset + 8]);\n        } else {\n            chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (lwr)])[0] << 8 | (&(pPage)->aCellIdx[2 * (lwr)])[1]))));\n        }\n        pCur->ix = (u16)lwr;\n        rc = moveToChild(pCur, chldPg);\n        if (rc)\n            break;\n    }\n  moveto_table_finish:\n    pCur->info.nSize = 0;\n    assert((pCur->curFlags & 4) == 0);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#73416:1#moveToRoot",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    MemPage *pRoot;\n    int rc = 0;\n    assert(cursorOwnsBtShared(pCur));\n    assert(1 < 3);\n    assert(0 < 3);\n    assert(4 > 3);\n    assert(pCur->eState < 3 || pCur->iPage < 0);\n    assert(pCur->pgnoRoot > 0 || pCur->iPage < 0);\n    if (pCur->iPage >= 0) {\n        if (pCur->iPage) {\n            releasePageNotNull(pCur->pPage);\n            while (--pCur->iPage)\n                {\n                    releasePageNotNull(pCur->apPage[pCur->iPage]);\n                }\n            pRoot = pCur->pPage = pCur->apPage[0];\n            goto skip_init;\n        }\n    } else if (pCur->pgnoRoot == 0) {\n        pCur->eState = 1;\n        return 16;\n    } else {\n        assert(pCur->iPage == (-1));\n        if (pCur->eState >= 3) {\n            if (pCur->eState == 4) {\n                assert(pCur->skipNext != 0);\n                return pCur->skipNext;\n            }\n            sqlite3BtreeClearCursor(pCur);\n        }\n        rc = getAndInitPage(pCur->pBt, pCur->pgnoRoot, &pCur->pPage, 0, pCur->curPagerFlags);\n        if (rc != 0) {\n            pCur->eState = 1;\n            return rc;\n        }\n        pCur->iPage = 0;\n        pCur->curIntKey = pCur->pPage->intKey;\n    }\n    pRoot = pCur->pPage;\n    assert(pRoot->pgno == pCur->pgnoRoot || (sqlite3Config.neverCorrupt == 0));\n    assert(pRoot->intKey == 1 || pRoot->intKey == 0);\n    if (pRoot->isInit == 0 || (pCur->pKeyInfo == 0) != pRoot->intKey) {\n        return sqlite3CorruptError(73472);\n    }\n  skip_init:\n    pCur->ix = 0;\n    pCur->info.nSize = 0;\n    pCur->curFlags &= ~(8 | 2 | 4);\n    if (pRoot->nCell > 0) {\n        pCur->eState = 0;\n    } else if (!pRoot->leaf) {\n        Pgno subpage;\n        if (pRoot->pgno != 1)\n            return sqlite3CorruptError(73484);\n        subpage = sqlite3Get4byte(&pRoot->aData[pRoot->hdrOffset + 8]);\n        pCur->eState = 0;\n        rc = moveToChild(pCur, subpage);\n    } else {\n        pCur->eState = 1;\n        rc = 16;\n    }\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#98611:12#sqlite3_blob_open",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    int nAttempt = 0;\n    int iCol;\n    int rc = 0;\n    char *zErr = 0;\n    Table *pTab;\n    Incrblob *pBlob = 0;\n    Parse sParse;\n    *ppBlob = 0;\n    wrFlag = !!wrFlag;\n    sqlite3_mutex_enter(db->mutex);\n    pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));\n    while (1)\n        {\n            sqlite3ParseObjectInit(&sParse, db);\n            if (!pBlob)\n                goto blob_open_out;\n            sqlite3DbFree(db, zErr);\n            zErr = 0;\n            sqlite3BtreeEnterAll(db);\n            pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);\n            if (pTab && ((pTab)->eTabType == 1)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open virtual table: %s\", zTable);\n            }\n            if (pTab && !(((pTab)->tabFlags & 128) == 0)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open table without rowid: %s\", zTable);\n            }\n            if (pTab && ((pTab)->eTabType == 2)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open view: %s\", zTable);\n            }\n            if (!pTab) {\n                if (sParse.zErrMsg) {\n                    sqlite3DbFree(db, zErr);\n                    zErr = sParse.zErrMsg;\n                    sParse.zErrMsg = 0;\n                }\n                rc = 1;\n                sqlite3BtreeLeaveAll(db);\n                goto blob_open_out;\n            }\n            pBlob->pTab = pTab;\n            pBlob->zDb = db->aDb[sqlite3SchemaToIndex(db, pTab->pSchema)].zDbSName;\n            for (iCol = 0; iCol < pTab->nCol; iCol++) {\n                if (sqlite3StrICmp(pTab->aCol[iCol].zCnName, zColumn) == 0) {\n                    break;\n                }\n            }\n            if (iCol == pTab->nCol) {\n                sqlite3DbFree(db, zErr);\n                zErr = sqlite3MPrintf(db, \"no such column: \\\"%s\\\"\", zColumn);\n                rc = 1;\n                sqlite3BtreeLeaveAll(db);\n                goto blob_open_out;\n            }\n            if (wrFlag) {\n                const char *zFault = 0;\n                Index *pIdx;\n                if (db->flags & 16384) {\n                    FKey *pFKey;\n                    assert(((pTab)->eTabType == 0));\n                    for (pFKey = pTab->u.tab.pFKey; pFKey; pFKey = pFKey->pNextFrom) {\n                        int j;\n                        for (j = 0; j < pFKey->nCol; j++) {\n                            if (pFKey->aCol[j].iFrom == iCol) {\n                                zFault = \"foreign key\";\n                            }\n                        }\n                    }\n                }\n                for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                    int j;\n                    for (j = 0; j < pIdx->nKeyCol; j++) {\n                        if (pIdx->aiColumn[j] == iCol || pIdx->aiColumn[j] == (-2)) {\n                            zFault = \"indexed\";\n                        }\n                    }\n                }\n                if (zFault) {\n                    sqlite3DbFree(db, zErr);\n                    zErr = sqlite3MPrintf(db, \"cannot open %s column for writing\", zFault);\n                    rc = 1;\n                    sqlite3BtreeLeaveAll(db);\n                    goto blob_open_out;\n                }\n            }\n            pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);\n            assert(pBlob->pStmt || db->mallocFailed);\n            if (pBlob->pStmt) {\n                static const int iLn = 0;\n                static const VdbeOpList openBlob[] = {{169, 0, 0, 0}, {112, 0, 0, 0}, {31, 0, 5, 1}, {94, 0, 0, 1}, {84, 1, 0, 0}, {70, 0, 0, 0}};\n                Vdbe *v = (Vdbe *)pBlob->pStmt;\n                int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                VdbeOp *aOp;\n                sqlite3VdbeAddOp4Int(v, 2, iDb, wrFlag, pTab->pSchema->schema_cookie, pTab->pSchema->iGeneration);\n                sqlite3VdbeChangeP5(v, 1);\n                assert(sqlite3VdbeCurrentAddr(v) == 2 || db->mallocFailed);\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (openBlob) / sizeof (openBlob[0]))), openBlob, iLn);\n                sqlite3VdbeUsesBtree(v, iDb);\n                if (db->mallocFailed == 0) {\n                    assert(aOp != 0);\n                    aOp[0].p1 = iDb;\n                    aOp[0].p2 = pTab->tnum;\n                    aOp[0].p3 = wrFlag;\n                    sqlite3VdbeChangeP4(v, 2, pTab->zName, 0);\n                }\n                if (db->mallocFailed == 0) {\n                    if (wrFlag)\n                        aOp[1].opcode = 113;\n                    aOp[1].p2 = pTab->tnum;\n                    aOp[1].p3 = iDb;\n                    aOp[1].p4type = (-3);\n                    aOp[1].p4.i = pTab->nCol + 1;\n                    aOp[3].p2 = pTab->nCol;\n                    sParse.nVar = 0;\n                    sParse.nMem = 1;\n                    sParse.nTab = 1;\n                    sqlite3VdbeMakeReady(v, &sParse);\n                }\n            }\n            pBlob->iCol = iCol;\n            pBlob->db = db;\n            sqlite3BtreeLeaveAll(db);\n            if (db->mallocFailed) {\n                goto blob_open_out;\n            }\n            rc = blobSeekToRow(pBlob, iRow, &zErr);\n            if ((++nAttempt) >= 50 || rc != 17)\n                break;\n            sqlite3ParseObjectReset(&sParse);\n        }\n  blob_open_out:\n    if (rc == 0 && db->mallocFailed == 0) {\n        *ppBlob = (sqlite3_blob *)pBlob;\n    } else {\n        if (pBlob && pBlob->pStmt)\n            sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);\n        sqlite3DbFree(db, pBlob);\n    }\n    sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : 0), zErr);\n    sqlite3DbFree(db, zErr);\n    sqlite3ParseObjectReset(&sParse);\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3BtreeOpen",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    BtShared *pBt = 0;\n    Btree *p;\n    sqlite3_mutex *mutexOpen = 0;\n    int rc = 0;\n    u8 nReserve;\n    unsigned char zDbHeader[100];\n    const int isTempDb = zFilename == 0 || zFilename[0] == 0;\n    const int isMemdb = (zFilename && strcmp(zFilename, \":memory:\") == 0) || (isTempDb && sqlite3TempInMemory(db)) || (vfsFlags & 128) != 0;\n    assert(db != 0);\n    assert(pVfs != 0);\n    assert(sqlite3_mutex_held(db->mutex));\n    assert((flags & 255) == flags);\n    assert((flags & 8) == 0 || (flags & 4) != 0);\n    assert((flags & 4) == 0 || isTempDb);\n    if (isMemdb) {\n        flags |= 2;\n    }\n    if ((vfsFlags & 256) != 0 && (isMemdb || isTempDb)) {\n        vfsFlags = (vfsFlags & ~256) | 512;\n    }\n    p = sqlite3MallocZero(sizeof(Btree));\n    if (!p) {\n        return 7;\n    }\n    p->inTrans = 0;\n    p->db = db;\n    p->lock.pBtree = p;\n    p->lock.iTable = 1;\n    if (isTempDb == 0 && (isMemdb == 0 || (vfsFlags & 64) != 0)) {\n        if (vfsFlags & 131072) {\n            int nFilename = sqlite3Strlen30(zFilename) + 1;\n            int nFullPathname = pVfs->mxPathname + 1;\n            char *zFullPathname = sqlite3Malloc(((nFullPathname) > (nFilename) ? (nFullPathname) : (nFilename)));\n            sqlite3_mutex *mutexShared;\n            p->sharable = 1;\n            if (!zFullPathname) {\n                sqlite3_free(p);\n                return 7;\n            }\n            if (isMemdb) {\n                memcpy(zFullPathname, zFilename, nFilename);\n            } else {\n                rc = sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname);\n                if (rc) {\n                    if (rc == (0 | (2 << 8))) {\n                        rc = 0;\n                    } else {\n                        sqlite3_free(zFullPathname);\n                        sqlite3_free(p);\n                        return rc;\n                    }\n                }\n            }\n            mutexOpen = sqlite3MutexAlloc(4);\n            sqlite3_mutex_enter(mutexOpen);\n            mutexShared = sqlite3MutexAlloc(2);\n            sqlite3_mutex_enter(mutexShared);\n            for (pBt = sqlite3SharedCacheList; pBt; pBt = pBt->pNext) {\n                assert(pBt->nRef > 0);\n                if (0 == strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0)) && sqlite3PagerVfs(pBt->pPager) == pVfs) {\n                    int iDb;\n                    for (iDb = db->nDb - 1; iDb >= 0; iDb--) {\n                        Btree *pExisting = db->aDb[iDb].pBt;\n                        if (pExisting && pExisting->pBt == pBt) {\n                            sqlite3_mutex_leave(mutexShared);\n                            sqlite3_mutex_leave(mutexOpen);\n                            sqlite3_free(zFullPathname);\n                            sqlite3_free(p);\n                            return 19;\n                        }\n                    }\n                    p->pBt = pBt;\n                    pBt->nRef++;\n                    break;\n                }\n            }\n            sqlite3_mutex_leave(mutexShared);\n            sqlite3_free(zFullPathname);\n        }\n    }\n    if (pBt == 0) {\n        assert(sizeof(i64) == 8);\n        assert(sizeof(u64) == 8);\n        assert(sizeof(u32) == 4);\n        assert(sizeof(u16) == 2);\n        assert(sizeof(Pgno) == 4);\n        pBt = sqlite3MallocZero(sizeof (*pBt));\n        if (pBt == 0) {\n            rc = 7;\n            goto btree_open_out;\n        }\n        rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename, sizeof(MemPage), flags, vfsFlags, pageReinit);\n        if (rc == 0) {\n            sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);\n            rc = sqlite3PagerReadFileheader(pBt->pPager, sizeof (zDbHeader), zDbHeader);\n        }\n        if (rc != 0) {\n            goto btree_open_out;\n        }\n        pBt->openFlags = (u8)flags;\n        pBt->db = db;\n        sqlite3PagerSetBusyHandler(pBt->pPager, btreeInvokeBusyHandler, pBt);\n        p->pBt = pBt;\n        pBt->pCursor = 0;\n        pBt->pPage1 = 0;\n        if (sqlite3PagerIsreadonly(pBt->pPager))\n            pBt->btsFlags |= 1;\n        pBt->pageSize = (zDbHeader[16] << 8) | (zDbHeader[17] << 16);\n        if (pBt->pageSize < 512 || pBt->pageSize > 65536 || ((pBt->pageSize - 1) & pBt->pageSize) != 0) {\n            pBt->pageSize = 0;\n            if (zFilename && !isMemdb) {\n                pBt->autoVacuum = (0 ? 1 : 0);\n                pBt->incrVacuum = (0 == 2 ? 1 : 0);\n            }\n            nReserve = 0;\n        } else {\n            nReserve = zDbHeader[20];\n            pBt->btsFlags |= 2;\n            pBt->autoVacuum = (sqlite3Get4byte(&zDbHeader[36 + 4 * 4]) ? 1 : 0);\n            pBt->incrVacuum = (sqlite3Get4byte(&zDbHeader[36 + 7 * 4]) ? 1 : 0);\n        }\n        rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);\n        if (rc)\n            goto btree_open_out;\n        pBt->usableSize = pBt->pageSize - nReserve;\n        assert((pBt->pageSize & 7) == 0);\n        pBt->nRef = 1;\n        if (p->sharable) {\n            sqlite3_mutex *mutexShared;\n            mutexShared = sqlite3MutexAlloc(2);\n            if (1 && sqlite3Config.bCoreMutex) {\n                pBt->mutex = sqlite3MutexAlloc(0);\n                if (pBt->mutex == 0) {\n                    rc = 7;\n                    goto btree_open_out;\n                }\n            }\n            sqlite3_mutex_enter(mutexShared);\n            pBt->pNext = sqlite3SharedCacheList;\n            sqlite3SharedCacheList = pBt;\n            sqlite3_mutex_leave(mutexShared);\n        }\n    }\n    if (p->sharable) {\n        int i;\n        Btree *pSib;\n        for (i = 0; i < db->nDb; i++) {\n            if ((pSib = db->aDb[i].pBt) != 0 && pSib->sharable) {\n                while (pSib->pPrev)\n                    {\n                        pSib = pSib->pPrev;\n                    }\n                if ((uptr)p->pBt < (uptr)pSib->pBt) {\n                    p->pNext = pSib;\n                    p->pPrev = 0;\n                    pSib->pPrev = p;\n                } else {\n                    while (pSib->pNext && (uptr)pSib->pNext->pBt < (uptr)p->pBt)\n                        {\n                            pSib = pSib->pNext;\n                        }\n                    p->pNext = pSib->pNext;\n                    p->pPrev = pSib;\n                    if (p->pNext) {\n                        p->pNext->pPrev = p;\n                    }\n                    pSib->pNext = p;\n                }\n                break;\n            }\n        }\n    }\n    *ppBtree = p;\n  btree_open_out:\n    if (rc != 0) {\n        if (pBt && pBt->pPager) {\n            sqlite3PagerClose(pBt->pPager, 0);\n        }\n        sqlite3_free(pBt);\n        sqlite3_free(p);\n        *ppBtree = 0;\n    } else {\n        sqlite3_file *pFile;\n        if (sqlite3BtreeSchema(p, 0, 0) == 0) {\n            sqlite3BtreeSetCacheSize(p, -2000);\n        }\n        pFile = sqlite3PagerFile(pBt->pPager);\n        if (pFile->pMethods) {\n            sqlite3OsFileControlHint(pFile, 30, (void *)&pBt->db);\n        }\n    }\n    if (mutexOpen) {\n        assert(sqlite3_mutex_held(mutexOpen));\n        sqlite3_mutex_leave(mutexOpen);\n    }\n    assert(rc != 0 || sqlite3BtreeConnectionCount(*ppBtree) > 0);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#70334:1#getAndInitPage",
            "gotos": 4,
            "labels": 2,
            "body": "{\n    int rc;\n    DbPage *pDbPage;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(pCur == 0 || ppPage == &pCur->pPage);\n    assert(pCur == 0 || bReadOnly == pCur->curPagerFlags);\n    assert(pCur == 0 || pCur->iPage > 0);\n    if (pgno > btreePagecount(pBt)) {\n        rc = sqlite3CorruptError(70349);\n        goto getAndInitPage_error1;\n    }\n    rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage **)&pDbPage, bReadOnly);\n    if (rc) {\n        goto getAndInitPage_error1;\n    }\n    *ppPage = (MemPage *)sqlite3PagerGetExtra(pDbPage);\n    if ((*ppPage)->isInit == 0) {\n        btreePageFromDbPage(pDbPage, pgno, pBt);\n        rc = btreeInitPage(*ppPage);\n        if (rc != 0) {\n            goto getAndInitPage_error2;\n        }\n    }\n    assert((*ppPage)->pgno == pgno || (sqlite3Config.neverCorrupt == 0));\n    assert((*ppPage)->aData == sqlite3PagerGetData(pDbPage));\n    if (pCur && ((*ppPage)->nCell < 1 || (*ppPage)->intKey != pCur->curIntKey)) {\n        rc = sqlite3CorruptError(70370);\n        goto getAndInitPage_error2;\n    }\n    return 0;\n  getAndInitPage_error2:\n    releasePage(*ppPage);\n  getAndInitPage_error1:\n    if (pCur) {\n        pCur->iPage--;\n        pCur->pPage = pCur->apPage[pCur->iPage];\n    }\n    ;\n    assert(pgno != 0 || rc != 0);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#69569:1#defragmentPage",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int i;\n    int pc;\n    int hdr;\n    int size;\n    int usableSize;\n    int cellOffset;\n    int cbrk;\n    int nCell;\n    unsigned char *data;\n    unsigned char *temp;\n    unsigned char *src;\n    int iCellFirst;\n    int iCellLast;\n    int iCellStart;\n    assert(sqlite3PagerIswriteable(pPage->pDbPage));\n    assert(pPage->pBt != 0);\n    assert(pPage->pBt->usableSize <= 65536);\n    assert(pPage->nOverflow == 0);\n    assert(sqlite3_mutex_held(pPage->pBt->mutex));\n    data = pPage->aData;\n    hdr = pPage->hdrOffset;\n    cellOffset = pPage->cellOffset;\n    nCell = pPage->nCell;\n    assert(nCell == ((&data[hdr + 3])[0] << 8 | (&data[hdr + 3])[1]) || (sqlite3Config.neverCorrupt == 0));\n    iCellFirst = cellOffset + 2 * nCell;\n    usableSize = pPage->pBt->usableSize;\n    if ((int)data[hdr + 7] <= nMaxFrag) {\n        int iFree = ((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);\n        if (iFree > usableSize - 4)\n            return sqlite3CorruptError(69605);\n        if (iFree) {\n            int iFree2 = ((&data[iFree])[0] << 8 | (&data[iFree])[1]);\n            if (iFree2 > usableSize - 4)\n                return sqlite3CorruptError(69608);\n            if (0 == iFree2 || (data[iFree2] == 0 && data[iFree2 + 1] == 0)) {\n                u8 *pEnd = &data[cellOffset + nCell * 2];\n                u8 *pAddr;\n                int sz2 = 0;\n                int sz = ((&data[iFree + 2])[0] << 8 | (&data[iFree + 2])[1]);\n                int top = ((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);\n                if (top >= iFree) {\n                    return sqlite3CorruptError(69616);\n                }\n                if (iFree2) {\n                    if (iFree + sz > iFree2)\n                        return sqlite3CorruptError(69619);\n                    sz2 = ((&data[iFree2 + 2])[0] << 8 | (&data[iFree2 + 2])[1]);\n                    if (iFree2 + sz2 > usableSize)\n                        return sqlite3CorruptError(69621);\n                    memmove(&data[iFree + sz + sz2], &data[iFree + sz], iFree2 - (iFree + sz));\n                    sz += sz2;\n                } else if (iFree + sz > usableSize) {\n                    return sqlite3CorruptError(69625);\n                }\n                cbrk = top + sz;\n                assert(cbrk + (iFree - top) <= usableSize);\n                memmove(&data[cbrk], &data[top], iFree - top);\n                for (pAddr = &data[cellOffset]; pAddr < pEnd; pAddr += 2) {\n                    pc = ((pAddr)[0] << 8 | (pAddr)[1]);\n                    if (pc < iFree) {\n                        ((pAddr)[0] = (u8)((pc + sz) >> 8) , (pAddr)[1] = (u8)(pc + sz));\n                    } else if (pc < iFree2) {\n                        ((pAddr)[0] = (u8)((pc + sz2) >> 8) , (pAddr)[1] = (u8)(pc + sz2));\n                    }\n                }\n                goto defragment_out;\n            }\n        }\n    }\n    cbrk = usableSize;\n    iCellLast = usableSize - 4;\n    iCellStart = ((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);\n    if (nCell > 0) {\n        temp = sqlite3PagerTempSpace(pPage->pBt->pPager);\n        memcpy(&temp[iCellStart], &data[iCellStart], usableSize - iCellStart);\n        src = temp;\n        for (i = 0; i < nCell; i++) {\n            u8 *pAddr;\n            pAddr = &data[cellOffset + i * 2];\n            pc = ((pAddr)[0] << 8 | (pAddr)[1]);\n            ;\n            ;\n            if (pc < iCellStart || pc > iCellLast) {\n                return sqlite3CorruptError(69658);\n            }\n            assert(pc >= iCellStart && pc <= iCellLast);\n            size = pPage->xCellSize(pPage, &src[pc]);\n            cbrk -= size;\n            if (cbrk < iCellStart || pc + size > usableSize) {\n                return sqlite3CorruptError(69664);\n            }\n            assert(cbrk + size <= usableSize && cbrk >= iCellStart);\n            ;\n            ;\n            ((pAddr)[0] = (u8)((cbrk) >> 8) , (pAddr)[1] = (u8)(cbrk));\n            memcpy(&data[cbrk], &src[pc], size);\n        }\n    }\n    data[hdr + 7] = 0;\n  defragment_out:\n    assert(pPage->nFree >= 0);\n    if (data[hdr + 7] + cbrk - iCellFirst != pPage->nFree) {\n        return sqlite3CorruptError(69678);\n    }\n    assert(cbrk >= iCellFirst);\n    ((&data[hdr + 5])[0] = (u8)((cbrk) >> 8) , (&data[hdr + 5])[1] = (u8)(cbrk));\n    data[hdr + 1] = 0;\n    data[hdr + 2] = 0;\n    memset(&data[iCellFirst], 0, cbrk - iCellFirst);\n    assert(sqlite3PagerIswriteable(pPage->pDbPage));\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#69069:1#ptrmapPut",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    DbPage *pDbPage;\n    u8 *pPtrmap;\n    Pgno iPtrmap;\n    int offset;\n    int rc;\n    if (*pRC)\n        return;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(0 == (ptrmapPageno((pBt), (((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)))) == (((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)))));\n    assert(pBt->autoVacuum);\n    if (key == 0) {\n        *pRC = sqlite3CorruptError(69084);\n        return;\n    }\n    iPtrmap = ptrmapPageno(pBt, key);\n    rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);\n    if (rc != 0) {\n        *pRC = rc;\n        return;\n    }\n    if (((char *)sqlite3PagerGetExtra(pDbPage))[0] != 0) {\n        *pRC = sqlite3CorruptError(69097);\n        goto ptrmap_exit;\n    }\n    offset = (5 * (key - iPtrmap - 1));\n    if (offset < 0) {\n        *pRC = sqlite3CorruptError(69102);\n        goto ptrmap_exit;\n    }\n    assert(offset <= (int)pBt->usableSize - 5);\n    pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);\n    if (eType != pPtrmap[offset] || sqlite3Get4byte(&pPtrmap[offset + 1]) != parent) {\n        ;\n        *pRC = rc = sqlite3PagerWrite(pDbPage);\n        if (rc == 0) {\n            pPtrmap[offset] = eType;\n            sqlite3Put4byte(&pPtrmap[offset + 1], parent);\n        }\n    }\n  ptrmap_exit:\n    sqlite3PagerUnref(pDbPage);\n}\n"
        },
        {
            "id": "#23:25#sqlite3BtreeBeginTrans",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    BtShared *pBt = p->pBt;\n    Pager *pPager = pBt->pPager;\n    int rc = 0;\n    sqlite3BtreeEnter(p);\n    assert(p->pBt->inTransaction != 0 || p->pBt->nTransaction == 0);\n    assert(p->pBt->inTransaction >= p->inTrans);\n    ;\n    if (p->inTrans == 2 || (p->inTrans == 1 && !wrflag)) {\n        goto trans_begun;\n    }\n    assert(pBt->inTransaction == 2 || (pBt->bDoTruncate) == 0);\n    if ((p->db->flags & 33554432) && sqlite3PagerIsreadonly(pPager) == 0) {\n        pBt->btsFlags &= ~1;\n    }\n    if ((pBt->btsFlags & 1) != 0 && wrflag) {\n        rc = 8;\n        goto trans_begun;\n    }\n    {\n        sqlite3 *pBlock = 0;\n        if ((wrflag && pBt->inTransaction == 2) || (pBt->btsFlags & 128) != 0) {\n            pBlock = pBt->pWriter->db;\n        } else if (wrflag > 1) {\n            BtLock *pIter;\n            for (pIter = pBt->pLock; pIter; pIter = pIter->pNext) {\n                if (pIter->pBtree != p) {\n                    pBlock = pIter->pBtree->db;\n                    break;\n                }\n            }\n        }\n        if (pBlock) {\n            ;\n            rc = (6 | (1 << 8));\n            goto trans_begun;\n        }\n    }\n    rc = querySharedCacheTableLock(p, 1, 1);\n    if (0 != rc)\n        goto trans_begun;\n    pBt->btsFlags &= ~16;\n    if (pBt->nPage == 0)\n        pBt->btsFlags |= 16;\n    do {\n        ;\n        while (pBt->pPage1 == 0 && 0 == (rc = lockBtree(pBt)))\n            ;\n        if (rc == 0 && wrflag) {\n            if ((pBt->btsFlags & 1) != 0) {\n                rc = 8;\n            } else {\n                rc = sqlite3PagerBegin(pPager, wrflag > 1, sqlite3TempInMemory(p->db));\n                if (rc == 0) {\n                    rc = newDatabase(pBt);\n                } else if (rc == (5 | (2 << 8)) && pBt->inTransaction == 0) {\n                    rc = 5;\n                }\n            }\n        }\n        if (rc != 0) {\n            (void)0;\n            unlockBtreeIfUnused(pBt);\n        }\n    } while ((rc & 255) == 5 && pBt->inTransaction == 0 && btreeInvokeBusyHandler(pBt));\n    ;\n    if (rc == 0) {\n        if (p->inTrans == 0) {\n            pBt->nTransaction++;\n            if (p->sharable) {\n                assert(p->lock.pBtree == p && p->lock.iTable == 1);\n                p->lock.eLock = 1;\n                p->lock.pNext = pBt->pLock;\n                pBt->pLock = &p->lock;\n            }\n        }\n        p->inTrans = (wrflag ? 2 : 1);\n        if (p->inTrans > pBt->inTransaction) {\n            pBt->inTransaction = p->inTrans;\n        }\n        if (wrflag) {\n            MemPage *pPage1 = pBt->pPage1;\n            assert(!pBt->pWriter);\n            pBt->pWriter = p;\n            pBt->btsFlags &= ~64;\n            if (wrflag > 1)\n                pBt->btsFlags |= 64;\n            if (pBt->nPage != sqlite3Get4byte(&pPage1->aData[28])) {\n                rc = sqlite3PagerWrite(pPage1->pDbPage);\n                if (rc == 0) {\n                    sqlite3Put4byte(&pPage1->aData[28], pBt->nPage);\n                }\n            }\n        }\n    }\n  trans_begun:\n    if (rc == 0) {\n        if (pSchemaVersion) {\n            *pSchemaVersion = sqlite3Get4byte(&pBt->pPage1->aData[40]);\n        }\n        if (wrflag) {\n            rc = sqlite3PagerOpenSavepoint(pPager, p->db->nSavepoint);\n        }\n    }\n    assert(p->pBt->inTransaction != 0 || p->pBt->nTransaction == 0);\n    assert(p->pBt->inTransaction >= p->inTrans);\n    ;\n    sqlite3BtreeLeave(p);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#174354:1#createFunctionApi",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int rc = 1;\n    FuncDestructor *pArg = 0;\n    sqlite3_mutex_enter(db->mutex);\n    if (xDestroy) {\n        pArg = (FuncDestructor *)sqlite3Malloc(sizeof(FuncDestructor));\n        if (!pArg) {\n            sqlite3OomFault(db);\n            xDestroy(p);\n            goto out;\n        }\n        pArg->nRef = 0;\n        pArg->xDestroy = xDestroy;\n        pArg->pUserData = p;\n    }\n    rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, xValue, xInverse, pArg);\n    if (pArg && pArg->nRef == 0) {\n        assert(rc != 0 || (xStep == 0 && xFinal == 0));\n        xDestroy(p);\n        sqlite3_free(pArg);\n    }\n  out:\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3PagerCommitPhaseOne",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    assert(pPager->eState == 2 || pPager->eState == 3 || pPager->eState == 4 || pPager->eState == 6);\n    assert(assert_pager_state(pPager));\n    if ((pPager->errCode))\n        return pPager->errCode;\n    if (sqlite3FaultSim(400))\n        return 10;\n    ;\n    if (pPager->eState < 3)\n        return 0;\n    assert(pPager->memDb == 0 || pPager->tempFile);\n    assert(((pPager->fd)->pMethods != 0) || pPager->tempFile);\n    if (0 == pagerFlushOnCommit(pPager, 1)) {\n        sqlite3BackupRestart(pPager->pBackup);\n    } else {\n        PgHdr *pList;\n        if (((pPager)->pWal != 0)) {\n            PgHdr *pPageOne = 0;\n            pList = sqlite3PcacheDirtyList(pPager->pPCache);\n            if (pList == 0) {\n                rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);\n                pList = pPageOne;\n                pList->pDirty = 0;\n            }\n            assert(rc == 0);\n            if ((pList)) {\n                rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);\n            }\n            sqlite3PagerUnref(pPageOne);\n            if (rc == 0) {\n                sqlite3PcacheCleanAll(pPager->pPCache);\n            }\n        } else {\n            rc = pager_incr_changecounter(pPager, 0);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            rc = writeSuperJournal(pPager, zSuper);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            rc = syncJournal(pPager, 0);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            pList = sqlite3PcacheDirtyList(pPager->pPCache);\n            if (0 == 0) {\n                rc = pager_write_pagelist(pPager, pList);\n            }\n            if (rc != 0) {\n                assert(rc != (10 | (11 << 8)));\n                goto commit_phase_one_exit;\n            }\n            sqlite3PcacheCleanAll(pPager->pPCache);\n            if (pPager->dbSize > pPager->dbFileSize) {\n                Pgno nNew = pPager->dbSize - (pPager->dbSize == ((pPager)->lckPgno));\n                assert(pPager->eState == 4);\n                rc = pager_truncate(pPager, nNew);\n                if (rc != 0)\n                    goto commit_phase_one_exit;\n            }\n            if (!noSync) {\n                rc = sqlite3PagerSync(pPager, zSuper);\n            }\n        }\n    }\n  commit_phase_one_exit:\n    if (rc == 0 && !((pPager)->pWal != 0)) {\n        pPager->eState = 5;\n    }\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3Select",
            "gotos": 12,
            "labels": 1,
            "body": "{\n    int i, j;\n    WhereInfo *pWInfo;\n    Vdbe *v;\n    int isAgg;\n    ExprList *pEList = 0;\n    SrcList *pTabList;\n    Expr *pWhere;\n    ExprList *pGroupBy;\n    Expr *pHaving;\n    AggInfo *pAggInfo = 0;\n    int rc = 1;\n    DistinctCtx sDistinct;\n    SortCtx sSort;\n    int iEnd;\n    sqlite3 *db;\n    ExprList *pMinMaxOrderBy = 0;\n    u8 minMaxFlag;\n    db = pParse->db;\n    assert(pParse == db->pParse);\n    v = sqlite3GetVdbe(pParse);\n    if (p == 0 || pParse->nErr) {\n        return 1;\n    }\n    assert(db->mallocFailed == 0);\n    if (sqlite3AuthCheck(pParse, 21, 0, 0, 0))\n        return 1;\n    assert(p->pOrderBy == 0 || pDest->eDest != 5);\n    assert(p->pOrderBy == 0 || pDest->eDest != 8);\n    assert(p->pOrderBy == 0 || pDest->eDest != 6);\n    assert(p->pOrderBy == 0 || pDest->eDest != 7);\n    if (((pDest->eDest) <= 6)) {\n        assert(pDest->eDest == 3 || pDest->eDest == 1 || pDest->eDest == 2 || pDest->eDest == 4 || pDest->eDest == 6 || pDest->eDest == 5);\n        if (p->pOrderBy) {\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3ExprListDelete, p->pOrderBy);\n            ;\n            p->pOrderBy = 0;\n        }\n        p->selFlags &= ~1;\n        p->selFlags |= 4194304;\n    }\n    sqlite3SelectPrep(pParse, p, 0);\n    if (pParse->nErr) {\n        goto select_end;\n    }\n    assert(db->mallocFailed == 0);\n    assert(p->pEList != 0);\n    if (p->selFlags & 8388608) {\n        SrcItem *p0 = &p->pSrc->a[0];\n        if (sameSrcAlias(p0, p->pSrc)) {\n            sqlite3ErrorMsg(pParse, \"target object/alias may not appear in FROM clause: %s\", p0->zAlias ? p0->zAlias : p0->pTab->zName);\n            goto select_end;\n        }\n        p->selFlags &= ~8388608;\n    }\n    if (pDest->eDest == 9) {\n        sqlite3GenerateColumnNames(pParse, p);\n    }\n    if (sqlite3WindowRewrite(pParse, p)) {\n        assert(pParse->nErr);\n        goto select_end;\n    }\n    pTabList = p->pSrc;\n    isAgg = (p->selFlags & 8) != 0;\n    memset(&sSort, 0, sizeof (sSort));\n    sSort.pOrderBy = p->pOrderBy;\n    for (i = 0; !p->pPrior && i < pTabList->nSrc; i++) {\n        SrcItem *pItem = &pTabList->a[i];\n        Select *pSub = pItem->pSelect;\n        Table *pTab = pItem->pTab;\n        assert(pTab != 0);\n        if ((pItem->fg.jointype & (8 | 16)) == 8 && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor) && (((db)->dbOptFlags & (8192)) == 0)) {\n            ;\n            pItem->fg.jointype &= ~(8 | 32);\n            assert(pItem->iCursor >= 0);\n            unsetJoinExpr(p->pWhere, pItem->iCursor, pTabList->a[0].fg.jointype & 64);\n        }\n        if (pSub == 0)\n            continue;\n        if (pTab->nCol != pSub->pEList->nExpr) {\n            sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\", pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n            goto select_end;\n        }\n        if ((pSub->selFlags & 8) != 0)\n            continue;\n        assert(pSub->pGroupBy == 0);\n        if (pSub->pOrderBy != 0 && (p->pOrderBy != 0 || pTabList->nSrc > 1) && pSub->pLimit == 0 && (pSub->selFlags & 134217728) == 0 && (p->selFlags & 134217728) == 0 && (((db)->dbOptFlags & (262144)) == 0)) {\n            ;\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3ExprListDelete, pSub->pOrderBy);\n            pSub->pOrderBy = 0;\n        }\n        if (pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (32 | 2)) != 0)) {\n            continue;\n        }\n        if (flattenSubquery(pParse, p, i, isAgg)) {\n            if (pParse->nErr)\n                goto select_end;\n            i = -1;\n        }\n        pTabList = p->pSrc;\n        if (db->mallocFailed)\n            goto select_end;\n        if (!((pDest->eDest) <= 8)) {\n            sSort.pOrderBy = p->pOrderBy;\n        }\n    }\n    if (p->pPrior) {\n        rc = multiSelect(pParse, p, pDest);\n        if (p->pNext == 0)\n            sqlite3VdbeExplainPop(pParse);\n        return rc;\n    }\n    if (p->pWhere != 0 && p->pWhere->op == 44 && (((db)->dbOptFlags & (32768)) == 0) && propagateConstants(pParse, p)) {\n    } else {\n        ;\n    }\n    for (i = 0; i < pTabList->nSrc; i++) {\n        SrcItem *pItem = &pTabList->a[i];\n        SrcItem *pPrior;\n        SelectDest dest;\n        Select *pSub;\n        const char *zSavedAuthContext;\n        if (pItem->colUsed == 0 && pItem->zName != 0) {\n            sqlite3AuthCheck(pParse, 20, pItem->zName, \"\", pItem->zDatabase);\n        }\n        pSub = pItem->pSelect;\n        if (pSub == 0)\n            continue;\n        assert(pItem->addrFillSub == 0);\n        pParse->nHeight += sqlite3SelectExprHeight(p);\n        if ((((db)->dbOptFlags & (4096)) == 0) && (pItem->fg.isCte == 0 || (pItem->u2.pCteUse->eM10d != 0 && pItem->u2.pCteUse->nUse < 2)) && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem)) {\n            assert(pItem->pSelect && (pItem->pSelect->selFlags & 16777216) != 0);\n        } else {\n            ;\n        }\n        zSavedAuthContext = pParse->zAuthContext;\n        pParse->zAuthContext = pItem->zName;\n        if (i == 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (32 | 2)) != 0) && (pItem->fg.isCte == 0 || pItem->u2.pCteUse->eM10d != 0) && (pTabList->a[0].fg.jointype & 64) == 0) {\n            int addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n            pItem->regReturn = ++pParse->nMem;\n            sqlite3VdbeAddOp3(v, 11, pItem->regReturn, 0, addrTop);\n            ;\n            pItem->addrFillSub = addrTop;\n            sqlite3SelectDestInit(&dest, 13, pItem->regReturn);\n            sqlite3VdbeExplain(pParse, 1, \"CO-ROUTINE %!S\", pItem);\n            sqlite3Select(pParse, pSub, &dest);\n            pItem->pTab->nRowLogEst = pSub->nSelectRow;\n            pItem->fg.viaCoroutine = 1;\n            pItem->regResult = dest.iSdst;\n            sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n            sqlite3VdbeJumpHere(v, addrTop - 1);\n            sqlite3ClearTempRegCache(pParse);\n        } else if (pItem->fg.isCte && pItem->u2.pCteUse->addrM9e > 0) {\n            CteUse *pCteUse = pItem->u2.pCteUse;\n            sqlite3VdbeAddOp2(v, 10, pCteUse->regRtn, pCteUse->addrM9e);\n            if (pItem->iCursor != pCteUse->iCur) {\n                sqlite3VdbeAddOp2(v, 115, pItem->iCursor, pCteUse->iCur);\n                ;\n            }\n            pSub->nSelectRow = pCteUse->nRowEst;\n        } else if ((pPrior = isSelfJoinView(pTabList, pItem)) != 0) {\n            if (pPrior->addrFillSub) {\n                sqlite3VdbeAddOp2(v, 10, pPrior->regReturn, pPrior->addrFillSub);\n            }\n            sqlite3VdbeAddOp2(v, 115, pItem->iCursor, pPrior->iCursor);\n            pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n        } else {\n            int topAddr;\n            int onceAddr = 0;\n            pItem->regReturn = ++pParse->nMem;\n            topAddr = sqlite3VdbeAddOp0(v, 9);\n            pItem->addrFillSub = topAddr + 1;\n            pItem->fg.isMaterialized = 1;\n            if (pItem->fg.isCorrelated == 0) {\n                onceAddr = sqlite3VdbeAddOp0(v, 15);\n                ;\n                ;\n            } else {\n                ;\n            }\n            sqlite3SelectDestInit(&dest, 12, pItem->iCursor);\n            sqlite3VdbeExplain(pParse, 1, \"MATERIALIZE %!S\", pItem);\n            dest.zAffSdst = sqlite3TableAffinityStr(db, pItem->pTab);\n            sqlite3Select(pParse, pSub, &dest);\n            sqlite3DbFree(db, dest.zAffSdst);\n            dest.zAffSdst = 0;\n            pItem->pTab->nRowLogEst = pSub->nSelectRow;\n            if (onceAddr)\n                sqlite3VdbeJumpHere(v, onceAddr);\n            sqlite3VdbeAddOp2(v, 67, pItem->regReturn, topAddr + 1);\n            ;\n            sqlite3VdbeJumpHere(v, topAddr);\n            sqlite3ClearTempRegCache(pParse);\n            if (pItem->fg.isCte && pItem->fg.isCorrelated == 0) {\n                CteUse *pCteUse = pItem->u2.pCteUse;\n                pCteUse->addrM9e = pItem->addrFillSub;\n                pCteUse->regRtn = pItem->regReturn;\n                pCteUse->iCur = pItem->iCursor;\n                pCteUse->nRowEst = pSub->nSelectRow;\n            }\n        }\n        if (db->mallocFailed)\n            goto select_end;\n        pParse->nHeight -= sqlite3SelectExprHeight(p);\n        pParse->zAuthContext = zSavedAuthContext;\n    }\n    pEList = p->pEList;\n    pWhere = p->pWhere;\n    pGroupBy = p->pGroupBy;\n    pHaving = p->pHaving;\n    sDistinct.isTnct = (p->selFlags & 1) != 0;\n    if ((p->selFlags & (1 | 8)) == 1 && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1) == 0 && p->pWin == 0) {\n        p->selFlags &= ~1;\n        pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n        p->selFlags |= 8;\n        assert(sDistinct.isTnct);\n        sDistinct.isTnct = 2;\n    }\n    if (sSort.pOrderBy) {\n        KeyInfo *pKeyInfo;\n        pKeyInfo = sqlite3KeyInfoFromExprList(pParse, sSort.pOrderBy, 0, pEList->nExpr);\n        sSort.iECursor = pParse->nTab++;\n        sSort.addrSortIndex = sqlite3VdbeAddOp4(v, 118, sSort.iECursor, sSort.pOrderBy->nExpr + 1 + pEList->nExpr, 0, (char *)pKeyInfo, (-8));\n    } else {\n        sSort.addrSortIndex = -1;\n    }\n    if (pDest->eDest == 12) {\n        sqlite3VdbeAddOp2(v, 118, pDest->iSDParm, pEList->nExpr);\n        if (p->selFlags & 2048) {\n            int ii;\n            for (ii = pEList->nExpr - 1; ii > 0 && pEList->a[ii].fg.bUsed == 0; ii--) {\n                sqlite3ExprDelete(db, pEList->a[ii].pExpr);\n                sqlite3DbFree(db, pEList->a[ii].zEName);\n                pEList->nExpr--;\n            }\n            for (ii = 0; ii < pEList->nExpr; ii++) {\n                if (pEList->a[ii].fg.bUsed == 0)\n                    pEList->a[ii].pExpr->op = 121;\n            }\n        }\n    }\n    iEnd = sqlite3VdbeMakeLabel(pParse);\n    if ((p->selFlags & 16384) == 0) {\n        p->nSelectRow = 320;\n    }\n    if (p->pLimit)\n        computeLimitRegisters(pParse, p, iEnd);\n    if (p->iLimit == 0 && sSort.addrSortIndex >= 0) {\n        sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, 119);\n        sSort.sortFlags |= 1;\n    }\n    if (p->selFlags & 1) {\n        sDistinct.tabTnct = pParse->nTab++;\n        sDistinct.addrTnct = sqlite3VdbeAddOp4(v, 118, sDistinct.tabTnct, 0, 0, (char *)sqlite3KeyInfoFromExprList(pParse, p->pEList, 0, 0), (-8));\n        sqlite3VdbeChangeP5(v, 8);\n        sDistinct.eTnctType = 3;\n    } else {\n        sDistinct.eTnctType = 0;\n    }\n    if (!isAgg && pGroupBy == 0) {\n        u16 wctrlFlags = (sDistinct.isTnct ? 256 : 0) | (p->selFlags & 16384);\n        Window *pWin = p->pWin;\n        if (pWin) {\n            sqlite3WindowCodeInit(pParse, p);\n        }\n        assert(16384 == 16384);\n        ;\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy, p->pEList, p, wctrlFlags, p->nSelectRow);\n        if (pWInfo == 0)\n            goto select_end;\n        if (sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow) {\n            p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n        }\n        if (sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo)) {\n            sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n        }\n        if (sSort.pOrderBy) {\n            sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n            sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n            if (sSort.nOBSat == sSort.pOrderBy->nExpr) {\n                sSort.pOrderBy = 0;\n            }\n        }\n        ;\n        if (sSort.addrSortIndex >= 0 && sSort.pOrderBy == 0) {\n            sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n        }\n        assert(p->pEList == pEList);\n        if (pWin) {\n            int addrGosub = sqlite3VdbeMakeLabel(pParse);\n            int iCont = sqlite3VdbeMakeLabel(pParse);\n            int iBreak = sqlite3VdbeMakeLabel(pParse);\n            int regGosub = ++pParse->nMem;\n            sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n            sqlite3VdbeAddOp2(v, 9, 0, iBreak);\n            sqlite3VdbeResolveLabel(v, addrGosub);\n            ;\n            sSort.labelOBLopt = 0;\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n            sqlite3VdbeResolveLabel(v, iCont);\n            sqlite3VdbeAddOp1(v, 67, regGosub);\n            ;\n            sqlite3VdbeResolveLabel(v, iBreak);\n        } else {\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, sqlite3WhereContinueLabel(pWInfo), sqlite3WhereBreakLabel(pWInfo));\n            ;\n            sqlite3WhereEnd(pWInfo);\n        }\n    } else {\n        NameContext sNC;\n        int iAMem;\n        int iBMem;\n        int iUseFlag;\n        int iAbortFlag;\n        int groupBySort;\n        int addrEnd;\n        int sortPTab = 0;\n        int sortOut = 0;\n        int orderByGrp = 0;\n        if (pGroupBy) {\n            int k;\n            struct ExprList_item *pItem;\n            for (k = p->pEList->nExpr , pItem = p->pEList->a; k > 0; k-- , pItem++) {\n                pItem->u.x.iAlias = 0;\n            }\n            for (k = pGroupBy->nExpr , pItem = pGroupBy->a; k > 0; k-- , pItem++) {\n                pItem->u.x.iAlias = 0;\n            }\n            assert(66 == sqlite3LogEst(100));\n            if (p->nSelectRow > 66)\n                p->nSelectRow = 66;\n            if (sSort.pOrderBy && pGroupBy->nExpr == sSort.pOrderBy->nExpr) {\n                int ii;\n                for (ii = 0; ii < pGroupBy->nExpr; ii++) {\n                    u8 sortFlags;\n                    sortFlags = sSort.pOrderBy->a[ii].fg.sortFlags & 1;\n                    pGroupBy->a[ii].fg.sortFlags = sortFlags;\n                }\n                if (sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1) == 0) {\n                    orderByGrp = 1;\n                }\n            }\n        } else {\n            assert(0 == sqlite3LogEst(1));\n            p->nSelectRow = 0;\n        }\n        addrEnd = sqlite3VdbeMakeLabel(pParse);\n        pAggInfo = sqlite3DbMallocZero(db, sizeof (*pAggInfo));\n        if (pAggInfo) {\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))agginfoFree, pAggInfo);\n            ;\n        }\n        if (db->mallocFailed) {\n            goto select_end;\n        }\n        pAggInfo->selId = p->selId;\n        memset(&sNC, 0, sizeof (sNC));\n        sNC.pParse = pParse;\n        sNC.pSrcList = pTabList;\n        sNC.uNC.pAggInfo = pAggInfo;\n        pAggInfo->mnReg = pParse->nMem + 1;\n        pAggInfo->nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n        pAggInfo->pGroupBy = pGroupBy;\n        sqlite3ExprAnalyzeAggList(&sNC, pEList);\n        sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n        if (pHaving) {\n            if (pGroupBy) {\n                assert(pWhere == p->pWhere);\n                assert(pHaving == p->pHaving);\n                assert(pGroupBy == p->pGroupBy);\n                havingToWhere(pParse, p);\n                pWhere = p->pWhere;\n            }\n            sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n        }\n        pAggInfo->nAccumulator = pAggInfo->nColumn;\n        if (p->pGroupBy == 0 && p->pHaving == 0 && pAggInfo->nFunc == 1) {\n            minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pFExpr, &pMinMaxOrderBy);\n        } else {\n            minMaxFlag = 0;\n        }\n        for (i = 0; i < pAggInfo->nFunc; i++) {\n            Expr *pExpr = pAggInfo->aFunc[i].pFExpr;\n            assert((((pExpr)->flags & 4096) == 0));\n            sNC.ncFlags |= 131072;\n            sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n            assert(!(((((pExpr))->flags & (16777216)) != 0) && pExpr->y.pWin->eFrmType != 166));\n            if ((((pExpr)->flags & (16777216)) != 0)) {\n                sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n            }\n            sNC.ncFlags &= ~131072;\n        }\n        pAggInfo->mxReg = pParse->nMem;\n        if (db->mallocFailed)\n            goto select_end;\n        if (pGroupBy) {\n            KeyInfo *pKeyInfo;\n            int addr1;\n            int addrOutputRow;\n            int regOutputRow;\n            int addrSetAbort;\n            int addrTopOfLoop;\n            int addrSortingIdx;\n            int addrReset;\n            int regReset;\n            ExprList *pDistinct = 0;\n            u16 distFlag = 0;\n            int eDist = 0;\n            if (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0 && (pAggInfo->aFunc[0].pFExpr != 0) && ((((pAggInfo->aFunc[0].pFExpr)->flags & 4096) == 0)) && pAggInfo->aFunc[0].pFExpr->x.pList != 0) {\n                Expr *pExpr = pAggInfo->aFunc[0].pFExpr->x.pList->a[0].pExpr;\n                pExpr = sqlite3ExprDup(db, pExpr, 0);\n                pDistinct = sqlite3ExprListDup(db, pGroupBy, 0);\n                pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);\n                distFlag = pDistinct ? (256 | 1024) : 0;\n            }\n            pAggInfo->sortingIdx = pParse->nTab++;\n            pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy, 0, pAggInfo->nColumn);\n            addrSortingIdx = sqlite3VdbeAddOp4(v, 119, pAggInfo->sortingIdx, pAggInfo->nSortingColumn, 0, (char *)pKeyInfo, (-8));\n            iUseFlag = ++pParse->nMem;\n            iAbortFlag = ++pParse->nMem;\n            regOutputRow = ++pParse->nMem;\n            addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n            regReset = ++pParse->nMem;\n            addrReset = sqlite3VdbeMakeLabel(pParse);\n            iAMem = pParse->nMem + 1;\n            pParse->nMem += pGroupBy->nExpr;\n            iBMem = pParse->nMem + 1;\n            pParse->nMem += pGroupBy->nExpr;\n            sqlite3VdbeAddOp2(v, 71, 0, iAbortFlag);\n            ;\n            sqlite3VdbeAddOp3(v, 75, 0, iAMem, iAMem + pGroupBy->nExpr - 1);\n            sqlite3VdbeAddOp2(v, 10, regReset, addrReset);\n            ;\n            pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct, p, (sDistinct.isTnct == 2 ? 128 : 64) | (orderByGrp ? 512 : 0) | distFlag, 0);\n            if (pWInfo == 0) {\n                sqlite3ExprListDelete(db, pDistinct);\n                goto select_end;\n            }\n            eDist = sqlite3WhereIsDistinct(pWInfo);\n            ;\n            if (sqlite3WhereIsOrdered(pWInfo) == pGroupBy->nExpr) {\n                groupBySort = 0;\n            } else {\n                int regBase;\n                int regRecord;\n                int nCol;\n                int nGroupBy;\n                explainTempTable(pParse, (sDistinct.isTnct && (p->selFlags & 1) == 0) ? \"DISTINCT\" : \"GROUP BY\");\n                groupBySort = 1;\n                nGroupBy = pGroupBy->nExpr;\n                nCol = nGroupBy;\n                j = nGroupBy;\n                for (i = 0; i < pAggInfo->nColumn; i++) {\n                    if (pAggInfo->aCol[i].iSorterColumn >= j) {\n                        nCol++;\n                        j++;\n                    }\n                }\n                regBase = sqlite3GetTempRange(pParse, nCol);\n                sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n                j = nGroupBy;\n                pAggInfo->directMode = 1;\n                for (i = 0; i < pAggInfo->nColumn; i++) {\n                    struct AggInfo_col *pCol = &pAggInfo->aCol[i];\n                    if (pCol->iSorterColumn >= j) {\n                        sqlite3ExprCode(pParse, pCol->pCExpr, j + regBase);\n                        j++;\n                    }\n                }\n                pAggInfo->directMode = 0;\n                regRecord = sqlite3GetTempReg(pParse);\n                sqlite3VdbeAddOp3(v, 97, regBase, nCol, regRecord);\n                sqlite3VdbeAddOp2(v, 139, pAggInfo->sortingIdx, regRecord);\n                sqlite3ReleaseTempReg(pParse, regRecord);\n                sqlite3ReleaseTempRange(pParse, regBase, nCol);\n                ;\n                sqlite3WhereEnd(pWInfo);\n                pAggInfo->sortingIdxPTab = sortPTab = pParse->nTab++;\n                sortOut = sqlite3GetTempReg(pParse);\n                sqlite3VdbeAddOp3(v, 121, sortPTab, sortOut, nCol);\n                sqlite3VdbeAddOp2(v, 34, pAggInfo->sortingIdx, addrEnd);\n                ;\n                ;\n                pAggInfo->useSortingIdx = 1;\n            }\n            if (orderByGrp && (((db)->dbOptFlags & (4)) == 0) && (groupBySort || sqlite3WhereIsSorted(pWInfo))) {\n                sSort.pOrderBy = 0;\n                sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n            }\n            addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n            if (groupBySort) {\n                sqlite3VdbeAddOp3(v, 133, pAggInfo->sortingIdx, sortOut, sortPTab);\n            }\n            for (j = 0; j < pGroupBy->nExpr; j++) {\n                if (groupBySort) {\n                    sqlite3VdbeAddOp3(v, 94, sortPTab, j, iBMem + j);\n                } else {\n                    pAggInfo->directMode = 1;\n                    sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem + j);\n                }\n            }\n            sqlite3VdbeAddOp4(v, 90, iAMem, iBMem, pGroupBy->nExpr, (char *)sqlite3KeyInfoRef(pKeyInfo), (-8));\n            addr1 = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp3(v, 14, addr1 + 1, 0, addr1 + 1);\n            ;\n            sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n            sqlite3VdbeAddOp2(v, 10, regOutputRow, addrOutputRow);\n            ;\n            sqlite3VdbeAddOp2(v, 59, iAbortFlag, addrEnd);\n            ;\n            ;\n            sqlite3VdbeAddOp2(v, 10, regReset, addrReset);\n            ;\n            sqlite3VdbeJumpHere(v, addr1);\n            updateAccumulator(pParse, iUseFlag, pAggInfo, eDist);\n            sqlite3VdbeAddOp2(v, 71, 1, iUseFlag);\n            ;\n            if (groupBySort) {\n                sqlite3VdbeAddOp2(v, 37, pAggInfo->sortingIdx, addrTopOfLoop);\n                ;\n            } else {\n                ;\n                sqlite3WhereEnd(pWInfo);\n                sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n            }\n            sqlite3ExprListDelete(db, pDistinct);\n            sqlite3VdbeAddOp2(v, 10, regOutputRow, addrOutputRow);\n            ;\n            sqlite3VdbeGoto(v, addrEnd);\n            addrSetAbort = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp2(v, 71, 1, iAbortFlag);\n            ;\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            sqlite3VdbeResolveLabel(v, addrOutputRow);\n            addrOutputRow = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp2(v, 59, iUseFlag, addrOutputRow + 2);\n            ;\n            ;\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            finalizeAggFunctions(pParse, pAggInfo);\n            sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow + 1, 16);\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, addrOutputRow + 1, addrSetAbort);\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            ;\n            sqlite3VdbeResolveLabel(v, addrReset);\n            resetAccumulator(pParse, pAggInfo);\n            sqlite3VdbeAddOp2(v, 71, 0, iUseFlag);\n            ;\n            sqlite3VdbeAddOp1(v, 67, regReset);\n            if (distFlag != 0 && eDist != 0) {\n                struct AggInfo_func *pF = &pAggInfo->aFunc[0];\n                fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);\n            }\n        } else {\n            Table *pTab;\n            if ((pTab = isSimpleCount(p, pAggInfo)) != 0) {\n                const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n                const int iCsr = pParse->nTab++;\n                Index *pIdx;\n                KeyInfo *pKeyInfo = 0;\n                Index *pBest = 0;\n                Pgno iRoot = pTab->tnum;\n                sqlite3CodeVerifySchema(pParse, iDb);\n                sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n                if (!(((pTab)->tabFlags & 128) == 0))\n                    pBest = sqlite3PrimaryKeyIndex(pTab);\n                if (!p->pSrc->a[0].fg.notIndexed) {\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        if (pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && (!pBest || pIdx->szIdxRow < pBest->szIdxRow)) {\n                            pBest = pIdx;\n                        }\n                    }\n                }\n                if (pBest) {\n                    iRoot = pBest->tnum;\n                    pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n                }\n                sqlite3VdbeAddOp4Int(v, 112, iCsr, (int)iRoot, iDb, 1);\n                if (pKeyInfo) {\n                    sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, (-8));\n                }\n                sqlite3VdbeAddOp2(v, 98, iCsr, pAggInfo->aFunc[0].iMem);\n                sqlite3VdbeAddOp1(v, 122, iCsr);\n                explainSimpleCount(pParse, pTab, pBest);\n            } else {\n                int regAcc = 0;\n                ExprList *pDistinct = 0;\n                u16 distFlag = 0;\n                int eDist;\n                if (pAggInfo->nAccumulator) {\n                    for (i = 0; i < pAggInfo->nFunc; i++) {\n                        if ((((pAggInfo->aFunc[i].pFExpr)->flags & (16777216)) != 0)) {\n                            continue;\n                        }\n                        if (pAggInfo->aFunc[i].pFunc->funcFlags & 32) {\n                            break;\n                        }\n                    }\n                    if (i == pAggInfo->nFunc) {\n                        regAcc = ++pParse->nMem;\n                        sqlite3VdbeAddOp2(v, 71, 0, regAcc);\n                    }\n                } else if (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0) {\n                    assert((((pAggInfo->aFunc[0].pFExpr)->flags & 4096) == 0));\n                    pDistinct = pAggInfo->aFunc[0].pFExpr->x.pList;\n                    distFlag = pDistinct ? (256 | 1024) : 0;\n                }\n                assert(p->pGroupBy == 0);\n                resetAccumulator(pParse, pAggInfo);\n                assert(minMaxFlag == 0 || pMinMaxOrderBy != 0);\n                assert(pMinMaxOrderBy == 0 || pMinMaxOrderBy->nExpr == 1);\n                ;\n                pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy, pDistinct, p, minMaxFlag | distFlag, 0);\n                if (pWInfo == 0) {\n                    goto select_end;\n                }\n                ;\n                eDist = sqlite3WhereIsDistinct(pWInfo);\n                updateAccumulator(pParse, regAcc, pAggInfo, eDist);\n                if (eDist != 0) {\n                    struct AggInfo_func *pF = pAggInfo->aFunc;\n                    if (pF) {\n                        fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);\n                    }\n                }\n                if (regAcc)\n                    sqlite3VdbeAddOp2(v, 71, 1, regAcc);\n                if (minMaxFlag) {\n                    sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);\n                }\n                ;\n                sqlite3WhereEnd(pWInfo);\n                finalizeAggFunctions(pParse, pAggInfo);\n            }\n            sSort.pOrderBy = 0;\n            sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 16);\n            selectInnerLoop(pParse, p, -1, 0, 0, pDest, addrEnd, addrEnd);\n        }\n        sqlite3VdbeResolveLabel(v, addrEnd);\n    }\n    if (sDistinct.eTnctType == 3) {\n        explainTempTable(pParse, \"DISTINCT\");\n    }\n    if (sSort.pOrderBy) {\n        explainTempTable(pParse, sSort.nOBSat > 0 ? \"RIGHT PART OF ORDER BY\" : \"ORDER BY\");\n        assert(p->pEList == pEList);\n        generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n    }\n    sqlite3VdbeResolveLabel(v, iEnd);\n    rc = (pParse->nErr > 0);\n  select_end:\n    assert(db->mallocFailed == 0 || db->mallocFailed == 1);\n    assert(db->mallocFailed == 0 || pParse->nErr != 0);\n    sqlite3ExprListDelete(db, pMinMaxOrderBy);\n    sqlite3VdbeExplainPop(pParse);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3PagerSharedLock",
            "gotos": 6,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    assert(sqlite3PcacheRefCount(pPager->pPCache) == 0);\n    assert(assert_pager_state(pPager));\n    assert(pPager->eState == 0 || pPager->eState == 1);\n    assert(pPager->errCode == 0);\n    if (!((pPager)->pWal != 0) && pPager->eState == 0) {\n        int bHotJournal = 1;\n        assert(!pPager->memDb);\n        assert(pPager->tempFile == 0 || pPager->eLock == 4);\n        rc = pager_wait_on_lock(pPager, 1);\n        if (rc != 0) {\n            assert(pPager->eLock == 0 || pPager->eLock == (4 + 1));\n            goto failed;\n        }\n        if (pPager->eLock <= 1) {\n            rc = hasHotJournal(pPager, &bHotJournal);\n        }\n        if (rc != 0) {\n            goto failed;\n        }\n        if (bHotJournal) {\n            if (pPager->readOnly) {\n                rc = (8 | (3 << 8));\n                goto failed;\n            }\n            rc = pagerLockDb(pPager, 4);\n            if (rc != 0) {\n                goto failed;\n            }\n            if (!((pPager->jfd)->pMethods != 0) && pPager->journalMode != 2) {\n                sqlite3_vfs *const pVfs = pPager->pVfs;\n                int bExists;\n                rc = sqlite3OsAccess(pVfs, pPager->zJournal, 0, &bExists);\n                if (rc == 0 && bExists) {\n                    int fout = 0;\n                    int f = 2 | 2048;\n                    assert(!pPager->tempFile);\n                    rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);\n                    assert(rc != 0 || ((pPager->jfd)->pMethods != 0));\n                    if (rc == 0 && fout & 1) {\n                        rc = sqlite3CantopenError(60413);\n                        sqlite3OsClose(pPager->jfd);\n                    }\n                }\n            }\n            if (((pPager->jfd)->pMethods != 0)) {\n                assert(rc == 0);\n                rc = pagerSyncHotJournal(pPager);\n                if (rc == 0) {\n                    rc = pager_playback(pPager, !pPager->tempFile);\n                    pPager->eState = 0;\n                }\n            } else if (!pPager->exclusiveMode) {\n                pagerUnlockDb(pPager, 1);\n            }\n            if (rc != 0) {\n                pager_error(pPager, rc);\n                goto failed;\n            }\n            assert(pPager->eState == 0);\n            assert((pPager->eLock == 1) || (pPager->exclusiveMode && pPager->eLock > 1));\n        }\n        if (!pPager->tempFile && pPager->hasHeldSharedLock) {\n            char dbFileVers[16];\n            ;\n            rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof (dbFileVers), 24);\n            if (rc != 0) {\n                if (rc != (10 | (2 << 8))) {\n                    goto failed;\n                }\n                memset(dbFileVers, 0, sizeof (dbFileVers));\n            }\n            if (memcmp(pPager->dbFileVers, dbFileVers, sizeof (dbFileVers)) != 0) {\n                pager_reset(pPager);\n                if (((pPager)->bUseFetch)) {\n                    sqlite3OsUnfetch(pPager->fd, 0, 0);\n                }\n            }\n        }\n        rc = pagerOpenWalIfPresent(pPager);\n        assert(pPager->pWal == 0 || rc == 0);\n    }\n    if (((pPager)->pWal != 0)) {\n        assert(rc == 0);\n        rc = pagerBeginReadTransaction(pPager);\n    }\n    if (pPager->tempFile == 0 && pPager->eState == 0 && rc == 0) {\n        rc = pagerPagecount(pPager, &pPager->dbSize);\n    }\n  failed:\n    if (rc != 0) {\n        assert(!pPager->memDb);\n        pager_unlock(pPager);\n        assert(pPager->eState == 0);\n    } else {\n        pPager->eState = 1;\n        pPager->hasHeldSharedLock = 1;\n    }\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#51749:12#sqlite3_deserialize",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    MemFile *p;\n    char *zSql;\n    sqlite3_stmt *pStmt = 0;\n    int rc;\n    int iDb;\n    sqlite3_mutex_enter(db->mutex);\n    if (zSchema == 0)\n        zSchema = db->aDb[0].zDbSName;\n    iDb = sqlite3FindDbName(db, zSchema);\n    ;\n    if (iDb < 2 && iDb != 0) {\n        rc = 1;\n        goto end_deserialize;\n    }\n    zSql = sqlite3_mprintf(\"ATTACH x AS %Q\", zSchema);\n    if (zSql == 0) {\n        rc = 7;\n    } else {\n        rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n    }\n    if (rc)\n        goto end_deserialize;\n    db->init.iDb = (u8)iDb;\n    db->init.reopenMemdb = 1;\n    rc = sqlite3_step(pStmt);\n    db->init.reopenMemdb = 0;\n    if (rc != 101) {\n        rc = 1;\n        goto end_deserialize;\n    }\n    p = memdbFromDbSchema(db, zSchema);\n    if (p == 0) {\n        rc = 1;\n    } else {\n        MemStore *pStore = p->pStore;\n        pStore->aData = pData;\n        pData = 0;\n        pStore->sz = szDb;\n        pStore->szAlloc = szBuf;\n        pStore->szMax = szBuf;\n        if (pStore->szMax < sqlite3Config.mxMemdbSize) {\n            pStore->szMax = sqlite3Config.mxMemdbSize;\n        }\n        pStore->mFlags = mFlags;\n        rc = 0;\n    }\n  end_deserialize:\n    sqlite3_finalize(pStmt);\n    if (pData && (mFlags & 1) != 0) {\n        sqlite3_free(pData);\n    }\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#57876:1#pager_playback",
            "gotos": 6,
            "labels": 1,
            "body": "{\n    sqlite3_vfs *pVfs = pPager->pVfs;\n    i64 szJ;\n    u32 nRec;\n    u32 u;\n    Pgno mxPg = 0;\n    int rc;\n    int res = 1;\n    char *zSuper = 0;\n    int needPagerReset;\n    int nPlayback = 0;\n    u32 savedPageSize = pPager->pageSize;\n    assert(((pPager->jfd)->pMethods != 0));\n    rc = sqlite3OsFileSize(pPager->jfd, &szJ);\n    if (rc != 0) {\n        goto end_playback;\n    }\n    zSuper = pPager->pTmpSpace;\n    rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname + 1);\n    if (rc == 0 && zSuper[0]) {\n        rc = sqlite3OsAccess(pVfs, zSuper, 0, &res);\n    }\n    zSuper = 0;\n    if (rc != 0 || !res) {\n        goto end_playback;\n    }\n    pPager->journalOff = 0;\n    needPagerReset = isHot;\n    while (1)\n        {\n            rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);\n            if (rc != 0) {\n                if (rc == 101) {\n                    rc = 0;\n                }\n                goto end_playback;\n            }\n            if (nRec == 4294967295U) {\n                assert(pPager->journalOff == (pPager->sectorSize));\n                nRec = (int)((szJ - (pPager->sectorSize)) / ((pPager->pageSize) + 8));\n            }\n            if (nRec == 0 && !isHot && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) {\n                nRec = (int)((szJ - pPager->journalOff) / ((pPager->pageSize) + 8));\n            }\n            if (pPager->journalOff == (pPager->sectorSize)) {\n                rc = pager_truncate(pPager, mxPg);\n                if (rc != 0) {\n                    goto end_playback;\n                }\n                pPager->dbSize = mxPg;\n                if (pPager->mxPgno < mxPg) {\n                    pPager->mxPgno = mxPg;\n                }\n            }\n            for (u = 0; u < nRec; u++) {\n                if (needPagerReset) {\n                    pager_reset(pPager);\n                    needPagerReset = 0;\n                }\n                rc = pager_playback_one_page(pPager, &pPager->journalOff, 0, 1, 0);\n                if (rc == 0) {\n                    nPlayback++;\n                } else {\n                    if (rc == 101) {\n                        pPager->journalOff = szJ;\n                        break;\n                    } else if (rc == (10 | (2 << 8))) {\n                        rc = 0;\n                        goto end_playback;\n                    } else {\n                        goto end_playback;\n                    }\n                }\n            }\n        }\n    assert(0);\n  end_playback:\n    if (rc == 0) {\n        rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);\n    }\n    pPager->changeCountDone = pPager->tempFile;\n    if (rc == 0) {\n        zSuper = &pPager->pTmpSpace[4];\n        rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname + 1);\n        ;\n    }\n    if (rc == 0 && (pPager->eState >= 4 || pPager->eState == 0)) {\n        rc = sqlite3PagerSync(pPager, 0);\n    }\n    if (rc == 0) {\n        rc = pager_end_transaction(pPager, zSuper[0] != '\\x00', 0);\n        ;\n    }\n    if (rc == 0 && zSuper[0] && res) {\n        assert(zSuper == &pPager->pTmpSpace[4]);\n        memset(&zSuper[-4], 0, 4);\n        rc = pager_delsuper(pPager, zSuper);\n        ;\n    }\n    if (isHot && nPlayback) {\n        sqlite3_log((27 | (2 << 8)), \"recovered %d pages from %s\", nPlayback, pPager->zJournal);\n    }\n    setSectorSize(pPager);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#65382:1#walBeginShmUnreliable",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    i64 szWal;\n    i64 iOffset;\n    u8 aBuf[32];\n    u8 *aFrame = 0;\n    int szFrame;\n    u8 *aData;\n    volatile void *pDummy;\n    int rc;\n    u32 aSaveCksum[2];\n    assert(pWal->bShmUnreliable);\n    assert(pWal->readOnly & 2);\n    assert(pWal->nWiData > 0 && pWal->apWiData[0]);\n    rc = walLockShared(pWal, (3 + (0)));\n    if (rc != 0) {\n        if (rc == 5)\n            rc = (-1);\n        goto begin_unreliable_shm_out;\n    }\n    pWal->readLock = 0;\n    rc = sqlite3OsShmMap(pWal->pDbFd, 0, (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)), 0, &pDummy);\n    assert(rc != 0);\n    if (rc != (8 | (5 << 8))) {\n        rc = (rc == 8 ? (-1) : rc);\n        goto begin_unreliable_shm_out;\n    }\n    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));\n    rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);\n    if (rc != 0) {\n        goto begin_unreliable_shm_out;\n    }\n    if (szWal < 32) {\n        *pChanged = 1;\n        rc = (pWal->hdr.mxFrame == 0 ? 0 : (-1));\n        goto begin_unreliable_shm_out;\n    }\n    rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);\n    if (rc != 0) {\n        goto begin_unreliable_shm_out;\n    }\n    if (memcmp(&pWal->hdr.aSalt, &aBuf[16], 8)) {\n        rc = (-1);\n        goto begin_unreliable_shm_out;\n    }\n    assert((pWal->szPage & (pWal->szPage - 1)) == 0);\n    assert(pWal->szPage >= 512 && pWal->szPage <= 65536);\n    szFrame = pWal->szPage + 24;\n    aFrame = (u8 *)sqlite3_malloc64(szFrame);\n    if (aFrame == 0) {\n        rc = 7;\n        goto begin_unreliable_shm_out;\n    }\n    aData = &aFrame[24];\n    aSaveCksum[0] = pWal->hdr.aFrameCksum[0];\n    aSaveCksum[1] = pWal->hdr.aFrameCksum[1];\n    for (iOffset = (32 + ((pWal->hdr.mxFrame + 1) - 1) * (i64)((pWal->szPage) + 24)); iOffset + szFrame <= szWal; iOffset += szFrame) {\n        u32 pgno;\n        u32 nTruncate;\n        rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n        if (rc != 0)\n            break;\n        if (!walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame))\n            break;\n        if (nTruncate) {\n            rc = (-1);\n            break;\n        }\n    }\n    pWal->hdr.aFrameCksum[0] = aSaveCksum[0];\n    pWal->hdr.aFrameCksum[1] = aSaveCksum[1];\n  begin_unreliable_shm_out:\n    sqlite3_free(aFrame);\n    if (rc != 0) {\n        int i;\n        for (i = 0; i < pWal->nWiData; i++) {\n            sqlite3_free((void *)pWal->apWiData[i]);\n            pWal->apWiData[i] = 0;\n        }\n        pWal->bShmUnreliable = 0;\n        sqlite3WalEndReadTransaction(pWal);\n        *pChanged = 1;\n    }\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#75567:1#editPage",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    u8 *const aData = pPg->aData;\n    const int hdr = pPg->hdrOffset;\n    u8 *pBegin = &pPg->aCellIdx[nNew * 2];\n    int nCell = pPg->nCell;\n    u8 *pData;\n    u8 *pCellptr;\n    int i;\n    int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;\n    int iNewEnd = iNew + nNew;\n    assert(nCell >= 0);\n    if (iOld < iNew) {\n        int nShift = pageFreeArray(pPg, iOld, iNew - iOld, pCArray);\n        if ((nShift > nCell))\n            return sqlite3CorruptError(75593);\n        memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift * 2], nCell * 2);\n        nCell -= nShift;\n    }\n    if (iNewEnd < iOldEnd) {\n        int nTail = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);\n        assert(nCell >= nTail);\n        nCell -= nTail;\n    }\n    pData = &aData[(((((int)((&aData[hdr + 5])[0] << 8 | (&aData[hdr + 5])[1])) - 1) & 65535) + 1)];\n    if (pData < pBegin)\n        goto editpage_fail;\n    if (pData > pPg->aDataEnd)\n        goto editpage_fail;\n    if (iNew < iOld) {\n        int nAdd = ((nNew) < (iOld - iNew) ? (nNew) : (iOld - iNew));\n        assert((iOld - iNew) < nNew || nCell == 0 || (sqlite3Config.neverCorrupt == 0));\n        assert(nAdd >= 0);\n        pCellptr = pPg->aCellIdx;\n        memmove(&pCellptr[nAdd * 2], pCellptr, nCell * 2);\n        if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iNew, nAdd, pCArray))\n            goto editpage_fail;\n        nCell += nAdd;\n    }\n    for (i = 0; i < pPg->nOverflow; i++) {\n        int iCell = (iOld + pPg->aiOvfl[i]) - iNew;\n        if (iCell >= 0 && iCell < nNew) {\n            pCellptr = &pPg->aCellIdx[iCell * 2];\n            if (nCell > iCell) {\n                memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);\n            }\n            nCell++;\n            cachedCellSize(pCArray, iCell + iNew);\n            if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iCell + iNew, 1, pCArray))\n                goto editpage_fail;\n        }\n    }\n    assert(nCell >= 0);\n    pCellptr = &pPg->aCellIdx[nCell * 2];\n    if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iNew + nCell, nNew - nCell, pCArray))\n        goto editpage_fail;\n    pPg->nCell = nNew;\n    pPg->nOverflow = 0;\n    ((&aData[hdr + 3])[0] = (u8)((pPg->nCell) >> 8) , (&aData[hdr + 3])[1] = (u8)(pPg->nCell));\n    ((&aData[hdr + 5])[0] = (u8)((pData - aData) >> 8) , (&aData[hdr + 5])[1] = (u8)(pData - aData));\n    return 0;\n  editpage_fail:\n    populateCellCache(pCArray, iNew, nNew);\n    return rebuildPage(pCArray, iNew, nNew, pPg);\n}\n"
        },
        {
            "id": "#23:25#sqlite3BtreeInsert",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    int rc;\n    int loc = seekResult;\n    int szNew = 0;\n    int idx;\n    MemPage *pPage;\n    Btree *p = pCur->pBtree;\n    BtShared *pBt = p->pBt;\n    unsigned char *oldCell;\n    unsigned char *newCell = 0;\n    assert((flags & (2 | 8 | 128)) == flags);\n    assert((flags & 128) == 0 || seekResult || pCur->pKeyInfo == 0);\n    if (pCur->curFlags & 32) {\n        rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);\n        if (rc)\n            return rc;\n        if (loc && pCur->iPage < 0) {\n            return sqlite3CorruptError(77101);\n        }\n    }\n    if (pCur->eState >= 3) {\n        ;\n        ;\n        rc = moveToRoot(pCur);\n        if (rc && rc != 16)\n            return rc;\n    }\n    assert(cursorOwnsBtShared(pCur));\n    assert((pCur->curFlags & 1) != 0 && pBt->inTransaction == 2 && (pBt->btsFlags & 1) == 0);\n    assert(hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo != 0, 2));\n    assert((flags & 128) || (pX->pKey == 0) == (pCur->pKeyInfo == 0));\n    if (pCur->pKeyInfo == 0) {\n        assert(pX->pKey == 0);\n        if (p->hasIncrblobCur) {\n            invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);\n        }\n        if ((pCur->curFlags & 2) != 0 && pX->nKey == pCur->info.nKey) {\n            assert(pX->nData >= 0 && pX->nZero >= 0);\n            if (pCur->info.nSize != 0 && pCur->info.nPayload == (u32)pX->nData + pX->nZero) {\n                return btreeOverwriteCell(pCur, pX);\n            }\n            assert(loc == 0);\n        } else if (loc == 0) {\n            rc = sqlite3BtreeTableMoveto(pCur, pX->nKey, (flags & 8) != 0, &loc);\n            if (rc)\n                return rc;\n        }\n    } else {\n        assert((flags & 2) == 0 || loc == 0);\n        if (loc == 0 && (flags & 2) == 0) {\n            if (pX->nMem) {\n                UnpackedRecord r;\n                r.pKeyInfo = pCur->pKeyInfo;\n                r.aMem = pX->aMem;\n                r.nField = pX->nMem;\n                r.default_rc = 0;\n                r.eqSeen = 0;\n                rc = sqlite3BtreeIndexMoveto(pCur, &r, &loc);\n            } else {\n                rc = btreeMoveto(pCur, pX->pKey, pX->nKey, (flags & 8) != 0, &loc);\n            }\n            if (rc)\n                return rc;\n        }\n        if (loc == 0) {\n            getCellInfo(pCur);\n            if (pCur->info.nKey == pX->nKey) {\n                BtreePayload x2;\n                x2.pData = pX->pKey;\n                x2.nData = pX->nKey;\n                x2.nZero = 0;\n                return btreeOverwriteCell(pCur, &x2);\n            }\n        }\n    }\n    assert(pCur->eState == 0 || (pCur->eState == 1 && loc));\n    pPage = pCur->pPage;\n    assert(pPage->intKey || pX->nKey >= 0 || (flags & 128));\n    assert(pPage->leaf || !pPage->intKey);\n    if (pPage->nFree < 0) {\n        if ((pCur->eState > 1)) {\n            rc = sqlite3CorruptError(77224);\n        } else {\n            rc = btreeComputeFreeSpace(pPage);\n        }\n        if (rc)\n            return rc;\n    }\n    ;\n    assert(pPage->isInit || (sqlite3Config.neverCorrupt == 0));\n    newCell = pBt->pTmpSpace;\n    assert(newCell != 0);\n    if (flags & 128) {\n        rc = 0;\n        szNew = pBt->nPreformatSize;\n        if (szNew < 4)\n            szNew = 4;\n        if ((pBt->autoVacuum) && szNew > pPage->maxLocal) {\n            CellInfo info;\n            pPage->xParseCell(pPage, newCell, &info);\n            if (info.nPayload != info.nLocal) {\n                Pgno ovfl = sqlite3Get4byte(&newCell[szNew - 4]);\n                ptrmapPut(pBt, ovfl, 3, pPage->pgno, &rc);\n            }\n        }\n    } else {\n        rc = fillInCell(pPage, newCell, pX, &szNew);\n    }\n    if (rc)\n        goto end_insert;\n    assert(szNew == pPage->xCellSize(pPage, newCell));\n    assert(szNew <= ((int)(pBt->pageSize - 8)));\n    idx = pCur->ix;\n    if (loc == 0) {\n        CellInfo info;\n        assert(idx >= 0);\n        if (idx >= pPage->nCell) {\n            return sqlite3CorruptError(77260);\n        }\n        rc = sqlite3PagerWrite(pPage->pDbPage);\n        if (rc) {\n            goto end_insert;\n        }\n        oldCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n        if (!pPage->leaf) {\n            memcpy(newCell, oldCell, 4);\n        }\n        pPage->xParseCell(pPage, oldCell, &info);\n        if (info.nLocal != info.nPayload) {\n            rc = clearCellOverflow(pPage, oldCell, &info);\n        } else {\n            rc = 0;\n        }\n        ;\n        ;\n        (pCur->curFlags &= ~4);\n        if (info.nSize == szNew && info.nLocal == info.nPayload && (!(pBt->autoVacuum) || szNew < pPage->minLocal)) {\n            assert(rc == 0);\n            if (oldCell < pPage->aData + pPage->hdrOffset + 10) {\n                return sqlite3CorruptError(77287);\n            }\n            if (oldCell + szNew > pPage->aDataEnd) {\n                return sqlite3CorruptError(77290);\n            }\n            memcpy(oldCell, newCell, szNew);\n            return 0;\n        }\n        dropCell(pPage, idx, info.nSize, &rc);\n        if (rc)\n            goto end_insert;\n    } else if (loc < 0 && pPage->nCell > 0) {\n        assert(pPage->leaf);\n        idx = ++pCur->ix;\n        pCur->curFlags &= ~2;\n    } else {\n        assert(pPage->leaf);\n    }\n    insertCell(pPage, idx, newCell, szNew, 0, 0, &rc);\n    assert(pPage->nOverflow == 0 || rc == 0);\n    assert(rc != 0 || pPage->nCell > 0 || pPage->nOverflow > 0);\n    pCur->info.nSize = 0;\n    if (pPage->nOverflow) {\n        assert(rc == 0);\n        pCur->curFlags &= ~(2);\n        rc = balance(pCur);\n        pCur->pPage->nOverflow = 0;\n        pCur->eState = 1;\n        if ((flags & 2) && rc == 0) {\n            btreeReleaseAllCursorPages(pCur);\n            if (pCur->pKeyInfo) {\n                assert(pCur->pKey == 0);\n                pCur->pKey = sqlite3Malloc(pX->nKey);\n                if (pCur->pKey == 0) {\n                    rc = 7;\n                } else {\n                    memcpy(pCur->pKey, pX->pKey, pX->nKey);\n                }\n            }\n            pCur->eState = 3;\n            pCur->nKey = pX->nKey;\n        }\n    }\n    assert(pCur->iPage < 0 || pCur->pPage->nOverflow == 0);\n  end_insert:\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3CreateView",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    Table *p;\n    int n;\n    const char *z;\n    Token sEnd;\n    DbFixer sFix;\n    Token *pName = 0;\n    int iDb;\n    sqlite3 *db = pParse->db;\n    if (pParse->nVar > 0) {\n        sqlite3ErrorMsg(pParse, \"parameters are not allowed in views\");\n        goto create_view_fail;\n    }\n    sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);\n    p = pParse->pNewTable;\n    if (p == 0 || pParse->nErr)\n        goto create_view_fail;\n    p->tabFlags |= 512;\n    sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    iDb = sqlite3SchemaToIndex(db, p->pSchema);\n    sqlite3FixInit(&sFix, pParse, iDb, \"view\", pName);\n    if (sqlite3FixSelect(&sFix, pSelect))\n        goto create_view_fail;\n    pSelect->selFlags |= 2097152;\n    if ((pParse->eParseMode >= 2)) {\n        p->u.view.pSelect = pSelect;\n        pSelect = 0;\n    } else {\n        p->u.view.pSelect = sqlite3SelectDup(db, pSelect, 1);\n    }\n    p->pCheck = sqlite3ExprListDup(db, pCNames, 1);\n    p->eTabType = 2;\n    if (db->mallocFailed)\n        goto create_view_fail;\n    sEnd = pParse->sLastToken;\n    assert(sEnd.z[0] != 0 || sEnd.n == 0);\n    if (sEnd.z[0] != ';') {\n        sEnd.z += sEnd.n;\n    }\n    sEnd.n = 0;\n    n = (int)(sEnd.z - pBegin->z);\n    assert(n > 0);\n    z = pBegin->z;\n    while ((sqlite3CtypeMap[(unsigned char)(z[n - 1])] & 1))\n        {\n            n--;\n        }\n    sEnd.z = &z[n - 1];\n    sEnd.n = 1;\n    sqlite3EndTable(pParse, 0, &sEnd, 0, 0);\n  create_view_fail:\n    sqlite3SelectDelete(db, pSelect);\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameExprlistUnmap(pParse, pCNames);\n    }\n    sqlite3ExprListDelete(db, pCNames);\n    return;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#43965:1#proxyTakeConch",
            "gotos": 6,
            "labels": 1,
            "body": "{\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    if (pCtx->conchHeld != 0) {\n        return 0;\n    } else {\n        unixFile *conchFile = pCtx->conchFile;\n        int pError = 0;\n        char readBuf;\n        char lockPath;\n        char *tempLockPath;\n        int rc = 0;\n        int createConch = 0;\n        int hostIdMatch = 0;\n        int readLen = 0;\n        int tryOldLockPath = 0;\n        int forceNewLockPath = 0;\n        ;\n        if ((rc & 255) == 10) {\n            storeLastErrno(pFile, pError);\n            goto end_takeconch;\n        }\n        if (rc != 0) {\n            goto end_takeconch;\n        }\n        if (readLen < 0) {\n            storeLastErrno(pFile, conchFile->lastErrno);\n            rc = (10 | (1 << 8));\n            goto end_takeconch;\n        } else if (readLen <= (1 + 16) || <recovery-expr>()[0] != (char)2) {\n            createConch = 1;\n        }\n        do {\n            if (!createConch && !forceNewLockPath) {\n                if (!pCtx->lockProxyPath) {\n                    if (hostIdMatch) {\n                        if (<recovery-expr>()) {\n                        }\n                        tempLockPath = <recovery-expr>();\n                        tryOldLockPath = 1;\n                        goto end_takeconch;\n                    }\n                } else if (hostIdMatch && !strncmp(pCtx->lockProxyPath, &<recovery-expr>()[(1 + 16)], readLen - (1 + 16))) {\n                    goto end_takeconch;\n                }\n            }\n            if (<recovery-expr>()) {\n                rc = 5;\n                goto end_takeconch;\n            }\n            if (!pCtx->lockProxyPath) {\n                tempLockPath = <recovery-expr>();\n            }\n            if (hostIdMatch && !createConch) {\n                if (conchFile->pInode && conchFile->pInode->nShared > 1) {\n                    rc = 5;\n                } else {\n                }\n            } else {\n            }\n            if (rc == 0) {\n                char writeBuffer;\n                int writeSize = 0;\n                <recovery-expr>()[0] = (char)2;\n                if (<recovery-expr>()) {\n                } else {\n                }\n                writeSize = (1 + 16) + strlen(&<recovery-expr>()[(1 + 16)]);\n                robust_ftruncate(conchFile->h, writeSize);\n                rc = unixWrite((sqlite3_file *)conchFile, <recovery-expr>(), writeSize, 0);\n                full_fsync(conchFile->h, 0, 0);\n                if (rc == 0 && createConch) {\n                    struct stat buf;\n                    int err = ((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pFile->h, &<recovery-expr>());\n                    if (err == 0) {\n                    }\n                }\n            }\n            conchFile->pMethod->xUnlock((sqlite3_file *)conchFile, 1);\n          end_takeconch:\n            ;\n            if (rc == 0 && pFile->openFlags) {\n                int fd;\n                if (pFile->h >= 0) {\n                    robust_close(pFile, pFile->h, 44130);\n                }\n                pFile->h = -1;\n                fd = <recovery-expr>()(pCtx->dbPath, pFile->openFlags, 0);\n                ;\n                if (fd >= 0) {\n                    pFile->h = fd;\n                } else {\n                    rc = sqlite3CantopenError(44138);\n                }\n            }\n            if (rc == 0 && !pCtx->lockProxy) {\n                char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;\n                rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);\n                if (rc != 0 && rc != 7 && tryOldLockPath) {\n                    forceNewLockPath = 1;\n                    tryOldLockPath = 0;\n                    continue;\n                }\n            }\n            if (rc == 0) {\n                if (tempLockPath) {\n                    pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);\n                    if (!pCtx->lockProxyPath) {\n                        rc = 7;\n                    }\n                }\n            }\n            if (rc == 0) {\n                pCtx->conchHeld = 1;\n                if (pCtx->lockProxy->pMethod == &afpIoMethods) {\n                    afpLockingContext *afpCtx;\n                    afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;\n                    afpCtx->dbPath = pCtx->lockProxyPath;\n                }\n            } else {\n                conchFile->pMethod->xUnlock((sqlite3_file *)conchFile, 0);\n            }\n            ;\n            return rc;\n        } while (1);\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#64904:1#walCheckpoint",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    int szPage;\n    WalIterator *pIter = 0;\n    u32 iDbpage = 0;\n    u32 iFrame = 0;\n    u32 mxSafeFrame;\n    u32 mxPage;\n    int i;\n    volatile WalCkptInfo *pInfo;\n    szPage = walPagesize(pWal);\n    ;\n    ;\n    pInfo = walCkptInfo(pWal);\n    if (pInfo->nBackfill < pWal->hdr.mxFrame) {\n        assert(eMode != 0 || xBusy == 0);\n        mxSafeFrame = pWal->hdr.mxFrame;\n        mxPage = pWal->hdr.nPage;\n        for (i = 1; i < (8 - 3); i++) {\n            u32 y = __atomic_load_n((pInfo->aReadMark + i), 0);\n            if (mxSafeFrame > y) {\n                assert(y <= pWal->hdr.mxFrame);\n                rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (i)), 1);\n                if (rc == 0) {\n                    u32 iMark = (i == 1 ? mxSafeFrame : 4294967295U);\n                    __atomic_store_n((pInfo->aReadMark + i), (iMark), 0);\n                    walUnlockExclusive(pWal, (3 + (i)), 1);\n                } else if (rc == 5) {\n                    mxSafeFrame = y;\n                    xBusy = 0;\n                } else {\n                    goto walcheckpoint_out;\n                }\n            }\n        }\n        if (pInfo->nBackfill < mxSafeFrame) {\n            rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);\n            assert(rc == 0 || pIter == 0);\n        }\n        if (pIter && (rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (0)), 1)) == 0) {\n            u32 nBackfill = pInfo->nBackfill;\n            pInfo->nBackfillAttempted = mxSafeFrame;\n            rc = sqlite3OsSync(pWal->pWalFd, (((sync_flags) >> 2) & 3));\n            if (rc == 0) {\n                i64 nReq = ((i64)mxPage * szPage);\n                i64 nSize;\n                sqlite3OsFileControl(pWal->pDbFd, 39, 0);\n                rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);\n                if (rc == 0 && nSize < nReq) {\n                    if ((nSize + 65536 + (i64)pWal->hdr.mxFrame * szPage) < nReq) {\n                        rc = sqlite3CorruptError(64988);\n                    } else {\n                        sqlite3OsFileControlHint(pWal->pDbFd, 5, &nReq);\n                    }\n                }\n            }\n            while (rc == 0 && 0 == walIteratorNext(pIter, &iDbpage, &iFrame))\n                {\n                    i64 iOffset;\n                    assert(walFramePgno(pWal, iFrame) == iDbpage);\n                    if (__atomic_load_n((&db->u1.isInterrupted), 0)) {\n                        rc = db->mallocFailed ? 7 : 9;\n                        break;\n                    }\n                    if (iFrame <= nBackfill || iFrame > mxSafeFrame || iDbpage > mxPage) {\n                        continue;\n                    }\n                    iOffset = (32 + ((iFrame) - 1) * (i64)((szPage) + 24)) + 24;\n                    rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);\n                    if (rc != 0)\n                        break;\n                    iOffset = (iDbpage - 1) * (i64)szPage;\n                    ;\n                    rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);\n                    if (rc != 0)\n                        break;\n                }\n            sqlite3OsFileControl(pWal->pDbFd, 37, 0);\n            if (rc == 0) {\n                if (mxSafeFrame == walIndexHdr(pWal)->mxFrame) {\n                    i64 szDb = pWal->hdr.nPage * (i64)szPage;\n                    ;\n                    rc = sqlite3OsTruncate(pWal->pDbFd, szDb);\n                    if (rc == 0) {\n                        rc = sqlite3OsSync(pWal->pDbFd, (((sync_flags) >> 2) & 3));\n                    }\n                }\n                if (rc == 0) {\n                    __atomic_store_n((&pInfo->nBackfill), (mxSafeFrame), 0);\n                }\n            }\n            walUnlockExclusive(pWal, (3 + (0)), 1);\n        }\n        if (rc == 5) {\n            rc = 0;\n        }\n    }\n    if (rc == 0 && eMode != 0) {\n        assert(pWal->writeLock);\n        if (pInfo->nBackfill < pWal->hdr.mxFrame) {\n            rc = 5;\n        } else if (eMode >= 2) {\n            u32 salt1;\n            sqlite3_randomness(4, &salt1);\n            assert(pInfo->nBackfill == pWal->hdr.mxFrame);\n            rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (1)), (8 - 3) - 1);\n            if (rc == 0) {\n                if (eMode == 3) {\n                    walRestartHdr(pWal, salt1);\n                    rc = sqlite3OsTruncate(pWal->pWalFd, 0);\n                }\n                walUnlockExclusive(pWal, (3 + (1)), (8 - 3) - 1);\n            }\n        }\n    }\n  walcheckpoint_out:\n    walIteratorFree(pIter);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3Vacuum",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    int iDb = 0;\n    if (v == 0)\n        goto build_vacuum_end;\n    if (pParse->nErr)\n        goto build_vacuum_end;\n    if (pNm) {\n        iDb = sqlite3TwoPartName(pParse, pNm, pNm, &pNm);\n        if (iDb < 0)\n            goto build_vacuum_end;\n    }\n    if (iDb != 1) {\n        int iIntoReg = 0;\n        if (pInto && sqlite3ResolveSelfReference(pParse, 0, 0, pInto, 0) == 0) {\n            iIntoReg = ++pParse->nMem;\n            sqlite3ExprCode(pParse, pInto, iIntoReg);\n        }\n        sqlite3VdbeAddOp2(v, 5, iDb, iIntoReg);\n        sqlite3VdbeUsesBtree(v, iDb);\n    }\n  build_vacuum_end:\n    sqlite3ExprDelete(pParse->db, pInto);\n    return;\n}\n"
        },
        {
            "id": "#23:25#sqlite3BitvecSet",
            "gotos": 2,
            "labels": 2,
            "body": "{\n    u32 h;\n    if (p == 0)\n        return 0;\n    assert(i > 0);\n    assert(i <= p->iSize);\n    i--;\n    while ((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) && p->iDivisor)\n        {\n            u32 bin = i / p->iDivisor;\n            i = i % p->iDivisor;\n            if (p->u.apSub[bin] == 0) {\n                p->u.apSub[bin] = sqlite3BitvecCreate(p->iDivisor);\n                if (p->u.apSub[bin] == 0)\n                    return 7;\n            }\n            p = p->u.apSub[bin];\n        }\n    if (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) {\n        p->u.aBitmap[i / 8] |= 1 << (i & (8 - 1));\n        return 0;\n    }\n    h = (((i++) * 1) % ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)));\n    if (!p->u.aHash[h]) {\n        if (p->nSet < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)) {\n            goto bitvec_set_end;\n        } else {\n            goto bitvec_set_rehash;\n        }\n    }\n    do {\n        if (p->u.aHash[h] == i)\n            return 0;\n        h++;\n        if (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)))\n            h = 0;\n    } while (p->u.aHash[h]);\n  bitvec_set_rehash:\n    if (p->nSet >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)) {\n        unsigned int j;\n        int rc;\n        u32 *aiValues = sqlite3DbMallocRaw(0, sizeof (p->u.aHash));\n        if (aiValues == 0) {\n            return 7;\n        } else {\n            memcpy(aiValues, p->u.aHash, sizeof (p->u.aHash));\n            memset(p->u.apSub, 0, sizeof (p->u.apSub));\n            p->iDivisor = (p->iSize + ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *)) - 1) / ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *));\n            rc = sqlite3BitvecSet(p, i);\n            for (j = 0; j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)); j++) {\n                if (aiValues[j])\n                    rc |= sqlite3BitvecSet(p, aiValues[j]);\n            }\n            sqlite3DbFree(0, aiValues);\n            return rc;\n        }\n    }\n  bitvec_set_end:\n    p->nSet++;\n    p->u.aHash[h] = i;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#43690:1#proxyCreateUnixFile",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int fd = -1;\n    unixFile *pNew;\n    int rc = 0;\n    int openFlags;\n    sqlite3_vfs dummyVfs;\n    int terrno = 0;\n    UnixUnusedFd *pUnused;\n    pUnused = findReusableFd(path, openFlags);\n    if (pUnused) {\n        fd = pUnused->fd;\n    } else {\n        pUnused = sqlite3_malloc64(sizeof (*pUnused));\n        if (!pUnused) {\n            return 7;\n        }\n    }\n    if (fd < 0) {\n        fd = <recovery-expr>()(path, openFlags, 0);\n        if (<recovery-expr>()) {\n            if (proxyCreateLockPath(path) == 0) {\n                fd = <recovery-expr>()(path, openFlags, 0);\n            }\n        }\n    }\n    if (fd < 0) {\n        fd = <recovery-expr>()(path, openFlags, 0);\n    }\n    if (fd < 0) {\n        if (islockfile) {\n            return 5;\n        }\n        switch (terrno) {\n            return 3;\n            return (10 | (15 << 8));\n          default:\n            return sqlite3CantopenError(43742);\n        }\n    }\n    pNew = (unixFile *)sqlite3_malloc64(sizeof (*pNew));\n    if (<recovery-expr>()) {\n        rc = 7;\n        goto end_create_proxy;\n    }\n    memset(pNew, 0, sizeof(unixFile));\n    pNew->openFlags = openFlags;\n    memset(&dummyVfs, 0, sizeof (dummyVfs));\n    dummyVfs.pAppData = (void *)&autolockIoFinder;\n    dummyVfs.zName = \"dummy\";\n    pUnused->fd = fd;\n    pUnused->flags = openFlags;\n    pNew->pPreallocatedUnused = pUnused;\n    rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file *)pNew, path, 0);\n    if (rc == 0) {\n        *ppFile = pNew;\n        return 0;\n    }\n  end_create_proxy:\n    robust_close(pNew, fd, 43766);\n    sqlite3_free(pNew);\n    sqlite3_free(pUnused);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#38559:1#posixUnlock",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode;\n    struct flock lock;\n    int rc = 0;\n    assert(pFile);\n    ;\n    assert(eFileLock <= 1);\n    if (pFile->eFileLock <= eFileLock) {\n        return 0;\n    }\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    assert(pInode->nShared != 0);\n    if (pFile->eFileLock > 1) {\n        assert(pInode->eFileLock == pFile->eFileLock);\n        if (eFileLock == 1) {\n            if (handleNFSUnlock) {\n                int tErrno;\n                <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n                if (unixFileLock(pFile, &<recovery-expr>()) == (-1)) {\n                    rc = (10 | (8 << 8));\n                    storeLastErrno(pFile, tErrno);\n                    goto end_unlock;\n                }\n                <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n                if (unixFileLock(pFile, &<recovery-expr>()) == (-1)) {\n                    rc = sqliteErrorFromPosixError(tErrno, (10 | (9 << 8)));\n                    if (((rc != 0) && (rc != 5))) {\n                        storeLastErrno(pFile, tErrno);\n                    }\n                    goto end_unlock;\n                }\n                if (unixFileLock(pFile, &<recovery-expr>()) == (-1)) {\n                    rc = (10 | (8 << 8));\n                    storeLastErrno(pFile, tErrno);\n                    goto end_unlock;\n                }\n            } else {\n                <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n                <recovery-expr>().l_len = 510;\n                if (unixFileLock(pFile, &<recovery-expr>())) {\n                    rc = (10 | (9 << 8));\n                    goto end_unlock;\n                }\n            }\n        }\n        <recovery-expr>().l_start = sqlite3PendingByte;\n        <recovery-expr>().l_len = 2L;\n        assert(sqlite3PendingByte + 1 == (sqlite3PendingByte + 1));\n        if (unixFileLock(pFile, &<recovery-expr>()) == 0) {\n            pInode->eFileLock = 1;\n        } else {\n            rc = (10 | (8 << 8));\n            goto end_unlock;\n        }\n    }\n    if (eFileLock == 0) {\n        pInode->nShared--;\n        if (pInode->nShared == 0) {\n            <recovery-expr>().l_start = <recovery-expr>().l_len = 0L;\n            if (unixFileLock(pFile, &<recovery-expr>()) == 0) {\n                pInode->eFileLock = 0;\n            } else {\n                rc = (10 | (8 << 8));\n                pInode->eFileLock = 0;\n                pFile->eFileLock = 0;\n            }\n        }\n        pInode->nLock--;\n        assert(pInode->nLock >= 0);\n        if (pInode->nLock == 0)\n            closePendingFds(pFile);\n    }\n  end_unlock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n    }\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#38309:1#unixLock",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode;\n    struct flock lock;\n    int tErrno = 0;\n    assert(pFile);\n    ;\n    if (pFile->eFileLock >= eFileLock) {\n        ;\n        return 0;\n    }\n    assert(pFile->eFileLock != 0 || eFileLock == 1);\n    assert(eFileLock != 3);\n    assert(eFileLock != 2 || pFile->eFileLock == 1);\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    if ((pFile->eFileLock != pInode->eFileLock && (pInode->eFileLock >= 3 || eFileLock > 1))) {\n        rc = 5;\n        goto end_lock;\n    }\n    if (eFileLock == 1 && (pInode->eFileLock == 1 || pInode->eFileLock == 2)) {\n        assert(eFileLock == 1);\n        assert(pFile->eFileLock == 0);\n        assert(pInode->nShared > 0);\n        pFile->eFileLock = 1;\n        pInode->nShared++;\n        pInode->nLock++;\n        goto end_lock;\n    }\n    <recovery-expr>().l_len = 1L;\n    if (eFileLock == 1 || (eFileLock == 4 && pFile->eFileLock < 3)) {\n        <recovery-expr>().l_start = sqlite3PendingByte;\n        if (unixFileLock(pFile, &<recovery-expr>())) {\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n            goto end_lock;\n        }\n    }\n    if (eFileLock == 1) {\n        assert(pInode->nShared == 0);\n        assert(pInode->eFileLock == 0);\n        assert(rc == 0);\n        <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n        <recovery-expr>().l_len = 510;\n        if (unixFileLock(pFile, &<recovery-expr>())) {\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n        }\n        <recovery-expr>().l_start = sqlite3PendingByte;\n        <recovery-expr>().l_len = 1L;\n        if (unixFileLock(pFile, &<recovery-expr>()) && rc == 0) {\n            rc = (10 | (8 << 8));\n        }\n        if (rc) {\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n            goto end_lock;\n        } else {\n            pFile->eFileLock = 1;\n            pInode->nLock++;\n            pInode->nShared = 1;\n        }\n    } else if (eFileLock == 4 && pInode->nShared > 1) {\n        rc = 5;\n    } else {\n        assert(0 != pFile->eFileLock);\n        assert(eFileLock == 2 || eFileLock == 4);\n        if (eFileLock == 2) {\n            <recovery-expr>().l_start = (sqlite3PendingByte + 1);\n            <recovery-expr>().l_len = 1L;\n        } else {\n            <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n            <recovery-expr>().l_len = 510;\n        }\n        if (unixFileLock(pFile, &<recovery-expr>())) {\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n        }\n    }\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n        pInode->eFileLock = eFileLock;\n    } else if (eFileLock == 4) {\n        pFile->eFileLock = 3;\n        pInode->eFileLock = 3;\n    }\n  end_lock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    ;\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#39569:1#afpLock",
            "gotos": 6,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode = pFile->pInode;\n    afpLockingContext *context = (afpLockingContext *)pFile->lockingContext;\n    assert(pFile);\n    ;\n    if (pFile->eFileLock >= eFileLock) {\n        ;\n        return 0;\n    }\n    assert(pFile->eFileLock != 0 || eFileLock == 1);\n    assert(eFileLock != 3);\n    assert(eFileLock != 2 || pFile->eFileLock == 1);\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    if ((pFile->eFileLock != pInode->eFileLock && (pInode->eFileLock >= 3 || eFileLock > 1))) {\n        rc = 5;\n        goto afp_end_lock;\n    }\n    if (eFileLock == 1 && (pInode->eFileLock == 1 || pInode->eFileLock == 2)) {\n        assert(eFileLock == 1);\n        assert(pFile->eFileLock == 0);\n        assert(pInode->nShared > 0);\n        pFile->eFileLock = 1;\n        pInode->nShared++;\n        pInode->nLock++;\n        goto afp_end_lock;\n    }\n    if (eFileLock == 1 || (eFileLock == 4 && pFile->eFileLock < 3)) {\n        int failed;\n        failed = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 1);\n        if (failed) {\n            rc = failed;\n            goto afp_end_lock;\n        }\n    }\n    if (eFileLock == 1) {\n        int lrc1, lrc2, lrc1Errno = 0;\n        long lk, mask;\n        assert(pInode->nShared == 0);\n        assert(pInode->eFileLock == 0);\n        mask = (sizeof(long) == 8) ? (4294967295U | (((i64)2147483647) << 32)) : 2147483647;\n        lk = random();\n        pInode->sharedByte = (lk & mask) % (510 - 1);\n        lrc1 = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 1);\n        if (((lrc1 != 0) && (lrc1 != 5))) {\n            lrc1Errno = pFile->lastErrno;\n        }\n        lrc2 = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 0);\n        if (((lrc1 != 0) && (lrc1 != 5))) {\n            storeLastErrno(pFile, lrc1Errno);\n            rc = lrc1;\n            goto afp_end_lock;\n        } else if (((lrc2 != 0) && (lrc2 != 5))) {\n            rc = lrc2;\n            goto afp_end_lock;\n        } else if (lrc1 != 0) {\n            rc = lrc1;\n        } else {\n            pFile->eFileLock = 1;\n            pInode->nLock++;\n            pInode->nShared = 1;\n        }\n    } else if (eFileLock == 4 && pInode->nShared > 1) {\n        rc = 5;\n    } else {\n        int failed = 0;\n        assert(0 != pFile->eFileLock);\n        if (eFileLock >= 2 && pFile->eFileLock < 2) {\n            failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 1), 1, 1);\n            if (!failed) {\n                context->reserved = 1;\n            }\n        }\n        if (!failed && eFileLock == 4) {\n            if (!(failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 0))) {\n                int failed2 = 0;\n                failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2), 510, 1);\n                if (failed && (failed2 = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 1))) {\n                    rc = ((failed & 255) == 10) ? failed2 : (10 | (15 << 8));\n                    goto afp_end_lock;\n                }\n            } else {\n                rc = failed;\n            }\n        }\n        if (failed) {\n            rc = failed;\n        }\n    }\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n        pInode->eFileLock = eFileLock;\n    } else if (eFileLock == 4) {\n        pFile->eFileLock = 3;\n        pInode->eFileLock = 3;\n    }\n  afp_end_lock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    ;\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#74313:1#allocateBtreePage",
            "gotos": 11,
            "labels": 1,
            "body": "{\n    MemPage *pPage1;\n    int rc;\n    u32 n;\n    u32 k;\n    MemPage *pTrunk = 0;\n    MemPage *pPrevTrunk = 0;\n    Pgno mxPage;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(eMode == 0 || (nearby > 0 && (pBt->autoVacuum)));\n    pPage1 = pBt->pPage1;\n    mxPage = btreePagecount(pBt);\n    n = sqlite3Get4byte(&pPage1->aData[36]);\n    ;\n    if (n >= mxPage) {\n        return sqlite3CorruptError(74337);\n    }\n    if (n > 0) {\n        Pgno iTrunk;\n        u8 searchList = 0;\n        u32 nSearch = 0;\n        if (eMode == 1) {\n            if (nearby <= mxPage) {\n                u8 eType;\n                assert(nearby > 0);\n                assert(pBt->autoVacuum);\n                rc = ptrmapGet(pBt, nearby, &eType, 0);\n                if (rc)\n                    return rc;\n                if (eType == 2) {\n                    searchList = 1;\n                }\n            }\n        } else if (eMode == 2) {\n            searchList = 1;\n        }\n        rc = sqlite3PagerWrite(pPage1->pDbPage);\n        if (rc)\n            return rc;\n        sqlite3Put4byte(&pPage1->aData[36], n - 1);\n        do {\n            pPrevTrunk = pTrunk;\n            if (pPrevTrunk) {\n                iTrunk = sqlite3Get4byte(&pPrevTrunk->aData[0]);\n            } else {\n                iTrunk = sqlite3Get4byte(&pPage1->aData[32]);\n            }\n            ;\n            if (iTrunk > mxPage || nSearch++ > n) {\n                rc = sqlite3CorruptError(74393);\n            } else {\n                rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);\n            }\n            if (rc) {\n                pTrunk = 0;\n                goto end_allocate_page;\n            }\n            assert(pTrunk != 0);\n            assert(pTrunk->aData != 0);\n            k = sqlite3Get4byte(&pTrunk->aData[4]);\n            if (k == 0 && !searchList) {\n                assert(pPrevTrunk == 0);\n                rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                if (rc) {\n                    goto end_allocate_page;\n                }\n                *pPgno = iTrunk;\n                memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);\n                *ppPage = pTrunk;\n                pTrunk = 0;\n                ;\n            } else if (k > (u32)(pBt->usableSize / 4 - 2)) {\n                rc = sqlite3CorruptError(74422);\n                goto end_allocate_page;\n            } else if (searchList && (nearby == iTrunk || (iTrunk < nearby && eMode == 2))) {\n                *pPgno = iTrunk;\n                *ppPage = pTrunk;\n                searchList = 0;\n                rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                if (rc) {\n                    goto end_allocate_page;\n                }\n                if (k == 0) {\n                    if (!pPrevTrunk) {\n                        memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);\n                    } else {\n                        rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);\n                        if (rc != 0) {\n                            goto end_allocate_page;\n                        }\n                        memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);\n                    }\n                } else {\n                    MemPage *pNewTrunk;\n                    Pgno iNewTrunk = sqlite3Get4byte(&pTrunk->aData[8]);\n                    if (iNewTrunk > mxPage) {\n                        rc = sqlite3CorruptError(74456);\n                        goto end_allocate_page;\n                    }\n                    ;\n                    rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0);\n                    if (rc != 0) {\n                        goto end_allocate_page;\n                    }\n                    rc = sqlite3PagerWrite(pNewTrunk->pDbPage);\n                    if (rc != 0) {\n                        releasePage(pNewTrunk);\n                        goto end_allocate_page;\n                    }\n                    memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);\n                    sqlite3Put4byte(&pNewTrunk->aData[4], k - 1);\n                    memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k - 1) * 4);\n                    releasePage(pNewTrunk);\n                    if (!pPrevTrunk) {\n                        assert(sqlite3PagerIswriteable(pPage1->pDbPage));\n                        sqlite3Put4byte(&pPage1->aData[32], iNewTrunk);\n                    } else {\n                        rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);\n                        if (rc) {\n                            goto end_allocate_page;\n                        }\n                        sqlite3Put4byte(&pPrevTrunk->aData[0], iNewTrunk);\n                    }\n                }\n                pTrunk = 0;\n                ;\n            } else if (k > 0) {\n                u32 closest;\n                Pgno iPage;\n                unsigned char *aData = pTrunk->aData;\n                if (nearby > 0) {\n                    u32 i;\n                    closest = 0;\n                    if (eMode == 2) {\n                        for (i = 0; i < k; i++) {\n                            iPage = sqlite3Get4byte(&aData[8 + i * 4]);\n                            if (iPage <= nearby) {\n                                closest = i;\n                                break;\n                            }\n                        }\n                    } else {\n                        int dist;\n                        dist = sqlite3AbsInt32(sqlite3Get4byte(&aData[8]) - nearby);\n                        for (i = 1; i < k; i++) {\n                            int d2 = sqlite3AbsInt32(sqlite3Get4byte(&aData[8 + i * 4]) - nearby);\n                            if (d2 < dist) {\n                                closest = i;\n                                dist = d2;\n                            }\n                        }\n                    }\n                } else {\n                    closest = 0;\n                }\n                iPage = sqlite3Get4byte(&aData[8 + closest * 4]);\n                ;\n                if (iPage > mxPage || iPage < 2) {\n                    rc = sqlite3CorruptError(74521);\n                    goto end_allocate_page;\n                }\n                ;\n                if (!searchList || (iPage == nearby || (iPage < nearby && eMode == 2))) {\n                    int noContent;\n                    *pPgno = iPage;\n                    ;\n                    rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                    if (rc)\n                        goto end_allocate_page;\n                    if (closest < k - 1) {\n                        memcpy(&aData[8 + closest * 4], &aData[4 + k * 4], 4);\n                    }\n                    sqlite3Put4byte(&aData[4], k - 1);\n                    noContent = !btreeGetHasContent(pBt, *pPgno) ? 1 : 0;\n                    rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);\n                    if (rc == 0) {\n                        rc = sqlite3PagerWrite((*ppPage)->pDbPage);\n                        if (rc != 0) {\n                            releasePage(*ppPage);\n                            *ppPage = 0;\n                        }\n                    }\n                    searchList = 0;\n                }\n            }\n            releasePage(pPrevTrunk);\n            pPrevTrunk = 0;\n        } while (searchList);\n    } else {\n        int bNoContent = (0 == (pBt->bDoTruncate)) ? 1 : 0;\n        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);\n        if (rc)\n            return rc;\n        pBt->nPage++;\n        if (pBt->nPage == ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)))\n            pBt->nPage++;\n        if (pBt->autoVacuum && (ptrmapPageno((pBt), (pBt->nPage)) == (pBt->nPage))) {\n            MemPage *pPg = 0;\n            ;\n            assert(pBt->nPage != ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)));\n            rc = btreeGetUnusedPage(pBt, pBt->nPage, &pPg, bNoContent);\n            if (rc == 0) {\n                rc = sqlite3PagerWrite(pPg->pDbPage);\n                releasePage(pPg);\n            }\n            if (rc)\n                return rc;\n            pBt->nPage++;\n            if (pBt->nPage == ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1))) {\n                pBt->nPage++;\n            }\n        }\n        sqlite3Put4byte(28 + (u8 *)pBt->pPage1->aData, pBt->nPage);\n        *pPgno = pBt->nPage;\n        assert(*pPgno != ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)));\n        rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);\n        if (rc)\n            return rc;\n        rc = sqlite3PagerWrite((*ppPage)->pDbPage);\n        if (rc != 0) {\n            releasePage(*ppPage);\n            *ppPage = 0;\n        }\n        ;\n    }\n    assert((sqlite3Config.neverCorrupt == 0) || *pPgno != ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)));\n  end_allocate_page:\n    releasePage(pTrunk);\n    releasePage(pPrevTrunk);\n    assert(rc != 0 || sqlite3PagerPageRefcount((*ppPage)->pDbPage) <= 1);\n    assert(rc != 0 || (*ppPage)->isInit == 0);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#41382:1#unixShmMap",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    unixFile *pDbFd = (unixFile *)fd;\n    unixShm *p;\n    unixShmNode *pShmNode;\n    int rc = 0;\n    int nShmPerMap = unixShmRegionPerMap();\n    int nReqRegion;\n    if (pDbFd->pShm == 0) {\n        rc = unixOpenSharedMemory(pDbFd);\n        if (rc != 0)\n            return rc;\n    }\n    p = pDbFd->pShm;\n    pShmNode = p->pShmNode;\n    sqlite3_mutex_enter(pShmNode->pShmMutex);\n    if (pShmNode->isUnlocked) {\n        rc = unixLockSharedMemory(pDbFd, pShmNode);\n        if (rc != 0)\n            goto shmpage_out;\n        pShmNode->isUnlocked = 0;\n    }\n    assert(szRegion == pShmNode->szRegion || pShmNode->nRegion == 0);\n    assert(pShmNode->pInode == pDbFd->pInode);\n    assert(pShmNode->hShm >= 0 || pDbFd->pInode->bProcessLock == 1);\n    assert(pShmNode->hShm < 0 || pDbFd->pInode->bProcessLock == 0);\n    nReqRegion = ((iRegion + nShmPerMap) / nShmPerMap) * nShmPerMap;\n    if (pShmNode->nRegion < nReqRegion) {\n        char **apNew;\n        int nByte = nReqRegion * szRegion;\n        struct stat sStat;\n        pShmNode->szRegion = szRegion;\n        if (pShmNode->hShm >= 0) {\n            if (((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pShmNode->hShm, &<recovery-expr>())) {\n                rc = (10 | (19 << 8));\n                goto shmpage_out;\n            }\n            if (<recovery-expr>().st_size < nByte) {\n                if (!bExtend) {\n                    goto shmpage_out;\n                } else {\n                    static const int pgsz = 4096;\n                    int iPg;\n                    assert((nByte % pgsz) == 0);\n                    for (iPg = (<recovery-expr>().st_size / pgsz); iPg < (nByte / pgsz); iPg++) {\n                        int x = 0;\n                        if (seekAndWriteFd(pShmNode->hShm, iPg * pgsz + pgsz - 1, \"\", 1, &x) != 1) {\n                            const char *zFile = pShmNode->zFilename;\n                            rc = unixLogErrorAtLine((10 | (19 << 8)), \"write\", zFile, 41460);\n                            goto shmpage_out;\n                        }\n                    }\n                }\n            }\n        }\n        apNew = (char **)sqlite3_realloc(pShmNode->apRegion, nReqRegion * sizeof(char *));\n        if (!apNew) {\n            rc = (10 | (12 << 8));\n            goto shmpage_out;\n        }\n        pShmNode->apRegion = apNew;\n        while (pShmNode->nRegion < nReqRegion)\n            {\n                int nMap = szRegion * nShmPerMap;\n                int i;\n                void *pMem;\n                if (pShmNode->hShm >= 0) {\n                    if (<recovery-expr>()) {\n                        rc = unixLogErrorAtLine((10 | (21 << 8)), \"mmap\", pShmNode->zFilename, 41487);\n                        goto shmpage_out;\n                    }\n                } else {\n                    pMem = sqlite3_malloc64(nMap);\n                    if (pMem == 0) {\n                        rc = 7;\n                        goto shmpage_out;\n                    }\n                    memset(pMem, 0, nMap);\n                }\n                for (i = 0; i < nShmPerMap; i++) {\n                    pShmNode->apRegion[pShmNode->nRegion + i] = &((char *)pMem)[szRegion * i];\n                }\n                pShmNode->nRegion += nShmPerMap;\n            }\n    }\n  shmpage_out:\n    if (pShmNode->nRegion > iRegion) {\n        *pp = pShmNode->apRegion[iRegion];\n    } else {\n        *pp = 0;\n    }\n    if (pShmNode->isReadonly && rc == 0)\n        rc = 8;\n    sqlite3_mutex_leave(pShmNode->pShmMutex);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#64091:1#walIndexRecover",
            "gotos": 7,
            "labels": 2,
            "body": "{\n    int rc;\n    i64 nSize;\n    u32 aFrameCksum[2] = {0, 0};\n    int iLock;\n    assert(pWal->ckptLock == 1 || pWal->ckptLock == 0);\n    assert(1 == 0 + 1);\n    assert(1 == 1);\n    assert(pWal->writeLock);\n    iLock = 1 + pWal->ckptLock;\n    rc = walLockExclusive(pWal, iLock, (3 + (0)) - iLock);\n    if (rc) {\n        return rc;\n    }\n    ;\n    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));\n    rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);\n    if (rc != 0) {\n        goto recovery_error;\n    }\n    if (nSize > 32) {\n        u8 aBuf[32];\n        u32 *aPrivate = 0;\n        u8 *aFrame = 0;\n        int szFrame;\n        u8 *aData;\n        int szPage;\n        u32 magic;\n        u32 version;\n        int isValid;\n        u32 iPg;\n        u32 iLastFrame;\n        rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);\n        if (rc != 0) {\n            goto recovery_error;\n        }\n        magic = sqlite3Get4byte(&aBuf[0]);\n        szPage = sqlite3Get4byte(&aBuf[8]);\n        if ((magic & 4294967294U) != 931071618 || szPage & (szPage - 1) || szPage > 65536 || szPage < 512) {\n            goto finished;\n        }\n        pWal->hdr.bigEndCksum = (u8)(magic & 1);\n        pWal->szPage = szPage;\n        pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);\n        memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);\n        walChecksumBytes(pWal->hdr.bigEndCksum == 0, aBuf, 32 - 2 * 4, 0, pWal->hdr.aFrameCksum);\n        if (pWal->hdr.aFrameCksum[0] != sqlite3Get4byte(&aBuf[24]) || pWal->hdr.aFrameCksum[1] != sqlite3Get4byte(&aBuf[28])) {\n            goto finished;\n        }\n        version = sqlite3Get4byte(&aBuf[4]);\n        if (version != 3007000) {\n            rc = sqlite3CantopenError(64174);\n            goto finished;\n        }\n        szFrame = szPage + 24;\n        aFrame = (u8 *)sqlite3_malloc64(szFrame + (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)));\n        if (!aFrame) {\n            rc = 7;\n            goto recovery_error;\n        }\n        aData = &aFrame[24];\n        aPrivate = (u32 *)&aData[szPage];\n        iLastFrame = (nSize - 32) / szFrame;\n        for (iPg = 0; iPg <= (u32)walFramePage(iLastFrame); iPg++) {\n            u32 *aShare;\n            u32 iFrame;\n            u32 iLast = ((iLastFrame) < ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + iPg * 4096) ? (iLastFrame) : ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + iPg * 4096));\n            u32 iFirst = 1 + (iPg == 0 ? 0 : (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + (iPg - 1) * 4096);\n            u32 nHdr, nHdr32;\n            rc = walIndexPage(pWal, iPg, (volatile u32 **)&aShare);\n            assert(aShare != 0 || rc != 0);\n            if (aShare == 0)\n                break;\n            pWal->apWiData[iPg] = aPrivate;\n            for (iFrame = iFirst; iFrame <= iLast; iFrame++) {\n                i64 iOffset = (32 + ((iFrame) - 1) * (i64)((szPage) + 24));\n                u32 pgno;\n                u32 nTruncate;\n                rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n                if (rc != 0)\n                    break;\n                isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);\n                if (!isValid)\n                    break;\n                rc = walIndexAppend(pWal, iFrame, pgno);\n                if ((rc != 0))\n                    break;\n                if (nTruncate) {\n                    pWal->hdr.mxFrame = iFrame;\n                    pWal->hdr.nPage = nTruncate;\n                    pWal->hdr.szPage = (u16)((szPage & 65280) | (szPage >> 16));\n                    ;\n                    ;\n                    aFrameCksum[0] = pWal->hdr.aFrameCksum[0];\n                    aFrameCksum[1] = pWal->hdr.aFrameCksum[1];\n                }\n            }\n            pWal->apWiData[iPg] = aShare;\n            nHdr = (iPg == 0 ? (sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) : 0);\n            nHdr32 = nHdr / sizeof(u32);\n            memcpy(&aShare[nHdr32], &aPrivate[nHdr32], (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)) - nHdr);\n            if (iFrame <= iLast)\n                break;\n        }\n        sqlite3_free(aFrame);\n    }\n  finished:\n    if (rc == 0) {\n        volatile WalCkptInfo *pInfo;\n        int i;\n        pWal->hdr.aFrameCksum[0] = aFrameCksum[0];\n        pWal->hdr.aFrameCksum[1] = aFrameCksum[1];\n        walIndexWriteHdr(pWal);\n        pInfo = walCkptInfo(pWal);\n        pInfo->nBackfill = 0;\n        pInfo->nBackfillAttempted = pWal->hdr.mxFrame;\n        pInfo->aReadMark[0] = 0;\n        for (i = 1; i < (8 - 3); i++) {\n            rc = walLockExclusive(pWal, (3 + (i)), 1);\n            if (rc == 0) {\n                if (i == 1 && pWal->hdr.mxFrame) {\n                    pInfo->aReadMark[i] = pWal->hdr.mxFrame;\n                } else {\n                    pInfo->aReadMark[i] = 4294967295U;\n                }\n                walUnlockExclusive(pWal, (3 + (i)), 1);\n            } else if (rc != 5) {\n                goto recovery_error;\n            }\n        }\n        if (pWal->hdr.nPage) {\n            sqlite3_log((27 | (1 << 8)), \"recovered %d frames from WAL file %s\", pWal->hdr.mxFrame, pWal->zWalName);\n        }\n    }\n  recovery_error:\n    ;\n    walUnlockExclusive(pWal, iLock, (3 + (0)) - iLock);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#108460:1#sqlite3ExprCodeIN",
            "gotos": 4,
            "labels": 2,
            "body": "{\n    int rRhsHasNull = 0;\n    int eType;\n    int rLhs;\n    int rLhsOrig;\n    Vdbe *v;\n    int *aiMap = 0;\n    char *zAff = 0;\n    int nVector;\n    int iDummy;\n    Expr *pLeft;\n    int i;\n    int destStep2;\n    int destStep6 = 0;\n    int addrTruthOp;\n    int destNotNull;\n    int addrTop;\n    int iTab = 0;\n    u8 okConstFactor = pParse->okConstFactor;\n    assert(!0);\n    pLeft = pExpr->pLeft;\n    if (sqlite3ExprCheckIN(pParse, pExpr))\n        return;\n    zAff = exprINAffinity(pParse, pExpr);\n    nVector = sqlite3ExprVectorSize(pExpr->pLeft);\n    aiMap = (int *)sqlite3DbMallocZero(pParse->db, nVector * (sizeof(int) + sizeof(char)) + 1);\n    if (pParse->db->mallocFailed)\n        goto sqlite3ExprCodeIN_oom_error;\n    v = pParse->pVdbe;\n    assert(v != 0);\n    ;\n    eType = sqlite3FindInIndex(pParse, pExpr, 2 | 1, destIfFalse == destIfNull ? 0 : &rRhsHasNull, aiMap, &iTab);\n    assert(pParse->nErr || nVector == 1 || eType == 2 || eType == 3 || eType == 4);\n    assert(pParse->okConstFactor == okConstFactor);\n    pParse->okConstFactor = 0;\n    rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);\n    pParse->okConstFactor = okConstFactor;\n    for (i = 0; i < nVector && aiMap[i] == i; i++) {\n    }\n    if (i == nVector) {\n        rLhs = rLhsOrig;\n    } else {\n        rLhs = sqlite3GetTempRange(pParse, nVector);\n        for (i = 0; i < nVector; i++) {\n            sqlite3VdbeAddOp3(v, 80, rLhsOrig + i, rLhs + aiMap[i], 0);\n        }\n    }\n    if (eType == 5) {\n        ExprList *pList;\n        CollSeq *pColl;\n        int labelOk = sqlite3VdbeMakeLabel(pParse);\n        int r2, regToFree;\n        int regCkNull = 0;\n        int ii;\n        assert((((pExpr)->flags & 4096) == 0));\n        pList = pExpr->x.pList;\n        pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n        if (destIfNull != destIfFalse) {\n            regCkNull = sqlite3GetTempReg(pParse);\n            sqlite3VdbeAddOp3(v, 102, rLhs, rLhs, regCkNull);\n        }\n        for (ii = 0; ii < pList->nExpr; ii++) {\n            r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);\n            if (regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr)) {\n                sqlite3VdbeAddOp3(v, 102, regCkNull, r2, regCkNull);\n            }\n            sqlite3ReleaseTempReg(pParse, regToFree);\n            if (ii < pList->nExpr - 1 || destIfNull != destIfFalse) {\n                int op = rLhs != r2 ? 53 : 51;\n                sqlite3VdbeAddOp4(v, op, rLhs, labelOk, r2, (void *)pColl, (-2));\n                ;\n                ;\n                ;\n                ;\n                sqlite3VdbeChangeP5(v, zAff[0]);\n            } else {\n                int op = rLhs != r2 ? 52 : 50;\n                assert(destIfNull == destIfFalse);\n                sqlite3VdbeAddOp4(v, op, rLhs, destIfFalse, r2, (void *)pColl, (-2));\n                ;\n                ;\n                sqlite3VdbeChangeP5(v, zAff[0] | 16);\n            }\n        }\n        if (regCkNull) {\n            sqlite3VdbeAddOp2(v, 50, regCkNull, destIfNull);\n            ;\n            sqlite3VdbeGoto(v, destIfFalse);\n        }\n        sqlite3VdbeResolveLabel(v, labelOk);\n        sqlite3ReleaseTempReg(pParse, regCkNull);\n        goto sqlite3ExprCodeIN_finished;\n    }\n    if (destIfNull == destIfFalse) {\n        destStep2 = destIfFalse;\n    } else {\n        destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);\n    }\n    for (i = 0; i < nVector; i++) {\n        Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);\n        if (pParse->nErr)\n            goto sqlite3ExprCodeIN_oom_error;\n        if (sqlite3ExprCanBeNull(p)) {\n            sqlite3VdbeAddOp2(v, 50, rLhs + i, destStep2);\n            ;\n        }\n    }\n    if (eType == 1) {\n        sqlite3VdbeAddOp3(v, 30, iTab, destIfFalse, rLhs);\n        ;\n        addrTruthOp = sqlite3VdbeAddOp0(v, 9);\n    } else {\n        sqlite3VdbeAddOp4(v, 96, rLhs, nVector, 0, zAff, nVector);\n        if (destIfFalse == destIfNull) {\n            sqlite3VdbeAddOp4Int(v, 28, iTab, destIfFalse, rLhs, nVector);\n            ;\n            goto sqlite3ExprCodeIN_finished;\n        }\n        addrTruthOp = sqlite3VdbeAddOp4Int(v, 29, iTab, 0, rLhs, nVector);\n        ;\n    }\n    if (rRhsHasNull && nVector == 1) {\n        sqlite3VdbeAddOp2(v, 51, rRhsHasNull, destIfFalse);\n        ;\n    }\n    if (destIfFalse == destIfNull)\n        sqlite3VdbeGoto(v, destIfFalse);\n    if (destStep6)\n        sqlite3VdbeResolveLabel(v, destStep6);\n    addrTop = sqlite3VdbeAddOp2(v, 36, iTab, destIfFalse);\n    ;\n    if (nVector > 1) {\n        destNotNull = sqlite3VdbeMakeLabel(pParse);\n    } else {\n        destNotNull = destIfFalse;\n    }\n    for (i = 0; i < nVector; i++) {\n        Expr *p;\n        CollSeq *pColl;\n        int r3 = sqlite3GetTempReg(pParse);\n        p = sqlite3VectorFieldSubexpr(pLeft, i);\n        pColl = sqlite3ExprCollSeq(pParse, p);\n        sqlite3VdbeAddOp3(v, 94, iTab, i, r3);\n        sqlite3VdbeAddOp4(v, 52, rLhs + i, destNotNull, r3, (void *)pColl, (-2));\n        ;\n        sqlite3ReleaseTempReg(pParse, r3);\n    }\n    sqlite3VdbeAddOp2(v, 9, 0, destIfNull);\n    if (nVector > 1) {\n        sqlite3VdbeResolveLabel(v, destNotNull);\n        sqlite3VdbeAddOp2(v, 39, iTab, addrTop + 1);\n        ;\n        sqlite3VdbeAddOp2(v, 9, 0, destIfFalse);\n    }\n    sqlite3VdbeJumpHere(v, addrTruthOp);\n  sqlite3ExprCodeIN_finished:\n    if (rLhs != rLhsOrig)\n        sqlite3ReleaseTempReg(pParse, rLhs);\n    ;\n  sqlite3ExprCodeIN_oom_error:\n    sqlite3DbFree(pParse->db, aiMap);\n    sqlite3DbFree(pParse->db, zAff);\n}\n"
        },
        {
            "id": "#23:25#sqlite3BtreeIntegrityCheck",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    Pgno i;\n    IntegrityCk sCheck;\n    BtShared *pBt = p->pBt;\n    u64 savedDbFlags = pBt->db->flags;\n    char zErr[100];\n    int bPartial = 0;\n    int bCkFreelist = 1;\n    ;\n    assert(nRoot > 0);\n    if (aRoot[0] == 0) {\n        assert(nRoot > 1);\n        bPartial = 1;\n        if (aRoot[1] != 1)\n            bCkFreelist = 0;\n    }\n    sqlite3BtreeEnter(p);\n    assert(p->inTrans > 0 && pBt->inTransaction > 0);\n    ;\n    sCheck.db = db;\n    sCheck.pBt = pBt;\n    sCheck.pPager = pBt->pPager;\n    sCheck.nPage = btreePagecount(sCheck.pBt);\n    sCheck.mxErr = mxErr;\n    sCheck.nErr = 0;\n    sCheck.bOomFault = 0;\n    sCheck.zPfx = 0;\n    sCheck.v1 = 0;\n    sCheck.v2 = 0;\n    sCheck.aPgRef = 0;\n    sCheck.heap = 0;\n    sqlite3StrAccumInit(&sCheck.errMsg, 0, zErr, sizeof (zErr), 1000000000);\n    sCheck.errMsg.printfFlags = 1;\n    if (sCheck.nPage == 0) {\n        goto integrity_ck_cleanup;\n    }\n    sCheck.aPgRef = sqlite3MallocZero((sCheck.nPage / 8) + 1);\n    if (!sCheck.aPgRef) {\n        sCheck.bOomFault = 1;\n        goto integrity_ck_cleanup;\n    }\n    sCheck.heap = (u32 *)sqlite3PageMalloc(pBt->pageSize);\n    if (sCheck.heap == 0) {\n        sCheck.bOomFault = 1;\n        goto integrity_ck_cleanup;\n    }\n    i = ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1));\n    if (i <= sCheck.nPage)\n        setPageReferenced(&sCheck, i);\n    if (bCkFreelist) {\n        sCheck.zPfx = \"Main freelist: \";\n        checkList(&sCheck, 1, sqlite3Get4byte(&pBt->pPage1->aData[32]), sqlite3Get4byte(&pBt->pPage1->aData[36]));\n        sCheck.zPfx = 0;\n    }\n    if (!bPartial) {\n        if (pBt->autoVacuum) {\n            Pgno mx = 0;\n            Pgno mxInHdr;\n            for (i = 0; (int)i < nRoot; i++)\n                if (mx < aRoot[i])\n                    mx = aRoot[i];\n            mxInHdr = sqlite3Get4byte(&pBt->pPage1->aData[52]);\n            if (mx != mxInHdr) {\n                checkAppendMsg(&sCheck, \"max rootpage (%d) disagrees with header (%d)\", mx, mxInHdr);\n            }\n        } else if (sqlite3Get4byte(&pBt->pPage1->aData[64]) != 0) {\n            checkAppendMsg(&sCheck, \"incremental_vacuum enabled with a max rootpage of zero\");\n        }\n    }\n    ;\n    pBt->db->flags &= ~(u64)2097152;\n    for (i = 0; (int)i < nRoot && sCheck.mxErr; i++) {\n        i64 notUsed;\n        if (aRoot[i] == 0)\n            continue;\n        if (pBt->autoVacuum && aRoot[i] > 1 && !bPartial) {\n            checkPtrmap(&sCheck, aRoot[i], 1, 0);\n        }\n        checkTreePage(&sCheck, aRoot[i], &notUsed, (4294967295U | (((i64)2147483647) << 32)));\n    }\n    pBt->db->flags = savedDbFlags;\n    if (!bPartial) {\n        for (i = 1; i <= sCheck.nPage && sCheck.mxErr; i++) {\n            if (getPageReferenced(&sCheck, i) == 0 && (ptrmapPageno(pBt, i) != i || !pBt->autoVacuum)) {\n                checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n            }\n            if (getPageReferenced(&sCheck, i) != 0 && (ptrmapPageno(pBt, i) == i && pBt->autoVacuum)) {\n                checkAppendMsg(&sCheck, \"Pointer map page %d is referenced\", i);\n            }\n        }\n    }\n  integrity_ck_cleanup:\n    sqlite3PageFree(sCheck.heap);\n    sqlite3_free(sCheck.aPgRef);\n    if (sCheck.bOomFault) {\n        sqlite3_str_reset(&sCheck.errMsg);\n        sCheck.nErr++;\n    }\n    *pnErr = sCheck.nErr;\n    if (sCheck.nErr == 0)\n        sqlite3_str_reset(&sCheck.errMsg);\n    sqlite3BtreeLeave(p);\n    return sqlite3StrAccumFinish(&sCheck.errMsg);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#113618:1#dropColumnFunc",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    int iSchema = sqlite3_value_int(argv[0]);\n    const char *zSql = (const char *)sqlite3_value_text(argv[1]);\n    int iCol = sqlite3_value_int(argv[2]);\n    const char *zDb = db->aDb[iSchema].zDbSName;\n    int rc;\n    Parse sParse;\n    RenameToken *pCol;\n    Table *pTab;\n    const char *zEnd;\n    char *zNew = 0;\n    sqlite3_xauth xAuth = db->xAuth;\n    db->xAuth = 0;\n    (void)(NotUsed);\n    rc = renameParseSql(&sParse, zDb, db, zSql, iSchema == 1);\n    if (rc != 0)\n        goto drop_column_done;\n    pTab = sParse.pNewTable;\n    if (pTab == 0 || pTab->nCol == 1 || iCol >= pTab->nCol) {\n        rc = sqlite3CorruptError(113646);\n        goto drop_column_done;\n    }\n    pCol = renameTokenFind(&sParse, 0, (void *)pTab->aCol[iCol].zCnName);\n    if (iCol < pTab->nCol - 1) {\n        RenameToken *pEnd;\n        pEnd = renameTokenFind(&sParse, 0, (void *)pTab->aCol[iCol + 1].zCnName);\n        zEnd = (const char *)pEnd->t.z;\n    } else {\n        assert(((pTab)->eTabType == 0));\n        zEnd = (const char *)&zSql[pTab->u.tab.addColOffset];\n        while ((pCol->t.z[0] != 0) && pCol->t.z[0] != ',')\n            pCol->t.z--;\n    }\n    zNew = sqlite3MPrintf(db, \"%.*s%s\", pCol->t.z - zSql, zSql, zEnd);\n    sqlite3_result_text(context, zNew, -1, ((sqlite3_destructor_type)-1));\n    sqlite3_free(zNew);\n  drop_column_done:\n    renameParseCleanup(&sParse);\n    db->xAuth = xAuth;\n    if (rc != 0) {\n        sqlite3_result_error_code(context, rc);\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#43827:1#proxyBreakConchLock",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    unixFile *conchFile = pCtx->conchFile;\n    char tPath;\n    char buf;\n    char *cPath = pCtx->conchFilePath;\n    char errmsg[64] = \"\";\n    int fd = -1;\n    int rc = -1;\n    (void)(<recovery-expr>());\n    if (<recovery-expr>()) {\n        goto end_breaklock;\n    }\n    if (<recovery-expr>()) {\n        goto end_breaklock;\n    }\n    if (fd < 0) {\n        goto end_breaklock;\n    }\n    if (<recovery-expr>()) {\n        goto end_breaklock;\n    }\n    if (rename(<recovery-expr>(), cPath)) {\n        goto end_breaklock;\n    }\n    rc = 0;\n    robust_close(pFile, conchFile->h, 43869);\n    conchFile->h = fd;\n  end_breaklock:\n    if (rc) {\n        if (fd >= 0) {\n            ((int (*)(const char *))aSyscall[16].pCurrent)(<recovery-expr>());\n            robust_close(pFile, fd, 43877);\n        }\n    }\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#23498:1#getDigits",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    static const u16 aMx[] = {12, 14, 24, 31, 59, 9999};\n    int cnt = 0;\n    char nextC;\n    do {\n        char N = zFormat[0] - '0';\n        char min = zFormat[1] - '0';\n        int val = 0;\n        u16 max;\n        assert(zFormat[2] >= 'a' && zFormat[2] <= 'f');\n        max = aMx[zFormat[2] - 'a'];\n        nextC = zFormat[3];\n        val = 0;\n        while (N--)\n            {\n                if (!(sqlite3CtypeMap[(unsigned char)(*zDate)] & 4)) {\n                    goto end_getDigits;\n                }\n                val = val * 10 + *zDate - '0';\n                zDate++;\n            }\n        if (val < (int)min || val > (int)max || (nextC != 0 && nextC != *zDate)) {\n            goto end_getDigits;\n        }\n        zDate++;\n        cnt++;\n        zFormat += 4;\n    } while (nextC);\n  end_getDigits:\n    ;\n    return cnt;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#42734:1#unixOpen",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    unixFile *p = (unixFile *)pFile;\n    int fd = -1;\n    int openFlags = 0;\n    int eType = flags & 1048320;\n    int noLock;\n    int rc = 0;\n    int ctrlFlags = 0;\n    int isExclusive = (flags & 16);\n    int isDelete = (flags & 8);\n    int isCreate = (flags & 4);\n    int isReadonly = (flags & 1);\n    int isReadWrite = (flags & 2);\n    int isAutoProxy = (flags & 32);\n    struct statfs fsInfo;\n    int isNewJrnl = (isCreate && (eType == 16384 || eType == 2048 || eType == 524288));\n    char zTmpname[514];\n    const char *zName = zPath;\n    assert((isReadonly == 0 || isReadWrite == 0) && (isReadWrite || isReadonly));\n    assert(isCreate == 0 || isReadWrite);\n    assert(isExclusive == 0 || isCreate);\n    assert(isDelete == 0 || isCreate);\n    assert((!isDelete && zName) || eType != 256);\n    assert((!isDelete && zName) || eType != 2048);\n    assert((!isDelete && zName) || eType != 16384);\n    assert((!isDelete && zName) || eType != 524288);\n    assert(eType == 256 || eType == 512 || eType == 2048 || eType == 4096 || eType == 8192 || eType == 16384 || eType == 1024 || eType == 524288);\n    if (<recovery-expr>()) {\n        sqlite3_randomness(0, 0);\n    }\n    memset(p, 0, sizeof(unixFile));\n    if (eType == 256) {\n        UnixUnusedFd *pUnused;\n        pUnused = findReusableFd(zName, flags);\n        if (pUnused) {\n            fd = pUnused->fd;\n        } else {\n            pUnused = sqlite3_malloc64(sizeof (*pUnused));\n            if (!pUnused) {\n                return 7;\n            }\n        }\n        p->pPreallocatedUnused = pUnused;\n        assert((flags & 64) || zName[strlen(zName) + 1] == 0);\n    } else if (!zName) {\n        assert(isDelete && !isNewJrnl);\n        rc = unixGetTempname(pVfs->mxPathname, zTmpname);\n        if (rc != 0) {\n            return rc;\n        }\n        zName = zTmpname;\n        assert(zName[strlen(zName) + 1] == 0);\n    }\n    openFlags |= (0 | 0 | 0);\n    if (fd < 0) {\n        if (rc != 0) {\n            assert(!p->pPreallocatedUnused);\n            assert(eType == 524288 || eType == 2048);\n            return rc;\n        }\n        ;\n        if (fd < 0) {\n            if (<recovery-expr>()) {\n                rc = (8 | (6 << 8));\n            } else if (<recovery-expr>()) {\n                flags &= ~(2 | 4);\n                flags |= 1;\n                isReadonly = 1;\n            }\n        }\n        if (fd < 0) {\n            int rc2 = unixLogErrorAtLine(sqlite3CantopenError(42890), \"open\", zName, 42890);\n            if (rc == 0)\n                rc = rc2;\n            goto open_finished;\n        }\n        if (<recovery-expr>()) {\n        }\n    }\n    assert(fd >= 0);\n    if (pOutFlags) {\n        *pOutFlags = flags;\n    }\n    if (p->pPreallocatedUnused) {\n        p->pPreallocatedUnused->fd = fd;\n        p->pPreallocatedUnused->flags = flags & (1 | 2);\n    }\n    if (isDelete) {\n        ((int (*)(const char *))aSyscall[16].pCurrent)(zName);\n    } else {\n        p->openFlags = openFlags;\n    }\n    if (fstatfs(fd, &<recovery-expr>()) == -1) {\n        robust_close(p, fd, 42944);\n        return (10 | (13 << 8));\n    }\n    if (0 == strncmp(\"msdos\", <recovery-expr>().f_fstypename, 5)) {\n        ((unixFile *)pFile)->fsFlags |= 1;\n    }\n    if (0 == strncmp(\"exfat\", <recovery-expr>().f_fstypename, 5)) {\n        ((unixFile *)pFile)->fsFlags |= 1;\n    }\n    if (isDelete)\n        ctrlFlags |= 32;\n    if (isReadonly)\n        ctrlFlags |= 2;\n    noLock = eType != 256;\n    if (noLock)\n        ctrlFlags |= 128;\n    if (isNewJrnl)\n        ctrlFlags |= 8;\n    if (flags & 64)\n        ctrlFlags |= 64;\n    if (<recovery-expr>()) {\n        char *envforce = getenv(\"SQLITE_FORCE_PROXY_LOCKING\");\n        int useProxy = 0;\n        if (<recovery-expr>()) {\n            useProxy = atoi(envforce) > 0;\n        } else {\n        }\n        if (useProxy) {\n            rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);\n            if (rc == 0) {\n                rc = proxyTransformUnixFile((unixFile *)pFile, \":auto:\");\n                if (rc != 0) {\n                    unixClose(pFile);\n                    return rc;\n                }\n            }\n            goto open_finished;\n        }\n    }\n    assert(zPath == 0 || zPath[0] == '/' || eType == 16384 || eType == 2048);\n    rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);\n  open_finished:\n    if (rc != 0) {\n        sqlite3_free(p->pPreallocatedUnused);\n    }\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3ExprIfFalse",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    assert(jumpIfNull == 16 || jumpIfNull == 0);\n    if ((v == 0))\n        return;\n    if (pExpr == 0)\n        return;\n    assert(!0);\n    op = ((pExpr->op + (50 & 1)) ^ 1) - (50 & 1);\n    assert(pExpr->op != 50 || op == 51);\n    assert(pExpr->op != 51 || op == 50);\n    assert(pExpr->op != 52 || op == 53);\n    assert(pExpr->op != 53 || op == 52);\n    assert(pExpr->op != 56 || op == 57);\n    assert(pExpr->op != 55 || op == 54);\n    assert(pExpr->op != 54 || op == 55);\n    assert(pExpr->op != 57 || op == 56);\n    switch (pExpr->op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);\n            } else if (pExpr->op == 44) {\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n            } else {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            } else {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (pExpr->op == 45) ? 52 : 53;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            assert(56 == 56);\n            ;\n            ;\n            assert(55 == 55);\n            ;\n            ;\n            assert(54 == 54);\n            ;\n            ;\n            assert(57 == 57);\n            ;\n            ;\n            assert(53 == 53);\n            ;\n            ;\n            ;\n            assert(52 == 52);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            if (jumpIfNull) {\n                sqlite3ExprCodeIN(pParse, pExpr, dest, dest);\n            } else {\n                int destIfNull = sqlite3VdbeMakeLabel(pParse);\n                sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);\n                sqlite3VdbeResolveLabel(v, destIfNull);\n            }\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 17, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#30033:12#sqlite3_str_vappendf",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    int c;\n    char *bufpt;\n    int precision;\n    int length;\n    int idx;\n    int width;\n    etByte flag_leftjustify;\n    etByte flag_prefix;\n    etByte flag_alternateform;\n    etByte flag_altform2;\n    etByte flag_zeropad;\n    etByte flag_long;\n    etByte done;\n    etByte cThousand;\n    etByte xtype = 17;\n    u8 bArgList;\n    char prefix;\n    sqlite_uint64 longvalue;\n    long double realvalue;\n    const et_info *infop;\n    char *zOut;\n    int nOut;\n    char *zExtra = 0;\n    int exp, e2;\n    int nsd;\n    double rounder;\n    etByte flag_dp;\n    etByte flag_rtz;\n    PrintfArguments *pArgList = 0;\n    char buf[70];\n    assert(pAccum->nChar > 0 || (pAccum->printfFlags & 4) == 0);\n    bufpt = 0;\n    if ((pAccum->printfFlags & 2) != 0) {\n        bArgList = 1;\n    } else {\n        bArgList = 0;\n    }\n    for (; (c = (*fmt)) != 0; ++fmt) {\n        if (c != '%') {\n            bufpt = (char *)fmt;\n            do {\n                fmt++;\n            } while (*fmt && *fmt != '%');\n            sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));\n            if (*fmt == 0)\n                break;\n        }\n        if ((c = (*++fmt)) == 0) {\n            sqlite3_str_append(pAccum, \"%\", 1);\n            break;\n        }\n        flag_leftjustify = flag_prefix = cThousand = flag_alternateform = flag_altform2 = flag_zeropad = 0;\n        done = 0;\n        width = 0;\n        flag_long = 0;\n        precision = -1;\n        do {\n            switch (c) {\n              case '-':\n                flag_leftjustify = 1;\n                break;\n              case '+':\n                flag_prefix = '+';\n                break;\n              case ' ':\n                flag_prefix = ' ';\n                break;\n              case '#':\n                flag_alternateform = 1;\n                break;\n              case '!':\n                flag_altform2 = 1;\n                break;\n              case '0':\n                flag_zeropad = 1;\n                break;\n              case ',':\n                cThousand = ',';\n                break;\n              default:\n                done = 1;\n                break;\n              case 'l':\n                {\n                    flag_long = 1;\n                    c = *++fmt;\n                    if (c == 'l') {\n                        c = *++fmt;\n                        flag_long = 2;\n                    }\n                    done = 1;\n                    break;\n                }\n              case '1':\n              case '2':\n              case '3':\n              case '4':\n              case '5':\n              case '6':\n              case '7':\n              case '8':\n              case '9':\n                {\n                    unsigned int wx = c - '0';\n                    while ((c = *++fmt) >= '0' && c <= '9')\n                        {\n                            wx = wx * 10 + c - '0';\n                        }\n                    ;\n                    width = wx & 2147483647;\n                    if (c != '.' && c != 'l') {\n                        done = 1;\n                    } else {\n                        fmt--;\n                    }\n                    break;\n                }\n              case '*':\n                {\n                    if (bArgList) {\n                        width = (int)getIntArg(pArgList);\n                    } else {\n                    }\n                    if (width < 0) {\n                        flag_leftjustify = 1;\n                        width = width >= -2147483647 ? -width : 0;\n                    }\n                    if ((c = fmt[1]) != '.' && c != 'l') {\n                        c = *++fmt;\n                        done = 1;\n                    }\n                    break;\n                }\n              case '.':\n                {\n                    c = *++fmt;\n                    if (c == '*') {\n                        if (bArgList) {\n                            precision = (int)getIntArg(pArgList);\n                        } else {\n                        }\n                        if (precision < 0) {\n                            precision = precision >= -2147483647 ? -precision : -1;\n                        }\n                        c = *++fmt;\n                    } else {\n                        unsigned int px = 0;\n                        while (c >= '0' && c <= '9')\n                            {\n                                px = px * 10 + c - '0';\n                                c = *++fmt;\n                            }\n                        ;\n                        precision = px & 2147483647;\n                    }\n                    if (c == 'l') {\n                        --fmt;\n                    } else {\n                        done = 1;\n                    }\n                    break;\n                }\n            }\n        } while (!done && (c = (*++fmt)) != 0);\n        infop = &fmtinfo[0];\n        xtype = 17;\n        for (idx = 0; idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0]))); idx++) {\n            if (c == fmtinfo[idx].fmttype) {\n                infop = &fmtinfo[idx];\n                xtype = infop->type;\n                break;\n            }\n        }\n        assert(width >= 0);\n        assert(precision >= (-1));\n        switch (xtype) {\n          case 13:\n            flag_long = sizeof(char *) == sizeof(i64) ? 2 : sizeof(char *) == sizeof(long) ? 1 : 0;\n          case 15:\n          case 0:\n            cThousand = 0;\n          case 16:\n            if (infop->flags & 1) {\n                i64 v;\n                if (bArgList) {\n                    v = getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        v = va_arg(<recovery-expr>(), <recovery-expr>());\n                    } else {\n                    }\n                } else {\n                }\n                if (v < 0) {\n                    ;\n                    ;\n                    longvalue = ~v;\n                    longvalue++;\n                    prefix = '-';\n                } else {\n                    longvalue = v;\n                    prefix = flag_prefix;\n                }\n            } else {\n                if (bArgList) {\n                    longvalue = (u64)getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        longvalue = va_arg(<recovery-expr>(), <recovery-expr>());\n                    } else {\n                    }\n                } else {\n                }\n                prefix = 0;\n            }\n            if (longvalue == 0)\n                flag_alternateform = 0;\n            if (flag_zeropad && precision < width - (prefix != 0)) {\n                precision = width - (prefix != 0);\n            }\n            if (precision < 70 - 10 - 70 / 3) {\n                nOut = 70;\n                zOut = buf;\n            } else {\n                u64 n;\n                n = (u64)precision + 10;\n                if (cThousand)\n                    n += precision / 3;\n                zOut = zExtra = printfTempBuf(pAccum, n);\n                if (zOut == 0)\n                    return;\n                nOut = (int)n;\n            }\n            bufpt = &zOut[nOut - 1];\n            if (xtype == 15) {\n                static const char zOrd[] = \"thstndrd\";\n                int x = (int)(longvalue % 10);\n                if (x >= 4 || (longvalue / 10) % 10 == 1) {\n                    x = 0;\n                }\n                *(--bufpt) = zOrd[x * 2 + 1];\n                *(--bufpt) = zOrd[x * 2];\n            }\n            {\n                const char *cset = &aDigits[infop->charset];\n                u8 base = infop->base;\n                do {\n                    *(--bufpt) = cset[longvalue % base];\n                    longvalue = longvalue / base;\n                } while (longvalue > 0);\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            while (precision > length)\n                {\n                    *(--bufpt) = '0';\n                    length++;\n                }\n            if (cThousand) {\n                int nn = (length - 1) / 3;\n                int ix = (length - 1) % 3 + 1;\n                bufpt -= nn;\n                for (idx = 0; nn > 0; idx++) {\n                    bufpt[idx] = bufpt[idx + nn];\n                    ix--;\n                    if (ix == 0) {\n                        bufpt[++idx] = cThousand;\n                        nn--;\n                        ix = 3;\n                    }\n                }\n            }\n            if (prefix)\n                *(--bufpt) = prefix;\n            if (flag_alternateform && infop->prefix) {\n                const char *pre;\n                char x;\n                pre = &aPrefix[infop->prefix];\n                for (; (x = (*pre)) != 0; pre++)\n                    *(--bufpt) = x;\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            break;\n          case 1:\n          case 2:\n          case 3:\n            if (bArgList) {\n                realvalue = getDoubleArg(pArgList);\n            } else {\n            }\n            if (precision < 0)\n                precision = 6;\n            if (precision > 100000000) {\n                precision = 100000000;\n            }\n            if (realvalue < 0.) {\n                realvalue = -realvalue;\n                prefix = '-';\n            } else {\n                prefix = flag_prefix;\n            }\n            if (xtype == 3 && precision > 0)\n                precision--;\n            ;\n            idx = precision & 4095;\n            rounder = arRound[idx % 10];\n            while (idx >= 10)\n                {\n                    rounder *= 1.0E-10;\n                    idx -= 10;\n                }\n            if (xtype == 1) {\n                double rx = (double)realvalue;\n                sqlite3_uint64 u;\n                int ex;\n                memcpy(&u, &rx, sizeof (u));\n                ex = -1023 + (int)((u >> 52) & 2047);\n                if (precision + (ex / 3) < 15)\n                    rounder += realvalue * 2.9999999999999999E-16;\n                realvalue += rounder;\n            }\n            exp = 0;\n            if (sqlite3IsNaN((double)realvalue)) {\n                bufpt = \"NaN\";\n                length = 3;\n                break;\n            }\n            if (realvalue > 0.) {\n                long double scale = 1.;\n                while (realvalue >= 1.0E+100 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+100;\n                        exp += 100;\n                    }\n                while (realvalue >= 1.0E+10 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+10;\n                        exp += 10;\n                    }\n                while (realvalue >= 10. * scale && exp <= 350)\n                    {\n                        scale *= 10.;\n                        exp++;\n                    }\n                realvalue /= scale;\n                while (realvalue < 1.0E-8)\n                    {\n                        realvalue *= 1.0E+8;\n                        exp -= 8;\n                    }\n                while (realvalue < 1.)\n                    {\n                        realvalue *= 10.;\n                        exp--;\n                    }\n                if (exp > 350) {\n                    bufpt = buf;\n                    buf[0] = prefix;\n                    memcpy(buf + (prefix != 0), \"Inf\", 4);\n                    length = 3 + (prefix != 0);\n                    break;\n                }\n            }\n            bufpt = buf;\n            if (xtype != 1) {\n                realvalue += rounder;\n                if (realvalue >= 10.) {\n                    realvalue *= 0.10000000000000001;\n                    exp++;\n                }\n            }\n            if (xtype == 3) {\n                flag_rtz = !flag_alternateform;\n                if (exp < -4 || exp > precision) {\n                    xtype = 2;\n                } else {\n                    precision = precision - exp;\n                    xtype = 1;\n                }\n            } else {\n                flag_rtz = flag_altform2;\n            }\n            if (xtype == 2) {\n                e2 = 0;\n            } else {\n                e2 = exp;\n            }\n            {\n                i64 szBufNeeded;\n                szBufNeeded = ((e2) > (0) ? (e2) : (0)) + (i64)precision + (i64)width + 15;\n                if (szBufNeeded > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);\n                    if (bufpt == 0)\n                        return;\n                }\n            }\n            zOut = bufpt;\n            nsd = 16 + flag_altform2 * 10;\n            flag_dp = (precision > 0 ? 1 : 0) | flag_alternateform | flag_altform2;\n            if (prefix) {\n                *(bufpt++) = prefix;\n            }\n            if (e2 < 0) {\n                *(bufpt++) = '0';\n            } else {\n                for (; e2 >= 0; e2--) {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            }\n            if (flag_dp) {\n                *(bufpt++) = '.';\n            }\n            for (e2++; e2 < 0; precision-- , e2++) {\n                assert(precision > 0);\n                *(bufpt++) = '0';\n            }\n            while ((precision--) > 0)\n                {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            if (flag_rtz && flag_dp) {\n                while (bufpt[-1] == '0')\n                    *(--bufpt) = 0;\n                assert(bufpt > zOut);\n                if (bufpt[-1] == '.') {\n                    if (flag_altform2) {\n                        *(bufpt++) = '0';\n                    } else {\n                        *(--bufpt) = 0;\n                    }\n                }\n            }\n            if (xtype == 2) {\n                *(bufpt++) = aDigits[infop->charset];\n                if (exp < 0) {\n                    *(bufpt++) = '-';\n                    exp = -exp;\n                } else {\n                    *(bufpt++) = '+';\n                }\n                if (exp >= 100) {\n                    *(bufpt++) = (char)((exp / 100) + '0');\n                    exp %= 100;\n                }\n                *(bufpt++) = (char)(exp / 10 + '0');\n                *(bufpt++) = (char)(exp % 10 + '0');\n            }\n            *bufpt = 0;\n            length = (int)(bufpt - zOut);\n            bufpt = zOut;\n            if (flag_zeropad && !flag_leftjustify && length < width) {\n                int i;\n                int nPad = width - length;\n                for (i = width; i >= nPad; i--) {\n                    bufpt[i] = bufpt[i - nPad];\n                }\n                i = prefix != 0;\n                while (nPad--)\n                    bufpt[i++] = '0';\n                length = width;\n            }\n            break;\n          case 4:\n            if (!bArgList) {\n            }\n            length = width = 0;\n            break;\n          case 7:\n            buf[0] = '%';\n            bufpt = buf;\n            length = 1;\n            break;\n          case 8:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                length = 1;\n                if (bufpt) {\n                    buf[0] = c = *(bufpt++);\n                    if ((c & 192) == 192) {\n                        while (length < 4 && (bufpt[0] & 192) == 128)\n                            {\n                                buf[length++] = *(bufpt++);\n                            }\n                    }\n                } else {\n                    buf[0] = 0;\n                }\n            } else {\n                unsigned int ch;\n                if (ch < 128) {\n                    buf[0] = ch & 255;\n                    length = 1;\n                } else if (ch < 2048) {\n                    buf[0] = 192 + (u8)((ch >> 6) & 31);\n                    buf[1] = 128 + (u8)(ch & 63);\n                    length = 2;\n                } else if (ch < 65536) {\n                    buf[0] = 224 + (u8)((ch >> 12) & 15);\n                    buf[1] = 128 + (u8)((ch >> 6) & 63);\n                    buf[2] = 128 + (u8)(ch & 63);\n                    length = 3;\n                } else {\n                    buf[0] = 240 + (u8)((ch >> 18) & 7);\n                    buf[1] = 128 + (u8)((ch >> 12) & 63);\n                    buf[2] = 128 + (u8)((ch >> 6) & 63);\n                    buf[3] = 128 + (u8)(ch & 63);\n                    length = 4;\n                }\n            }\n            if (precision > 1) {\n                width -= precision - 1;\n                if (width > 1 && !flag_leftjustify) {\n                    sqlite3_str_appendchar(pAccum, width - 1, ' ');\n                    width = 0;\n                }\n                while (precision-- > 1)\n                    {\n                        sqlite3_str_append(pAccum, buf, length);\n                    }\n            }\n            bufpt = buf;\n            flag_altform2 = 1;\n            goto adjust_width_for_utf8;\n          case 5:\n          case 6:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                xtype = 5;\n            } else {\n            }\n            if (bufpt == 0) {\n                bufpt = \"\";\n            } else if (xtype == 6) {\n                if (pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 && pAccum->accError == 0) {\n                    assert((pAccum->printfFlags & 4) == 0);\n                    pAccum->zText = bufpt;\n                    pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);\n                    pAccum->nChar = 2147483647 & (int)strlen(bufpt);\n                    pAccum->printfFlags |= 4;\n                    length = 0;\n                    break;\n                }\n                zExtra = bufpt;\n            }\n            if (precision >= 0) {\n                if (flag_altform2) {\n                    unsigned char *z = (unsigned char *)bufpt;\n                    while (precision-- > 0 && z[0])\n                        {\n                            {\n                                if ((*(z++)) >= 192) {\n                                    while ((*z & 192) == 128)\n                                        {\n                                            z++;\n                                        }\n                                }\n                            }\n                            ;\n                        }\n                    length = (int)(z - (unsigned char *)bufpt);\n                } else {\n                    for (length = 0; length < precision && bufpt[length]; length++) {\n                    }\n                }\n            } else {\n                length = 2147483647 & (int)strlen(bufpt);\n            }\n          adjust_width_for_utf8:\n            if (flag_altform2 && width > 0) {\n                int ii = length - 1;\n                while (ii >= 0)\n                    if ((bufpt[ii--] & 192) == 128)\n                        width++;\n            }\n            break;\n          case 9:\n          case 10:\n          case 14:\n            {\n                i64 i, j, k, n;\n                int needQuote, isnull;\n                char ch;\n                char q = ((xtype == 14) ? '\"' : '\\'');\n                char *escarg;\n                if (bArgList) {\n                    escarg = getTextArg(pArgList);\n                } else {\n                }\n                isnull = escarg == 0;\n                if (isnull)\n                    escarg = (xtype == 10 ? \"NULL\" : \"(NULL)\");\n                k = precision;\n                for (i = n = 0; k != 0 && (ch = escarg[i]) != 0; i++ , k--) {\n                    if (ch == q)\n                        n++;\n                    if (flag_altform2 && (ch & 192) == 192) {\n                        while ((escarg[i + 1] & 192) == 128)\n                            {\n                                i++;\n                            }\n                    }\n                }\n                needQuote = !isnull && xtype == 10;\n                n += i + 3;\n                if (n > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, n);\n                    if (bufpt == 0)\n                        return;\n                } else {\n                    bufpt = buf;\n                }\n                j = 0;\n                if (needQuote)\n                    bufpt[j++] = q;\n                k = i;\n                for (i = 0; i < k; i++) {\n                    bufpt[j++] = ch = escarg[i];\n                    if (ch == q)\n                        bufpt[j++] = ch;\n                }\n                if (needQuote)\n                    bufpt[j++] = q;\n                bufpt[j] = 0;\n                length = j;\n                goto adjust_width_for_utf8;\n            }\n          case 11:\n            {\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                if (flag_alternateform) {\n                    Expr *pExpr;\n                    if ((pExpr) && (!(((pExpr)->flags & (2048)) != 0))) {\n                        sqlite3_str_appendall(pAccum, (const char *)pExpr->u.zToken);\n                        sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);\n                    }\n                } else {\n                    Token *pToken;\n                    assert(bArgList == 0);\n                    if (pToken && pToken->n) {\n                        sqlite3_str_append(pAccum, (const char *)pToken->z, pToken->n);\n                        sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          case 12:\n            {\n                SrcItem *pItem;\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                assert(bArgList == 0);\n                if (pItem->zAlias && !flag_altform2) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else if (pItem->zName) {\n                    if (pItem->zDatabase) {\n                        sqlite3_str_appendall(pAccum, pItem->zDatabase);\n                        sqlite3_str_append(pAccum, \".\", 1);\n                    }\n                    sqlite3_str_appendall(pAccum, pItem->zName);\n                } else if (pItem->zAlias) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else {\n                    Select *pSel = pItem->pSelect;\n                    assert(pSel != 0);\n                    if (pSel->selFlags & 2048) {\n                        sqlite3_str_appendf(pAccum, \"(join-%u)\", pSel->selId);\n                    } else {\n                        sqlite3_str_appendf(pAccum, \"(subquery-%u)\", pSel->selId);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          default:\n            {\n                assert(xtype == 17);\n                return;\n            }\n        }\n        width -= length;\n        if (width > 0) {\n            if (!flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n            sqlite3_str_append(pAccum, bufpt, length);\n            if (flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n        } else {\n            sqlite3_str_append(pAccum, bufpt, length);\n        }\n        if (zExtra) {\n            sqlite3DbFree(pAccum->db, zExtra);\n            zExtra = 0;\n        }\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#198948:1#jsonRemoveFunc",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    if (argc < 1)\n        return;\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    assert(x.nNode);\n    for (i = 1; i < (u32)argc; i++) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        if (zPath == 0)\n            goto remove_done;\n        pNode = jsonLookup(&x, zPath, 0, ctx);\n        if (x.nErr)\n            goto remove_done;\n        if (pNode)\n            pNode->jnFlags |= 4;\n    }\n    if ((x.aNode[0].jnFlags & 4) == 0) {\n        jsonReturnJson(x.aNode, ctx, 0);\n    }\n  remove_done:\n    jsonParseReset(&x);\n}\n"
        },
        {
            "id": "#23:25#sqlite3WhereCodeOneLoopStart",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int j, k;\n    int iCur;\n    int addrNxt;\n    int bRev;\n    WhereLoop *pLoop;\n    WhereClause *pWC;\n    WhereTerm *pTerm;\n    sqlite3 *db;\n    SrcItem *pTabItem;\n    int addrBrk;\n    int addrHalt;\n    int addrCont;\n    int iRowidReg = 0;\n    int iReleaseReg = 0;\n    Index *pIdx = 0;\n    int iLoop;\n    pWC = &pWInfo->sWC;\n    db = pParse->db;\n    pLoop = pLevel->pWLoop;\n    pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];\n    iCur = pTabItem->iCursor;\n    pLevel->notReady = notReady & ~sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);\n    bRev = (pWInfo->revMask >> iLevel) & 1;\n    ;\n    addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);\n    addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(pParse);\n    assert((pWInfo->wctrlFlags & (32 | 4096)) || pLevel->iFrom > 0 || (pTabItem[0].fg.jointype & 8) == 0);\n    if (pLevel->iFrom > 0 && (pTabItem[0].fg.jointype & 8) != 0) {\n        pLevel->iLeftJoin = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, pLevel->iLeftJoin);\n        ;\n    }\n    for (j = iLevel; j > 0; j--) {\n        if (pWInfo->a[j].iLeftJoin)\n            break;\n        if (pWInfo->a[j].pRJ)\n            break;\n    }\n    addrHalt = pWInfo->a[j].addrBrk;\n    if (pTabItem->fg.viaCoroutine) {\n        int regYield = pTabItem->regReturn;\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, pTabItem->addrFillSub);\n        pLevel->p2 = sqlite3VdbeAddOp2(v, 12, regYield, addrBrk);\n        ;\n        ;\n        pLevel->op = 9;\n    } else if ((pLoop->wsFlags & 1024) != 0) {\n        int iReg;\n        int addrNotFound;\n        int nConstraint = pLoop->nLTerm;\n        iReg = sqlite3GetTempRange(pParse, nConstraint + 2);\n        addrNotFound = pLevel->addrBrk;\n        for (j = 0; j < nConstraint; j++) {\n            int iTarget = iReg + j + 2;\n            pTerm = pLoop->aLTerm[j];\n            if ((pTerm == 0))\n                continue;\n            if (pTerm->eOperator & 1) {\n                if (((j) <= 31 ? ((unsigned int)1) << (j) : 0) & pLoop->u.vtab.mHandleIn) {\n                    int iTab = pParse->nTab++;\n                    int iCache = ++pParse->nMem;\n                    sqlite3CodeRhsOfIN(pParse, pTerm->pExpr, iTab);\n                    sqlite3VdbeAddOp3(v, 174, iTab, iTarget, iCache);\n                } else {\n                    codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);\n                    addrNotFound = pLevel->addrNxt;\n                }\n            } else {\n                Expr *pRight = pTerm->pExpr->pRight;\n                codeExprOrVector(pParse, pRight, iTarget, 1);\n                if (pTerm->eMatchOp == 74 && pLoop->u.vtab.bOmitOffset) {\n                    assert(pTerm->eOperator == 64);\n                    assert(pWInfo->pSelect != 0);\n                    assert(pWInfo->pSelect->iOffset > 0);\n                    sqlite3VdbeAddOp2(v, 71, 0, pWInfo->pSelect->iOffset);\n                    ;\n                }\n            }\n        }\n        sqlite3VdbeAddOp2(v, 71, pLoop->u.vtab.idxNum, iReg);\n        sqlite3VdbeAddOp2(v, 71, nConstraint, iReg + 1);\n        sqlite3VdbeAddOp4(v, 6, iCur, addrNotFound, iReg, pLoop->u.vtab.idxStr, pLoop->u.vtab.needFree ? (-6) : (-1));\n        ;\n        pLoop->u.vtab.needFree = 0;\n        if (db->mallocFailed)\n            pLoop->u.vtab.idxStr = 0;\n        pLevel->p1 = iCur;\n        pLevel->op = pWInfo->eOnePass ? 184 : 63;\n        pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        assert((pLoop->wsFlags & 8192) == 0);\n        for (j = 0; j < nConstraint; j++) {\n            pTerm = pLoop->aLTerm[j];\n            if (j < 16 && (pLoop->u.vtab.omitMask >> j) & 1) {\n                disableTerm(pLevel, pTerm);\n                continue;\n            }\n            if ((pTerm->eOperator & 1) != 0 && (((j) <= 31 ? ((unsigned int)1) << (j) : 0) & pLoop->u.vtab.mHandleIn) == 0 && !db->mallocFailed) {\n                Expr *pCompare;\n                Expr *pRight;\n                VdbeOp *pOp;\n                int iIn;\n                for (iIn = 0; (iIn < pLevel->u.in.nIn); iIn++) {\n                    pOp = sqlite3VdbeGetOp(v, pLevel->u.in.aInLoop[iIn].addrInTop);\n                    if ((pOp->opcode == 94 && pOp->p3 == iReg + j + 2) || (pOp->opcode == 135 && pOp->p2 == iReg + j + 2)) {\n                        ;\n                        sqlite3VdbeAddOp3(v, pOp->opcode, pOp->p1, pOp->p2, pOp->p3);\n                        break;\n                    }\n                }\n                pCompare = sqlite3PExpr(pParse, 53, 0, 0);\n                if (!db->mallocFailed) {\n                    int iFld = pTerm->u.x.iField;\n                    Expr *pLeft = pTerm->pExpr->pLeft;\n                    assert(pLeft != 0);\n                    if (iFld > 0) {\n                        assert(pLeft->op == 177);\n                        assert((((pLeft)->flags & 4096) == 0));\n                        assert(iFld <= pLeft->x.pList->nExpr);\n                        pCompare->pLeft = pLeft->x.pList->a[iFld - 1].pExpr;\n                    } else {\n                        pCompare->pLeft = pLeft;\n                    }\n                    pCompare->pRight = pRight = sqlite3Expr(db, 176, 0);\n                    if (pRight) {\n                        pRight->iTable = iReg + j + 2;\n                        sqlite3ExprIfFalse(pParse, pCompare, pLevel->addrCont, 16);\n                    }\n                    pCompare->pLeft = 0;\n                }\n                sqlite3ExprDelete(db, pCompare);\n            }\n        }\n    } else if ((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & (4 | 1)) != 0) {\n        assert(pLoop->u.btree.nEq == 1);\n        pTerm = pLoop->aLTerm[0];\n        assert(pTerm != 0);\n        assert(pTerm->pExpr != 0);\n        ;\n        iReleaseReg = ++pParse->nMem;\n        iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);\n        if (iRowidReg != iReleaseReg)\n            sqlite3ReleaseTempReg(pParse, iReleaseReg);\n        addrNxt = pLevel->addrNxt;\n        if (pLevel->regFilter) {\n            sqlite3VdbeAddOp2(v, 13, iRowidReg, addrNxt);\n            ;\n            sqlite3VdbeAddOp4Int(v, 64, pLevel->regFilter, addrNxt, iRowidReg, 1);\n            ;\n            filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady);\n        }\n        sqlite3VdbeAddOp3(v, 30, iCur, addrNxt, iRowidReg);\n        ;\n        pLevel->op = 184;\n    } else if ((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & 2) != 0) {\n        int testOp = 184;\n        int start;\n        int memEndValue = 0;\n        WhereTerm *pStart, *pEnd;\n        j = 0;\n        pStart = pEnd = 0;\n        if (pLoop->wsFlags & 32)\n            pStart = pLoop->aLTerm[j++];\n        if (pLoop->wsFlags & 16)\n            pEnd = pLoop->aLTerm[j++];\n        assert(pStart != 0 || pEnd != 0);\n        if (bRev) {\n            pTerm = pStart;\n            pStart = pEnd;\n            pEnd = pTerm;\n        }\n        ;\n        if (pStart) {\n            Expr *pX;\n            int r1, rTemp;\n            int op;\n            const u8 aMoveOp[] = {24, 22, 21, 23};\n            assert(55 == 54 + 1);\n            assert(56 == 54 + 2);\n            assert(57 == 54 + 3);\n            assert((pStart->wtFlags & 128) == 0);\n            ;\n            pX = pStart->pExpr;\n            assert(pX != 0);\n            ;\n            if (sqlite3ExprIsVector(pX->pRight)) {\n                r1 = rTemp = sqlite3GetTempReg(pParse);\n                codeExprOrVector(pParse, pX->pRight, r1, 1);\n                ;\n                ;\n                ;\n                ;\n                op = aMoveOp[((pX->op - 54 - 1) & 3) | 1];\n                assert(pX->op != 54 || op == 23);\n                assert(pX->op != 57 || op == 23);\n                assert(pX->op != 56 || op == 22);\n                assert(pX->op != 55 || op == 22);\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);\n                disableTerm(pLevel, pStart);\n                op = aMoveOp[(pX->op - 54)];\n            }\n            sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);\n            ;\n            ;\n            ;\n            ;\n            ;\n            sqlite3ReleaseTempReg(pParse, rTemp);\n        } else {\n            sqlite3VdbeAddOp2(v, bRev ? 32 : 36, iCur, addrHalt);\n            ;\n            ;\n        }\n        if (pEnd) {\n            Expr *pX;\n            pX = pEnd->pExpr;\n            assert(pX != 0);\n            assert((pEnd->wtFlags & 128) == 0);\n            ;\n            ;\n            memEndValue = ++pParse->nMem;\n            codeExprOrVector(pParse, pX->pRight, memEndValue, 1);\n            if (0 == sqlite3ExprIsVector(pX->pRight) && (pX->op == 56 || pX->op == 54)) {\n                testOp = bRev ? 55 : 57;\n            } else {\n                testOp = bRev ? 56 : 54;\n            }\n            if (0 == sqlite3ExprIsVector(pX->pRight)) {\n                disableTerm(pLevel, pEnd);\n            }\n        }\n        start = sqlite3VdbeCurrentAddr(v);\n        pLevel->op = bRev ? 38 : 39;\n        pLevel->p1 = iCur;\n        pLevel->p2 = start;\n        assert(pLevel->p5 == 0);\n        if (testOp != 184) {\n            iRowidReg = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 135, iCur, iRowidReg);\n            sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);\n            ;\n            ;\n            ;\n            ;\n            sqlite3VdbeChangeP5(v, 67 | 16);\n        }\n    } else if (pLoop->wsFlags & 512) {\n        static const u8 aStartOp[] = {0, 0, 36, 32, 24, 21, 23, 22};\n        static const u8 aEndOp[] = {45, 41, 40, 42};\n        u16 nEq = pLoop->u.btree.nEq;\n        u16 nBtm = pLoop->u.btree.nBtm;\n        u16 nTop = pLoop->u.btree.nTop;\n        int regBase;\n        WhereTerm *pRangeStart = 0;\n        WhereTerm *pRangeEnd = 0;\n        int startEq;\n        int endEq;\n        int start_constraints;\n        int nConstraint;\n        int iIdxCur;\n        int nExtraReg = 0;\n        int op;\n        char *zStartAff;\n        char *zEndAff = 0;\n        u8 bSeekPastNull = 0;\n        u8 bStopAtNull = 0;\n        int omitTable;\n        int regBignull = 0;\n        int addrSeekScan = 0;\n        pIdx = pLoop->u.btree.pIndex;\n        iIdxCur = pLevel->iIdxCur;\n        assert(nEq >= pLoop->nSkip);\n        j = nEq;\n        if (pLoop->wsFlags & 32) {\n            pRangeStart = pLoop->aLTerm[j++];\n            nExtraReg = ((nExtraReg) > (pLoop->u.btree.nBtm) ? (nExtraReg) : (pLoop->u.btree.nBtm));\n            assert((pRangeStart->wtFlags & 256) == 0 || (pLoop->wsFlags & 16) != 0);\n        }\n        if (pLoop->wsFlags & 16) {\n            pRangeEnd = pLoop->aLTerm[j++];\n            nExtraReg = ((nExtraReg) > (pLoop->u.btree.nTop) ? (nExtraReg) : (pLoop->u.btree.nTop));\n            if ((pRangeEnd->wtFlags & 256) != 0) {\n                assert(pRangeStart != 0);\n                assert(pRangeStart->wtFlags & 256);\n                pLevel->iLikeRepCntr = (u32)++pParse->nMem;\n                sqlite3VdbeAddOp2(v, 71, 1, (int)pLevel->iLikeRepCntr);\n                ;\n                pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);\n                ;\n                ;\n                assert((bRev & ~1) == 0);\n                pLevel->iLikeRepCntr <<= 1;\n                pLevel->iLikeRepCntr |= bRev ^ (pIdx->aSortOrder[nEq] == 1);\n            }\n            if (pRangeStart == 0) {\n                j = pIdx->aiColumn[nEq];\n                if ((j >= 0 && pIdx->pTable->aCol[j].notNull == 0) || j == (-2)) {\n                    bSeekPastNull = 1;\n                }\n            }\n        }\n        assert(pRangeEnd == 0 || (pRangeEnd->wtFlags & 128) == 0);\n        if ((pLoop->wsFlags & (16 | 32)) == 0 && (pLoop->wsFlags & 524288) != 0) {\n            assert(bSeekPastNull == 0 && nExtraReg == 0 && nBtm == 0 && nTop == 0);\n            assert(pRangeEnd == 0 && pRangeStart == 0);\n            ;\n            nExtraReg = 1;\n            bSeekPastNull = 1;\n            pLevel->regBignull = regBignull = ++pParse->nMem;\n            if (pLevel->iLeftJoin) {\n                sqlite3VdbeAddOp2(v, 71, 0, regBignull);\n            }\n            pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);\n        }\n        if ((nEq < pIdx->nColumn && bRev == (pIdx->aSortOrder[nEq] == 0))) {\n            {\n                WhereTerm *t = pRangeEnd;\n                pRangeEnd = pRangeStart;\n                pRangeStart = t;\n            }\n            ;\n            {\n                u8 t = bSeekPastNull;\n                bSeekPastNull = bStopAtNull;\n                bStopAtNull = t;\n            }\n            ;\n            {\n                u8 t = nBtm;\n                nBtm = nTop;\n                nTop = t;\n            }\n            ;\n        }\n        if (iLevel > 0 && (pLoop->wsFlags & 1048576) != 0) {\n            sqlite3VdbeAddOp1(v, 136, iIdxCur);\n        }\n        ;\n        regBase = codeAllEqualityTerms(pParse, pLevel, bRev, nExtraReg, &zStartAff);\n        assert(zStartAff == 0 || sqlite3Strlen30(zStartAff) >= nEq);\n        if (zStartAff && nTop) {\n            zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);\n        }\n        addrNxt = (regBignull ? pLevel->addrBignull : pLevel->addrNxt);\n        ;\n        ;\n        ;\n        ;\n        startEq = !pRangeStart || pRangeStart->eOperator & ((2 << (55 - 53)) | (2 << (57 - 53)));\n        endEq = !pRangeEnd || pRangeEnd->eOperator & ((2 << (55 - 53)) | (2 << (57 - 53)));\n        start_constraints = pRangeStart || nEq > 0;\n        nConstraint = nEq;\n        if (pRangeStart) {\n            Expr *pRight = pRangeStart->pExpr->pRight;\n            codeExprOrVector(pParse, pRight, regBase + nEq, nBtm);\n            whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);\n            if ((pRangeStart->wtFlags & 128) == 0 && sqlite3ExprCanBeNull(pRight)) {\n                sqlite3VdbeAddOp2(v, 50, regBase + nEq, addrNxt);\n                ;\n            }\n            if (zStartAff) {\n                updateRangeAffinityStr(pRight, nBtm, &zStartAff[nEq]);\n            }\n            nConstraint += nBtm;\n            ;\n            if (sqlite3ExprIsVector(pRight) == 0) {\n                disableTerm(pLevel, pRangeStart);\n            } else {\n                startEq = 1;\n            }\n            bSeekPastNull = 0;\n        } else if (bSeekPastNull) {\n            startEq = 0;\n            sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n            start_constraints = 1;\n            nConstraint++;\n        } else if (regBignull) {\n            sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n            start_constraints = 1;\n            nConstraint++;\n        }\n        codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);\n        if (pLoop->nSkip > 0 && nConstraint == pLoop->nSkip) {\n        } else {\n            if (regBignull) {\n                sqlite3VdbeAddOp2(v, 71, 1, regBignull);\n                ;\n            }\n            if (pLevel->regFilter) {\n                sqlite3VdbeAddOp4Int(v, 64, pLevel->regFilter, addrNxt, regBase, nEq);\n                ;\n                filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady);\n            }\n            op = aStartOp[(start_constraints << 2) + (startEq << 1) + bRev];\n            assert(op != 0);\n            if ((pLoop->wsFlags & 1048576) != 0 && op == 23) {\n                assert(regBignull == 0);\n                addrSeekScan = sqlite3VdbeAddOp1(v, 124, (pIdx->aiRowLogEst[0] + 9) / 10);\n                if (pRangeStart) {\n                    sqlite3VdbeChangeP5(v, 1);\n                    sqlite3VdbeChangeP2(v, addrSeekScan, sqlite3VdbeCurrentAddr(v) + 1);\n                    addrSeekScan = 0;\n                }\n                ;\n            }\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            assert(bSeekPastNull == 0 || bStopAtNull == 0);\n            if (regBignull) {\n                assert(bSeekPastNull == 1 || bStopAtNull == 1);\n                assert(bSeekPastNull == !bStopAtNull);\n                assert(bStopAtNull == startEq);\n                sqlite3VdbeAddOp2(v, 9, 0, sqlite3VdbeCurrentAddr(v) + 2);\n                op = aStartOp[(nConstraint > 1) * 4 + 2 + bRev];\n                sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint - startEq);\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                assert(op == 36 || op == 32 || op == 23 || op == 22);\n            }\n        }\n        nConstraint = nEq;\n        assert(pLevel->p2 == 0);\n        if (pRangeEnd) {\n            Expr *pRight = pRangeEnd->pExpr->pRight;\n            if (addrSeekScan) {\n                pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n            }\n            codeExprOrVector(pParse, pRight, regBase + nEq, nTop);\n            whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);\n            if ((pRangeEnd->wtFlags & 128) == 0 && sqlite3ExprCanBeNull(pRight)) {\n                sqlite3VdbeAddOp2(v, 50, regBase + nEq, addrNxt);\n                ;\n            }\n            if (zEndAff) {\n                updateRangeAffinityStr(pRight, nTop, zEndAff);\n                codeApplyAffinity(pParse, regBase + nEq, nTop, zEndAff);\n            } else {\n                assert(pParse->db->mallocFailed);\n            }\n            nConstraint += nTop;\n            ;\n            if (sqlite3ExprIsVector(pRight) == 0) {\n                disableTerm(pLevel, pRangeEnd);\n            } else {\n                endEq = 1;\n            }\n        } else if (bStopAtNull) {\n            if (regBignull == 0) {\n                sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n                endEq = 0;\n            }\n            nConstraint++;\n        }\n        if (zStartAff)\n            sqlite3DbNNFreeNN(db, zStartAff);\n        if (zEndAff)\n            sqlite3DbNNFreeNN(db, zEndAff);\n        if (pLevel->p2 == 0)\n            pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        if (nConstraint) {\n            if (regBignull) {\n                sqlite3VdbeAddOp2(v, 17, regBignull, sqlite3VdbeCurrentAddr(v) + 3);\n                ;\n                ;\n            }\n            op = aEndOp[bRev * 2 + endEq];\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            if (addrSeekScan)\n                sqlite3VdbeJumpHere(v, addrSeekScan);\n        }\n        if (regBignull) {\n            assert(bSeekPastNull == !bStopAtNull);\n            assert(bSeekPastNull + bStopAtNull == 1);\n            assert(nConstraint + bSeekPastNull > 0);\n            sqlite3VdbeAddOp2(v, 16, regBignull, sqlite3VdbeCurrentAddr(v) + 2);\n            ;\n            ;\n            op = aEndOp[bRev * 2 + bSeekPastNull];\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint + bSeekPastNull);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n        }\n        if ((pLoop->wsFlags & 262144) != 0) {\n            sqlite3VdbeAddOp3(v, 125, iIdxCur, nEq, nEq);\n        }\n        omitTable = (pLoop->wsFlags & 64) != 0 && (pWInfo->wctrlFlags & (32 | 4096)) == 0;\n        if (omitTable) {\n        } else if ((((pIdx->pTable)->tabFlags & 128) == 0)) {\n            codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);\n        } else if (iCur != iIdxCur) {\n            Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);\n            iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);\n            for (j = 0; j < pPk->nKeyCol; j++) {\n                k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);\n                sqlite3VdbeAddOp3(v, 94, iIdxCur, k, iRowidReg + j);\n            }\n            sqlite3VdbeAddOp4Int(v, 28, iCur, addrCont, iRowidReg, pPk->nKeyCol);\n            ;\n        }\n        if (pLevel->iLeftJoin == 0) {\n            if (pIdx->pPartIdxWhere) {\n                whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);\n            }\n        } else {\n            ;\n            assert((pWInfo->wctrlFlags & (32 | 4096)) == 0);\n        }\n        if (pLoop->wsFlags & 4096) {\n            pLevel->op = 184;\n        } else if (bRev) {\n            pLevel->op = 38;\n        } else {\n            pLevel->op = 39;\n        }\n        pLevel->p1 = iIdxCur;\n        pLevel->p3 = (pLoop->wsFlags & 65536) != 0 ? 1 : 0;\n        if ((pLoop->wsFlags & 15) == 0) {\n            pLevel->p5 = 1;\n        } else {\n            assert(pLevel->p5 == 0);\n        }\n        if (omitTable)\n            pIdx = 0;\n    } else if (pLoop->wsFlags & 8192) {\n        WhereClause *pOrWc;\n        SrcList *pOrTab;\n        Index *pCov = 0;\n        int iCovCur = pParse->nTab++;\n        int regReturn = ++pParse->nMem;\n        int regRowset = 0;\n        int regRowid = 0;\n        int iLoopBody = sqlite3VdbeMakeLabel(pParse);\n        int iRetInit;\n        int untestedTerms = 0;\n        int ii;\n        Expr *pAndExpr = 0;\n        Table *pTab = pTabItem->pTab;\n        pTerm = pLoop->aLTerm[0];\n        assert(pTerm != 0);\n        assert(pTerm->eOperator & 512);\n        assert((pTerm->wtFlags & 16) != 0);\n        pOrWc = &pTerm->u.pOrInfo->wc;\n        pLevel->op = 67;\n        pLevel->p1 = regReturn;\n        if (pWInfo->nLevel > 1) {\n            int nNotReady;\n            SrcItem *origSrc;\n            nNotReady = pWInfo->nLevel - iLevel - 1;\n            pOrTab = sqlite3DbMallocRawNN(db, sizeof (*pOrTab) + nNotReady * sizeof (pOrTab->a[0]));\n            if (pOrTab == 0)\n                return notReady;\n            pOrTab->nAlloc = (u8)(nNotReady + 1);\n            pOrTab->nSrc = pOrTab->nAlloc;\n            memcpy(pOrTab->a, pTabItem, sizeof (*pTabItem));\n            origSrc = pWInfo->pTabList->a;\n            for (k = 1; k <= nNotReady; k++) {\n                memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof (pOrTab->a[k]));\n            }\n        } else {\n            pOrTab = pWInfo->pTabList;\n        }\n        if ((pWInfo->wctrlFlags & 16) == 0) {\n            if ((((pTab)->tabFlags & 128) == 0)) {\n                regRowset = ++pParse->nMem;\n                sqlite3VdbeAddOp2(v, 75, 0, regRowset);\n            } else {\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                regRowset = pParse->nTab++;\n                sqlite3VdbeAddOp2(v, 118, regRowset, pPk->nKeyCol);\n                sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n            }\n            regRowid = ++pParse->nMem;\n        }\n        iRetInit = sqlite3VdbeAddOp2(v, 71, 0, regReturn);\n        if (pWC->nTerm > 1) {\n            int iTerm;\n            for (iTerm = 0; iTerm < pWC->nTerm; iTerm++) {\n                Expr *pExpr = pWC->a[iTerm].pExpr;\n                if (&pWC->a[iTerm] == pTerm)\n                    continue;\n                ;\n                ;\n                ;\n                if ((pWC->a[iTerm].wtFlags & (2 | 4 | 32768)) != 0) {\n                    continue;\n                }\n                if ((pWC->a[iTerm].eOperator & 16383) == 0)\n                    continue;\n                if ((((pExpr)->flags & (4194304)) != 0))\n                    continue;\n                pExpr = sqlite3ExprDup(db, pExpr, 0);\n                pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);\n            }\n            if (pAndExpr) {\n                pAndExpr = sqlite3PExpr(pParse, 44 | 65536, 0, pAndExpr);\n            }\n        }\n        sqlite3VdbeExplain(pParse, 1, \"MULTI-INDEX OR\");\n        for (ii = 0; ii < pOrWc->nTerm; ii++) {\n            WhereTerm *pOrTerm = &pOrWc->a[ii];\n            if (pOrTerm->leftCursor == iCur || (pOrTerm->eOperator & 1024) != 0) {\n                WhereInfo *pSubWInfo;\n                Expr *pOrExpr = pOrTerm->pExpr;\n                Expr *pDelete;\n                int jmp1 = 0;\n                ;\n                pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, 0);\n                if (db->mallocFailed) {\n                    sqlite3ExprDelete(db, pDelete);\n                    continue;\n                }\n                if (pAndExpr) {\n                    pAndExpr->pLeft = pOrExpr;\n                    pOrExpr = pAndExpr;\n                }\n                sqlite3VdbeExplain(pParse, 1, \"INDEX %d\", ii + 1);\n                ;\n                pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0, 0, 32, iCovCur);\n                assert(pSubWInfo || pParse->nErr);\n                if (pSubWInfo) {\n                    WhereLoop *pSubLoop;\n                    int addrExplain = sqlite3WhereExplainOneScan(pParse, pOrTab, &pSubWInfo->a[0], 0);\n                    ((void)addrExplain);\n                    if ((pWInfo->wctrlFlags & 16) == 0) {\n                        int iSet = ((ii == pOrWc->nTerm - 1) ? -1 : ii);\n                        if ((((pTab)->tabFlags & 128) == 0)) {\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid);\n                            jmp1 = sqlite3VdbeAddOp4Int(v, 47, regRowset, 0, regRowid, iSet);\n                            ;\n                        } else {\n                            Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                            int nPk = pPk->nKeyCol;\n                            int iPk;\n                            int r;\n                            r = sqlite3GetTempRange(pParse, nPk);\n                            for (iPk = 0; iPk < nPk; iPk++) {\n                                int iCol = pPk->aiColumn[iPk];\n                                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r + iPk);\n                            }\n                            if (iSet) {\n                                jmp1 = sqlite3VdbeAddOp4Int(v, 29, regRowset, 0, r, nPk);\n                                ;\n                            }\n                            if (iSet >= 0) {\n                                sqlite3VdbeAddOp3(v, 97, r, nPk, regRowid);\n                                sqlite3VdbeAddOp4Int(v, 138, regRowset, regRowid, r, nPk);\n                                if (iSet)\n                                    sqlite3VdbeChangeP5(v, 16);\n                            }\n                            sqlite3ReleaseTempRange(pParse, r, nPk);\n                        }\n                    }\n                    sqlite3VdbeAddOp2(v, 10, regReturn, iLoopBody);\n                    if (jmp1)\n                        sqlite3VdbeJumpHere(v, jmp1);\n                    if (pSubWInfo->untestedTerms)\n                        untestedTerms = 1;\n                    pSubLoop = pSubWInfo->a[0].pWLoop;\n                    assert((pSubLoop->wsFlags & 16384) == 0);\n                    if ((pSubLoop->wsFlags & 512) != 0 && (ii == 0 || pSubLoop->u.btree.pIndex == pCov) && ((((pTab)->tabFlags & 128) == 0) || !((pSubLoop->u.btree.pIndex)->idxType == 2))) {\n                        assert(pSubWInfo->a[0].iIdxCur == iCovCur);\n                        pCov = pSubLoop->u.btree.pIndex;\n                    } else {\n                        pCov = 0;\n                    }\n                    if (sqlite3WhereUsesDeferredSeek(pSubWInfo)) {\n                        pWInfo->bDeferredSeek = 1;\n                    }\n                    sqlite3WhereEnd(pSubWInfo);\n                    sqlite3VdbeExplainPop(pParse);\n                }\n                sqlite3ExprDelete(db, pDelete);\n            }\n        }\n        sqlite3VdbeExplainPop(pParse);\n        assert(pLevel->pWLoop == pLoop);\n        assert((pLoop->wsFlags & 8192) != 0);\n        assert((pLoop->wsFlags & 2048) == 0);\n        pLevel->u.pCoveringIdx = pCov;\n        if (pCov)\n            pLevel->iIdxCur = iCovCur;\n        if (pAndExpr) {\n            pAndExpr->pLeft = 0;\n            sqlite3ExprDelete(db, pAndExpr);\n        }\n        sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));\n        sqlite3VdbeGoto(v, pLevel->addrBrk);\n        sqlite3VdbeResolveLabel(v, iLoopBody);\n        assert(pLevel->op == 67);\n        pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        if (pWInfo->nLevel > 1) {\n            sqlite3DbFreeNN(db, pOrTab);\n        }\n        if (!untestedTerms)\n            disableTerm(pLevel, pTerm);\n    } else {\n        static const u8 aStep[] = {39, 38};\n        static const u8 aStart[] = {36, 32};\n        assert(bRev == 0 || bRev == 1);\n        if (pTabItem->fg.isRecursive) {\n            pLevel->op = 184;\n        } else {\n            ;\n            pLevel->op = aStep[bRev];\n            pLevel->p1 = iCur;\n            pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrHalt);\n            ;\n            ;\n            pLevel->p5 = 1;\n        }\n    }\n    iLoop = (pIdx ? 1 : 2);\n    do {\n        int iNext = 0;\n        for (pTerm = pWC->a , j = pWC->nTerm; j > 0; j-- , pTerm++) {\n            Expr *pE;\n            int skipLikeAddr = 0;\n            ;\n            ;\n            if (pTerm->wtFlags & (2 | 4))\n                continue;\n            if ((pTerm->prereqAll & pLevel->notReady) != 0) {\n                ;\n                pWInfo->untestedTerms = 1;\n                continue;\n            }\n            pE = pTerm->pExpr;\n            assert(pE != 0);\n            if (pTabItem->fg.jointype & (8 | 64 | 16)) {\n                if (!(((pE)->flags & (1 | 2)) != 0)) {\n                    continue;\n                } else if ((pTabItem->fg.jointype & 8) == 8 && !(((pE)->flags & (1)) != 0)) {\n                    continue;\n                } else {\n                    Bitmask m = sqlite3WhereGetMask(&pWInfo->sMaskSet, pE->w.iJoin);\n                    if (m & pLevel->notReady) {\n                        continue;\n                    }\n                }\n            }\n            if (iLoop == 1 && !sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx)) {\n                iNext = 2;\n                continue;\n            }\n            if (iLoop < 3 && (pTerm->wtFlags & 4096)) {\n                if (iNext == 0)\n                    iNext = 3;\n                continue;\n            }\n            if ((pTerm->wtFlags & 512) != 0) {\n                u32 x = pLevel->iLikeRepCntr;\n                if (x > 0) {\n                    skipLikeAddr = sqlite3VdbeAddOp1(v, (x & 1) ? 17 : 16, (int)(x >> 1));\n                    ;\n                    ;\n                }\n            }\n            sqlite3ExprIfFalse(pParse, pE, addrCont, 16);\n            if (skipLikeAddr)\n                sqlite3VdbeJumpHere(v, skipLikeAddr);\n            pTerm->wtFlags |= 4;\n        }\n        iLoop = iNext;\n    } while (iLoop > 0);\n    for (pTerm = pWC->a , j = pWC->nBase; j > 0; j-- , pTerm++) {\n        Expr *pE, sEAlt;\n        WhereTerm *pAlt;\n        if (pTerm->wtFlags & (2 | 4))\n            continue;\n        if ((pTerm->eOperator & (2 | 128)) == 0)\n            continue;\n        if ((pTerm->eOperator & 2048) == 0)\n            continue;\n        if (pTerm->leftCursor != iCur)\n            continue;\n        if (pTabItem->fg.jointype & (8 | 64 | 16))\n            continue;\n        pE = pTerm->pExpr;\n        assert(!(((pE)->flags & (1)) != 0));\n        assert((pTerm->prereqRight & pLevel->notReady) != 0);\n        assert((pTerm->eOperator & (512 | 1024)) == 0);\n        pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.x.leftColumn, notReady, 2 | 1 | 128, 0);\n        if (pAlt == 0)\n            continue;\n        if (pAlt->wtFlags & (4))\n            continue;\n        if ((pAlt->eOperator & 1) && (((pAlt->pExpr)->flags & 4096) != 0) && (pAlt->pExpr->x.pSelect->pEList->nExpr > 1)) {\n            continue;\n        }\n        ;\n        ;\n        ;\n        ;\n        sEAlt = *pAlt->pExpr;\n        sEAlt.pLeft = pE->pLeft;\n        sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, 16);\n        pAlt->wtFlags |= 4;\n    }\n    if (pLevel->pRJ) {\n        Table *pTab;\n        int nPk;\n        int r;\n        int jmp1 = 0;\n        WhereRightJoin *pRJ = pLevel->pRJ;\n        pTab = pWInfo->pTabList->a[pLevel->iFrom].pTab;\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            r = sqlite3GetTempRange(pParse, 2);\n            sqlite3ExprCodeGetColumnOfTable(v, pTab, pLevel->iTabCur, -1, r + 1);\n            nPk = 1;\n        } else {\n            int iPk;\n            Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n            nPk = pPk->nKeyCol;\n            r = sqlite3GetTempRange(pParse, nPk + 1);\n            for (iPk = 0; iPk < nPk; iPk++) {\n                int iCol = pPk->aiColumn[iPk];\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r + 1 + iPk);\n            }\n        }\n        jmp1 = sqlite3VdbeAddOp4Int(v, 29, pRJ->iMatch, 0, r + 1, nPk);\n        ;\n        ;\n        sqlite3VdbeAddOp3(v, 97, r + 1, nPk, r);\n        sqlite3VdbeAddOp4Int(v, 138, pRJ->iMatch, r, r + 1, nPk);\n        sqlite3VdbeAddOp4Int(v, 180, pRJ->regBloom, 0, r + 1, nPk);\n        sqlite3VdbeChangeP5(v, 16);\n        sqlite3VdbeJumpHere(v, jmp1);\n        sqlite3ReleaseTempRange(pParse, r, nPk + 1);\n    }\n    if (pLevel->iLeftJoin) {\n        pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);\n        sqlite3VdbeAddOp2(v, 71, 1, pLevel->iLeftJoin);\n        ;\n        if (pLevel->pRJ == 0) {\n            goto code_outer_join_constraints;\n        }\n    }\n    if (pLevel->pRJ) {\n        WhereRightJoin *pRJ = pLevel->pRJ;\n        sqlite3VdbeAddOp2(v, 74, 0, pRJ->regReturn);\n        pRJ->addrSubrtn = sqlite3VdbeCurrentAddr(v);\n        assert(pParse->withinRJSubrtn < 255);\n        pParse->withinRJSubrtn++;\n      code_outer_join_constraints:\n        for (pTerm = pWC->a , j = 0; j < pWC->nBase; j++ , pTerm++) {\n            ;\n            ;\n            if (pTerm->wtFlags & (2 | 4))\n                continue;\n            if ((pTerm->prereqAll & pLevel->notReady) != 0) {\n                assert(pWInfo->untestedTerms);\n                continue;\n            }\n            if (pTabItem->fg.jointype & 64)\n                continue;\n            assert(pTerm->pExpr);\n            sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 16);\n            pTerm->wtFlags |= 4;\n        }\n    }\n    return pLevel->notReady;\n}\n"
        },
        {
            "id": "#23:25#sqlite3RunVacuum",
            "gotos": 12,
            "labels": 1,
            "body": "{\n    int rc = 0;\n    Btree *pMain;\n    Btree *pTemp;\n    u32 saved_mDbFlags;\n    u64 saved_flags;\n    i64 saved_nChange;\n    i64 saved_nTotalChange;\n    u32 saved_openFlags;\n    u8 saved_mTrace;\n    Db *pDb = 0;\n    int isMemDb;\n    int nRes;\n    int nDb;\n    const char *zDbMain;\n    const char *zOut;\n    u32 pgflags = 1;\n    if (!db->autoCommit) {\n        sqlite3SetString(pzErrMsg, db, \"cannot VACUUM from within a transaction\");\n        return 1;\n    }\n    if (db->nVdbeActive > 1) {\n        sqlite3SetString(pzErrMsg, db, \"cannot VACUUM - SQL statements in progress\");\n        return 1;\n    }\n    saved_openFlags = db->openFlags;\n    if (pOut) {\n        if (sqlite3_value_type(pOut) != 3) {\n            sqlite3SetString(pzErrMsg, db, \"non-text filename\");\n            return 1;\n        }\n        zOut = (const char *)sqlite3_value_text(pOut);\n        db->openFlags &= ~1;\n        db->openFlags |= 4 | 2;\n    } else {\n        zOut = \"\";\n    }\n    saved_flags = db->flags;\n    saved_mDbFlags = db->mDbFlags;\n    saved_nChange = db->nChange;\n    saved_nTotalChange = db->nTotalChange;\n    saved_mTrace = db->mTrace;\n    db->flags |= 1 | 512;\n    db->mDbFlags |= 2 | 4;\n    db->flags &= ~(u64)(16384 | 4096 | 268435456 | ((u64)(1) << 32));\n    db->mTrace = 0;\n    zDbMain = db->aDb[iDb].zDbSName;\n    pMain = db->aDb[iDb].pBt;\n    isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));\n    nDb = db->nDb;\n    rc = execSqlF(db, pzErrMsg, \"ATTACH %Q AS vacuum_db\", zOut);\n    db->openFlags = saved_openFlags;\n    if (rc != 0)\n        goto end_of_vacuum;\n    assert((db->nDb - 1) == nDb);\n    pDb = &db->aDb[nDb];\n    assert(strcmp(pDb->zDbSName, \"vacuum_db\") == 0);\n    pTemp = pDb->pBt;\n    if (pOut) {\n        sqlite3_file *id = sqlite3PagerFile(sqlite3BtreePager(pTemp));\n        i64 sz = 0;\n        if (id->pMethods != 0 && (sqlite3OsFileSize(id, &sz) != 0 || sz > 0)) {\n            rc = 1;\n            sqlite3SetString(pzErrMsg, db, \"output file already exists\");\n            goto end_of_vacuum;\n        }\n        db->mDbFlags |= 8;\n        pgflags = db->aDb[iDb].safety_level | (db->flags & 56);\n    }\n    nRes = sqlite3BtreeGetRequestedReserve(pMain);\n    sqlite3BtreeSetCacheSize(pTemp, db->aDb[iDb].pSchema->cache_size);\n    sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain, 0));\n    sqlite3BtreeSetPagerFlags(pTemp, pgflags | 32);\n    rc = execSql(db, pzErrMsg, \"BEGIN\");\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = sqlite3BtreeBeginTrans(pMain, pOut == 0 ? 2 : 0, 0);\n    if (rc != 0)\n        goto end_of_vacuum;\n    if (sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain)) == 5 && pOut == 0) {\n        db->nextPagesize = 0;\n    }\n    if (sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0) || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0)) || (db->mallocFailed)) {\n        rc = 7;\n        goto end_of_vacuum;\n    }\n    sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac >= 0 ? db->nextAutovac : sqlite3BtreeGetAutoVacuum(pMain));\n    db->init.iDb = nDb;\n    rc = execSqlF(db, pzErrMsg, \"SELECT sql FROM \\\"%w\\\".sqlite_schema WHERE type='table'AND name<>'sqlite_sequence' AND coalesce(rootpage,1)>0\", zDbMain);\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = execSqlF(db, pzErrMsg, \"SELECT sql FROM \\\"%w\\\".sqlite_schema WHERE type='index'\", zDbMain);\n    if (rc != 0)\n        goto end_of_vacuum;\n    db->init.iDb = 0;\n    rc = execSqlF(db, pzErrMsg, \"SELECT'INSERT INTO vacuum_db.'||quote(name)||' SELECT*FROM\\\"%w\\\".'||quote(name)FROM vacuum_db.sqlite_schema WHERE type='table'AND coalesce(rootpage,1)>0\", zDbMain);\n    assert((db->mDbFlags & 4) != 0);\n    db->mDbFlags &= ~4;\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = execSqlF(db, pzErrMsg, \"INSERT INTO vacuum_db.sqlite_schema SELECT*FROM \\\"%w\\\".sqlite_schema WHERE type IN('view','trigger') OR(type='table'AND rootpage=0)\", zDbMain);\n    if (rc)\n        goto end_of_vacuum;\n    {\n        u32 meta;\n        int i;\n        static const unsigned char aCopy[] = {1, 1, 3, 0, 5, 0, 6, 0, 8, 0};\n        assert(2 == sqlite3BtreeTxnState(pTemp));\n        assert(pOut != 0 || 2 == sqlite3BtreeTxnState(pMain));\n        for (i = 0; i < ((int)(sizeof (aCopy) / sizeof (aCopy[0]))); i += 2) {\n            sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);\n            rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta + aCopy[i + 1]);\n            if ((rc != 0))\n                goto end_of_vacuum;\n        }\n        if (pOut == 0) {\n            rc = sqlite3BtreeCopyFile(pMain, pTemp);\n        }\n        if (rc != 0)\n            goto end_of_vacuum;\n        rc = sqlite3BtreeCommit(pTemp);\n        if (rc != 0)\n            goto end_of_vacuum;\n        if (pOut == 0) {\n            sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));\n        }\n    }\n    assert(rc == 0);\n    if (pOut == 0) {\n        nRes = sqlite3BtreeGetRequestedReserve(pTemp);\n        rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes, 1);\n    }\n  end_of_vacuum:\n    db->init.iDb = 0;\n    db->mDbFlags = saved_mDbFlags;\n    db->flags = saved_flags;\n    db->nChange = saved_nChange;\n    db->nTotalChange = saved_nTotalChange;\n    db->mTrace = saved_mTrace;\n    sqlite3BtreeSetPageSize(pMain, -1, 0, 1);\n    db->autoCommit = 1;\n    if (pDb) {\n        sqlite3BtreeClose(pDb->pBt);\n        pDb->pBt = 0;\n        pDb->pSchema = 0;\n    }\n    sqlite3ResetAllSchemasOfConnection(db);\n    return rc;\n}\n"
        },
        {
            "id": "#23:25#sqlite3AtoF",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    int incr;\n    const char *zEnd;\n    int sign = 1;\n    i64 s = 0;\n    int d = 0;\n    int esign = 1;\n    int e = 0;\n    int eValid = 1;\n    double result;\n    int nDigit = 0;\n    int eType = 1;\n    assert(enc == 1 || enc == 2 || enc == 3);\n    *pResult = 0.;\n    if (length == 0)\n        return 0;\n    if (enc == 1) {\n        incr = 1;\n        zEnd = z + length;\n    } else {\n        int i;\n        incr = 2;\n        length &= ~1;\n        assert(2 == 2 && 3 == 3);\n        ;\n        ;\n        for (i = 3 - enc; i < length && z[i] == 0; i += 2) {\n        }\n        if (i < length)\n            eType = -100;\n        zEnd = &z[i ^ 1];\n        z += (enc & 1);\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1))\n        z += incr;\n    if (z >= zEnd)\n        return 0;\n    if (*z == '-') {\n        sign = -1;\n        z += incr;\n    } else if (*z == '+') {\n        z += incr;\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n        {\n            s = s * 10 + (*z - '0');\n            z += incr;\n            nDigit++;\n            if (s >= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) {\n                while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n                    {\n                        z += incr;\n                        d++;\n                    }\n            }\n        }\n    if (z >= zEnd)\n        goto do_atof_calc;\n    if (*z == '.') {\n        z += incr;\n        eType++;\n        while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n            {\n                if (s < (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) {\n                    s = s * 10 + (*z - '0');\n                    d--;\n                    nDigit++;\n                }\n                z += incr;\n            }\n    }\n    if (z >= zEnd)\n        goto do_atof_calc;\n    if (*z == 'e' || *z == 'E') {\n        z += incr;\n        eValid = 0;\n        eType++;\n        if (z >= zEnd)\n            goto do_atof_calc;\n        if (*z == '-') {\n            esign = -1;\n            z += incr;\n        } else if (*z == '+') {\n            z += incr;\n        }\n        while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n            {\n                e = e < 10000 ? (e * 10 + (*z - '0')) : 10000;\n                z += incr;\n                eValid = 1;\n            }\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1))\n        z += incr;\n  do_atof_calc:\n    e = (e * esign) + d;\n    if (e < 0) {\n        esign = -1;\n        e *= -1;\n    } else {\n        esign = 1;\n    }\n    if (s == 0) {\n        result = sign < 0 ? -(double)0 : (double)0;\n    } else {\n        while (e > 0)\n            {\n                if (esign > 0) {\n                    if (s >= ((4294967295U | (((i64)2147483647) << 32)) / 10))\n                        break;\n                    s *= 10;\n                } else {\n                    if (s % 10 != 0)\n                        break;\n                    s /= 10;\n                }\n                e--;\n            }\n        s = sign < 0 ? -s : s;\n        if (e == 0) {\n            result = (double)s;\n        } else {\n            if (e > 307) {\n                if (e < 342) {\n                    long double scale = sqlite3Pow10(e - 308);\n                    if (esign < 0) {\n                        result = s / scale;\n                        result /= 1.0E+308;\n                    } else {\n                        result = s * scale;\n                        result *= 1.0E+308;\n                    }\n                } else {\n                    assert(e >= 342);\n                    if (esign < 0) {\n                        result = 0. * s;\n                    } else {\n                        result = 1.0E+308 * 1.0E+308 * s;\n                    }\n                }\n            } else {\n                long double scale = sqlite3Pow10(e);\n                if (esign < 0) {\n                    result = s / scale;\n                } else {\n                    result = s * scale;\n                }\n            }\n        }\n    }\n    *pResult = result;\n    if (z == zEnd && nDigit > 0 && eValid && eType > 0) {\n        return eType;\n    } else if (eType >= 2 && (eType == 3 || eValid) && nDigit > 0) {\n        return -1;\n    } else {\n        return 0;\n    }\n}\n"
        },
        {
            "id": "#23:25#sqlite3DeleteFrom",
            "gotos": 9,
            "labels": 1,
            "body": "{\n    Vdbe *v;\n    Table *pTab;\n    int i;\n    WhereInfo *pWInfo;\n    Index *pIdx;\n    int iTabCur;\n    int iDataCur = 0;\n    int iIdxCur = 0;\n    int nIdx;\n    sqlite3 *db;\n    AuthContext sContext;\n    NameContext sNC;\n    int iDb;\n    int memCnt = 0;\n    int rcauth;\n    int eOnePass;\n    int aiCurOnePass[2];\n    u8 *aToOpen = 0;\n    Index *pPk;\n    int iPk = 0;\n    i16 nPk = 1;\n    int iKey;\n    i16 nKey;\n    int iEphCur = 0;\n    int iRowSet = 0;\n    int addrBypass = 0;\n    int addrLoop = 0;\n    int addrEphOpen = 0;\n    int bComplex;\n    int isView;\n    Trigger *pTrigger;\n    memset(&sContext, 0, sizeof (sContext));\n    db = pParse->db;\n    assert(db->pParse == pParse);\n    if (pParse->nErr) {\n        goto delete_from_cleanup;\n    }\n    assert(db->mallocFailed == 0);\n    assert(pTabList->nSrc == 1);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0)\n        goto delete_from_cleanup;\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 128, 0, 0);\n    isView = ((pTab)->eTabType == 2);\n    bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto delete_from_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, (pTrigger ? 1 : 0))) {\n        goto delete_from_cleanup;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iDb < db->nDb);\n    rcauth = sqlite3AuthCheck(pParse, 9, pTab->zName, 0, db->aDb[iDb].zDbSName);\n    assert(rcauth == 0 || rcauth == 1 || rcauth == 2);\n    if (rcauth == 1) {\n        goto delete_from_cleanup;\n    }\n    assert(!isView || pTrigger);\n    assert(pTabList->nSrc == 1);\n    iTabCur = pTabList->a[0].iCursor = pParse->nTab++;\n    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n        pParse->nTab++;\n    }\n    if (isView) {\n        sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0) {\n        goto delete_from_cleanup;\n    }\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, bComplex, iDb);\n    if (isView) {\n        sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iTabCur);\n        iDataCur = iIdxCur = iTabCur;\n        pOrderBy = 0;\n        pLimit = 0;\n    }\n    memset(&sNC, 0, sizeof (sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    if (sqlite3ResolveExprNames(&sNC, pWhere)) {\n        goto delete_from_cleanup;\n    }\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning) {\n        memCnt = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, memCnt);\n    }\n    if (rcauth == 0 && pWhere == 0 && !bComplex && !((pTab)->eTabType == 1)) {\n        assert(!isView);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp4(v, 145, pTab->tnum, iDb, memCnt ? memCnt : -1, pTab->zName, (-1));\n        }\n        for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n            assert(pIdx->pSchema == pTab->pSchema);\n            if (((pIdx)->idxType == 2) && !(((pTab)->tabFlags & 128) == 0)) {\n                sqlite3VdbeAddOp3(v, 145, pIdx->tnum, iDb, memCnt ? memCnt : -1);\n            } else {\n                sqlite3VdbeAddOp2(v, 145, pIdx->tnum, iDb);\n            }\n        }\n    } else {\n        u16 wcf = 4 | 16;\n        if (sNC.ncFlags & 64)\n            bComplex = 1;\n        wcf |= (bComplex ? 0 : 8);\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            pPk = 0;\n            nPk = 1;\n            iRowSet = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 75, 0, iRowSet);\n        } else {\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n            assert(pPk != 0);\n            nPk = pPk->nKeyCol;\n            iPk = pParse->nMem + 1;\n            pParse->nMem += nPk;\n            iEphCur = pParse->nTab++;\n            addrEphOpen = sqlite3VdbeAddOp2(v, 118, iEphCur, nPk);\n            sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n        }\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0, wcf, iTabCur + 1);\n        if (pWInfo == 0)\n            goto delete_from_cleanup;\n        eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n        assert(((pTab)->eTabType == 1) == 0 || eOnePass != 2);\n        assert(((pTab)->eTabType == 1) || bComplex || eOnePass != 0);\n        if (eOnePass != 1)\n            sqlite3MultiWrite(pParse);\n        if (sqlite3WhereUsesDeferredSeek(pWInfo)) {\n            sqlite3VdbeAddOp1(v, 143, iTabCur);\n        }\n        if (memCnt) {\n            sqlite3VdbeAddOp2(v, 86, memCnt, 1);\n        }\n        if (pPk) {\n            for (i = 0; i < nPk; i++) {\n                assert(pPk->aiColumn[i] >= 0);\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, pPk->aiColumn[i], iPk + i);\n            }\n            iKey = iPk;\n        } else {\n            iKey = ++pParse->nMem;\n            sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);\n        }\n        if (eOnePass != 0) {\n            nKey = nPk;\n            aToOpen = sqlite3DbMallocRawNN(db, nIdx + 2);\n            if (aToOpen == 0) {\n                sqlite3WhereEnd(pWInfo);\n                goto delete_from_cleanup;\n            }\n            memset(aToOpen, 1, nIdx + 1);\n            aToOpen[nIdx + 1] = 0;\n            if (aiCurOnePass[0] >= 0)\n                aToOpen[aiCurOnePass[0] - iTabCur] = 0;\n            if (aiCurOnePass[1] >= 0)\n                aToOpen[aiCurOnePass[1] - iTabCur] = 0;\n            if (addrEphOpen)\n                sqlite3VdbeChangeToNoop(v, addrEphOpen);\n            addrBypass = sqlite3VdbeMakeLabel(pParse);\n        } else {\n            if (pPk) {\n                iKey = ++pParse->nMem;\n                nKey = 0;\n                sqlite3VdbeAddOp4(v, 97, iPk, nPk, iKey, sqlite3IndexAffinityStr(pParse->db, pPk), nPk);\n                sqlite3VdbeAddOp4Int(v, 138, iEphCur, iKey, iPk, nPk);\n            } else {\n                nKey = 1;\n                sqlite3VdbeAddOp2(v, 156, iRowSet, iKey);\n            }\n            sqlite3WhereEnd(pWInfo);\n        }\n        if (!isView) {\n            int iAddrOnce = 0;\n            if (eOnePass == 2) {\n                iAddrOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n            }\n            ;\n            sqlite3OpenTableAndIndices(pParse, pTab, 113, 8, iTabCur, aToOpen, &iDataCur, &iIdxCur);\n            assert(pPk || ((pTab)->eTabType == 1) || iDataCur == iTabCur);\n            assert(pPk || ((pTab)->eTabType == 1) || iIdxCur == iDataCur + 1);\n            if (eOnePass == 2) {\n                sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce);\n            }\n        }\n        if (eOnePass != 0) {\n            assert(nKey == nPk);\n            if (!((pTab)->eTabType == 1) && aToOpen[iDataCur - iTabCur]) {\n                assert(pPk != 0 || ((pTab)->eTabType == 2));\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, addrBypass, iKey, nKey);\n                ;\n            }\n        } else if (pPk) {\n            addrLoop = sqlite3VdbeAddOp1(v, 36, iEphCur);\n            ;\n            if (((pTab)->eTabType == 1)) {\n                sqlite3VdbeAddOp3(v, 94, iEphCur, 0, iKey);\n            } else {\n                sqlite3VdbeAddOp2(v, 134, iEphCur, iKey);\n            }\n            assert(nKey == 0);\n        } else {\n            addrLoop = sqlite3VdbeAddOp3(v, 46, iRowSet, 0, iKey);\n            ;\n            assert(nKey == 1);\n        }\n        if (((pTab)->eTabType == 1)) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            sqlite3VtabMakeWritable(pParse, pTab);\n            assert(eOnePass == 0 || eOnePass == 1);\n            sqlite3MayAbort(pParse);\n            if (eOnePass == 1) {\n                sqlite3VdbeAddOp1(v, 122, iTabCur);\n                if (((pParse)->pToplevel == 0)) {\n                    pParse->isMultiWrite = 0;\n                }\n            }\n            sqlite3VdbeAddOp4(v, 7, 0, 1, iKey, pVTab, (-11));\n            sqlite3VdbeChangeP5(v, 2);\n        } else {\n            int count = (pParse->nested == 0);\n            sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, iKey, nKey, count, 11, eOnePass, aiCurOnePass[1]);\n        }\n        if (eOnePass != 0) {\n            sqlite3VdbeResolveLabel(v, addrBypass);\n            sqlite3WhereEnd(pWInfo);\n        } else if (pPk) {\n            sqlite3VdbeAddOp2(v, 39, iEphCur, addrLoop + 1);\n            ;\n            sqlite3VdbeJumpHere(v, addrLoop);\n        } else {\n            sqlite3VdbeGoto(v, addrLoop);\n            sqlite3VdbeJumpHere(v, addrLoop);\n        }\n    }\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (memCnt) {\n        sqlite3CodeChangeCount(v, memCnt, \"rows deleted\");\n    }\n  delete_from_cleanup:\n    sqlite3AuthContextPop(&sContext);\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprDelete(db, pWhere);\n    if (aToOpen)\n        sqlite3DbNNFreeNN(db, aToOpen);\n    return;\n}\n"
        },
        {
            "id": "#23:25#sqlite3CreateIndex",
            "gotos": 28,
            "labels": 1,
            "body": "{\n    Table *pTab = 0;\n    Index *pIndex = 0;\n    char *zName = 0;\n    int nName;\n    int i, j;\n    DbFixer sFix;\n    int sortOrderMask;\n    sqlite3 *db = pParse->db;\n    Db *pDb;\n    int iDb;\n    Token *pName = 0;\n    struct ExprList_item *pListItem;\n    int nExtra = 0;\n    int nExtraCol;\n    char *zExtra = 0;\n    Index *pPk = 0;\n    assert(db->pParse == pParse);\n    if (pParse->nErr) {\n        goto exit_create_index;\n    }\n    assert(db->mallocFailed == 0);\n    if ((pParse->eParseMode == 1) && idxType != 2) {\n        goto exit_create_index;\n    }\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto exit_create_index;\n    }\n    if (sqlite3HasExplicitNulls(pParse, pList)) {\n        goto exit_create_index;\n    }\n    if (pTblName != 0) {\n        assert(pName1 && pName2);\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0)\n            goto exit_create_index;\n        assert(pName && pName->z);\n        if (!db->init.busy) {\n            pTab = sqlite3SrcListLookup(pParse, pTblName);\n            if (pName2->n == 0 && pTab && pTab->pSchema == db->aDb[1].pSchema) {\n                iDb = 1;\n            }\n        }\n        sqlite3FixInit(&sFix, pParse, iDb, \"index\", pName);\n        if (sqlite3FixSrcList(&sFix, pTblName)) {\n            assert(0);\n        }\n        pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);\n        assert(db->mallocFailed == 0 || pTab == 0);\n        if (pTab == 0)\n            goto exit_create_index;\n        if (iDb == 1 && db->aDb[iDb].pSchema != pTab->pSchema) {\n            sqlite3ErrorMsg(pParse, \"cannot create a TEMP index on non-TEMP table \\\"%s\\\"\", pTab->zName);\n            goto exit_create_index;\n        }\n        if (!(((pTab)->tabFlags & 128) == 0))\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n    } else {\n        assert(pName == 0);\n        assert(pStart == 0);\n        pTab = pParse->pNewTable;\n        if (!pTab)\n            goto exit_create_index;\n        iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    }\n    pDb = &db->aDb[iDb];\n    assert(pTab != 0);\n    if (sqlite3_strnicmp(pTab->zName, \"sqlite_\", 7) == 0 && db->init.busy == 0 && pTblName != 0) {\n        sqlite3ErrorMsg(pParse, \"table %s may not be indexed\", pTab->zName);\n        goto exit_create_index;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"views may not be indexed\");\n        goto exit_create_index;\n    }\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables may not be indexed\");\n        goto exit_create_index;\n    }\n    if (pName) {\n        zName = sqlite3NameFromToken(db, pName);\n        if (zName == 0)\n            goto exit_create_index;\n        assert(pName->z != 0);\n        if (0 != sqlite3CheckObjectName(pParse, zName, \"index\", pTab->zName)) {\n            goto exit_create_index;\n        }\n        if (!(pParse->eParseMode >= 2)) {\n            if (!db->init.busy) {\n                if (sqlite3FindTable(db, zName, pDb->zDbSName) != 0) {\n                    sqlite3ErrorMsg(pParse, \"there is already a table named %s\", zName);\n                    goto exit_create_index;\n                }\n            }\n            if (sqlite3FindIndex(db, zName, pDb->zDbSName) != 0) {\n                if (!ifNotExist) {\n                    sqlite3ErrorMsg(pParse, \"index %s already exists\", zName);\n                } else {\n                    assert(!db->init.busy);\n                    sqlite3CodeVerifySchema(pParse, iDb);\n                    sqlite3ForceNotReadOnly(pParse);\n                }\n                goto exit_create_index;\n            }\n        }\n    } else {\n        int n;\n        Index *pLoop;\n        for (pLoop = pTab->pIndex , n = 1; pLoop; pLoop = pLoop->pNext , n++) {\n        }\n        zName = sqlite3MPrintf(db, \"sqlite_autoindex_%s_%d\", pTab->zName, n);\n        if (zName == 0) {\n            goto exit_create_index;\n        }\n        if ((pParse->eParseMode != 0))\n            zName[7]++;\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        const char *zDb = pDb->zDbSName;\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto exit_create_index;\n        }\n        i = 1;\n        if (!0 && iDb == 1)\n            i = 3;\n        if (sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb)) {\n            goto exit_create_index;\n        }\n    }\n    if (pList == 0) {\n        Token prevCol;\n        Column *pCol = &pTab->aCol[pTab->nCol - 1];\n        pCol->colFlags |= 8;\n        sqlite3TokenInit(&prevCol, pCol->zCnName);\n        pList = sqlite3ExprListAppend(pParse, 0, sqlite3ExprAlloc(db, 59, &prevCol, 0));\n        if (pList == 0)\n            goto exit_create_index;\n        assert(pList->nExpr == 1);\n        sqlite3ExprListSetSortOrder(pList, sortOrder, -1);\n    } else {\n        sqlite3ExprListCheckLength(pParse, pList, \"index\");\n        if (pParse->nErr)\n            goto exit_create_index;\n    }\n    for (i = 0; i < pList->nExpr; i++) {\n        Expr *pExpr = pList->a[i].pExpr;\n        assert(pExpr != 0);\n        if (pExpr->op == 113) {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));\n        }\n    }\n    nName = sqlite3Strlen30(zName);\n    nExtraCol = pPk ? pPk->nKeyCol : 1;\n    assert(pList->nExpr + nExtraCol <= 32767);\n    pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol, nName + nExtra + 1, &zExtra);\n    if (db->mallocFailed) {\n        goto exit_create_index;\n    }\n    assert(((((char *)(pIndex->aiRowLogEst) - (char *)0) & 7) == 0));\n    assert(((((char *)(pIndex->azColl) - (char *)0) & 7) == 0));\n    pIndex->zName = zExtra;\n    zExtra += nName + 1;\n    memcpy(pIndex->zName, zName, nName + 1);\n    pIndex->pTable = pTab;\n    pIndex->onError = (u8)onError;\n    pIndex->uniqNotNull = onError != 0;\n    pIndex->idxType = idxType;\n    pIndex->pSchema = db->aDb[iDb].pSchema;\n    pIndex->nKeyCol = pList->nExpr;\n    if (pPIWhere) {\n        sqlite3ResolveSelfReference(pParse, pTab, 2, pPIWhere, 0);\n        pIndex->pPartIdxWhere = pPIWhere;\n        pPIWhere = 0;\n    }\n    assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n    if (pDb->pSchema->file_format >= 4) {\n        sortOrderMask = -1;\n    } else {\n        sortOrderMask = 0;\n    }\n    pListItem = pList->a;\n    if ((pParse->eParseMode >= 2)) {\n        pIndex->aColExpr = pList;\n        pList = 0;\n    }\n    for (i = 0; i < pIndex->nKeyCol; i++ , pListItem++) {\n        Expr *pCExpr;\n        int requestedSortOrder;\n        const char *zColl;\n        sqlite3StringToId(pListItem->pExpr);\n        sqlite3ResolveSelfReference(pParse, pTab, 32, pListItem->pExpr, 0);\n        if (pParse->nErr)\n            goto exit_create_index;\n        pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);\n        if (pCExpr->op != 167) {\n            if (pTab == pParse->pNewTable) {\n                sqlite3ErrorMsg(pParse, \"expressions prohibited in PRIMARY KEY and UNIQUE constraints\");\n                goto exit_create_index;\n            }\n            if (pIndex->aColExpr == 0) {\n                pIndex->aColExpr = pList;\n                pList = 0;\n            }\n            j = (-2);\n            pIndex->aiColumn[i] = (-2);\n            pIndex->uniqNotNull = 0;\n            pIndex->bHasExpr = 1;\n        } else {\n            j = pCExpr->iColumn;\n            assert(j <= 32767);\n            if (j < 0) {\n                j = pTab->iPKey;\n            } else {\n                if (pTab->aCol[j].notNull == 0) {\n                    pIndex->uniqNotNull = 0;\n                }\n                if (pTab->aCol[j].colFlags & 32) {\n                    pIndex->bHasVCol = 1;\n                    pIndex->bHasExpr = 1;\n                }\n            }\n            pIndex->aiColumn[i] = (i16)j;\n        }\n        zColl = 0;\n        if (pListItem->pExpr->op == 113) {\n            int nColl;\n            assert(!(((pListItem->pExpr)->flags & (2048)) != 0));\n            zColl = pListItem->pExpr->u.zToken;\n            nColl = sqlite3Strlen30(zColl) + 1;\n            assert(nExtra >= nColl);\n            memcpy(zExtra, zColl, nColl);\n            zColl = zExtra;\n            zExtra += nColl;\n            nExtra -= nColl;\n        } else if (j >= 0) {\n            zColl = sqlite3ColumnColl(&pTab->aCol[j]);\n        }\n        if (!zColl)\n            zColl = sqlite3StrBINARY;\n        if (!db->init.busy && !sqlite3LocateCollSeq(pParse, zColl)) {\n            goto exit_create_index;\n        }\n        pIndex->azColl[i] = zColl;\n        requestedSortOrder = pListItem->fg.sortFlags & sortOrderMask;\n        pIndex->aSortOrder[i] = (u8)requestedSortOrder;\n    }\n    if (pPk) {\n        for (j = 0; j < pPk->nKeyCol; j++) {\n            int x = pPk->aiColumn[j];\n            assert(x >= 0);\n            if (isDupColumn(pIndex, pIndex->nKeyCol, pPk, j)) {\n                pIndex->nColumn--;\n            } else {\n                ;\n                pIndex->aiColumn[i] = x;\n                pIndex->azColl[i] = pPk->azColl[j];\n                pIndex->aSortOrder[i] = pPk->aSortOrder[j];\n                i++;\n            }\n        }\n        assert(i == pIndex->nColumn);\n    } else {\n        pIndex->aiColumn[i] = (-1);\n        pIndex->azColl[i] = sqlite3StrBINARY;\n    }\n    sqlite3DefaultRowEst(pIndex);\n    if (pParse->pNewTable == 0)\n        estimateIndexWidth(pIndex);\n    assert((((pTab)->tabFlags & 128) == 0) || pTab->iPKey < 0 || sqlite3TableColumnToIndex(pIndex, pTab->iPKey) >= 0);\n    recomputeColumnsNotIndexed(pIndex);\n    if (pTblName != 0 && pIndex->nColumn >= pTab->nCol) {\n        pIndex->isCovering = 1;\n        for (j = 0; j < pTab->nCol; j++) {\n            if (j == pTab->iPKey)\n                continue;\n            if (sqlite3TableColumnToIndex(pIndex, j) >= 0)\n                continue;\n            pIndex->isCovering = 0;\n            break;\n        }\n    }\n    if (pTab == pParse->pNewTable) {\n        Index *pIdx;\n        for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n            int k;\n            assert(((pIdx)->onError != 0));\n            assert(pIdx->idxType != 0);\n            assert(((pIndex)->onError != 0));\n            if (pIdx->nKeyCol != pIndex->nKeyCol)\n                continue;\n            for (k = 0; k < pIdx->nKeyCol; k++) {\n                const char *z1;\n                const char *z2;\n                assert(pIdx->aiColumn[k] >= 0);\n                if (pIdx->aiColumn[k] != pIndex->aiColumn[k])\n                    break;\n                z1 = pIdx->azColl[k];\n                z2 = pIndex->azColl[k];\n                if (sqlite3StrICmp(z1, z2))\n                    break;\n            }\n            if (k == pIdx->nKeyCol) {\n                if (pIdx->onError != pIndex->onError) {\n                    if (!(pIdx->onError == 11 || pIndex->onError == 11)) {\n                        sqlite3ErrorMsg(pParse, \"conflicting ON CONFLICT clauses specified\", 0);\n                    }\n                    if (pIdx->onError == 11) {\n                        pIdx->onError = pIndex->onError;\n                    }\n                }\n                if (idxType == 2)\n                    pIdx->idxType = idxType;\n                if ((pParse->eParseMode >= 2)) {\n                    pIndex->pNext = pParse->pNewIndex;\n                    pParse->pNewIndex = pIndex;\n                    pIndex = 0;\n                }\n                goto exit_create_index;\n            }\n        }\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        assert(pParse->nErr == 0);\n        if (db->init.busy) {\n            Index *p;\n            assert(!(pParse->eParseMode != 0));\n            assert(sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema));\n            if (pTblName != 0) {\n                pIndex->tnum = db->init.newTnum;\n                if (sqlite3IndexHasDuplicateRootPage(pIndex)) {\n                    sqlite3ErrorMsg(pParse, \"invalid rootpage\");\n                    pParse->rc = sqlite3CorruptError(121012);\n                    goto exit_create_index;\n                }\n            }\n            p = sqlite3HashInsert(&pIndex->pSchema->idxHash, pIndex->zName, pIndex);\n            if (p) {\n                assert(p == pIndex);\n                sqlite3OomFault(db);\n                goto exit_create_index;\n            }\n            db->mDbFlags |= 1;\n        } else if ((((pTab)->tabFlags & 128) == 0) || pTblName != 0) {\n            Vdbe *v;\n            char *zStmt;\n            int iMem = ++pParse->nMem;\n            v = sqlite3GetVdbe(pParse);\n            if (v == 0)\n                goto exit_create_index;\n            sqlite3BeginWriteOperation(pParse, 1, iDb);\n            pIndex->tnum = (Pgno)sqlite3VdbeAddOp0(v, 184);\n            sqlite3VdbeAddOp3(v, 147, iDb, iMem, 2);\n            assert(pName != 0 || pStart == 0);\n            if (pStart) {\n                int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;\n                if (pName->z[n - 1] == ';')\n                    n--;\n                zStmt = sqlite3MPrintf(db, \"CREATE%s INDEX %.*s\", onError == 0 ? \"\" : \" UNIQUE\", n, pName->z);\n            } else {\n                zStmt = 0;\n            }\n            sqlite3NestedParse(pParse, \"INSERT INTO %Q.sqlite_master VALUES('index',%Q,%Q,#%d,%Q);\", db->aDb[iDb].zDbSName, pIndex->zName, pTab->zName, iMem, zStmt);\n            sqlite3DbFree(db, zStmt);\n            if (pTblName) {\n                sqlite3RefillIndex(pParse, pIndex, iMem);\n                sqlite3ChangeCookie(pParse, iDb);\n                sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, \"name='%q' AND type='index'\", pIndex->zName), 0);\n                sqlite3VdbeAddOp2(v, 166, 0, 1);\n            }\n            sqlite3VdbeJumpHere(v, (int)pIndex->tnum);\n        }\n    }\n    if (db->init.busy || pTblName == 0) {\n        pIndex->pNext = pTab->pIndex;\n        pTab->pIndex = pIndex;\n        pIndex = 0;\n    } else if ((pParse->eParseMode >= 2)) {\n        assert(pParse->pNewIndex == 0);\n        pParse->pNewIndex = pIndex;\n        pIndex = 0;\n    }\n  exit_create_index:\n    if (pIndex)\n        sqlite3FreeIndex(db, pIndex);\n    if (pTab) {\n        Index **ppFrom;\n        Index *pThis;\n        for (ppFrom = &pTab->pIndex; (pThis = *ppFrom) != 0; ppFrom = &pThis->pNext) {\n            Index *pNext;\n            if (pThis->onError != 5)\n                continue;\n            while ((pNext = pThis->pNext) != 0 && pNext->onError != 5)\n                {\n                    *ppFrom = pNext;\n                    pThis->pNext = pNext->pNext;\n                    pNext->pNext = pThis;\n                    ppFrom = &pNext->pNext;\n                }\n            break;\n        }\n    }\n    sqlite3ExprDelete(db, pPIWhere);\n    sqlite3ExprListDelete(db, pList);\n    sqlite3SrcListDelete(db, pTblName);\n    sqlite3DbFree(db, zName);\n}\n"
        }
    ],
    "total": 2429,
    "visited": 112
}
