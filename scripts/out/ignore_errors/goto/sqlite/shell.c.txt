{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#25275:1#quickscan",
            "gotos": 5,
            "labels": 2,
            "body": "{\n    char cin;\n    char cWait = (char)qss;\n    if (cWait == 0) {\n      PlainScan:\n        assert(cWait == 0);\n        while ((cin = *zLine++) != 0)\n            {\n                if (isspace((unsigned char)cin))\n                    continue;\n                switch (cin) {\n                  case '-':\n                    if (*zLine != '-')\n                        break;\n                    while ((cin = *++zLine) != 0)\n                        if (cin == '\\n')\n                            goto PlainScan;\n                    return qss;\n                  case ';':\n                    qss |= QSS_EndingSemi;\n                    continue;\n                  case '/':\n                    if (*zLine == '*') {\n                        ++zLine;\n                        cWait = '*';\n                        qss = ((cWait) | ((qss) & QSS_ScanMask));\n                        goto TermScan;\n                    }\n                    break;\n                  case '[':\n                    cin = ']';\n                  case '`':\n                  case '\\'':\n                  case '\"':\n                    cWait = cin;\n                    qss = QSS_HasDark | cWait;\n                    goto TermScan;\n                  default:\n                    break;\n                }\n                qss = (qss & ~QSS_EndingSemi) | QSS_HasDark;\n            }\n    } else {\n      TermScan:\n        while ((cin = *zLine++) != 0)\n            {\n                if (cin == cWait) {\n                    switch (cWait) {\n                      case '*':\n                        if (*zLine != '/')\n                            continue;\n                        ++zLine;\n                        cWait = 0;\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      case '`':\n                      case '\\'':\n                      case '\"':\n                        if (*zLine == cWait) {\n                            ++zLine;\n                            continue;\n                        }\n                      case ']':\n                        cWait = 0;\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      default:\n                        assert(0);\n                    }\n                }\n            }\n    }\n    return qss;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#20038:1#tryToCloneData",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    sqlite3_stmt *pQuery = 0;\n    sqlite3_stmt *pInsert = 0;\n    char *zQuery = 0;\n    char *zInsert = 0;\n    int rc;\n    int i, j, n;\n    int nTable = strlen30(zTable);\n    int k = 0;\n    int cnt = 0;\n    const int spinRate = 10000;\n    zQuery = sqlite3_mprintf(\"SELECT * FROM \\\"%w\\\"\", zTable);\n    shell_check_oom(zQuery);\n    rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n    if (rc) {\n        goto end_data_xfer;\n    }\n    n = sqlite3_column_count(pQuery);\n    zInsert = sqlite3_malloc64(200 + nTable + n * 3);\n    shell_check_oom(zInsert);\n    sqlite3_snprintf(200 + nTable, zInsert, \"INSERT OR IGNORE INTO \\\"%s\\\" VALUES(?\", zTable);\n    i = strlen30(zInsert);\n    for (j = 1; j < n; j++) {\n        memcpy(zInsert + i, \",?\", 2);\n        i += 2;\n    }\n    memcpy(zInsert + i, \");\", 3);\n    rc = sqlite3_prepare_v2(newDb, zInsert, -1, &pInsert, 0);\n    if (rc) {\n        goto end_data_xfer;\n    }\n    for (k = 0; k < 2; k++) {\n        while ((rc = sqlite3_step(pQuery)) == 100)\n            {\n                for (i = 0; i < n; i++) {\n                    switch (sqlite3_column_type(pQuery, i)) {\n                      case 5:\n                        {\n                            sqlite3_bind_null(pInsert, i + 1);\n                            break;\n                        }\n                      case 1:\n                        {\n                            sqlite3_bind_int64(pInsert, i + 1, sqlite3_column_int64(pQuery, i));\n                            break;\n                        }\n                      case 2:\n                        {\n                            sqlite3_bind_double(pInsert, i + 1, sqlite3_column_double(pQuery, i));\n                            break;\n                        }\n                      case 3:\n                        {\n                            sqlite3_bind_text(pInsert, i + 1, (const char *)sqlite3_column_text(pQuery, i), -1, ((sqlite3_destructor_type)0));\n                            break;\n                        }\n                      case 4:\n                        {\n                            sqlite3_bind_blob(pInsert, i + 1, sqlite3_column_blob(pQuery, i), sqlite3_column_bytes(pQuery, i), ((sqlite3_destructor_type)0));\n                            break;\n                        }\n                    }\n                }\n                rc = sqlite3_step(pInsert);\n                if (rc != 0 && rc != 100 && rc != 101) {\n                }\n                sqlite3_reset(pInsert);\n                cnt++;\n                if ((cnt % spinRate) == 0) {\n                    printf(\"%c\\b\", \"|/-\\\\\"[(cnt / spinRate) % 4]);\n                }\n            }\n        if (rc == 101)\n            break;\n        sqlite3_finalize(pQuery);\n        sqlite3_free(zQuery);\n        zQuery = sqlite3_mprintf(\"SELECT * FROM \\\"%w\\\" ORDER BY rowid DESC;\", zTable);\n        shell_check_oom(zQuery);\n        rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n        if (rc) {\n            break;\n        }\n    }\n  end_data_xfer:\n    sqlite3_finalize(pQuery);\n    sqlite3_finalize(pInsert);\n    sqlite3_free(zQuery);\n    sqlite3_free(zInsert);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#19218:1#readHexDb",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    unsigned char *a = 0;\n    int nLine;\n    int n = 0;\n    int pgsz = 0;\n    int iOffset = 0;\n    int j, k;\n    int rc;\n    const char *zDbFilename = p->pAuxDb->zDbFilename;\n    unsigned int x[16];\n    char zLine[1000];\n    if (zDbFilename) {\n        if (<recovery-expr>()) {\n            return 0;\n        }\n        nLine = 0;\n    } else {\n        nLine = p->lineno;\n    }\n    *pnData = 0;\n    nLine++;\n    if (<recovery-expr>())\n        goto readHexDb_error;\n    rc = sscanf(zLine, \"| size %d pagesize %d\", &n, &pgsz);\n    if (rc != 2)\n        goto readHexDb_error;\n    if (n < 0)\n        goto readHexDb_error;\n    if (pgsz < 512 || pgsz > 65536 || (pgsz & (pgsz - 1)) != 0)\n        goto readHexDb_error;\n    n = (n + pgsz - 1) & ~(pgsz - 1);\n    a = sqlite3_malloc(n ? n : 1);\n    shell_check_oom(a);\n    memset(a, 0, n);\n    if (pgsz < 512 || pgsz > 65536 || (pgsz & (pgsz - 1)) != 0) {\n        goto readHexDb_error;\n    }\n    *pnData = n;\n    if (<recovery-expr>()) {\n    } else {\n        p->lineno = nLine;\n    }\n    return a;\n  readHexDb_error:\n    if (<recovery-expr>()) {\n    } else {\n        while (fgets(zLine, sizeof (zLine), <recovery-expr>(p)) != 0)\n            {\n                nLine++;\n                if (<recovery-expr>()(zLine, \"| end \", 6) == 0)\n                    break;\n            }\n        p->lineno = nLine;\n    }\n    sqlite3_free(a);\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#15787:1#editFunc",
            "gotos": 7,
            "labels": 1,
            "body": "{\n    const char *zEditor;\n    char *zTempFile = 0;\n    sqlite3 *db;\n    char *zCmd = 0;\n    int bBin;\n    int rc;\n    int hasCRNL = 0;\n    sqlite3_int64 sz;\n    sqlite3_int64 x;\n    unsigned char *p = 0;\n    if (argc == 2) {\n        zEditor = (const char *)sqlite3_value_text(argv[1]);\n    } else {\n        zEditor = getenv(\"VISUAL\");\n    }\n    if (zEditor == 0) {\n        sqlite3_result_error(context, \"no editor for edit()\", -1);\n        return;\n    }\n    if (sqlite3_value_type(argv[0]) == 5) {\n        sqlite3_result_error(context, \"NULL input to edit()\", -1);\n        return;\n    }\n    db = sqlite3_context_db_handle(context);\n    zTempFile = 0;\n    sqlite3_file_control(db, 0, 16, &zTempFile);\n    if (zTempFile == 0) {\n        sqlite3_uint64 r = 0;\n        sqlite3_randomness(sizeof (r), &r);\n        zTempFile = sqlite3_mprintf(\"temp%llx\", r);\n        if (zTempFile == 0) {\n            sqlite3_result_error_nomem(context);\n            return;\n        }\n    }\n    bBin = sqlite3_value_type(argv[0]) == 4;\n    if (<recovery-expr>()) {\n        sqlite3_result_error(context, \"edit() cannot open temp file\", -1);\n        goto edit_func_end;\n    }\n    sz = sqlite3_value_bytes(argv[0]);\n    if (bBin) {\n    } else {\n        const char *z = (const char *)sqlite3_value_text(argv[0]);\n        if (z && strstr(z, \"\\r\\n\") != 0)\n            hasCRNL = 1;\n    }\n    if (x != sz) {\n        sqlite3_result_error(context, \"edit() could not write the whole file\", -1);\n        goto edit_func_end;\n    }\n    zCmd = sqlite3_mprintf(\"%s \\\"%s\\\"\", zEditor, zTempFile);\n    if (zCmd == 0) {\n        sqlite3_result_error_nomem(context);\n        goto edit_func_end;\n    }\n    rc = system(zCmd);\n    sqlite3_free(zCmd);\n    if (rc) {\n        sqlite3_result_error(context, \"EDITOR returned non-zero\", -1);\n        goto edit_func_end;\n    }\n    if (<recovery-expr>()) {\n        sqlite3_result_error(context, \"edit() cannot reopen temp file after edit\", -1);\n        goto edit_func_end;\n    }\n    p = sqlite3_malloc64(sz + 1);\n    if (p == 0) {\n        sqlite3_result_error_nomem(context);\n        goto edit_func_end;\n    }\n    if (x != sz) {\n        sqlite3_result_error(context, \"could not read back the whole file\", -1);\n        goto edit_func_end;\n    }\n    if (bBin) {\n        sqlite3_result_blob64(context, p, sz, sqlite3_free);\n    } else {\n        sqlite3_int64 i, j;\n        if (hasCRNL) {\n        } else {\n            for (i = j = 0; i < sz; i++) {\n                if (p[i] == '\\r' && p[i + 1] == '\\n')\n                    i++;\n                p[j++] = p[i];\n            }\n            sz = j;\n            p[sz] = 0;\n        }\n        sqlite3_result_text64(context, (const char *)p, sz, sqlite3_free, 1);\n    }\n    p = 0;\n  edit_func_end:\n    ;\n    unlink(zTempFile);\n    sqlite3_free(zTempFile);\n    sqlite3_free(p);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#20150:1#tryToCloneSchema",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    sqlite3_stmt *pQuery = 0;\n    char *zQuery = 0;\n    int rc;\n    const unsigned char *zName;\n    const unsigned char *zSql;\n    char *zErrMsg = 0;\n    zQuery = sqlite3_mprintf(\"SELECT name, sql FROM sqlite_schema WHERE %s\", zWhere);\n    shell_check_oom(zQuery);\n    rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n    if (rc) {\n        goto end_schema_xfer;\n    }\n    while ((rc = sqlite3_step(pQuery)) == 100)\n        {\n            zName = sqlite3_column_text(pQuery, 0);\n            zSql = sqlite3_column_text(pQuery, 1);\n            if (zName == 0 || zSql == 0)\n                continue;\n            printf(\"%s... \", zName);\n            sqlite3_exec(newDb, (const char *)zSql, 0, 0, &zErrMsg);\n            if (zErrMsg) {\n                sqlite3_free(zErrMsg);\n                zErrMsg = 0;\n            }\n            if (xForEach) {\n                xForEach(p, newDb, (const char *)zName);\n            }\n            printf(\"done\\n\");\n        }\n    if (rc != 101) {\n        sqlite3_finalize(pQuery);\n        sqlite3_free(zQuery);\n        zQuery = sqlite3_mprintf(\"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid DESC\", zWhere);\n        shell_check_oom(zQuery);\n        rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n        if (rc) {\n            goto end_schema_xfer;\n        }\n        while (sqlite3_step(pQuery) == 100)\n            {\n                zName = sqlite3_column_text(pQuery, 0);\n                zSql = sqlite3_column_text(pQuery, 1);\n                if (zName == 0 || zSql == 0)\n                    continue;\n                printf(\"%s... \", zName);\n                sqlite3_exec(newDb, (const char *)zSql, 0, 0, &zErrMsg);\n                if (zErrMsg) {\n                    sqlite3_free(zErrMsg);\n                    zErrMsg = 0;\n                }\n                if (xForEach) {\n                    xForEach(p, newDb, (const char *)zName);\n                }\n                printf(\"done\\n\");\n            }\n    }\n  end_schema_xfer:\n    sqlite3_finalize(pQuery);\n    sqlite3_free(zQuery);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#10543:1#idxFindIndexes",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    IdxStatement *pStmt;\n    sqlite3 *dbm = p->dbm;\n    int rc = 0;\n    IdxHash hIdx;\n    idxHashInit(&hIdx);\n    for (pStmt = p->pStatement; rc == 0 && pStmt; pStmt = pStmt->pNext) {\n        IdxHashEntry *pEntry;\n        sqlite3_stmt *pExplain = 0;\n        idxHashClear(&hIdx);\n        rc = idxPrintfPrepareStmt(dbm, &pExplain, pzErr, \"EXPLAIN QUERY PLAN %s\", pStmt->zSql);\n        while (rc == 0 && sqlite3_step(pExplain) == 100)\n            {\n                const char *zDetail = (const char *)sqlite3_column_text(pExplain, 3);\n                int nDetail;\n                int i;\n                if (!zDetail)\n                    continue;\n                nDetail = (int)strlen(zDetail);\n                for (i = 0; i < nDetail; i++) {\n                    const char *zIdx = 0;\n                    if (i + 13 < nDetail && memcmp(&zDetail[i], \" USING INDEX \", 13) == 0) {\n                        zIdx = &zDetail[i + 13];\n                    } else if (i + 22 < nDetail && memcmp(&zDetail[i], \" USING COVERING INDEX \", 22) == 0) {\n                        zIdx = &zDetail[i + 22];\n                    }\n                    if (zIdx) {\n                        const char *zSql;\n                        int nIdx = 0;\n                        while (zIdx[nIdx] != '\\x00' && (zIdx[nIdx] != ' ' || zIdx[nIdx + 1] != '('))\n                            {\n                                nIdx++;\n                            }\n                        zSql = idxHashSearch(&p->hIdx, zIdx, nIdx);\n                        if (zSql) {\n                            idxHashAdd(&rc, &hIdx, zSql, 0);\n                            if (rc)\n                                goto find_indexes_out;\n                        }\n                        break;\n                    }\n                }\n                if (zDetail[0] != '-') {\n                    pStmt->zEQP = idxAppendText(&rc, pStmt->zEQP, \"%s\\n\", zDetail);\n                }\n            }\n        for (pEntry = hIdx.pFirst; pEntry; pEntry = pEntry->pNext) {\n            pStmt->zIdx = idxAppendText(&rc, pStmt->zIdx, \"%s;\\n\", pEntry->zKey);\n        }\n        idxFinalize(&rc, pExplain);\n    }\n  find_indexes_out:\n    idxHashClear(&hIdx);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#3970:1#sqlite3re_match",
            "gotos": 2,
            "labels": 2,
            "body": "{\n    ReStateSet aStateSet[2], *pThis, *pNext;\n    ReStateNumber aSpace[100];\n    ReStateNumber *pToFree;\n    unsigned int i = 0;\n    unsigned int iSwap = 0;\n    int c = 268435455;\n    int cPrev = 0;\n    int rc = 0;\n    ReInput in;\n    in.z = zIn;\n    in.i = 0;\n    in.mx = nIn >= 0 ? nIn : (int)strlen((const char *)zIn);\n    if (pRe->nInit) {\n        unsigned char x = pRe->zInit[0];\n        while (in.i + pRe->nInit <= in.mx && (zIn[in.i] != x || strncmp((const char *)zIn + in.i, (const char *)pRe->zInit, pRe->nInit) != 0))\n            {\n                in.i++;\n            }\n        if (in.i + pRe->nInit > in.mx)\n            return 0;\n        c = 268435455 - 1;\n    }\n    if (pRe->nState <= (sizeof (aSpace) / (sizeof (aSpace[0]) * 2))) {\n        pToFree = 0;\n        aStateSet[0].aState = aSpace;\n    } else {\n        pToFree = sqlite3_malloc64(sizeof(ReStateNumber) * 2 * pRe->nState);\n        if (pToFree == 0)\n            return -1;\n        aStateSet[0].aState = pToFree;\n    }\n    aStateSet[1].aState = &aStateSet[0].aState[pRe->nState];\n    pNext = &aStateSet[1];\n    pNext->nState = 0;\n    re_add_state(pNext, 0);\n    while (c != 0 && pNext->nState > 0)\n        {\n            cPrev = c;\n            c = pRe->xNextChar(&in);\n            pThis = pNext;\n            pNext = &aStateSet[iSwap];\n            iSwap = 1 - iSwap;\n            pNext->nState = 0;\n            for (i = 0; i < pThis->nState; i++) {\n                int x = pThis->aState[i];\n                switch (pRe->aOp[x]) {\n                  case 1:\n                    {\n                        if (pRe->aArg[x] == c)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 18:\n                    {\n                        if (cPrev == 268435455)\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 2:\n                    {\n                        if (c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 11:\n                    {\n                        if (re_word_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 12:\n                    {\n                        if (!re_word_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 13:\n                    {\n                        if (re_digit_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 14:\n                    {\n                        if (!re_digit_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 15:\n                    {\n                        if (re_space_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 16:\n                    {\n                        if (!re_space_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 17:\n                    {\n                        if (re_word_char(c) != re_word_char(cPrev))\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 3:\n                    {\n                        re_add_state(pNext, x);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 4:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 5:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        break;\n                    }\n                  case 6:\n                    {\n                        rc = 1;\n                        goto re_match_end;\n                    }\n                  case 8:\n                    {\n                        if (c == 0)\n                            break;\n                        goto re_op_cc_inc;\n                    }\n                  case 7:\n                  re_op_cc_inc:\n                    {\n                        int j = 1;\n                        int n = pRe->aArg[x];\n                        int hit = 0;\n                        for (j = 1; j > 0 && j < n; j++) {\n                            if (pRe->aOp[x + j] == 9) {\n                                if (pRe->aArg[x + j] == c) {\n                                    hit = 1;\n                                    j = -1;\n                                }\n                            } else {\n                                if (pRe->aArg[x + j] <= c && pRe->aArg[x + j + 1] >= c) {\n                                    hit = 1;\n                                    j = -1;\n                                } else {\n                                    j++;\n                                }\n                            }\n                        }\n                        if (pRe->aOp[x] == 8)\n                            hit = !hit;\n                        if (hit)\n                            re_add_state(pNext, x + n);\n                        break;\n                    }\n                }\n            }\n        }\n    for (i = 0; i < pNext->nState; i++) {\n        int x = pNext->aState[i];\n        while (pRe->aOp[x] == 5)\n            x += pRe->aArg[x];\n        if (pRe->aOp[x] == 6) {\n            rc = 1;\n            break;\n        }\n    }\n  re_match_end:\n    sqlite3_free(pToFree);\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#17826:1#exec_prepared_stmt_columnar",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    sqlite3_int64 nRow = 0;\n    int nColumn = 0;\n    char **azData = 0;\n    sqlite3_int64 nAlloc = 0;\n    char *abRowDiv = 0;\n    const unsigned char *uz;\n    const char *z;\n    char **azQuoted = 0;\n    int rc;\n    sqlite3_int64 i, nData;\n    int j, nTotal, w, n;\n    const char *colSep = 0;\n    const char *rowSep = 0;\n    const unsigned char **azNextLine = 0;\n    int bNextLine = 0;\n    int bMultiLineRowExists = 0;\n    int bw = p->cmOpts.bWordWrap;\n    const char *zEmpty = \"\";\n    const char *zShowNull = p->nullValue;\n    rc = sqlite3_step(pStmt);\n    if (rc != 100)\n        return;\n    nColumn = sqlite3_column_count(pStmt);\n    nAlloc = nColumn * 4;\n    if (nAlloc <= 0)\n        nAlloc = 1;\n    azData = sqlite3_malloc64(nAlloc * sizeof(char *));\n    shell_check_oom(azData);\n    azNextLine = sqlite3_malloc64(nColumn * sizeof(char *));\n    shell_check_oom((void *)azNextLine);\n    memset((void *)azNextLine, 0, nColumn * sizeof(char *));\n    if (p->cmOpts.bQuote) {\n        azQuoted = sqlite3_malloc64(nColumn * sizeof(char *));\n        shell_check_oom(azQuoted);\n        memset(azQuoted, 0, nColumn * sizeof(char *));\n    }\n    abRowDiv = sqlite3_malloc64(nAlloc / nColumn);\n    shell_check_oom(abRowDiv);\n    if (nColumn > p->nWidth) {\n        p->colWidth = realloc(p->colWidth, (nColumn + 1) * 2 * sizeof(int));\n        shell_check_oom(p->colWidth);\n        for (i = p->nWidth; i < nColumn; i++)\n            p->colWidth[i] = 0;\n        p->nWidth = nColumn;\n        p->actualWidth = &p->colWidth[nColumn];\n    }\n    memset(p->actualWidth, 0, nColumn * sizeof(int));\n    for (i = 0; i < nColumn; i++) {\n        w = p->colWidth[i];\n        if (w < 0)\n            w = -w;\n        p->actualWidth[i] = w;\n    }\n    for (i = 0; i < nColumn; i++) {\n        const unsigned char *zNotUsed;\n        int wx = p->colWidth[i];\n        if (wx == 0) {\n            wx = p->cmOpts.iWrap;\n        }\n        if (wx < 0)\n            wx = -wx;\n        uz = (const unsigned char *)sqlite3_column_name(pStmt, i);\n        azData[i] = translateForDisplayAndDup(uz, &zNotUsed, wx, bw);\n    }\n    do {\n        int useNextLine = bNextLine;\n        bNextLine = 0;\n        if ((nRow + 2) * nColumn >= nAlloc) {\n            nAlloc *= 2;\n            azData = sqlite3_realloc64(azData, nAlloc * sizeof(char *));\n            shell_check_oom(azData);\n            abRowDiv = sqlite3_realloc64(abRowDiv, nAlloc / nColumn);\n            shell_check_oom(abRowDiv);\n        }\n        abRowDiv[nRow] = 1;\n        nRow++;\n        for (i = 0; i < nColumn; i++) {\n            int wx = p->colWidth[i];\n            if (wx == 0) {\n                wx = p->cmOpts.iWrap;\n            }\n            if (wx < 0)\n                wx = -wx;\n            if (useNextLine) {\n                uz = azNextLine[i];\n                if (uz == 0)\n                    uz = (u8 *)zEmpty;\n            } else if (p->cmOpts.bQuote) {\n                sqlite3_free(azQuoted[i]);\n                azQuoted[i] = quoted_column(pStmt, i);\n                uz = (const unsigned char *)azQuoted[i];\n            } else {\n                uz = (const unsigned char *)sqlite3_column_text(pStmt, i);\n                if (uz == 0)\n                    uz = (u8 *)zShowNull;\n            }\n            azData[nRow * nColumn + i] = translateForDisplayAndDup(uz, &azNextLine[i], wx, bw);\n            if (azNextLine[i]) {\n                bNextLine = 1;\n                abRowDiv[nRow - 1] = 0;\n                bMultiLineRowExists = 1;\n            }\n        }\n    } while (bNextLine || sqlite3_step(pStmt) == 100);\n    nTotal = nColumn * (nRow + 1);\n    for (i = 0; i < nTotal; i++) {\n        z = azData[i];\n        if (z == 0)\n            z = (char *)zEmpty;\n        n = strlenChar(z);\n        j = i % nColumn;\n        if (n > p->actualWidth[j])\n            p->actualWidth[j] = n;\n    }\n    if (seenInterrupt)\n        goto columnar_end;\n    if (nColumn == 0)\n        goto columnar_end;\n    switch (p->cMode) {\n      case 1:\n        {\n            colSep = \"  \";\n            rowSep = \"\\n\";\n            if (p->showHeader) {\n                for (i = 0; i < nColumn; i++) {\n                    w = p->actualWidth[i];\n                    if (p->colWidth[i] < 0)\n                        w = -w;\n                    <recovery-expr>()(<recovery-expr>(p), w, azData[i]);\n                    fputs(i == nColumn - 1 ? \"\\n\" : \"  \", <recovery-expr>(p));\n                }\n                for (i = 0; i < nColumn; i++) {\n                    <recovery-expr>()(<recovery-expr>(p), p->actualWidth[i]);\n                    fputs(i == nColumn - 1 ? \"\\n\" : \"  \", <recovery-expr>(p));\n                }\n            }\n            break;\n        }\n      case 15:\n        {\n            colSep = \" | \";\n            rowSep = \" |\\n\";\n            print_row_separator(p, nColumn, \"+\");\n            fputs(\"| \", <recovery-expr>(p));\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(<recovery-expr>(p), \"%*s%s%*s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\");\n                fputs(i == nColumn - 1 ? \" |\\n\" : \" | \", <recovery-expr>(p));\n            }\n            print_row_separator(p, nColumn, \"+\");\n            break;\n        }\n      case 14:\n        {\n            colSep = \" | \";\n            rowSep = \" |\\n\";\n            fputs(\"| \", <recovery-expr>(p));\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(<recovery-expr>(p), \"%*s%s%*s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\");\n                fputs(i == nColumn - 1 ? \" |\\n\" : \" | \", <recovery-expr>(p));\n            }\n            print_row_separator(p, nColumn, \"|\");\n            break;\n        }\n      case 16:\n        {\n            colSep = \" \\342\\224\\202 \";\n            rowSep = \" \\342\\224\\202\\n\";\n            print_box_row_separator(p, nColumn, \"\\342\\224\\214\", \"\\342\\224\\254\", \"\\342\\224\\220\");\n            fprintf(<recovery-expr>(p), \"\\342\\224\\202 \");\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(<recovery-expr>(p), \"%*s%s%*s%s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\", i == nColumn - 1 ? \" \\342\\224\\202\\n\" : \" \\342\\224\\202 \");\n            }\n            print_box_row_separator(p, nColumn, \"\\342\\224\\234\", \"\\342\\224\\274\", \"\\342\\224\\244\");\n            break;\n        }\n    }\n    for (i = nColumn , j = 0; i < nTotal; i++ , j++) {\n        if (j == 0 && p->cMode != 1) {\n            fprintf(<recovery-expr>(p), \"%s\", p->cMode == 16 ? \"\\342\\224\\202 \" : \"| \");\n        }\n        z = azData[i];\n        if (z == 0)\n            z = p->nullValue;\n        w = p->actualWidth[j];\n        if (p->colWidth[j] < 0)\n            w = -w;\n        <recovery-expr>()(<recovery-expr>(p), w, z);\n        if (j == nColumn - 1) {\n            fprintf(<recovery-expr>(p), \"%s\", rowSep);\n            if (bMultiLineRowExists && abRowDiv[i / nColumn - 1] && i + 1 < nTotal) {\n                if (p->cMode == 15) {\n                    print_row_separator(p, nColumn, \"+\");\n                } else if (p->cMode == 16) {\n                    print_box_row_separator(p, nColumn, \"\\342\\224\\234\", \"\\342\\224\\274\", \"\\342\\224\\244\");\n                } else if (p->cMode == 1) {\n                    fprintf(<recovery-expr>(p), \"\\n\");\n                }\n            }\n            j = -1;\n            if (seenInterrupt)\n                goto columnar_end;\n        } else {\n            fprintf(<recovery-expr>(p), \"%s\", colSep);\n        }\n    }\n    if (p->cMode == 15) {\n        print_row_separator(p, nColumn, \"+\");\n    } else if (p->cMode == 16) {\n        print_box_row_separator(p, nColumn, \"\\342\\224\\224\", \"\\342\\224\\264\", \"\\342\\224\\230\");\n    }\n  columnar_end:\n    if (seenInterrupt) {\n        fprintf(<recovery-expr>(p), \"Interrupt\\n\");\n    }\n    nData = (nRow + 1) * nColumn;\n    for (i = 0; i < nData; i++) {\n        z = azData[i];\n        if (z != zEmpty && z != zShowNull)\n            free(azData[i]);\n    }\n    sqlite3_free(azData);\n    sqlite3_free((void *)azNextLine);\n    sqlite3_free(abRowDiv);\n    if (azQuoted) {\n        for (i = 0; i < nColumn; i++)\n            sqlite3_free(azQuoted[i]);\n        sqlite3_free(azQuoted);\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#2889:1#decimalMulFunc",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    Decimal *pA = decimal_new(context, argv[0], 0, 0);\n    Decimal *pB = decimal_new(context, argv[1], 0, 0);\n    signed char *acc = 0;\n    int i, j, k;\n    int minFrac;\n    (void)(argc);\n    if (pA == 0 || pA->oom || pA->isNull || pB == 0 || pB->oom || pB->isNull) {\n        goto mul_end;\n    }\n    acc = sqlite3_malloc64(pA->nDigit + pB->nDigit + 2);\n    if (acc == 0) {\n        sqlite3_result_error_nomem(context);\n        goto mul_end;\n    }\n    memset(acc, 0, pA->nDigit + pB->nDigit + 2);\n    minFrac = pA->nFrac;\n    if (pB->nFrac < minFrac)\n        minFrac = pB->nFrac;\n    for (i = pA->nDigit - 1; i >= 0; i--) {\n        signed char f = pA->a[i];\n        int carry = 0, x;\n        for (j = pB->nDigit - 1 , k = i + j + 3; j >= 0; j-- , k--) {\n            x = acc[k] + f * pB->a[j] + carry;\n            acc[k] = x % 10;\n            carry = x / 10;\n        }\n        x = acc[k] + carry;\n        acc[k] = x % 10;\n        acc[k - 1] += x / 10;\n    }\n    sqlite3_free(pA->a);\n    pA->a = acc;\n    acc = 0;\n    pA->nDigit += pB->nDigit + 2;\n    pA->nFrac += pB->nFrac;\n    pA->sign ^= pB->sign;\n    while (pA->nFrac > minFrac && pA->a[pA->nDigit - 1] == 0)\n        {\n            pA->nFrac--;\n            pA->nDigit--;\n        }\n    decimal_result(context, pA);\n  mul_end:\n    sqlite3_free(acc);\n    decimal_free(pA);\n    decimal_free(pB);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#21990:1#do_meta_command",
            "gotos": 48,
            "labels": 3,
            "body": "{\n    int h = 1;\n    int nArg = 0;\n    int n, c;\n    int rc = 0;\n    char *azArg[52];\n    if (p->expert.pExpert) {\n        expertFinish(p, 1, 0);\n    }\n    while (zLine[h] && nArg < (int)(sizeof (azArg) / sizeof (azArg[0])) - 1)\n        {\n            while (isspace((unsigned char)zLine[h]))\n                {\n                    h++;\n                }\n            if (zLine[h] == 0)\n                break;\n            if (zLine[h] == '\\'' || zLine[h] == '\"') {\n                int delim = zLine[h++];\n                azArg[nArg++] = &zLine[h];\n                while (zLine[h] && zLine[h] != delim)\n                    {\n                        if (zLine[h] == '\\\\' && delim == '\"' && zLine[h + 1] != 0)\n                            h++;\n                        h++;\n                    }\n                if (zLine[h] == delim) {\n                    zLine[h++] = 0;\n                }\n                if (delim == '\"')\n                    resolve_backslashes(azArg[nArg - 1]);\n            } else {\n                azArg[nArg++] = &zLine[h];\n                while (zLine[h] && !isspace((unsigned char)zLine[h]))\n                    {\n                        h++;\n                    }\n                if (zLine[h])\n                    zLine[h++] = 0;\n                resolve_backslashes(azArg[nArg - 1]);\n            }\n        }\n    azArg[nArg] = 0;\n    if (nArg == 0)\n        return 0;\n    n = strlen30(azArg[0]);\n    c = azArg[0][0];\n    clearTempFile(p);\n    if (c == 'a' && <recovery-expr>()(azArg[0], \"auth\", n) == 0) {\n        if (nArg != 2) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        if (booleanValue(azArg[1])) {\n            sqlite3_set_authorizer(p->db, shellAuth, p);\n        } else if (p->bSafeModePersist) {\n            sqlite3_set_authorizer(p->db, safeModeAuth, p);\n        } else {\n            sqlite3_set_authorizer(p->db, 0, 0);\n        }\n    } else if ((c == 'b' && n >= 3 && <recovery-expr>()(azArg[0], \"backup\", n) == 0) || (c == 's' && n >= 3 && <recovery-expr>()(azArg[0], \"save\", n) == 0)) {\n        const char *zDestFile = 0;\n        const char *zDb = 0;\n        sqlite3 *pDest;\n        sqlite3_backup *pBackup;\n        int j;\n        int bAsync = 0;\n        const char *zVfs = 0;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        for (j = 1; j < nArg; j++) {\n            const char *z = azArg[j];\n            if (z[0] == '-') {\n                if (z[1] == '-')\n                    z++;\n                if (cli_strcmp(z, \"-append\") == 0) {\n                    zVfs = \"apndvfs\";\n                } else if (cli_strcmp(z, \"-async\") == 0) {\n                    bAsync = 1;\n                } else {\n                    return 1;\n                }\n            } else if (zDestFile == 0) {\n                zDestFile = azArg[j];\n            } else if (zDb == 0) {\n                zDb = zDestFile;\n                zDestFile = azArg[j];\n            } else {\n                return 1;\n            }\n        }\n        if (zDestFile == 0) {\n            return 1;\n        }\n        if (zDb == 0)\n            zDb = \"main\";\n        rc = sqlite3_open_v2(zDestFile, &pDest, 2 | 4, zVfs);\n        if (rc != 0) {\n            close_db(pDest);\n            return 1;\n        }\n        if (bAsync) {\n            sqlite3_exec(pDest, \"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;\", 0, 0, 0);\n        }\n        open_db(p, 0);\n        pBackup = sqlite3_backup_init(pDest, \"main\", p->db, zDb);\n        if (pBackup == 0) {\n            close_db(pDest);\n            return 1;\n        }\n        while ((rc = sqlite3_backup_step(pBackup, 100)) == 0)\n            {\n            }\n        sqlite3_backup_finish(pBackup);\n        if (rc == 101) {\n            rc = 0;\n        } else {\n            rc = 1;\n        }\n        close_db(pDest);\n    } else if (c == 'b' && n >= 3 && <recovery-expr>()(azArg[0], \"bail\", n) == 0) {\n        if (nArg == 2) {\n            bail_on_error = booleanValue(azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'b' && n >= 3 && <recovery-expr>()(azArg[0], \"binary\", n) == 0) {\n        if (nArg == 2) {\n            if (booleanValue(azArg[1])) {\n                ;\n            } else {\n                ;\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'b' && n >= 3 && <recovery-expr>()(azArg[0], \"breakpoint\", n) == 0) {\n        test_breakpoint();\n    } else if (c == 'c' && cli_strcmp(azArg[0], \"cd\") == 0) {\n        failIfSafeMode(p, \"cannot run .cd in safe mode\");\n        if (nArg == 2) {\n            rc = chdir(azArg[1]);\n            if (rc) {\n                rc = 1;\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'c' && n >= 3 && <recovery-expr>()(azArg[0], \"changes\", n) == 0) {\n        if (nArg == 2) {\n            setOrClearFlag(p, 32, azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'c' && n >= 3 && <recovery-expr>()(azArg[0], \"check\", n) == 0) {\n        char *zRes = 0;\n        output_reset(p);\n        if (nArg != 2) {\n            rc = 2;\n        } else if ((zRes = readFile(\"testcase-out.txt\", 0)) == 0) {\n            rc = 2;\n        } else if (testcase_glob(azArg[1], zRes) == 0) {\n            rc = 1;\n        } else {\n            p->nCheck++;\n        }\n        sqlite3_free(zRes);\n    } else if (c == 'c' && <recovery-expr>()(azArg[0], \"clone\", n) == 0) {\n        failIfSafeMode(p, \"cannot run .clone in safe mode\");\n        if (nArg == 2) {\n            tryToClone(p, azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'c' && <recovery-expr>()(azArg[0], \"connection\", n) == 0) {\n        if (nArg == 1) {\n            int i;\n            for (i = 0; i < (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0])); i++) {\n                const char *zFile = p->aAuxDb[i].zDbFilename;\n                if (p->aAuxDb[i].db == 0 && p->pAuxDb != &p->aAuxDb[i]) {\n                    zFile = \"(not open)\";\n                } else if (zFile == 0) {\n                    zFile = \"(memory)\";\n                } else if (zFile[0] == 0) {\n                    zFile = \"(temporary-file)\";\n                }\n                if (p->pAuxDb == &p->aAuxDb[i]) {\n                } else if (p->aAuxDb[i].db != 0) {\n                }\n            }\n        } else if (nArg == 2 && isdigit((unsigned char)azArg[1][0]) && azArg[1][1] == 0) {\n            int i = azArg[1][0] - '0';\n            if (p->pAuxDb != &p->aAuxDb[i] && i >= 0 && i < (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0]))) {\n                p->pAuxDb->db = p->db;\n                p->pAuxDb = &p->aAuxDb[i];\n                globalDb = p->db = p->pAuxDb->db;\n                p->pAuxDb->db = 0;\n            }\n        } else if (nArg == 3 && cli_strcmp(azArg[1], \"close\") == 0 && isdigit((unsigned char)azArg[2][0]) && azArg[2][1] == 0) {\n            int i = azArg[2][0] - '0';\n            if (i < 0 || i >= (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0]))) {\n            } else if (p->pAuxDb == &p->aAuxDb[i]) {\n                rc = 1;\n            } else if (p->aAuxDb[i].db) {\n                ;\n                close_db(p->aAuxDb[i].db);\n                p->aAuxDb[i].db = 0;\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'd' && n > 1 && <recovery-expr>()(azArg[0], \"databases\", n) == 0) {\n        char **azName = 0;\n        int nName = 0;\n        sqlite3_stmt *pStmt;\n        int i;\n        open_db(p, 0);\n        rc = sqlite3_prepare_v2(p->db, \"PRAGMA database_list\", -1, &pStmt, 0);\n        if (rc) {\n            rc = 1;\n        } else {\n            while (sqlite3_step(pStmt) == 100)\n                {\n                    const char *zSchema = (const char *)sqlite3_column_text(pStmt, 1);\n                    const char *zFile = (const char *)sqlite3_column_text(pStmt, 2);\n                    if (zSchema == 0 || zFile == 0)\n                        continue;\n                    azName = sqlite3_realloc(azName, (nName + 1) * 2 * sizeof(char *));\n                    shell_check_oom(azName);\n                    azName[nName * 2] = strdup(zSchema);\n                    azName[nName * 2 + 1] = strdup(zFile);\n                    nName++;\n                }\n        }\n        sqlite3_finalize(pStmt);\n        for (i = 0; i < nName; i++) {\n            int eTxn = sqlite3_txn_state(p->db, azName[i * 2]);\n            int bRdonly = sqlite3_db_readonly(p->db, azName[i * 2]);\n            const char *z = azName[i * 2 + 1];\n            fprintf(<recovery-expr>(p), \"%s: %s %s%s\\n\", azName[i * 2], z && z[0] ? z : \"\\\"\\\"\", bRdonly ? \"r/o\" : \"r/w\", eTxn == 0 ? \"\" : eTxn == 1 ? \" read-txn\" : \" write-txn\");\n            free(azName[i * 2]);\n            free(azName[i * 2 + 1]);\n        }\n        sqlite3_free(azName);\n    } else if (c == 'd' && n >= 3 && <recovery-expr>()(azArg[0], \"dbconfig\", n) == 0) {\n        static const struct DbConfigChoices {\n            const char *zName;\n            int op;\n        } aDbConfig[] = {{\"defensive\", 1010}, {\"dqs_ddl\", 1014}, {\"dqs_dml\", 1013}, {\"enable_fkey\", 1002}, {\"enable_qpsg\", 1007}, {\"enable_trigger\", 1003}, {\"enable_view\", 1015}, {\"fts3_tokenizer\", 1004}, {\"legacy_alter_table\", 1012}, {\"legacy_file_format\", 1016}, {\"load_extension\", 1005}, {\"no_ckpt_on_close\", 1006}, {\"reset_database\", 1009}, {\"trigger_eqp\", 1008}, {\"trusted_schema\", 1017}, {\"writable_schema\", 1011}};\n        int ii, v;\n        open_db(p, 0);\n        for (ii = 0; ii < (int)(sizeof (aDbConfig) / sizeof (aDbConfig[0])); ii++) {\n            if (nArg > 1 && cli_strcmp(azArg[1], aDbConfig[ii].zName) != 0)\n                continue;\n            if (nArg >= 3) {\n                sqlite3_db_config(p->db, aDbConfig[ii].op, booleanValue(azArg[2]), 0);\n            }\n            sqlite3_db_config(p->db, aDbConfig[ii].op, -1, &v);\n            fprintf(<recovery-expr>(p), \"%19s %s\\n\", aDbConfig[ii].zName, v ? \"on\" : \"off\");\n            if (nArg > 1)\n                break;\n        }\n        if (nArg > 1 && ii == (int)(sizeof (aDbConfig) / sizeof (aDbConfig[0]))) {\n        }\n    } else if (c == 'd' && <recovery-expr>()(azArg[0], \"dump\", n) == 0) {\n        char *zLike = 0;\n        char *zSql;\n        int i;\n        int savedShowHeader = p->showHeader;\n        int savedShellFlags = p->shellFlgs;\n        ((p)->shellFlgs &= (~(8 | 16 | 64 | 256 | 512)));\n        for (i = 1; i < nArg; i++) {\n            if (azArg[i][0] == '-') {\n                const char *z = azArg[i] + 1;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"preserve-rowids\") == 0) {\n                    ((p)->shellFlgs |= (8));\n                } else if (cli_strcmp(z, \"newlines\") == 0) {\n                    ((p)->shellFlgs |= (16));\n                } else if (cli_strcmp(z, \"data-only\") == 0) {\n                    ((p)->shellFlgs |= (256));\n                } else if (cli_strcmp(z, \"nosys\") == 0) {\n                    ((p)->shellFlgs |= (512));\n                } else {\n                    rc = 1;\n                    sqlite3_free(zLike);\n                    goto meta_command_exit;\n                }\n            } else {\n                char *zExpr = sqlite3_mprintf(\"name LIKE %Q ESCAPE '\\\\' OR EXISTS (  SELECT 1 FROM sqlite_schema WHERE     name LIKE %Q ESCAPE '\\\\' AND    sql LIKE 'CREATE VIRTUAL TABLE%%' AND    substr(o.name, 1, length(name)+1) == (name||'_'))\", azArg[i], azArg[i]);\n                if (zLike) {\n                    zLike = sqlite3_mprintf(\"%z OR %z\", zLike, zExpr);\n                } else {\n                    zLike = zExpr;\n                }\n            }\n        }\n        open_db(p, 0);\n        if ((p->shellFlgs & 256) == 0) {\n            fprintf(<recovery-expr>(p), \"PRAGMA foreign_keys=OFF;\\n\");\n            fprintf(<recovery-expr>(p), \"BEGIN TRANSACTION;\\n\");\n        }\n        p->writableSchema = 0;\n        p->showHeader = 0;\n        sqlite3_exec(p->db, \"SAVEPOINT dump; PRAGMA writable_schema=ON\", 0, 0, 0);\n        p->nErr = 0;\n        if (zLike == 0)\n            zLike = sqlite3_mprintf(\"true\");\n        zSql = sqlite3_mprintf(\"SELECT name, type, sql FROM sqlite_schema AS o WHERE (%s) AND type=='table'  AND sql NOT NULL ORDER BY tbl_name='sqlite_sequence', rowid\", zLike);\n        run_schema_dump_query(p, zSql);\n        sqlite3_free(zSql);\n        if ((p->shellFlgs & 256) == 0) {\n            zSql = sqlite3_mprintf(\"SELECT sql FROM sqlite_schema AS o WHERE (%s) AND sql NOT NULL  AND type IN ('index','trigger','view')\", zLike);\n            run_table_dump_query(p, zSql);\n            sqlite3_free(zSql);\n        }\n        sqlite3_free(zLike);\n        if (p->writableSchema) {\n            fprintf(<recovery-expr>(p), \"PRAGMA writable_schema=OFF;\\n\");\n            p->writableSchema = 0;\n        }\n        sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);\n        sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);\n        if ((p->shellFlgs & 256) == 0) {\n            fprintf(<recovery-expr>(p), p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");\n        }\n        p->showHeader = savedShowHeader;\n        p->shellFlgs = savedShellFlags;\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"echo\", n) == 0) {\n        if (nArg == 2) {\n            setOrClearFlag(p, 64, azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"eqp\", n) == 0) {\n        if (nArg == 2) {\n            p->autoEQPtest = 0;\n            if (p->autoEQPtrace) {\n                if (p->db)\n                    sqlite3_exec(p->db, \"PRAGMA vdbe_trace=OFF;\", 0, 0, 0);\n                p->autoEQPtrace = 0;\n            }\n            if (cli_strcmp(azArg[1], \"full\") == 0) {\n                p->autoEQP = 3;\n            } else if (cli_strcmp(azArg[1], \"trigger\") == 0) {\n                p->autoEQP = 2;\n            } else {\n                p->autoEQP = (u8)booleanValue(azArg[1]);\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"exit\", n) == 0) {\n        if (nArg > 1 && (rc = (int)integerValue(azArg[1])) != 0)\n            exit(rc);\n        rc = 2;\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"explain\", n) == 0) {\n        int val = 1;\n        if (nArg >= 2) {\n            if (cli_strcmp(azArg[1], \"auto\") == 0) {\n                val = 99;\n            } else {\n                val = booleanValue(azArg[1]);\n            }\n        }\n        if (val == 1 && p->mode != 9) {\n            p->normalMode = p->mode;\n            p->mode = 9;\n            p->autoExplain = 0;\n        } else if (val == 0) {\n            if (p->mode == 9)\n                p->mode = p->normalMode;\n            p->autoExplain = 0;\n        } else if (val == 99) {\n            if (p->mode == 9)\n                p->mode = p->normalMode;\n            p->autoExplain = 1;\n        }\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"expert\", n) == 0) {\n        if (p->bSafeMode) {\n            rc = 1;\n        } else {\n            open_db(p, 0);\n            expertDotCommand(p, azArg, nArg);\n        }\n    } else if (c == 'f' && <recovery-expr>()(azArg[0], \"filectrl\", n) == 0) {\n        static const struct {\n            const char *zCtrlName;\n            int ctrlCode;\n            const char *zUsage;\n        } aCtrl[] = {{\"chunk_size\", 6, \"SIZE\"}, {\"data_version\", 35, \"\"}, {\"has_moved\", 20, \"\"}, {\"lock_timeout\", 34, \"MILLISEC\"}, {\"persist_wal\", 10, \"[BOOLEAN]\"}, {\"psow\", 13, \"[BOOLEAN]\"}, {\"reserve_bytes\", 38, \"[N]\"}, {\"size_limit\", 36, \"[LIMIT]\"}, {\"tempfilename\", 16, \"\"}};\n        int filectrl = -1;\n        int iCtrl = -1;\n        sqlite3_int64 iRes = 0;\n        int isOk = 0;\n        int n2, i;\n        const char *zCmd = 0;\n        const char *zSchema = 0;\n        open_db(p, 0);\n        zCmd = nArg >= 2 ? azArg[1] : \"help\";\n        if (zCmd[0] == '-' && (cli_strcmp(zCmd, \"--schema\") == 0 || cli_strcmp(zCmd, \"-schema\") == 0) && nArg >= 4) {\n            zSchema = azArg[2];\n            for (i = 3; i < nArg; i++)\n                azArg[i - 2] = azArg[i];\n            nArg -= 2;\n            zCmd = azArg[1];\n        }\n        if (zCmd[0] == '-' && zCmd[1]) {\n            zCmd++;\n            if (zCmd[0] == '-' && zCmd[1])\n                zCmd++;\n        }\n        if (cli_strcmp(zCmd, \"help\") == 0) {\n            fprintf(<recovery-expr>(p), \"Available file-controls:\\n\");\n            for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n                fprintf(<recovery-expr>(p), \"  .filectrl %s %s\\n\", aCtrl[i].zCtrlName, aCtrl[i].zUsage);\n            }\n            rc = 1;\n            goto meta_command_exit;\n        }\n        n2 = strlen30(zCmd);\n        for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n            if (<recovery-expr>()(zCmd, aCtrl[i].zCtrlName, n2) == 0) {\n                if (filectrl < 0) {\n                    filectrl = aCtrl[i].ctrlCode;\n                    iCtrl = i;\n                } else {\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            }\n        }\n        if (filectrl < 0) {\n        } else {\n            switch (filectrl) {\n              case 36:\n                {\n                    if (nArg != 2 && nArg != 3)\n                        break;\n                    iRes = nArg == 3 ? integerValue(azArg[2]) : -1;\n                    sqlite3_file_control(p->db, zSchema, 36, &iRes);\n                    isOk = 1;\n                    break;\n                }\n              case 34:\n              case 6:\n                {\n                    int x;\n                    if (nArg != 3)\n                        break;\n                    x = (int)integerValue(azArg[2]);\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    isOk = 2;\n                    break;\n                }\n              case 10:\n              case 13:\n                {\n                    int x;\n                    if (nArg != 2 && nArg != 3)\n                        break;\n                    x = nArg == 3 ? booleanValue(azArg[2]) : -1;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    iRes = x;\n                    isOk = 1;\n                    break;\n                }\n              case 35:\n              case 20:\n                {\n                    int x;\n                    if (nArg != 2)\n                        break;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    iRes = x;\n                    isOk = 1;\n                    break;\n                }\n              case 16:\n                {\n                    char *z = 0;\n                    if (nArg != 2)\n                        break;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &z);\n                    if (z) {\n                        fprintf(<recovery-expr>(p), \"%s\\n\", z);\n                        sqlite3_free(z);\n                    }\n                    isOk = 2;\n                    break;\n                }\n              case 38:\n                {\n                    int x;\n                    if (nArg >= 3) {\n                        x = atoi(azArg[2]);\n                        sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    }\n                    x = -1;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    fprintf(<recovery-expr>(p), \"%d\\n\", x);\n                    isOk = 2;\n                    break;\n                }\n            }\n        }\n        if (isOk == 0 && iCtrl >= 0) {\n            fprintf(<recovery-expr>(p), \"Usage: .filectrl %s %s\\n\", zCmd, aCtrl[iCtrl].zUsage);\n            rc = 1;\n        } else if (isOk == 1) {\n            char zBuf[100];\n            sqlite3_snprintf(sizeof (zBuf), zBuf, \"%lld\", iRes);\n            fprintf(<recovery-expr>(p), \"%s\\n\", zBuf);\n        }\n    } else if (c == 'f' && <recovery-expr>()(azArg[0], \"fullschema\", n) == 0) {\n        ShellState data;\n        int doStats = 0;\n        memcpy(&data, p, sizeof (data));\n        data.showHeader = 0;\n        data.cMode = data.mode = 3;\n        if (nArg == 2 && optionMatch(azArg[1], \"indent\")) {\n            data.cMode = data.mode = 11;\n            nArg = 1;\n        }\n        if (nArg != 1) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        rc = sqlite3_exec(p->db, \"SELECT sql FROM  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x     FROM sqlite_schema UNION ALL   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' ORDER BY x\", callback, &data, 0);\n        if (rc == 0) {\n            sqlite3_stmt *pStmt;\n            rc = sqlite3_prepare_v2(p->db, \"SELECT rowid FROM sqlite_schema WHERE name GLOB 'sqlite_stat[134]'\", -1, &pStmt, 0);\n            doStats = sqlite3_step(pStmt) == 100;\n            sqlite3_finalize(pStmt);\n        }\n        if (doStats == 0) {\n            fprintf(<recovery-expr>(p), \"/* No STAT tables available */\\n\");\n        } else {\n            fprintf(<recovery-expr>(p), \"ANALYZE sqlite_schema;\\n\");\n            data.cMode = data.mode = 5;\n            data.zDestTable = \"sqlite_stat1\";\n            shell_exec(&data, \"SELECT * FROM sqlite_stat1\", 0);\n            data.zDestTable = \"sqlite_stat4\";\n            shell_exec(&data, \"SELECT * FROM sqlite_stat4\", 0);\n            fprintf(<recovery-expr>(p), \"ANALYZE sqlite_schema;\\n\");\n        }\n    } else if (c == 'h' && <recovery-expr>()(azArg[0], \"headers\", n) == 0) {\n        if (nArg == 2) {\n            p->showHeader = booleanValue(azArg[1]);\n            p->shellFlgs |= 128;\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'h' && <recovery-expr>()(azArg[0], \"help\", n) == 0) {\n        if (nArg >= 2) {\n            n = <recovery-expr>()(<recovery-expr>(p), azArg[1]);\n            if (n == 0) {\n                fprintf(<recovery-expr>(p), \"Nothing matches '%s'\\n\", azArg[1]);\n            }\n        } else {\n            <recovery-expr>()(<recovery-expr>(p), 0);\n        }\n    } else if (c == 'i' && <recovery-expr>()(azArg[0], \"import\", n) == 0) {\n        char *zTable = 0;\n        char *zSchema = 0;\n        char *zFile = 0;\n        sqlite3_stmt *pStmt;\n        int nCol;\n        int nByte;\n        int i, j;\n        int needCommit;\n        int nSep;\n        char *zSql;\n        char *zFullTabName;\n        ImportCtx sCtx;\n        char *(*xRead)(ImportCtx *);\n        int eVerbose = 0;\n        int nSkip = 0;\n        int useOutputMode = 1;\n        char *zCreate = 0;\n        failIfSafeMode(p, \"cannot run .import in safe mode\");\n        memset(&sCtx, 0, sizeof (sCtx));\n        if (p->mode == 10) {\n            xRead = ascii_read_one_field;\n        } else {\n            xRead = csv_read_one_field;\n        }\n        rc = 1;\n        for (i = 1; i < nArg; i++) {\n            char *z = azArg[i];\n            if (z[0] == '-' && z[1] == '-')\n                z++;\n            if (z[0] != '-') {\n                if (zFile == 0) {\n                    zFile = z;\n                } else if (zTable == 0) {\n                    zTable = z;\n                } else {\n                    fprintf(<recovery-expr>(p), \"ERROR: extra argument: \\\"%s\\\".  Usage:\\n\", z);\n                    <recovery-expr>()(<recovery-expr>(p), \"import\");\n                    goto meta_command_exit;\n                }\n            } else if (cli_strcmp(z, \"-v\") == 0) {\n                eVerbose++;\n            } else if (cli_strcmp(z, \"-schema\") == 0 && i < nArg - 1) {\n                zSchema = azArg[++i];\n            } else if (cli_strcmp(z, \"-skip\") == 0 && i < nArg - 1) {\n                nSkip = integerValue(azArg[++i]);\n            } else if (cli_strcmp(z, \"-ascii\") == 0) {\n                sCtx.cColSep = \"\\037\"[0];\n                sCtx.cRowSep = \"\\036\"[0];\n                xRead = ascii_read_one_field;\n                useOutputMode = 0;\n            } else if (cli_strcmp(z, \"-csv\") == 0) {\n                sCtx.cColSep = ',';\n                sCtx.cRowSep = '\\n';\n                xRead = csv_read_one_field;\n                useOutputMode = 0;\n            } else {\n                fprintf(<recovery-expr>(p), \"ERROR: unknown option: \\\"%s\\\".  Usage:\\n\", z);\n                <recovery-expr>()(<recovery-expr>(p), \"import\");\n                goto meta_command_exit;\n            }\n        }\n        if (zTable == 0) {\n            fprintf(<recovery-expr>(p), \"ERROR: missing %s argument. Usage:\\n\", zFile == 0 ? \"FILE\" : \"TABLE\");\n            <recovery-expr>()(<recovery-expr>(p), \"import\");\n            goto meta_command_exit;\n        }\n        seenInterrupt = 0;\n        open_db(p, 0);\n        if (useOutputMode) {\n            nSep = strlen30(p->colSeparator);\n            if (nSep == 0) {\n                goto meta_command_exit;\n            }\n            if (nSep > 1) {\n                goto meta_command_exit;\n            }\n            nSep = strlen30(p->rowSeparator);\n            if (nSep == 0) {\n                goto meta_command_exit;\n            }\n            if (nSep == 2 && p->mode == 8 && cli_strcmp(p->rowSeparator, \"\\r\\n\") == 0) {\n                sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n                nSep = strlen30(p->rowSeparator);\n            }\n            if (nSep > 1) {\n                goto meta_command_exit;\n            }\n            sCtx.cColSep = p->colSeparator[0];\n            sCtx.cRowSep = p->rowSeparator[0];\n        }\n        sCtx.zFile = zFile;\n        sCtx.nLine = 1;\n        if (sCtx.zFile[0] == '|') {\n            <recovery-expr>(sCtx) = <recovery-expr>()(sCtx.zFile + 1, \"r\");\n            sCtx.zFile = \"<pipe>\";\n            sCtx.xCloser = <recovery-expr>();\n        } else {\n            <recovery-expr>(sCtx) = fopen(sCtx.zFile, \"rb\");\n        }\n        if (<recovery-expr>(sCtx) == 0) {\n            goto meta_command_exit;\n        }\n        if (eVerbose >= 2 || (eVerbose >= 1 && useOutputMode)) {\n            char zSep[2];\n            zSep[1] = 0;\n            zSep[0] = sCtx.cColSep;\n            fprintf(<recovery-expr>(p), \"Column separator \");\n            <recovery-expr>()(<recovery-expr>(p), zSep);\n            fprintf(<recovery-expr>(p), \", row separator \");\n            zSep[0] = sCtx.cRowSep;\n            <recovery-expr>()(<recovery-expr>(p), zSep);\n            fprintf(<recovery-expr>(p), \"\\n\");\n        }\n        sCtx.z = sqlite3_malloc64(120);\n        if (sCtx.z == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        while ((nSkip--) > 0)\n            {\n                while (xRead(&sCtx) && sCtx.cTerm == sCtx.cColSep)\n                    {\n                    }\n            }\n        if (zSchema != 0) {\n            zFullTabName = sqlite3_mprintf(\"\\\"%w\\\".\\\"%w\\\"\", zSchema, zTable);\n        } else {\n            zFullTabName = sqlite3_mprintf(\"\\\"%w\\\"\", zTable);\n        }\n        zSql = sqlite3_mprintf(\"SELECT * FROM %s\", zFullTabName);\n        if (zSql == 0 || zFullTabName == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        nByte = strlen30(zSql);\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        import_append_char(&sCtx, 0);\n        if (rc && sqlite3_strglob(\"no such table: *\", sqlite3_errmsg(p->db)) == 0) {\n            sqlite3 *dbCols = 0;\n            char *zRenames = 0;\n            char *zColDefs;\n            zCreate = sqlite3_mprintf(\"CREATE TABLE %s\", zFullTabName);\n            while (xRead(&sCtx))\n                {\n                    zAutoColumn(sCtx.z, &dbCols, 0);\n                    if (sCtx.cTerm != sCtx.cColSep)\n                        break;\n                }\n            zColDefs = zAutoColumn(0, &dbCols, &zRenames);\n            if (zRenames != 0) {\n                sqlite3_free(zRenames);\n            }\n            assert(dbCols == 0);\n            if (zColDefs == 0) {\n              import_fail:\n                sqlite3_free(zCreate);\n                sqlite3_free(zSql);\n                sqlite3_free(zFullTabName);\n                import_cleanup(&sCtx);\n                rc = 1;\n                goto meta_command_exit;\n            }\n            zCreate = sqlite3_mprintf(\"%z%z\\n\", zCreate, zColDefs);\n            if (eVerbose >= 1) {\n                fprintf(<recovery-expr>(p), \"%s\\n\", zCreate);\n            }\n            rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);\n            if (rc) {\n                goto import_fail;\n            }\n            sqlite3_free(zCreate);\n            zCreate = 0;\n            rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        }\n        if (rc) {\n            if (pStmt)\n                sqlite3_finalize(pStmt);\n            goto import_fail;\n        }\n        sqlite3_free(zSql);\n        nCol = sqlite3_column_count(pStmt);\n        sqlite3_finalize(pStmt);\n        pStmt = 0;\n        if (nCol == 0)\n            return 0;\n        zSql = sqlite3_malloc64(nByte * 2 + 20 + nCol * 2);\n        if (zSql == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        sqlite3_snprintf(nByte + 20, zSql, \"INSERT INTO %s VALUES(?\", zFullTabName);\n        j = strlen30(zSql);\n        for (i = 1; i < nCol; i++) {\n            zSql[j++] = ',';\n            zSql[j++] = '?';\n        }\n        zSql[j++] = ')';\n        zSql[j] = 0;\n        if (eVerbose >= 2) {\n            fprintf(<recovery-expr>(p), \"Insert using: %s\\n\", zSql);\n        }\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        if (rc) {\n            if (pStmt)\n                sqlite3_finalize(pStmt);\n            goto import_fail;\n        }\n        sqlite3_free(zSql);\n        sqlite3_free(zFullTabName);\n        needCommit = sqlite3_get_autocommit(p->db);\n        if (needCommit)\n            sqlite3_exec(p->db, \"BEGIN\", 0, 0, 0);\n        do {\n            int startLine = sCtx.nLine;\n            for (i = 0; i < nCol; i++) {\n                char *z = xRead(&sCtx);\n                if (z == 0 && i == 0)\n                    break;\n                if (p->mode == 10 && (z == 0 || z[0] == 0) && i == 0)\n                    break;\n                sqlite3_bind_text(pStmt, i + 1, z, -1, ((sqlite3_destructor_type)-1));\n                if (i < nCol - 1 && sCtx.cTerm != sCtx.cColSep) {\n                    i += 2;\n                    while (i <= nCol)\n                        {\n                            sqlite3_bind_null(pStmt, i);\n                            i++;\n                        }\n                }\n            }\n            if (sCtx.cTerm == sCtx.cColSep) {\n                do {\n                    xRead(&sCtx);\n                    i++;\n                } while (sCtx.cTerm == sCtx.cColSep);\n            }\n            if (i >= nCol) {\n                sqlite3_step(pStmt);\n                rc = sqlite3_reset(pStmt);\n                if (rc != 0) {\n                    sCtx.nErr++;\n                } else {\n                    sCtx.nRow++;\n                }\n            }\n        } while (<recovery-expr>());\n        import_cleanup(&sCtx);\n        sqlite3_finalize(pStmt);\n        if (needCommit)\n            sqlite3_exec(p->db, \"COMMIT\", 0, 0, 0);\n        if (eVerbose > 0) {\n            fprintf(<recovery-expr>(p), \"Added %d rows with %d errors using %d lines of input\\n\", sCtx.nRow, sCtx.nErr, sCtx.nLine - 1);\n        }\n    } else if (c == 'i' && <recovery-expr>()(azArg[0], \"imposter\", n) == 0) {\n        char *zSql;\n        char *zCollist = 0;\n        sqlite3_stmt *pStmt;\n        int tnum = 0;\n        int isWO = 0;\n        int lenPK = 0;\n        int i;\n        if (!(nArg == 3 || (nArg == 2 && sqlite3_stricmp(azArg[1], \"off\") == 0))) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        if (nArg == 2) {\n            sqlite3_test_control(25, p->db, \"main\", 0, 1);\n            goto meta_command_exit;\n        }\n        zSql = sqlite3_mprintf(\"SELECT rootpage, 0 FROM sqlite_schema WHERE name='%q' AND type='index'UNION ALL SELECT rootpage, 1 FROM sqlite_schema WHERE name='%q' AND type='table'   AND sql LIKE '%%without%%rowid%%'\", azArg[1], azArg[1]);\n        sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n        if (sqlite3_step(pStmt) == 100) {\n            tnum = sqlite3_column_int(pStmt, 0);\n            isWO = sqlite3_column_int(pStmt, 1);\n        }\n        sqlite3_finalize(pStmt);\n        zSql = sqlite3_mprintf(\"PRAGMA index_xinfo='%q'\", azArg[1]);\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n        i = 0;\n        while (rc == 0 && sqlite3_step(pStmt) == 100)\n            {\n                char zLabel[20];\n                const char *zCol = (const char *)sqlite3_column_text(pStmt, 2);\n                i++;\n                if (zCol == 0) {\n                    if (sqlite3_column_int(pStmt, 1) == -1) {\n                        zCol = \"_ROWID_\";\n                    } else {\n                        sqlite3_snprintf(sizeof (zLabel), zLabel, \"expr%d\", i);\n                        zCol = zLabel;\n                    }\n                }\n                if (isWO && lenPK == 0 && sqlite3_column_int(pStmt, 5) == 0 && zCollist) {\n                    lenPK = (int)strlen(zCollist);\n                }\n                if (zCollist == 0) {\n                    zCollist = sqlite3_mprintf(\"\\\"%w\\\"\", zCol);\n                } else {\n                    zCollist = sqlite3_mprintf(\"%z,\\\"%w\\\"\", zCollist, zCol);\n                }\n            }\n        sqlite3_finalize(pStmt);\n        if (i == 0 || tnum == 0) {\n            rc = 1;\n            sqlite3_free(zCollist);\n            goto meta_command_exit;\n        }\n        if (lenPK == 0)\n            lenPK = 100000;\n        zSql = sqlite3_mprintf(\"CREATE TABLE \\\"%w\\\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID\", azArg[2], zCollist, lenPK, zCollist);\n        sqlite3_free(zCollist);\n        rc = sqlite3_test_control(25, p->db, \"main\", 1, tnum);\n        if (rc == 0) {\n            rc = sqlite3_exec(p->db, zSql, 0, 0, 0);\n            sqlite3_test_control(25, p->db, \"main\", 0, 0);\n            if (rc) {\n            } else {\n            }\n        } else {\n            rc = 1;\n        }\n        sqlite3_free(zSql);\n    } else if (c == 'l' && n >= 5 && <recovery-expr>()(azArg[0], \"limits\", n) == 0) {\n        static const struct {\n            const char *zLimitName;\n            int limitCode;\n        } aLimit[] = {{\"length\", 0}, {\"sql_length\", 1}, {\"column\", 2}, {\"expr_depth\", 3}, {\"compound_select\", 4}, {\"vdbe_op\", 5}, {\"function_arg\", 6}, {\"attached\", 7}, {\"like_pattern_length\", 8}, {\"variable_number\", 9}, {\"trigger_depth\", 10}, {\"worker_threads\", 11}};\n        int i, n2;\n        open_db(p, 0);\n        if (nArg == 1) {\n            for (i = 0; i < (int)(sizeof (aLimit) / sizeof (aLimit[0])); i++) {\n                printf(\"%20s %d\\n\", aLimit[i].zLimitName, sqlite3_limit(p->db, aLimit[i].limitCode, -1));\n            }\n        } else if (nArg > 3) {\n            rc = 1;\n            goto meta_command_exit;\n        } else {\n            int iLimit = -1;\n            n2 = strlen30(azArg[1]);\n            for (i = 0; i < (int)(sizeof (aLimit) / sizeof (aLimit[0])); i++) {\n                if (sqlite3_strnicmp(aLimit[i].zLimitName, azArg[1], n2) == 0) {\n                    if (iLimit < 0) {\n                        iLimit = i;\n                    } else {\n                        rc = 1;\n                        goto meta_command_exit;\n                    }\n                }\n            }\n            if (iLimit < 0) {\n                rc = 1;\n                goto meta_command_exit;\n            }\n            if (nArg == 3) {\n                sqlite3_limit(p->db, aLimit[iLimit].limitCode, (int)integerValue(azArg[2]));\n            }\n            printf(\"%20s %d\\n\", aLimit[iLimit].zLimitName, sqlite3_limit(p->db, aLimit[iLimit].limitCode, -1));\n        }\n    } else if (c == 'l' && n > 2 && <recovery-expr>()(azArg[0], \"lint\", n) == 0) {\n        open_db(p, 0);\n        lintDotCommand(p, azArg, nArg);\n    } else if (c == 'l' && <recovery-expr>()(azArg[0], \"load\", n) == 0) {\n        const char *zFile, *zProc;\n        char *zErrMsg = 0;\n        failIfSafeMode(p, \"cannot run .load in safe mode\");\n        if (nArg < 2) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        zFile = azArg[1];\n        zProc = nArg >= 3 ? azArg[2] : 0;\n        open_db(p, 0);\n        rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);\n        if (rc != 0) {\n            sqlite3_free(zErrMsg);\n            rc = 1;\n        }\n    } else if (c == 'l' && <recovery-expr>()(azArg[0], \"log\", n) == 0) {\n        failIfSafeMode(p, \"cannot run .log in safe mode\");\n        if (nArg != 2) {\n            rc = 1;\n        } else {\n            const char *zFile = azArg[1];\n            <recovery-expr>()(<recovery-expr>(p));\n            <recovery-expr>(p) = <recovery-expr>()(zFile, 0);\n        }\n    } else if (c == 'm' && <recovery-expr>()(azArg[0], \"mode\", n) == 0) {\n        const char *zMode = 0;\n        const char *zTabname = 0;\n        int i, n2;\n        ColModeOpts cmOpts = {60, 0, 0};\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (optionMatch(z, \"wrap\") && i + 1 < nArg) {\n                cmOpts.iWrap = integerValue(azArg[++i]);\n            } else if (optionMatch(z, \"ww\")) {\n                cmOpts.bWordWrap = 1;\n            } else if (optionMatch(z, \"wordwrap\") && i + 1 < nArg) {\n                cmOpts.bWordWrap = (u8)booleanValue(azArg[++i]);\n            } else if (optionMatch(z, \"quote\")) {\n                cmOpts.bQuote = 1;\n            } else if (optionMatch(z, \"noquote\")) {\n                cmOpts.bQuote = 0;\n            } else if (zMode == 0) {\n                zMode = z;\n                if (cli_strcmp(z, \"qbox\") == 0) {\n                    ColModeOpts cmo = {60, 1, 0};\n                    zMode = \"box\";\n                    cmOpts = cmo;\n                }\n            } else if (zTabname == 0) {\n                zTabname = z;\n            } else if (z[0] == '-') {\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (zMode == 0) {\n            if (p->mode == 1 || (p->mode >= 14 && p->mode <= 16)) {\n                fprintf(<recovery-expr>(p), \"current output mode: %s --wrap %d --wordwrap %s --%squote\\n\", modeDescr[p->mode], p->cmOpts.iWrap, p->cmOpts.bWordWrap ? \"on\" : \"off\", p->cmOpts.bQuote ? \"\" : \"no\");\n            } else {\n                fprintf(<recovery-expr>(p), \"current output mode: %s\\n\", modeDescr[p->mode]);\n            }\n            zMode = modeDescr[p->mode];\n        }\n        n2 = strlen30(zMode);\n        if (<recovery-expr>()(zMode, \"lines\", n2) == 0) {\n            p->mode = 0;\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (<recovery-expr>()(zMode, \"columns\", n2) == 0) {\n            p->mode = 1;\n            if ((p->shellFlgs & 128) == 0) {\n                p->showHeader = 1;\n            }\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n            p->cmOpts = cmOpts;\n        } else if (<recovery-expr>()(zMode, \"list\", n2) == 0) {\n            p->mode = 2;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"|\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (<recovery-expr>()(zMode, \"html\", n2) == 0) {\n            p->mode = 4;\n        } else if (<recovery-expr>()(zMode, \"tcl\", n2) == 0) {\n            p->mode = 7;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \" \");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (<recovery-expr>()(zMode, \"csv\", n2) == 0) {\n            p->mode = 8;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\r\\n\");\n        } else if (<recovery-expr>()(zMode, \"tabs\", n2) == 0) {\n            p->mode = 2;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"\\t\");\n        } else if (<recovery-expr>()(zMode, \"insert\", n2) == 0) {\n            p->mode = 5;\n            set_table_name(p, zTabname ? zTabname : \"table\");\n        } else if (<recovery-expr>()(zMode, \"quote\", n2) == 0) {\n            p->mode = 6;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (<recovery-expr>()(zMode, \"ascii\", n2) == 0) {\n            p->mode = 10;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"\\037\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\036\");\n        } else if (<recovery-expr>()(zMode, \"markdown\", n2) == 0) {\n            p->mode = 14;\n            p->cmOpts = cmOpts;\n        } else if (<recovery-expr>()(zMode, \"table\", n2) == 0) {\n            p->mode = 15;\n            p->cmOpts = cmOpts;\n        } else if (<recovery-expr>()(zMode, \"box\", n2) == 0) {\n            p->mode = 16;\n            p->cmOpts = cmOpts;\n        } else if (<recovery-expr>()(zMode, \"count\", n2) == 0) {\n            p->mode = 17;\n        } else if (<recovery-expr>()(zMode, \"off\", n2) == 0) {\n            p->mode = 18;\n        } else if (<recovery-expr>()(zMode, \"json\", n2) == 0) {\n            p->mode = 13;\n        } else {\n            rc = 1;\n        }\n        p->cMode = p->mode;\n    } else if (c == 'n' && cli_strcmp(azArg[0], \"nonce\") == 0) {\n        if (nArg != 2) {\n            rc = 1;\n        } else if (p->zNonce == 0 || cli_strcmp(azArg[1], p->zNonce) != 0) {\n            exit(1);\n        } else {\n            p->bSafeMode = 0;\n            return 0;\n        }\n    } else if (c == 'n' && <recovery-expr>()(azArg[0], \"nullvalue\", n) == 0) {\n        if (nArg == 2) {\n            sqlite3_snprintf(sizeof (p->nullValue), p->nullValue, \"%.*s\", (int)(int)(sizeof (p->nullValue) / sizeof (p->nullValue[0])) - 1, azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'o' && <recovery-expr>()(azArg[0], \"open\", n) == 0 && n >= 2) {\n        const char *zFN = 0;\n        char *zNewFilename = 0;\n        int iName = 1;\n        int newFlag = 0;\n        int openMode = 0;\n        for (iName = 1; iName < nArg; iName++) {\n            const char *z = azArg[iName];\n            if (optionMatch(z, \"new\")) {\n                newFlag = 1;\n            } else if (optionMatch(z, \"append\")) {\n                openMode = 2;\n            } else if (optionMatch(z, \"readonly\")) {\n                openMode = 4;\n            } else if (optionMatch(z, \"nofollow\")) {\n                p->openFlags |= 16777216;\n            } else if (optionMatch(z, \"deserialize\")) {\n                openMode = 5;\n            } else if (optionMatch(z, \"hexdb\")) {\n                openMode = 6;\n            } else if (optionMatch(z, \"maxsize\") && iName + 1 < nArg) {\n                p->szMax = integerValue(azArg[++iName]);\n            } else if (z[0] == '-') {\n                rc = 1;\n                goto meta_command_exit;\n            } else if (zFN) {\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                zFN = z;\n            }\n        }\n        ;\n        close_db(p->db);\n        p->db = 0;\n        p->pAuxDb->zDbFilename = 0;\n        sqlite3_free(p->pAuxDb->zFreeOnClose);\n        p->pAuxDb->zFreeOnClose = 0;\n        p->openMode = openMode;\n        p->openFlags = 0;\n        p->szMax = 0;\n        if (zFN || p->openMode == 6) {\n            if (newFlag && zFN && !p->bSafeMode)\n                shellDeleteFile(zFN);\n            if (p->bSafeMode && p->openMode != 6 && zFN && cli_strcmp(zFN, \":memory:\") != 0) {\n                failIfSafeMode(p, \"cannot open disk-based database files in safe mode\");\n            }\n            if (zFN) {\n                zNewFilename = sqlite3_mprintf(\"%s\", zFN);\n                shell_check_oom(zNewFilename);\n            } else {\n                zNewFilename = 0;\n            }\n            p->pAuxDb->zDbFilename = zNewFilename;\n            open_db(p, 1);\n            if (p->db == 0) {\n                sqlite3_free(zNewFilename);\n            } else {\n                p->pAuxDb->zFreeOnClose = zNewFilename;\n            }\n        }\n        if (p->db == 0) {\n            p->pAuxDb->zDbFilename = 0;\n            open_db(p, 0);\n        }\n    } else if ((c == 'o' && (<recovery-expr>()(azArg[0], \"output\", n) == 0 || <recovery-expr>()(azArg[0], \"once\", n) == 0)) || (c == 'e' && n == 5 && cli_strcmp(azArg[0], \"excel\") == 0)) {\n        char *zFile = 0;\n        int bTxtMode = 0;\n        int i;\n        int eMode = 0;\n        int bOnce = 0;\n        unsigned char zBOM[4];\n        zBOM[0] = 0;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        if (c == 'e') {\n            eMode = 'x';\n            bOnce = 2;\n        } else if (<recovery-expr>()(azArg[0], \"once\", n) == 0) {\n            bOnce = 1;\n        }\n        for (i = 1; i < nArg; i++) {\n            char *z = azArg[i];\n            if (z[0] == '-') {\n                if (z[1] == '-')\n                    z++;\n                if (cli_strcmp(z, \"-bom\") == 0) {\n                    zBOM[0] = 239;\n                    zBOM[1] = 187;\n                    zBOM[2] = 191;\n                    zBOM[3] = 0;\n                } else if (c != 'e' && cli_strcmp(z, \"-x\") == 0) {\n                    eMode = 'x';\n                } else if (c != 'e' && cli_strcmp(z, \"-e\") == 0) {\n                    eMode = 'e';\n                } else {\n                    fprintf(<recovery-expr>(p), \"ERROR: unknown option: \\\"%s\\\".  Usage:\\n\", azArg[i]);\n                    <recovery-expr>()(<recovery-expr>(p), azArg[0]);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else if (zFile == 0 && eMode != 'e' && eMode != 'x') {\n                zFile = sqlite3_mprintf(\"%s\", z);\n                if (zFile && zFile[0] == '|') {\n                    while (i + 1 < nArg)\n                        zFile = sqlite3_mprintf(\"%z %s\", zFile, azArg[++i]);\n                    break;\n                }\n            } else {\n                fprintf(<recovery-expr>(p), \"ERROR: extra parameter: \\\"%s\\\".  Usage:\\n\", azArg[i]);\n                <recovery-expr>()(<recovery-expr>(p), azArg[0]);\n                rc = 1;\n                sqlite3_free(zFile);\n                goto meta_command_exit;\n            }\n        }\n        if (zFile == 0) {\n            zFile = sqlite3_mprintf(\"stdout\");\n        }\n        if (bOnce) {\n            p->outCount = 2;\n        } else {\n            p->outCount = 0;\n        }\n        output_reset(p);\n        if (eMode == 'e' || eMode == 'x') {\n            p->doXdgOpen = 1;\n            outputModePush(p);\n            if (eMode == 'x') {\n                newTempFile(p, \"csv\");\n                ((p)->shellFlgs &= (~(64)));\n                p->mode = 8;\n                sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n                sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\r\\n\");\n            } else {\n                newTempFile(p, \"txt\");\n                bTxtMode = 1;\n            }\n            sqlite3_free(zFile);\n            zFile = sqlite3_mprintf(\"%s\", p->zTempFile);\n        }\n        shell_check_oom(zFile);\n        if (zFile[0] == '|') {\n            <recovery-expr>(p) = <recovery-expr>()(zFile + 1, \"w\");\n            if (<recovery-expr>(p) == 0) {\n                rc = 1;\n            } else {\n                if (zBOM[0])\n                    fwrite(zBOM, 1, 3, <recovery-expr>(p));\n                sqlite3_snprintf(sizeof (<recovery-expr>(p)), <recovery-expr>(p), \"%s\", zFile);\n            }\n        } else {\n            <recovery-expr>(p) = <recovery-expr>()(zFile, bTxtMode);\n            if (<recovery-expr>(p) == 0) {\n                if (cli_strcmp(zFile, \"off\") != 0) {\n                }\n                rc = 1;\n            } else {\n                if (zBOM[0])\n                    fwrite(zBOM, 1, 3, <recovery-expr>(p));\n                sqlite3_snprintf(sizeof (<recovery-expr>(p)), <recovery-expr>(p), \"%s\", zFile);\n            }\n        }\n        sqlite3_free(zFile);\n    } else if (c == 'p' && n >= 3 && <recovery-expr>()(azArg[0], \"parameter\", n) == 0) {\n        open_db(p, 0);\n        if (nArg <= 1)\n            goto parameter_syntax_error;\n        if (nArg == 2 && cli_strcmp(azArg[1], \"clear\") == 0) {\n            sqlite3_exec(p->db, \"DROP TABLE IF EXISTS temp.sqlite_parameters;\", 0, 0, 0);\n        } else if (nArg == 2 && cli_strcmp(azArg[1], \"list\") == 0) {\n            sqlite3_stmt *pStmt = 0;\n            int rx;\n            int len = 0;\n            rx = sqlite3_prepare_v2(p->db, \"SELECT max(length(key)) FROM temp.sqlite_parameters;\", -1, &pStmt, 0);\n            if (rx == 0 && sqlite3_step(pStmt) == 100) {\n                len = sqlite3_column_int(pStmt, 0);\n                if (len > 40)\n                    len = 40;\n            }\n            sqlite3_finalize(pStmt);\n            pStmt = 0;\n            if (len) {\n                rx = sqlite3_prepare_v2(p->db, \"SELECT key, quote(value) FROM temp.sqlite_parameters;\", -1, &pStmt, 0);\n                while (rx == 0 && sqlite3_step(pStmt) == 100)\n                    {\n                        fprintf(<recovery-expr>(p), \"%-*s %s\\n\", len, sqlite3_column_text(pStmt, 0), sqlite3_column_text(pStmt, 1));\n                    }\n                sqlite3_finalize(pStmt);\n            }\n        } else if (nArg == 2 && cli_strcmp(azArg[1], \"init\") == 0) {\n            bind_table_init(p);\n        } else if (nArg == 4 && cli_strcmp(azArg[1], \"set\") == 0) {\n            int rx;\n            char *zSql;\n            sqlite3_stmt *pStmt;\n            const char *zKey = azArg[2];\n            const char *zValue = azArg[3];\n            bind_table_init(p);\n            zSql = sqlite3_mprintf(\"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%s);\", zKey, zValue);\n            shell_check_oom(zSql);\n            pStmt = 0;\n            rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n            sqlite3_free(zSql);\n            if (rx != 0) {\n                sqlite3_finalize(pStmt);\n                pStmt = 0;\n                zSql = sqlite3_mprintf(\"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%Q);\", zKey, zValue);\n                shell_check_oom(zSql);\n                rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n                sqlite3_free(zSql);\n                if (rx != 0) {\n                    fprintf(<recovery-expr>(p), \"Error: %s\\n\", sqlite3_errmsg(p->db));\n                    sqlite3_finalize(pStmt);\n                    pStmt = 0;\n                    rc = 1;\n                }\n            }\n            sqlite3_step(pStmt);\n            sqlite3_finalize(pStmt);\n        } else if (nArg == 3 && cli_strcmp(azArg[1], \"unset\") == 0) {\n            char *zSql = sqlite3_mprintf(\"DELETE FROM temp.sqlite_parameters WHERE key=%Q\", azArg[2]);\n            shell_check_oom(zSql);\n            sqlite3_exec(p->db, zSql, 0, 0, 0);\n            sqlite3_free(zSql);\n        } else\n          parameter_syntax_error:\n            <recovery-expr>()(<recovery-expr>(p), \"parameter\");\n    } else if (c == 'p' && n >= 3 && <recovery-expr>()(azArg[0], \"print\", n) == 0) {\n        int i;\n        for (i = 1; i < nArg; i++) {\n            if (i > 1)\n                fprintf(<recovery-expr>(p), \" \");\n            fprintf(<recovery-expr>(p), \"%s\", azArg[i]);\n        }\n        fprintf(<recovery-expr>(p), \"\\n\");\n    } else if (c == 'p' && n >= 3 && <recovery-expr>()(azArg[0], \"progress\", n) == 0) {\n        int i;\n        int nn = 0;\n        p->flgProgress = 0;\n        p->mxProgress = 0;\n        p->nProgress = 0;\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-') {\n                z++;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"quiet\") == 0 || cli_strcmp(z, \"q\") == 0) {\n                    p->flgProgress |= 1;\n                    continue;\n                }\n                if (cli_strcmp(z, \"reset\") == 0) {\n                    p->flgProgress |= 2;\n                    continue;\n                }\n                if (cli_strcmp(z, \"once\") == 0) {\n                    p->flgProgress |= 4;\n                    continue;\n                }\n                if (cli_strcmp(z, \"limit\") == 0) {\n                    if (i + 1 >= nArg) {\n                        rc = 1;\n                        goto meta_command_exit;\n                    } else {\n                        p->mxProgress = (int)integerValue(azArg[++i]);\n                    }\n                    continue;\n                }\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                nn = (int)integerValue(z);\n            }\n        }\n        open_db(p, 0);\n        sqlite3_progress_handler(p->db, nn, progress_handler, p);\n    } else if (c == 'p' && <recovery-expr>()(azArg[0], \"prompt\", n) == 0) {\n        if (nArg >= 2) {\n            strncpy(mainPrompt, azArg[1], (int)(int)(sizeof (mainPrompt) / sizeof (mainPrompt[0])) - 1);\n        }\n        if (nArg >= 3) {\n            strncpy(continuePrompt, azArg[2], (int)(int)(sizeof (continuePrompt) / sizeof (continuePrompt[0])) - 1);\n        }\n    } else if (c == 'q' && <recovery-expr>()(azArg[0], \"quit\", n) == 0) {\n        rc = 2;\n    } else if (c == 'r' && n >= 3 && <recovery-expr>()(azArg[0], \"read\", n) == 0) {\n        int savedLineno = p->lineno;\n        failIfSafeMode(p, \"cannot run .read in safe mode\");\n        if (nArg != 2) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        if (azArg[1][0] == '|') {\n            <recovery-expr>(p) = <recovery-expr>()(azArg[1] + 1, \"r\");\n            if (<recovery-expr>(p) == 0) {\n                rc = 1;\n            } else {\n                rc = process_input(p);\n                <recovery-expr>()(<recovery-expr>(p));\n            }\n        } else if ((<recovery-expr>(p) = <recovery-expr>()(azArg[1])) == 0) {\n            rc = 1;\n        } else {\n            rc = process_input(p);\n            fclose(<recovery-expr>(p));\n        }\n        p->lineno = savedLineno;\n    } else if (c == 'r' && n >= 3 && <recovery-expr>()(azArg[0], \"restore\", n) == 0) {\n        const char *zSrcFile;\n        const char *zDb;\n        sqlite3 *pSrc;\n        sqlite3_backup *pBackup;\n        int nTimeout = 0;\n        failIfSafeMode(p, \"cannot run .restore in safe mode\");\n        if (nArg == 2) {\n            zSrcFile = azArg[1];\n            zDb = \"main\";\n        } else if (nArg == 3) {\n            zSrcFile = azArg[2];\n            zDb = azArg[1];\n        } else {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        rc = sqlite3_open(zSrcFile, &pSrc);\n        if (rc != 0) {\n            close_db(pSrc);\n            return 1;\n        }\n        open_db(p, 0);\n        pBackup = sqlite3_backup_init(p->db, zDb, pSrc, \"main\");\n        if (pBackup == 0) {\n            close_db(pSrc);\n            return 1;\n        }\n        while ((rc = sqlite3_backup_step(pBackup, 100)) == 0 || rc == 5)\n            {\n                if (rc == 5) {\n                    if (nTimeout++ >= 3)\n                        break;\n                    sqlite3_sleep(100);\n                }\n            }\n        sqlite3_backup_finish(pBackup);\n        if (rc == 101) {\n            rc = 0;\n        } else if (rc == 5 || rc == 6) {\n            rc = 1;\n        } else {\n            rc = 1;\n        }\n        close_db(pSrc);\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"scanstats\", n) == 0) {\n        if (nArg == 2) {\n            p->scanstatsOn = (u8)booleanValue(azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"schema\", n) == 0) {\n        ShellText sSelect;\n        ShellState data;\n        char *zErrMsg = 0;\n        const char *zDiv = \"(\";\n        const char *zName = 0;\n        int iSchema = 0;\n        int bDebug = 0;\n        int bNoSystemTabs = 0;\n        int ii;\n        open_db(p, 0);\n        memcpy(&data, p, sizeof (data));\n        data.showHeader = 0;\n        data.cMode = data.mode = 3;\n        initText(&sSelect);\n        for (ii = 1; ii < nArg; ii++) {\n            if (optionMatch(azArg[ii], \"indent\")) {\n                data.cMode = data.mode = 11;\n            } else if (optionMatch(azArg[ii], \"debug\")) {\n                bDebug = 1;\n            } else if (optionMatch(azArg[ii], \"nosys\")) {\n                bNoSystemTabs = 1;\n            } else if (azArg[ii][0] == '-') {\n                rc = 1;\n                goto meta_command_exit;\n            } else if (zName == 0) {\n                zName = azArg[ii];\n            } else {\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (zName != 0) {\n            int isSchema = sqlite3_strlike(zName, \"sqlite_master\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_schema\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_temp_master\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_temp_schema\", '\\\\') == 0;\n            if (isSchema) {\n                char *new_argv[2], *new_colv[2];\n                new_argv[0] = sqlite3_mprintf(\"CREATE TABLE %s (\\n  type text,\\n  name text,\\n  tbl_name text,\\n  rootpage integer,\\n  sql text\\n)\", zName);\n                shell_check_oom(new_argv[0]);\n                new_argv[1] = 0;\n                new_colv[0] = \"sql\";\n                new_colv[1] = 0;\n                callback(&data, 1, new_argv, new_colv);\n                sqlite3_free(new_argv[0]);\n            }\n        }\n        if (zDiv) {\n            sqlite3_stmt *pStmt = 0;\n            rc = sqlite3_prepare_v2(p->db, \"SELECT name FROM pragma_database_list\", -1, &pStmt, 0);\n            if (rc) {\n                sqlite3_finalize(pStmt);\n                rc = 1;\n                goto meta_command_exit;\n            }\n            appendText(&sSelect, \"SELECT sql FROM\", 0);\n            iSchema = 0;\n            while (sqlite3_step(pStmt) == 100)\n                {\n                    const char *zDb = (const char *)sqlite3_column_text(pStmt, 0);\n                    char zScNum[30];\n                    sqlite3_snprintf(sizeof (zScNum), zScNum, \"%d\", ++iSchema);\n                    appendText(&sSelect, zDiv, 0);\n                    zDiv = \" UNION ALL \";\n                    appendText(&sSelect, \"SELECT shell_add_schema(sql,\", 0);\n                    if (sqlite3_stricmp(zDb, \"main\") != 0) {\n                        appendText(&sSelect, zDb, '\\'');\n                    } else {\n                        appendText(&sSelect, \"NULL\", 0);\n                    }\n                    appendText(&sSelect, \",name) AS sql, type, tbl_name, name, rowid,\", 0);\n                    appendText(&sSelect, zScNum, 0);\n                    appendText(&sSelect, \" AS snum, \", 0);\n                    appendText(&sSelect, zDb, '\\'');\n                    appendText(&sSelect, \" AS sname FROM \", 0);\n                    appendText(&sSelect, zDb, quoteChar(zDb));\n                    appendText(&sSelect, \".sqlite_schema\", 0);\n                }\n            sqlite3_finalize(pStmt);\n            if (zName) {\n                appendText(&sSelect, \" UNION ALL SELECT shell_module_schema(name), 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list\", 0);\n            }\n            appendText(&sSelect, \") WHERE \", 0);\n            if (zName) {\n                char *zQarg = sqlite3_mprintf(\"%Q\", zName);\n                int bGlob;\n                shell_check_oom(zQarg);\n                bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 || strchr(zName, '[') != 0;\n                if (strchr(zName, '.')) {\n                    appendText(&sSelect, \"lower(printf('%s.%s',sname,tbl_name))\", 0);\n                } else {\n                    appendText(&sSelect, \"lower(tbl_name)\", 0);\n                }\n                appendText(&sSelect, bGlob ? \" GLOB \" : \" LIKE \", 0);\n                appendText(&sSelect, zQarg, 0);\n                if (!bGlob) {\n                    appendText(&sSelect, \" ESCAPE '\\\\' \", 0);\n                }\n                appendText(&sSelect, \" AND \", 0);\n                sqlite3_free(zQarg);\n            }\n            if (bNoSystemTabs) {\n                appendText(&sSelect, \"name NOT LIKE 'sqlite_%%' AND \", 0);\n            }\n            appendText(&sSelect, \"sql IS NOT NULL ORDER BY snum, rowid\", 0);\n            if (bDebug) {\n                fprintf(<recovery-expr>(p), \"SQL: %s;\\n\", sSelect.z);\n            } else {\n                rc = sqlite3_exec(p->db, sSelect.z, callback, &data, &zErrMsg);\n            }\n            freeText(&sSelect);\n        }\n        if (zErrMsg) {\n            sqlite3_free(zErrMsg);\n            rc = 1;\n        } else if (rc != 0) {\n            rc = 1;\n        } else {\n            rc = 0;\n        }\n    } else if ((c == 's' && n == 11 && <recovery-expr>()(azArg[0], \"selecttrace\", n) == 0) || (c == 't' && n == 9 && <recovery-expr>()(azArg[0], \"treetrace\", n) == 0)) {\n        unsigned int x = nArg >= 2 ? (unsigned int)integerValue(azArg[1]) : 4294967295U;\n        sqlite3_test_control(31, 1, &x);\n    } else if (c == 's' && n >= 4 && <recovery-expr>()(azArg[0], \"selftest\", n) == 0) {\n        int bIsInit = 0;\n        int bVerbose = 0;\n        int bSelftestExists;\n        int i, k;\n        int nTest = 0;\n        int nErr = 0;\n        ShellText str;\n        sqlite3_stmt *pStmt = 0;\n        open_db(p, 0);\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-' && z[1] == '-')\n                z++;\n            if (cli_strcmp(z, \"-init\") == 0) {\n                bIsInit = 1;\n            } else if (cli_strcmp(z, \"-v\") == 0) {\n                bVerbose++;\n            } else {\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (sqlite3_table_column_metadata(p->db, \"main\", \"selftest\", 0, 0, 0, 0, 0, 0) != 0) {\n            bSelftestExists = 0;\n        } else {\n            bSelftestExists = 1;\n        }\n        if (bIsInit) {\n            createSelftestTable(p);\n            bSelftestExists = 1;\n        }\n        initText(&str);\n        appendText(&str, \"x\", 0);\n        for (k = bSelftestExists; k >= 0; k--) {\n            if (k == 1) {\n                rc = sqlite3_prepare_v2(p->db, \"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno\", -1, &pStmt, 0);\n            } else {\n                rc = sqlite3_prepare_v2(p->db, \"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),      (1,'run','PRAGMA integrity_check','ok')\", -1, &pStmt, 0);\n            }\n            if (rc) {\n                rc = 1;\n                sqlite3_finalize(pStmt);\n                goto meta_command_exit;\n            }\n            for (i = 1; sqlite3_step(pStmt) == 100; i++) {\n                int tno = sqlite3_column_int(pStmt, 0);\n                const char *zOp = (const char *)sqlite3_column_text(pStmt, 1);\n                const char *zSql = (const char *)sqlite3_column_text(pStmt, 2);\n                const char *zAns = (const char *)sqlite3_column_text(pStmt, 3);\n                if (zOp == 0)\n                    continue;\n                if (zSql == 0)\n                    continue;\n                if (zAns == 0)\n                    continue;\n                k = 0;\n                if (bVerbose > 0) {\n                    printf(\"%d: %s %s\\n\", tno, zOp, zSql);\n                }\n                if (cli_strcmp(zOp, \"memo\") == 0) {\n                    fprintf(<recovery-expr>(p), \"%s\\n\", zSql);\n                } else if (cli_strcmp(zOp, \"run\") == 0) {\n                    char *zErrMsg = 0;\n                    str.n = 0;\n                    str.z[0] = 0;\n                    rc = sqlite3_exec(p->db, zSql, captureOutputCallback, &str, &zErrMsg);\n                    nTest++;\n                    if (bVerbose) {\n                        fprintf(<recovery-expr>(p), \"Result: %s\\n\", str.z);\n                    }\n                    if (rc || zErrMsg) {\n                        nErr++;\n                        rc = 1;\n                        fprintf(<recovery-expr>(p), \"%d: error-code-%d: %s\\n\", tno, rc, zErrMsg);\n                        sqlite3_free(zErrMsg);\n                    } else if (cli_strcmp(zAns, str.z) != 0) {\n                        nErr++;\n                        rc = 1;\n                        fprintf(<recovery-expr>(p), \"%d: Expected: [%s]\\n\", tno, zAns);\n                        fprintf(<recovery-expr>(p), \"%d:      Got: [%s]\\n\", tno, str.z);\n                    }\n                } else {\n                    rc = 1;\n                    break;\n                }\n            }\n            sqlite3_finalize(pStmt);\n        }\n        freeText(&str);\n        fprintf(<recovery-expr>(p), \"%d errors out of %d tests\\n\", nErr, nTest);\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"separator\", n) == 0) {\n        if (nArg < 2 || nArg > 3) {\n            rc = 1;\n        }\n        if (nArg >= 2) {\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"%.*s\", (int)(int)(sizeof (p->colSeparator) / sizeof (p->colSeparator[0])) - 1, azArg[1]);\n        }\n        if (nArg >= 3) {\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"%.*s\", (int)(int)(sizeof (p->rowSeparator) / sizeof (p->rowSeparator[0])) - 1, azArg[2]);\n        }\n    } else if (c == 's' && n >= 4 && <recovery-expr>()(azArg[0], \"sha3sum\", n) == 0) {\n        const char *zLike = 0;\n        int i;\n        int bSchema = 0;\n        int bSeparate = 0;\n        int iSize = 224;\n        int bDebug = 0;\n        sqlite3_stmt *pStmt;\n        char *zSql;\n        char *zSep;\n        ShellText sSql;\n        ShellText sQuery;\n        open_db(p, 0);\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-') {\n                z++;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"schema\") == 0) {\n                    bSchema = 1;\n                } else if (cli_strcmp(z, \"sha3-224\") == 0 || cli_strcmp(z, \"sha3-256\") == 0 || cli_strcmp(z, \"sha3-384\") == 0 || cli_strcmp(z, \"sha3-512\") == 0) {\n                    iSize = atoi(&z[5]);\n                } else if (cli_strcmp(z, \"debug\") == 0) {\n                    bDebug = 1;\n                } else {\n                    <recovery-expr>()(<recovery-expr>(p), azArg[0]);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else if (zLike) {\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                zLike = z;\n                bSeparate = 1;\n                if (sqlite3_strlike(\"sqlite\\\\_%\", zLike, '\\\\') == 0)\n                    bSchema = 1;\n            }\n        }\n        if (bSchema) {\n            zSql = \"SELECT lower(name) FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 UNION ALL SELECT 'sqlite_schema' ORDER BY 1 collate nocase\";\n        } else {\n            zSql = \"SELECT lower(name) FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 AND name NOT LIKE 'sqlite_%' ORDER BY 1 collate nocase\";\n        }\n        sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        initText(&sQuery);\n        initText(&sSql);\n        appendText(&sSql, \"WITH [sha3sum$query](a,b) AS(\", 0);\n        zSep = \"VALUES(\";\n        while (100 == sqlite3_step(pStmt))\n            {\n                const char *zTab = (const char *)sqlite3_column_text(pStmt, 0);\n                if (zTab == 0)\n                    continue;\n                if (zLike && sqlite3_strlike(zLike, zTab, 0) != 0)\n                    continue;\n                if (<recovery-expr>()(zTab, \"sqlite_\", 7) != 0) {\n                    appendText(&sQuery, \"SELECT * FROM \", 0);\n                    appendText(&sQuery, zTab, '\"');\n                    appendText(&sQuery, \" NOT INDEXED;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_schema\") == 0) {\n                    appendText(&sQuery, \"SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY name;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_sequence\") == 0) {\n                    appendText(&sQuery, \"SELECT name,seq FROM sqlite_sequence ORDER BY name;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_stat1\") == 0) {\n                    appendText(&sQuery, \"SELECT tbl,idx,stat FROM sqlite_stat1 ORDER BY tbl,idx;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_stat4\") == 0) {\n                    appendText(&sQuery, \"SELECT * FROM \", 0);\n                    appendText(&sQuery, zTab, 0);\n                    appendText(&sQuery, \" ORDER BY tbl, idx, rowid;\\n\", 0);\n                }\n                appendText(&sSql, zSep, 0);\n                appendText(&sSql, sQuery.z, '\\'');\n                sQuery.n = 0;\n                appendText(&sSql, \",\", 0);\n                appendText(&sSql, zTab, '\\'');\n                zSep = \"),(\";\n            }\n        sqlite3_finalize(pStmt);\n        if (bSeparate) {\n            zSql = sqlite3_mprintf(\"%s)) SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label   FROM [sha3sum$query]\", sSql.z, iSize);\n        } else {\n            zSql = sqlite3_mprintf(\"%s)) SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash   FROM [sha3sum$query]\", sSql.z, iSize);\n        }\n        shell_check_oom(zSql);\n        freeText(&sQuery);\n        freeText(&sSql);\n        if (bDebug) {\n            fprintf(<recovery-expr>(p), \"%s\\n\", zSql);\n        } else {\n            shell_exec(p, zSql, 0);\n        }\n        sqlite3_free(zSql);\n    } else if (c == 's' && (<recovery-expr>()(azArg[0], \"shell\", n) == 0 || <recovery-expr>()(azArg[0], \"system\", n) == 0)) {\n        char *zCmd;\n        int i, x;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        if (nArg < 2) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        zCmd = sqlite3_mprintf(strchr(azArg[1], ' ') == 0 ? \"%s\" : \"\\\"%s\\\"\", azArg[1]);\n        for (i = 2; i < nArg && zCmd != 0; i++) {\n            zCmd = sqlite3_mprintf(strchr(azArg[i], ' ') == 0 ? \"%z %s\" : \"%z \\\"%s\\\"\", zCmd, azArg[i]);\n        }\n        x = zCmd != 0 ? system(zCmd) : 1;\n        sqlite3_free(zCmd);\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"show\", n) == 0) {\n        static const char *azBool[] = {\"off\", \"on\", \"trigger\", \"full\"};\n        const char *zOut;\n        int i;\n        if (nArg != 1) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"echo\", azBool[(((p)->shellFlgs & (64)) != 0)]);\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"eqp\", azBool[p->autoEQP & 3]);\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"explain\", p->mode == 9 ? \"on\" : p->autoExplain ? \"auto\" : \"off\");\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"headers\", azBool[p->showHeader != 0]);\n        if (p->mode == 1 || (p->mode >= 14 && p->mode <= 16)) {\n            fprintf(<recovery-expr>(p), \"%12.12s: %s --wrap %d --wordwrap %s --%squote\\n\", \"mode\", modeDescr[p->mode], p->cmOpts.iWrap, p->cmOpts.bWordWrap ? \"on\" : \"off\", p->cmOpts.bQuote ? \"\" : \"no\");\n        } else {\n            fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"mode\", modeDescr[p->mode]);\n        }\n        fprintf(<recovery-expr>(p), \"%12.12s: \", \"nullvalue\");\n        <recovery-expr>()(<recovery-expr>(p), p->nullValue);\n        fprintf(<recovery-expr>(p), \"\\n\");\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"output\", strlen30(<recovery-expr>(p)) ? <recovery-expr>(p) : \"stdout\");\n        fprintf(<recovery-expr>(p), \"%12.12s: \", \"colseparator\");\n        <recovery-expr>()(<recovery-expr>(p), p->colSeparator);\n        fprintf(<recovery-expr>(p), \"\\n\");\n        fprintf(<recovery-expr>(p), \"%12.12s: \", \"rowseparator\");\n        <recovery-expr>()(<recovery-expr>(p), p->rowSeparator);\n        fprintf(<recovery-expr>(p), \"\\n\");\n        switch (p->statsOn) {\n          case 0:\n            zOut = \"off\";\n            break;\n          default:\n            zOut = \"on\";\n            break;\n          case 2:\n            zOut = \"stmt\";\n            break;\n          case 3:\n            zOut = \"vmstep\";\n            break;\n        }\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"stats\", zOut);\n        fprintf(<recovery-expr>(p), \"%12.12s: \", \"width\");\n        for (i = 0; i < p->nWidth; i++) {\n            fprintf(<recovery-expr>(p), \"%d \", p->colWidth[i]);\n        }\n        fprintf(<recovery-expr>(p), \"\\n\");\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"filename\", p->pAuxDb->zDbFilename ? p->pAuxDb->zDbFilename : \"\");\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"stats\", n) == 0) {\n        if (nArg == 2) {\n            if (cli_strcmp(azArg[1], \"stmt\") == 0) {\n                p->statsOn = 2;\n            } else if (cli_strcmp(azArg[1], \"vmstep\") == 0) {\n                p->statsOn = 3;\n            } else {\n                p->statsOn = (u8)booleanValue(azArg[1]);\n            }\n        } else if (nArg == 1) {\n            display_stats(p->db, p, 0);\n        } else {\n            rc = 1;\n        }\n    } else if ((c == 't' && n > 1 && <recovery-expr>()(azArg[0], \"tables\", n) == 0) || (c == 'i' && (<recovery-expr>()(azArg[0], \"indices\", n) == 0 || <recovery-expr>()(azArg[0], \"indexes\", n) == 0))) {\n        sqlite3_stmt *pStmt;\n        char **azResult;\n        int nRow, nAlloc;\n        int ii;\n        ShellText s;\n        initText(&s);\n        open_db(p, 0);\n        rc = sqlite3_prepare_v2(p->db, \"PRAGMA database_list\", -1, &pStmt, 0);\n        if (rc) {\n            sqlite3_finalize(pStmt);\n            return shellDatabaseError(p->db);\n        }\n        if (nArg > 2 && c == 'i') {\n            rc = 1;\n            sqlite3_finalize(pStmt);\n            goto meta_command_exit;\n        }\n        for (ii = 0; sqlite3_step(pStmt) == 100; ii++) {\n            const char *zDbName = (const char *)sqlite3_column_text(pStmt, 1);\n            if (zDbName == 0)\n                continue;\n            if (s.z && s.z[0])\n                appendText(&s, \" UNION ALL \", 0);\n            if (sqlite3_stricmp(zDbName, \"main\") == 0) {\n                appendText(&s, \"SELECT name FROM \", 0);\n            } else {\n                appendText(&s, \"SELECT \", 0);\n                appendText(&s, zDbName, '\\'');\n                appendText(&s, \"||'.'||name FROM \", 0);\n            }\n            appendText(&s, zDbName, '\"');\n            appendText(&s, \".sqlite_schema \", 0);\n            if (c == 't') {\n                appendText(&s, \" WHERE type IN ('table','view')   AND name NOT LIKE 'sqlite_%'   AND name LIKE ?1\", 0);\n            } else {\n                appendText(&s, \" WHERE type='index'   AND tbl_name LIKE ?1\", 0);\n            }\n        }\n        rc = sqlite3_finalize(pStmt);\n        if (rc == 0) {\n            appendText(&s, \" ORDER BY 1\", 0);\n            rc = sqlite3_prepare_v2(p->db, s.z, -1, &pStmt, 0);\n        }\n        freeText(&s);\n        if (rc)\n            return shellDatabaseError(p->db);\n        nRow = nAlloc = 0;\n        azResult = 0;\n        if (nArg > 1) {\n            sqlite3_bind_text(pStmt, 1, azArg[1], -1, ((sqlite3_destructor_type)-1));\n        } else {\n            sqlite3_bind_text(pStmt, 1, \"%\", -1, ((sqlite3_destructor_type)0));\n        }\n        while (sqlite3_step(pStmt) == 100)\n            {\n                if (nRow >= nAlloc) {\n                    char **azNew;\n                    int n2 = nAlloc * 2 + 10;\n                    azNew = sqlite3_realloc64(azResult, sizeof (azResult[0]) * n2);\n                    shell_check_oom(azNew);\n                    nAlloc = n2;\n                    azResult = azNew;\n                }\n                azResult[nRow] = sqlite3_mprintf(\"%s\", sqlite3_column_text(pStmt, 0));\n                shell_check_oom(azResult[nRow]);\n                nRow++;\n            }\n        if (sqlite3_finalize(pStmt) != 0) {\n            rc = shellDatabaseError(p->db);\n        }\n        if (rc == 0 && nRow > 0) {\n            int len, maxlen = 0;\n            int i, j;\n            int nPrintCol, nPrintRow;\n            for (i = 0; i < nRow; i++) {\n                len = strlen30(azResult[i]);\n                if (len > maxlen)\n                    maxlen = len;\n            }\n            nPrintCol = 80 / (maxlen + 2);\n            if (nPrintCol < 1)\n                nPrintCol = 1;\n            nPrintRow = (nRow + nPrintCol - 1) / nPrintCol;\n            for (i = 0; i < nPrintRow; i++) {\n                for (j = i; j < nRow; j += nPrintRow) {\n                    char *zSp = j < nPrintRow ? \"\" : \"  \";\n                    fprintf(<recovery-expr>(p), \"%s%-*s\", zSp, maxlen, azResult[j] ? azResult[j] : \"\");\n                }\n                fprintf(<recovery-expr>(p), \"\\n\");\n            }\n        }\n        for (ii = 0; ii < nRow; ii++)\n            sqlite3_free(azResult[ii]);\n        sqlite3_free(azResult);\n    } else if (c == 't' && cli_strcmp(azArg[0], \"testcase\") == 0) {\n        output_reset(p);\n        <recovery-expr>(p) = <recovery-expr>()(\"testcase-out.txt\", 0);\n        if (<recovery-expr>(p) == 0) {\n        }\n        if (nArg >= 2) {\n            sqlite3_snprintf(sizeof (p->zTestcase), p->zTestcase, \"%s\", azArg[1]);\n        } else {\n            sqlite3_snprintf(sizeof (p->zTestcase), p->zTestcase, \"?\");\n        }\n    } else if (c == 't' && n >= 8 && <recovery-expr>()(azArg[0], \"testctrl\", n) == 0) {\n        static const struct {\n            const char *zCtrlName;\n            int ctrlCode;\n            int unSafe;\n            const char *zUsage;\n        } aCtrl[] = {{\"always\", 13, 1, \"BOOLEAN\"}, {\"assert\", 12, 1, \"BOOLEAN\"}, {\"byteorder\", 22, 0, \"\"}, {\"extra_schema_checks\", 29, 0, \"BOOLEAN\"}, {\"imposter\", 25, 1, \"SCHEMA ON/OFF ROOTPAGE\"}, {\"internal_functions\", 17, 0, \"\"}, {\"localtime_fault\", 18, 0, \"BOOLEAN\"}, {\"never_corrupt\", 20, 1, \"BOOLEAN\"}, {\"optimizations\", 15, 0, \"DISABLE-MASK\"}, {\"pending_byte\", 11, 0, \"OFFSET  \"}, {\"prng_restore\", 6, 0, \"\"}, {\"prng_save\", 5, 0, \"\"}, {\"prng_seed\", 28, 0, \"SEED ?db?\"}, {\"seek_count\", 30, 0, \"\"}, {\"sorter_mmap\", 24, 0, \"NMAX\"}, {\"tune\", 32, 1, \"ID VALUE\"}};\n        int testctrl = -1;\n        int iCtrl = -1;\n        int rc2 = 0;\n        int isOk = 0;\n        int i, n2;\n        const char *zCmd = 0;\n        open_db(p, 0);\n        zCmd = nArg >= 2 ? azArg[1] : \"help\";\n        if (zCmd[0] == '-' && zCmd[1]) {\n            zCmd++;\n            if (zCmd[0] == '-' && zCmd[1])\n                zCmd++;\n        }\n        if (cli_strcmp(zCmd, \"help\") == 0) {\n            fprintf(<recovery-expr>(p), \"Available test-controls:\\n\");\n            for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n                fprintf(<recovery-expr>(p), \"  .testctrl %s %s\\n\", aCtrl[i].zCtrlName, aCtrl[i].zUsage);\n            }\n            rc = 1;\n            goto meta_command_exit;\n        }\n        n2 = strlen30(zCmd);\n        for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n            if (<recovery-expr>()(zCmd, aCtrl[i].zCtrlName, n2) == 0) {\n                if (testctrl < 0) {\n                    testctrl = aCtrl[i].ctrlCode;\n                    iCtrl = i;\n                } else {\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            }\n        }\n        if (testctrl < 0) {\n        } else if (aCtrl[iCtrl].unSafe && p->bSafeMode) {\n            exit(1);\n        } else {\n            switch (testctrl) {\n              case 15:\n                if (nArg == 3) {\n                    unsigned int opt = (unsigned int)strtol(azArg[2], 0, 0);\n                    rc2 = sqlite3_test_control(testctrl, p->db, opt);\n                    isOk = 3;\n                }\n                break;\n              case 5:\n              case 6:\n              case 22:\n                if (nArg == 2) {\n                    rc2 = sqlite3_test_control(testctrl);\n                    isOk = testctrl == 22 ? 1 : 3;\n                }\n                break;\n              case 11:\n                if (nArg == 3) {\n                    unsigned int opt = (unsigned int)integerValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 3;\n                }\n                break;\n              case 28:\n                if (nArg == 3 || nArg == 4) {\n                    int ii = (int)integerValue(azArg[2]);\n                    sqlite3 *db;\n                    if (ii == 0 && cli_strcmp(azArg[2], \"random\") == 0) {\n                        sqlite3_randomness(sizeof (ii), &ii);\n                        printf(\"-- random seed: %d\\n\", ii);\n                    }\n                    if (nArg == 3) {\n                        db = 0;\n                    } else {\n                        db = p->db;\n                        sqlite3_table_column_metadata(db, 0, \"x\", 0, 0, 0, 0, 0, 0);\n                    }\n                    rc2 = sqlite3_test_control(testctrl, ii, db);\n                    isOk = 3;\n                }\n                break;\n              case 12:\n              case 13:\n                if (nArg == 3) {\n                    int opt = booleanValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 1;\n                }\n                break;\n              case 18:\n              case 20:\n                if (nArg == 3) {\n                    int opt = booleanValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 3;\n                }\n                break;\n              case 17:\n                rc2 = sqlite3_test_control(testctrl, p->db);\n                isOk = 3;\n                break;\n              case 25:\n                if (nArg == 5) {\n                    rc2 = sqlite3_test_control(testctrl, p->db, azArg[2], integerValue(azArg[3]), integerValue(azArg[4]));\n                    isOk = 3;\n                }\n                break;\n              case 30:\n                {\n                    u64 x = 0;\n                    rc2 = sqlite3_test_control(testctrl, p->db, &x);\n                    fprintf(<recovery-expr>(p), \"%llu\\n\", x);\n                    isOk = 3;\n                    break;\n                }\n              case 24:\n                if (nArg == 3) {\n                    int opt = (unsigned int)integerValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, p->db, opt);\n                    isOk = 3;\n                }\n                break;\n            }\n        }\n        if (isOk == 0 && iCtrl >= 0) {\n            fprintf(<recovery-expr>(p), \"Usage: .testctrl %s %s\\n\", zCmd, aCtrl[iCtrl].zUsage);\n            rc = 1;\n        } else if (isOk == 1) {\n            fprintf(<recovery-expr>(p), \"%d\\n\", rc2);\n        } else if (isOk == 2) {\n            fprintf(<recovery-expr>(p), \"0x%08x\\n\", rc2);\n        }\n    } else if (c == 't' && n > 4 && <recovery-expr>()(azArg[0], \"timeout\", n) == 0) {\n        open_db(p, 0);\n        sqlite3_busy_timeout(p->db, nArg >= 2 ? (int)integerValue(azArg[1]) : 0);\n    } else if (c == 't' && n >= 5 && <recovery-expr>()(azArg[0], \"timer\", n) == 0) {\n        if (nArg == 2) {\n            enableTimer = booleanValue(azArg[1]);\n            if (enableTimer && !1) {\n                enableTimer = 0;\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 't' && <recovery-expr>()(azArg[0], \"trace\", n) == 0) {\n        int mType = 0;\n        int jj;\n        open_db(p, 0);\n        for (jj = 1; jj < nArg; jj++) {\n            const char *z = azArg[jj];\n            if (z[0] == '-') {\n                if (optionMatch(z, \"expanded\")) {\n                    p->eTraceType = 1;\n                } else if (optionMatch(z, \"plain\")) {\n                    p->eTraceType = 0;\n                } else if (optionMatch(z, \"profile\")) {\n                    mType |= 2;\n                } else if (optionMatch(z, \"row\")) {\n                    mType |= 4;\n                } else if (optionMatch(z, \"stmt\")) {\n                    mType |= 1;\n                } else if (optionMatch(z, \"close\")) {\n                    mType |= 8;\n                } else {\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else {\n                <recovery-expr>()(<recovery-expr>(p));\n                <recovery-expr>(p) = <recovery-expr>()(azArg[1], 0);\n            }\n        }\n        if (<recovery-expr>(p) == 0) {\n            sqlite3_trace_v2(p->db, 0, 0, 0);\n        } else {\n            if (mType == 0)\n                mType = 1;\n            sqlite3_trace_v2(p->db, mType, sql_trace_callback, p);\n        }\n    } else if (c == 'v' && <recovery-expr>()(azArg[0], \"version\", n) == 0) {\n        fprintf(<recovery-expr>(p), \"SQLite %s %s\\n\", sqlite3_libversion(), sqlite3_sourceid());\n        fprintf(<recovery-expr>(p), \"clang-16.0.0\\n\");\n    } else if (c == 'v' && <recovery-expr>()(azArg[0], \"vfsinfo\", n) == 0) {\n        const char *zDbName = nArg == 2 ? azArg[1] : \"main\";\n        sqlite3_vfs *pVfs = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, zDbName, 27, &pVfs);\n            if (pVfs) {\n                fprintf(<recovery-expr>(p), \"vfs.zName      = \\\"%s\\\"\\n\", pVfs->zName);\n                fprintf(<recovery-expr>(p), \"vfs.iVersion   = %d\\n\", pVfs->iVersion);\n                fprintf(<recovery-expr>(p), \"vfs.szOsFile   = %d\\n\", pVfs->szOsFile);\n                fprintf(<recovery-expr>(p), \"vfs.mxPathname = %d\\n\", pVfs->mxPathname);\n            }\n        }\n    } else if (c == 'v' && <recovery-expr>()(azArg[0], \"vfslist\", n) == 0) {\n        sqlite3_vfs *pVfs;\n        sqlite3_vfs *pCurrent = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, \"main\", 27, &pCurrent);\n        }\n        for (pVfs = sqlite3_vfs_find(0); pVfs; pVfs = pVfs->pNext) {\n            fprintf(<recovery-expr>(p), \"vfs.zName      = \\\"%s\\\"%s\\n\", pVfs->zName, pVfs == pCurrent ? \"  <--- CURRENT\" : \"\");\n            fprintf(<recovery-expr>(p), \"vfs.iVersion   = %d\\n\", pVfs->iVersion);\n            fprintf(<recovery-expr>(p), \"vfs.szOsFile   = %d\\n\", pVfs->szOsFile);\n            fprintf(<recovery-expr>(p), \"vfs.mxPathname = %d\\n\", pVfs->mxPathname);\n            if (pVfs->pNext) {\n                fprintf(<recovery-expr>(p), \"-----------------------------------\\n\");\n            }\n        }\n    } else if (c == 'v' && <recovery-expr>()(azArg[0], \"vfsname\", n) == 0) {\n        const char *zDbName = nArg == 2 ? azArg[1] : \"main\";\n        char *zVfsName = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, zDbName, 12, &zVfsName);\n            if (zVfsName) {\n                fprintf(<recovery-expr>(p), \"%s\\n\", zVfsName);\n                sqlite3_free(zVfsName);\n            }\n        }\n    } else if (c == 'w' && <recovery-expr>()(azArg[0], \"wheretrace\", n) == 0) {\n        unsigned int x = nArg >= 2 ? (unsigned int)integerValue(azArg[1]) : 4294967295U;\n        sqlite3_test_control(31, 3, &x);\n    } else if (c == 'w' && <recovery-expr>()(azArg[0], \"width\", n) == 0) {\n        int j;\n        assert(nArg <= (int)(sizeof (azArg) / sizeof (azArg[0])));\n        p->nWidth = nArg - 1;\n        p->colWidth = realloc(p->colWidth, (p->nWidth + 1) * sizeof(int) * 2);\n        if (p->colWidth == 0 && p->nWidth > 0)\n            shell_out_of_memory();\n        if (p->nWidth)\n            p->actualWidth = &p->colWidth[p->nWidth];\n        for (j = 1; j < nArg; j++) {\n            p->colWidth[j - 1] = (int)integerValue(azArg[j]);\n        }\n    } else {\n        rc = 1;\n    }\n  meta_command_exit:\n    if (p->outCount) {\n        p->outCount--;\n        if (p->outCount == 0)\n            output_reset(p);\n    }\n    p->bSafeMode = p->bSafeModePersist;\n    return rc;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#2639:1#decimalCmpFunc",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    Decimal *pA = 0, *pB = 0;\n    int rc;\n    (void)(argc);\n    pA = decimal_new(context, argv[0], 0, 0);\n    if (pA == 0 || pA->isNull)\n        goto cmp_done;\n    pB = decimal_new(context, argv[1], 0, 0);\n    if (pB == 0 || pB->isNull)\n        goto cmp_done;\n    rc = decimal_cmp(pA, pB);\n    if (rc < 0)\n        rc = -1;\n    else if (rc > 0)\n        rc = +1;\n    sqlite3_result_int(context, rc);\n  cmp_done:\n    decimal_free(pA);\n    decimal_free(pB);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#2413:1#decimal_new",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    Decimal *p;\n    int n, i;\n    const unsigned char *zIn;\n    int iExp = 0;\n    p = sqlite3_malloc(sizeof (*p));\n    if (p == 0)\n        goto new_no_mem;\n    p->sign = 0;\n    p->oom = 0;\n    p->isInit = 1;\n    p->isNull = 0;\n    p->nDigit = 0;\n    p->nFrac = 0;\n    if (zAlt) {\n        n = nAlt , zIn = zAlt;\n    } else {\n        if (sqlite3_value_type(pIn) == 5) {\n            p->a = 0;\n            p->isNull = 1;\n            return p;\n        }\n        n = sqlite3_value_bytes(pIn);\n        zIn = sqlite3_value_text(pIn);\n    }\n    p->a = sqlite3_malloc64(n + 1);\n    if (p->a == 0)\n        goto new_no_mem;\n    for (i = 0; isspace(zIn[i]); i++) {\n    }\n    if (zIn[i] == '-') {\n        p->sign = 1;\n        i++;\n    } else if (zIn[i] == '+') {\n        i++;\n    }\n    while (i < n && zIn[i] == '0')\n        i++;\n    while (i < n)\n        {\n            char c = zIn[i];\n            if (c >= '0' && c <= '9') {\n                p->a[p->nDigit++] = c - '0';\n            } else if (c == '.') {\n                p->nFrac = p->nDigit + 1;\n            } else if (c == 'e' || c == 'E') {\n                int j = i + 1;\n                int neg = 0;\n                if (j >= n)\n                    break;\n                if (zIn[j] == '-') {\n                    neg = 1;\n                    j++;\n                } else if (zIn[j] == '+') {\n                    j++;\n                }\n                while (j < n && iExp < 1000000)\n                    {\n                        if (zIn[j] >= '0' && zIn[j] <= '9') {\n                            iExp = iExp * 10 + zIn[j] - '0';\n                        }\n                        j++;\n                    }\n                if (neg)\n                    iExp = -iExp;\n                break;\n            }\n            i++;\n        }\n    if (p->nFrac) {\n        p->nFrac = p->nDigit - (p->nFrac - 1);\n    }\n    if (iExp > 0) {\n        if (p->nFrac > 0) {\n            if (iExp <= p->nFrac) {\n                p->nFrac -= iExp;\n                iExp = 0;\n            } else {\n                iExp -= p->nFrac;\n                p->nFrac = 0;\n            }\n        }\n        if (iExp > 0) {\n            p->a = sqlite3_realloc64(p->a, p->nDigit + iExp + 1);\n            if (p->a == 0)\n                goto new_no_mem;\n            memset(p->a + p->nDigit, 0, iExp);\n            p->nDigit += iExp;\n        }\n    } else if (iExp < 0) {\n        int nExtra;\n        iExp = -iExp;\n        nExtra = p->nDigit - p->nFrac - 1;\n        if (nExtra) {\n            if (nExtra >= iExp) {\n                p->nFrac += iExp;\n                iExp = 0;\n            } else {\n                iExp -= nExtra;\n                p->nFrac = p->nDigit - 1;\n            }\n        }\n        if (iExp > 0) {\n            p->a = sqlite3_realloc64(p->a, p->nDigit + iExp + 1);\n            if (p->a == 0)\n                goto new_no_mem;\n            memmove(p->a + iExp, p->a, p->nDigit);\n            memset(p->a, 0, iExp);\n            p->nDigit += iExp;\n            p->nFrac += iExp;\n        }\n    }\n    return p;\n  new_no_mem:\n    if (pCtx)\n        sqlite3_result_error_nomem(pCtx);\n    sqlite3_free(p);\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#20828:1#lintDotCommand",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int n;\n    n = (nArg >= 2 ? strlen30(azArg[1]) : 0);\n    if (n < 1 || sqlite3_strnicmp(azArg[1], \"fkey-indexes\", n))\n        goto usage;\n    return lintFkeyIndexes(pState, azArg, nArg);\n  usage:\n    ;\n    return 1;\n}\n"
        }
    ],
    "total": 346,
    "visited": 13
}
