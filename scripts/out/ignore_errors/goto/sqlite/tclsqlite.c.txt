{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/../src/tclsqlite.c#1931:1#DbObjCmd",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    SqliteDb *pDb = (SqliteDb *)cd;\n    int choice;\n    int rc;\n    static const char *DB_strs[] = {\"authorizer\", \"backup\", \"bind_fallback\", \"busy\", \"cache\", \"changes\", \"close\", \"collate\", \"collation_needed\", \"commit_hook\", \"complete\", \"config\", \"copy\", \"deserialize\", \"enable_load_extension\", \"errorcode\", \"erroroffset\", \"eval\", \"exists\", \"function\", \"incrblob\", \"interrupt\", \"last_insert_rowid\", \"nullvalue\", \"onecolumn\", \"preupdate\", \"profile\", \"progress\", \"rekey\", \"restore\", \"rollback_hook\", \"serialize\", \"status\", \"timeout\", \"total_changes\", \"trace\", \"trace_v2\", \"transaction\", \"unlock_notify\", \"update_hook\", \"version\", \"wal_hook\", 0};\n    enum DB_enum {\n        DB_AUTHORIZER,\n        DB_BACKUP,\n        DB_BIND_FALLBACK,\n        DB_BUSY,\n        DB_CACHE,\n        DB_CHANGES,\n        DB_CLOSE,\n        DB_COLLATE,\n        DB_COLLATION_NEEDED,\n        DB_COMMIT_HOOK,\n        DB_COMPLETE,\n        DB_CONFIG,\n        DB_COPY,\n        DB_DESERIALIZE,\n        DB_ENABLE_LOAD_EXTENSION,\n        DB_ERRORCODE,\n        DB_ERROROFFSET,\n        DB_EVAL,\n        DB_EXISTS,\n        DB_FUNCTION,\n        DB_INCRBLOB,\n        DB_INTERRUPT,\n        DB_LAST_INSERT_ROWID,\n        DB_NULLVALUE,\n        DB_ONECOLUMN,\n        DB_PREUPDATE,\n        DB_PROFILE,\n        DB_PROGRESS,\n        DB_REKEY,\n        DB_RESTORE,\n        DB_ROLLBACK_HOOK,\n        DB_SERIALIZE,\n        DB_STATUS,\n        DB_TIMEOUT,\n        DB_TOTAL_CHANGES,\n        DB_TRACE,\n        DB_TRACE_V2,\n        DB_TRANSACTION,\n        DB_UNLOCK_NOTIFY,\n        DB_UPDATE_HOOK,\n        DB_VERSION,\n        DB_WAL_HOOK\n    };\n    if (objc < 2) {\n        Tcl_WrongNumArgs(<recovery-expr>(), 1, <recovery-expr>(), \"SUBCOMMAND ...\");\n    }\n    if (Tcl_GetIndexFromObj(<recovery-expr>(), <recovery-expr>()[1], DB_strs, \"option\", 0, &choice)) {\n    }\n    switch ((enum DB_enum)choice) {\n      case DB_AUTHORIZER:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zAuth) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zAuth, (char *)0);\n                }\n            } else {\n                char *zAuth;\n                int len;\n                if (pDb->zAuth) {\n                    Tcl_Free(pDb->zAuth);\n                }\n                zAuth = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zAuth && len > 0) {\n                    pDb->zAuth = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zAuth, zAuth, len + 1);\n                } else {\n                    pDb->zAuth = 0;\n                }\n                if (pDb->zAuth) {\n                    typedef int (*sqlite3_auth_cb)(void *, int, const char *, const char *, const char *, const char *);\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_set_authorizer(<recovery-expr>(pDb), (sqlite3_auth_cb)auth_callback, pDb);\n                } else {\n                    sqlite3_set_authorizer(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_BACKUP:\n        {\n            const char *zDestFile;\n            const char *zSrcDb;\n            if (objc == 3) {\n                zSrcDb = \"main\";\n                zDestFile = Tcl_GetString(<recovery-expr>()[2]);\n            } else if (objc == 4) {\n                zSrcDb = Tcl_GetString(<recovery-expr>()[2]);\n                zDestFile = Tcl_GetString(<recovery-expr>()[3]);\n            } else {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?DATABASE? FILENAME\");\n            }\n            if (<recovery-expr>()) {\n            }\n            if (<recovery-expr>()) {\n            }\n            while (<recovery-expr>())\n                {\n                }\n            if (<recovery-expr>()) {\n            } else {\n            }\n            break;\n        }\n      case DB_BIND_FALLBACK:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zBindFallback) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zBindFallback, (char *)0);\n                }\n            } else {\n                char *zCallback;\n                int len;\n                if (pDb->zBindFallback) {\n                    Tcl_Free(pDb->zBindFallback);\n                }\n                zCallback = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zCallback && len > 0) {\n                    pDb->zBindFallback = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zBindFallback, zCallback, len + 1);\n                } else {\n                    pDb->zBindFallback = 0;\n                }\n            }\n            break;\n        }\n      case DB_BUSY:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"CALLBACK\");\n            } else if (objc == 2) {\n                if (pDb->zBusy) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zBusy, (char *)0);\n                }\n            } else {\n                char *zBusy;\n                int len;\n                if (pDb->zBusy) {\n                    Tcl_Free(pDb->zBusy);\n                }\n                zBusy = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zBusy && len > 0) {\n                    pDb->zBusy = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zBusy, zBusy, len + 1);\n                } else {\n                    pDb->zBusy = 0;\n                }\n                if (pDb->zBusy) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_busy_handler(<recovery-expr>(pDb), DbBusyHandler, pDb);\n                } else {\n                    sqlite3_busy_handler(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_CACHE:\n        {\n            char *subCmd;\n            int n;\n            if (objc <= 2) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 1, <recovery-expr>(), \"cache option ?arg?\");\n            }\n            subCmd = Tcl_GetStringFromObj(<recovery-expr>()[2], 0);\n            if (*subCmd == 'f' && strcmp(subCmd, \"flush\") == 0) {\n                if (objc != 3) {\n                    Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"flush\");\n                } else {\n                    flushStmtCache(pDb);\n                }\n            } else if (*subCmd == 's' && strcmp(subCmd, \"size\") == 0) {\n                if (objc != 4) {\n                    Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"size n\");\n                } else {\n                    if (<recovery-expr>()) {\n                        Tcl_AppendResult(<recovery-expr>(), \"cannot convert \\\"\", Tcl_GetStringFromObj(<recovery-expr>()[3], 0), \"\\\" to integer\", (char *)0);\n                    } else {\n                        if (n < 0) {\n                            flushStmtCache(pDb);\n                            n = 0;\n                        } else if (n > 100) {\n                            n = 100;\n                        }\n                        pDb->maxStmt = n;\n                    }\n                }\n            } else {\n                Tcl_AppendResult(<recovery-expr>(), \"bad option \\\"\", Tcl_GetStringFromObj(<recovery-expr>()[2], 0), \"\\\": must be flush or size\", (char *)0);\n            }\n            break;\n        }\n      case DB_CHANGES:\n        {\n            if (objc != 2) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"\");\n            }\n            break;\n        }\n      case DB_CLOSE:\n        {\n            Tcl_DeleteCommand(<recovery-expr>(), Tcl_GetStringFromObj(<recovery-expr>()[0], 0));\n            break;\n        }\n      case DB_COLLATE:\n        {\n            SqlCollate *pCollate;\n            char *zName;\n            char *zScript;\n            int nScript;\n            if (objc != 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"NAME SCRIPT\");\n            }\n            zName = Tcl_GetStringFromObj(<recovery-expr>()[2], 0);\n            zScript = Tcl_GetStringFromObj(<recovery-expr>()[3], &nScript);\n            pCollate = (SqlCollate *)Tcl_Alloc(sizeof (*pCollate) + nScript + 1);\n            <recovery-expr>(pCollate) = <recovery-expr>();\n            pCollate->pNext = pDb->pCollate;\n            pCollate->zScript = (char *)&pCollate[1];\n            pDb->pCollate = pCollate;\n            memcpy(pCollate->zScript, zScript, nScript + 1);\n            if (<recovery-expr>()) {\n            }\n            break;\n        }\n      case DB_COLLATION_NEEDED:\n        {\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"SCRIPT\");\n            }\n            if (<recovery-expr>(pDb)) {\n                Tcl_DecrRefCount(<recovery-expr>(pDb));\n            }\n            <recovery-expr>(pDb) = Tcl_DuplicateObj(<recovery-expr>()[2]);\n            Tcl_IncrRefCount(<recovery-expr>(pDb));\n            sqlite3_collation_needed(<recovery-expr>(pDb), pDb, <recovery-expr>());\n            break;\n        }\n      case DB_COMMIT_HOOK:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zCommit) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zCommit, (char *)0);\n                }\n            } else {\n                const char *zCommit;\n                int len;\n                if (pDb->zCommit) {\n                    Tcl_Free(pDb->zCommit);\n                }\n                zCommit = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zCommit && len > 0) {\n                    pDb->zCommit = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zCommit, zCommit, len + 1);\n                } else {\n                    pDb->zCommit = 0;\n                }\n                if (pDb->zCommit) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_commit_hook(<recovery-expr>(pDb), DbCommitHandler, pDb);\n                } else {\n                    sqlite3_commit_hook(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_COMPLETE:\n        {\n            int isComplete;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"SQL\");\n            }\n            isComplete = sqlite3_complete(Tcl_GetStringFromObj(<recovery-expr>()[2], 0));\n            break;\n        }\n      case DB_CONFIG:\n        {\n            static const struct DbConfigChoices {\n                const char *zName;\n                int op;\n            } aDbConfig[];\n            int ii;\n            if (objc > 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?OPTION? ?BOOLEAN?\");\n            }\n            if (objc == 2) {\n            } else {\n                const char *zOpt = Tcl_GetString(<recovery-expr>()[2]);\n                int onoff = -1;\n                int v = 0;\n                if (zOpt[0] == '-')\n                    zOpt++;\n                if (<recovery-expr>()) {\n                    Tcl_AppendResult(<recovery-expr>(), \"unknown config option: \\\"\", zOpt, \"\\\"\", (void *)0);\n                }\n                if (objc == 4) {\n                    if (Tcl_GetBooleanFromObj(<recovery-expr>(), <recovery-expr>()[3], &onoff)) {\n                    }\n                }\n                sqlite3_db_config(<recovery-expr>(pDb), aDbConfig[ii].op, onoff, &v);\n            }\n            break;\n        }\n      case DB_COPY:\n        {\n            char *zTable;\n            char *zFile;\n            char *zConflict;\n            int nCol;\n            int nByte;\n            int i, j;\n            int nSep;\n            int nNull;\n            char *zSql;\n            char *zLine;\n            char **azCol;\n            const char *zCommit;\n            int lineno = 0;\n            char zLineNum[80];\n            const char *zSep;\n            const char *zNull;\n            if (objc < 5 || objc > 7) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\");\n            }\n            if (objc >= 6) {\n                zSep = Tcl_GetStringFromObj(<recovery-expr>()[5], 0);\n            } else {\n                zSep = \"\\t\";\n            }\n            if (objc >= 7) {\n                zNull = Tcl_GetStringFromObj(<recovery-expr>()[6], 0);\n            } else {\n                zNull = \"\";\n            }\n            zConflict = Tcl_GetStringFromObj(<recovery-expr>()[2], 0);\n            zTable = Tcl_GetStringFromObj(<recovery-expr>()[3], 0);\n            zFile = Tcl_GetStringFromObj(<recovery-expr>()[4], 0);\n            nSep = strlen30(zSep);\n            nNull = strlen30(zNull);\n            if (nSep == 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: non-null separator required for copy\", (char *)0);\n            }\n            if (strcmp(zConflict, \"rollback\") != 0 && strcmp(zConflict, \"abort\") != 0 && strcmp(zConflict, \"fail\") != 0 && strcmp(zConflict, \"ignore\") != 0 && strcmp(zConflict, \"replace\") != 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: \\\"\", zConflict, \"\\\", conflict-algorithm must be one of: rollback, abort, fail, ignore, or replace\", (char *)0);\n            }\n            zSql = sqlite3_mprintf(\"SELECT * FROM '%q'\", zTable);\n            if (zSql == 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: no such table: \", zTable, (char *)0);\n            }\n            nByte = strlen30(zSql);\n            sqlite3_free(zSql);\n            if (rc) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n                nCol = 0;\n            } else {\n            }\n            if (nCol == 0) {\n            }\n            zSql = malloc(nByte + 50 + nCol * 2);\n            if (zSql == 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: can't malloc()\", (char *)0);\n            }\n            sqlite3_snprintf(nByte + 50, zSql, \"INSERT OR %q INTO '%q' VALUES(?\", zConflict, zTable);\n            j = strlen30(zSql);\n            for (i = 1; i < nCol; i++) {\n                zSql[j++] = ',';\n                zSql[j++] = '?';\n            }\n            zSql[j++] = ')';\n            zSql[j] = 0;\n            free(zSql);\n            if (rc) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n            }\n            if (<recovery-expr>()) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: cannot open file: \", zFile, (char *)0);\n            }\n            azCol = malloc(sizeof (azCol[0]) * (nCol + 1));\n            if (azCol == 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: can't malloc()\", (char *)0);\n            }\n            (void)sqlite3_exec(<recovery-expr>(pDb), \"BEGIN\", 0, 0, 0);\n            zCommit = \"COMMIT\";\n            while (<recovery-expr>())\n                {\n                    char *z;\n                    lineno++;\n                    azCol[0] = zLine;\n                    for (i = 0 , z = zLine; *z; z++) {\n                        if (*z == zSep[0] && strncmp(z, zSep, nSep) == 0) {\n                            *z = 0;\n                            i++;\n                            if (i < nCol) {\n                                azCol[i] = &z[nSep];\n                                z += nSep - 1;\n                            }\n                        }\n                    }\n                    if (i + 1 != nCol) {\n                        char *zErr;\n                        int nErr = strlen30(zFile) + 200;\n                        zErr = malloc(nErr);\n                        if (zErr) {\n                            sqlite3_snprintf(nErr, zErr, \"Error: %s line %d: expected %d columns of data but found %d\", zFile, lineno, nCol, i + 1);\n                            Tcl_AppendResult(<recovery-expr>(), zErr, (char *)0);\n                            free(zErr);\n                        }\n                        zCommit = \"ROLLBACK\";\n                        break;\n                    }\n                    for (i = 0; i < nCol; i++) {\n                        if ((nNull > 0 && strcmp(azCol[i], zNull) == 0) || strlen30(azCol[i]) == 0) {\n                        } else {\n                        }\n                    }\n                    free(zLine);\n                    if (<recovery-expr>()) {\n                        Tcl_AppendResult(<recovery-expr>(), \"Error: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n                        zCommit = \"ROLLBACK\";\n                        break;\n                    }\n                }\n            free(azCol);\n            (void)sqlite3_exec(<recovery-expr>(pDb), zCommit, 0, 0, 0);\n            if (zCommit[0] == 'C') {\n            } else {\n                sqlite3_snprintf(sizeof (zLineNum), zLineNum, \"%d\", lineno);\n                Tcl_AppendResult(<recovery-expr>(), \", failed while processing line: \", zLineNum, (char *)0);\n            }\n            break;\n        }\n      case DB_DESERIALIZE:\n        {\n            const char *zSchema = 0;\n            unsigned char *pBA;\n            unsigned char *pData;\n            int len, xrc;\n            int i;\n            int isReadonly = 0;\n            if (objc < 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?DATABASE? VALUE\");\n                break;\n            }\n            for (i = 2; i < objc - 1; i++) {\n                const char *z = Tcl_GetString(<recovery-expr>()[i]);\n                if (strcmp(z, \"-maxsize\") == 0 && i < objc - 2) {\n                    if (rc)\n                        goto deserialize_error;\n                    continue;\n                }\n                if (strcmp(z, \"-readonly\") == 0 && i < objc - 2) {\n                    rc = Tcl_GetBooleanFromObj(<recovery-expr>(), <recovery-expr>()[++i], &isReadonly);\n                    if (rc)\n                        goto deserialize_error;\n                    continue;\n                }\n                if (zSchema == 0 && i == objc - 2 && z[0] != '-') {\n                    zSchema = z;\n                    continue;\n                }\n                Tcl_AppendResult(<recovery-expr>(), \"unknown option: \", z, (char *)0);\n                goto deserialize_error;\n            }\n            pData = sqlite3_malloc64(len);\n            if (pData == 0 && len > 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"out of memory\", (char *)0);\n            } else {\n                int flags;\n                if (len > 0)\n                    memcpy(pData, pBA, len);\n                if (isReadonly) {\n                } else {\n                }\n                xrc = sqlite3_deserialize(<recovery-expr>(pDb), zSchema, pData, len, len, flags);\n                if (xrc) {\n                    Tcl_AppendResult(<recovery-expr>(), \"unable to set MEMDB content\", (char *)0);\n                }\n                if (<recovery-expr>()) {\n                }\n            }\n          deserialize_error:\n            break;\n        }\n      case DB_ENABLE_LOAD_EXTENSION:\n        {\n            int onoff;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"BOOLEAN\");\n            }\n            if (Tcl_GetBooleanFromObj(<recovery-expr>(), <recovery-expr>()[2], &onoff)) {\n            }\n            sqlite3_enable_load_extension(<recovery-expr>(pDb), onoff);\n            break;\n        }\n      case DB_ERRORCODE:\n        {\n            Tcl_SetObjResult(<recovery-expr>(), Tcl_NewIntObj(sqlite3_errcode(<recovery-expr>(pDb))));\n            break;\n        }\n      case DB_ERROROFFSET:\n        {\n            Tcl_SetObjResult(<recovery-expr>(), Tcl_NewIntObj(sqlite3_error_offset(<recovery-expr>(pDb))));\n            break;\n        }\n      case DB_EXISTS:\n      case DB_ONECOLUMN:\n        {\n            DbEvalContext sEval;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"SQL\");\n            }\n            <recovery-expr>()(&sEval, pDb, <recovery-expr>()[2], 0, 0);\n            rc = dbEvalStep(&sEval);\n            if (choice == DB_ONECOLUMN) {\n                if (<recovery-expr>()) {\n                } else if (<recovery-expr>()) {\n                    Tcl_ResetResult(<recovery-expr>());\n                }\n            } else if (<recovery-expr>()) {\n            }\n            dbEvalFinalize(&sEval);\n            if (<recovery-expr>()) {\n            }\n            break;\n        }\n      case DB_EVAL:\n        {\n            int evalFlags = 0;\n            const char *zOpt;\n            while (objc > 3 && (zOpt = Tcl_GetString(<recovery-expr>()[2])) != 0 && zOpt[0] == '-')\n                {\n                    if (strcmp(zOpt, \"-withoutnulls\") == 0) {\n                        evalFlags |= 1;\n                    } else {\n                        Tcl_AppendResult(<recovery-expr>(), \"unknown option: \\\"\", zOpt, \"\\\"\", (void *)0);\n                    }\n                    objc--;\n                    <recovery-expr>()++;\n                }\n            if (objc < 3 || objc > 5) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?\");\n            }\n            if (objc == 3) {\n                DbEvalContext sEval;\n                <recovery-expr>()(&sEval, pDb, <recovery-expr>()[2], 0, 0);\n                while (<recovery-expr>())\n                    {\n                        int i;\n                        int nCol;\n                        <recovery-expr>()(&sEval, &nCol, 0);\n                        for (i = 0; i < nCol; i++) {\n                        }\n                    }\n                dbEvalFinalize(&sEval);\n                if (<recovery-expr>()) {\n                }\n            } else {\n                DbEvalContext *p;\n                if (objc >= 5 && *(char *)Tcl_GetString(<recovery-expr>()[3])) {\n                }\n                p = (DbEvalContext *)Tcl_Alloc(sizeof(DbEvalContext));\n            }\n            break;\n        }\n      case DB_FUNCTION:\n        {\n            int flags;\n            SqlFunc *pFunc;\n            char *zName;\n            int nArg = -1;\n            int i;\n            int eType;\n            if (objc < 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"NAME ?SWITCHES? SCRIPT\");\n            }\n            for (i = 3; i < (objc - 1); i++) {\n                const char *z = Tcl_GetString(<recovery-expr>()[i]);\n                int n = strlen30(z);\n                if (n > 1 && strncmp(z, \"-argcount\", n) == 0) {\n                    if (i == (objc - 2)) {\n                        Tcl_AppendResult(<recovery-expr>(), \"option requires an argument: \", z, (char *)0);\n                    }\n                    if (nArg < 0) {\n                        Tcl_AppendResult(<recovery-expr>(), \"number of arguments must be non-negative\", (char *)0);\n                    }\n                    i++;\n                } else if (n > 1 && strncmp(z, \"-deterministic\", n) == 0) {\n                } else if (n > 1 && strncmp(z, \"-directonly\", n) == 0) {\n                } else if (n > 1 && strncmp(z, \"-innocuous\", n) == 0) {\n                } else if (n > 1 && strncmp(z, \"-returntype\", n) == 0) {\n                    const char *azType[] = {\"integer\", \"real\", \"text\", \"blob\", \"any\", 0};\n                    if (i == (objc - 2)) {\n                        Tcl_AppendResult(<recovery-expr>(), \"option requires an argument: \", z, (char *)0);\n                    }\n                    i++;\n                    if (Tcl_GetIndexFromObj(<recovery-expr>(), <recovery-expr>()[i], azType, \"type\", 0, &eType)) {\n                    }\n                    eType++;\n                } else {\n                    Tcl_AppendResult(<recovery-expr>(), \"bad option \\\"\", z, \"\\\": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype\", (char *)0);\n                }\n            }\n            zName = Tcl_GetStringFromObj(<recovery-expr>()[2], 0);\n            pFunc = findSqlFunc(pDb, zName);\n            if (<recovery-expr>(pFunc)) {\n                Tcl_DecrRefCount(<recovery-expr>(pFunc));\n            }\n            pFunc->eType = eType;\n            rc = sqlite3_create_function(<recovery-expr>(pDb), zName, nArg, flags, pFunc, <recovery-expr>(), 0, 0);\n            if (<recovery-expr>()) {\n            }\n            break;\n        }\n      case DB_INCRBLOB:\n        {\n            int isReadonly = 0;\n            const char *zDb = \"main\";\n            const char *zTable;\n            const char *zColumn;\n            if (objc > 3 && strcmp(Tcl_GetString(<recovery-expr>()[2]), \"-readonly\") == 0) {\n                isReadonly = 1;\n            }\n            if (objc != (5 + isReadonly) && objc != (6 + isReadonly)) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?-readonly? ?DB? TABLE COLUMN ROWID\");\n            }\n            if (objc == (6 + isReadonly)) {\n                zDb = Tcl_GetString(<recovery-expr>()[2 + isReadonly]);\n            }\n            zTable = Tcl_GetString(<recovery-expr>()[objc - 3]);\n            zColumn = Tcl_GetString(<recovery-expr>()[objc - 2]);\n            if (<recovery-expr>()) {\n            }\n            break;\n        }\n      case DB_INTERRUPT:\n        {\n            sqlite3_interrupt(<recovery-expr>(pDb));\n            break;\n        }\n      case DB_NULLVALUE:\n        {\n            if (objc != 2 && objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"NULLVALUE\");\n            }\n            if (objc == 3) {\n                int len;\n                char *zNull = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (pDb->zNull) {\n                    Tcl_Free(pDb->zNull);\n                }\n                if (zNull && len > 0) {\n                    pDb->zNull = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zNull, zNull, len);\n                    pDb->zNull[len] = '\\x00';\n                } else {\n                    pDb->zNull = 0;\n                }\n            }\n            Tcl_SetObjResult(<recovery-expr>(), Tcl_NewStringObj(pDb->zNull, -1));\n            break;\n        }\n      case DB_LAST_INSERT_ROWID:\n        {\n            if (objc != 2) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"\");\n            }\n            break;\n        }\n      case DB_PROGRESS:\n        {\n            if (objc == 2) {\n                if (pDb->zProgress) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zProgress, (char *)0);\n                }\n            } else if (objc == 4) {\n                char *zProgress;\n                int len;\n                int N;\n                if (<recovery-expr>()) {\n                }\n                ;\n                if (pDb->zProgress) {\n                    Tcl_Free(pDb->zProgress);\n                }\n                zProgress = Tcl_GetStringFromObj(<recovery-expr>()[3], &len);\n                if (zProgress && len > 0) {\n                    pDb->zProgress = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zProgress, zProgress, len + 1);\n                } else {\n                    pDb->zProgress = 0;\n                }\n                if (pDb->zProgress) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_progress_handler(<recovery-expr>(pDb), N, DbProgressHandler, pDb);\n                } else {\n                    sqlite3_progress_handler(<recovery-expr>(pDb), 0, 0, 0);\n                }\n            } else {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"N CALLBACK\");\n            }\n            break;\n        }\n      case DB_PROFILE:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zProfile) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zProfile, (char *)0);\n                }\n            } else {\n                char *zProfile;\n                int len;\n                if (pDb->zProfile) {\n                    Tcl_Free(pDb->zProfile);\n                }\n                zProfile = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zProfile && len > 0) {\n                    pDb->zProfile = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zProfile, zProfile, len + 1);\n                } else {\n                    pDb->zProfile = 0;\n                }\n                if (pDb->zProfile) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_profile(<recovery-expr>(pDb), <recovery-expr>(), pDb);\n                } else {\n                    sqlite3_profile(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_REKEY:\n        {\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"KEY\");\n            }\n            break;\n        }\n      case DB_RESTORE:\n        {\n            const char *zSrcFile;\n            const char *zDestDb;\n            int nTimeout = 0;\n            if (objc == 3) {\n                zDestDb = \"main\";\n                zSrcFile = Tcl_GetString(<recovery-expr>()[2]);\n            } else if (objc == 4) {\n                zDestDb = Tcl_GetString(<recovery-expr>()[2]);\n                zSrcFile = Tcl_GetString(<recovery-expr>()[3]);\n            } else {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?DATABASE? FILENAME\");\n            }\n            if (<recovery-expr>()) {\n            }\n            if (<recovery-expr>()) {\n                Tcl_AppendResult(<recovery-expr>(), \"restore failed: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n            }\n            while (<recovery-expr>())\n                {\n                    if (<recovery-expr>()) {\n                        if (nTimeout++ >= 3)\n                            break;\n                        sqlite3_sleep(100);\n                    }\n                }\n            if (<recovery-expr>()) {\n            } else if (<recovery-expr>()) {\n                Tcl_AppendResult(<recovery-expr>(), \"restore failed: source database busy\", (char *)0);\n            } else {\n                Tcl_AppendResult(<recovery-expr>(), \"restore failed: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n            }\n            break;\n        }\n      case DB_SERIALIZE:\n        {\n            const char *zSchema = objc >= 3 ? Tcl_GetString(<recovery-expr>()[2]) : \"main\";\n            unsigned char *pData;\n            if (objc != 2 && objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?DATABASE?\");\n            } else {\n                int needFree;\n                if (pData) {\n                    needFree = 0;\n                } else {\n                    needFree = 1;\n                }\n                if (needFree)\n                    sqlite3_free(pData);\n            }\n            break;\n        }\n      case DB_STATUS:\n        {\n            int v;\n            const char *zOp;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"(step|sort|autoindex)\");\n            }\n            zOp = Tcl_GetString(<recovery-expr>()[2]);\n            if (strcmp(zOp, \"step\") == 0) {\n                v = pDb->nStep;\n            } else if (strcmp(zOp, \"sort\") == 0) {\n                v = pDb->nSort;\n            } else if (strcmp(zOp, \"autoindex\") == 0) {\n                v = pDb->nIndex;\n            } else if (strcmp(zOp, \"vmstep\") == 0) {\n                v = pDb->nVMStep;\n            } else {\n                Tcl_AppendResult(<recovery-expr>(), \"bad argument: should be autoindex, step, sort or vmstep\", (char *)0);\n            }\n            Tcl_SetObjResult(<recovery-expr>(), Tcl_NewIntObj(v));\n            break;\n        }\n      case DB_TIMEOUT:\n        {\n            int ms;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"MILLISECONDS\");\n            }\n            sqlite3_busy_timeout(<recovery-expr>(pDb), ms);\n            break;\n        }\n      case DB_TOTAL_CHANGES:\n        {\n            if (objc != 2) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"\");\n            }\n            break;\n        }\n      case DB_TRACE:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zTrace) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zTrace, (char *)0);\n                }\n            } else {\n                char *zTrace;\n                int len;\n                if (pDb->zTrace) {\n                    Tcl_Free(pDb->zTrace);\n                }\n                zTrace = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zTrace && len > 0) {\n                    pDb->zTrace = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zTrace, zTrace, len + 1);\n                } else {\n                    pDb->zTrace = 0;\n                }\n                if (pDb->zTrace) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_trace(<recovery-expr>(pDb), DbTraceHandler, pDb);\n                } else {\n                    sqlite3_trace(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_TRACE_V2:\n        {\n            if (objc > 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK? ?MASK?\");\n            } else if (objc == 2) {\n                if (pDb->zTraceV2) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zTraceV2, (char *)0);\n                }\n            } else {\n                char *zTraceV2;\n                int len;\n                if (objc == 4) {\n                    static const char *TTYPE_strs[] = {\"statement\", \"profile\", \"row\", \"close\", 0};\n                    enum TTYPE_enum {\n                        TTYPE_STMT,\n                        TTYPE_PROFILE,\n                        TTYPE_ROW,\n                        TTYPE_CLOSE\n                    };\n                    int i;\n                    if (<recovery-expr>()) {\n                    }\n                    for (i = 0; i < len; i++) {\n                        int ttype;\n                        if (<recovery-expr>()) {\n                        }\n                        if (<recovery-expr>()) {\n                            if (<recovery-expr>()) {\n                            } else {\n                            }\n                        } else {\n                            switch ((enum TTYPE_enum)ttype) {\n                              case TTYPE_STMT:\n                                ;\n                                break;\n                              case TTYPE_PROFILE:\n                                ;\n                                break;\n                              case TTYPE_ROW:\n                                ;\n                                break;\n                              case TTYPE_CLOSE:\n                                ;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                }\n                if (pDb->zTraceV2) {\n                    Tcl_Free(pDb->zTraceV2);\n                }\n                zTraceV2 = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zTraceV2 && len > 0) {\n                    pDb->zTraceV2 = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zTraceV2, zTraceV2, len + 1);\n                } else {\n                    pDb->zTraceV2 = 0;\n                }\n                if (pDb->zTraceV2) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                } else {\n                    sqlite3_trace_v2(<recovery-expr>(pDb), 0, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_TRANSACTION:\n        {\n            const char *zBegin = \"SAVEPOINT _tcl_transaction\";\n            if (objc != 3 && objc != 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"[TYPE] SCRIPT\");\n            }\n            if (pDb->nTransaction == 0 && objc == 4) {\n                static const char *TTYPE_strs[] = {\"deferred\", \"exclusive\", \"immediate\", 0};\n                enum TTYPE_enum {\n                    TTYPE_DEFERRED,\n                    TTYPE_EXCLUSIVE,\n                    TTYPE_IMMEDIATE\n                };\n                int ttype;\n                if (Tcl_GetIndexFromObj(<recovery-expr>(), <recovery-expr>()[2], TTYPE_strs, \"transaction type\", 0, &ttype)) {\n                }\n                switch ((enum TTYPE_enum)ttype) {\n                  case TTYPE_DEFERRED:\n                    ;\n                    break;\n                  case TTYPE_EXCLUSIVE:\n                    zBegin = \"BEGIN EXCLUSIVE\";\n                    break;\n                  case TTYPE_IMMEDIATE:\n                    zBegin = \"BEGIN IMMEDIATE\";\n                    break;\n                }\n            }\n            pDb->disableAuth++;\n            rc = sqlite3_exec(<recovery-expr>(pDb), zBegin, 0, 0, 0);\n            pDb->disableAuth--;\n            if (<recovery-expr>()) {\n                Tcl_AppendResult(<recovery-expr>(), sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n            }\n            pDb->nTransaction++;\n            addDatabaseRef(pDb);\n            if (0) {\n                (void)0;\n                (void)0;\n            } else {\n            }\n            break;\n        }\n      case DB_UNLOCK_NOTIFY:\n        {\n            Tcl_AppendResult(<recovery-expr>(), \"unlock_notify not available in this build\", (char *)0);\n            break;\n        }\n      case DB_PREUPDATE:\n        {\n            Tcl_AppendResult(<recovery-expr>(), \"preupdate_hook was omitted at compile-time\", (char *)0);\n            break;\n        }\n      case DB_WAL_HOOK:\n      case DB_UPDATE_HOOK:\n      case DB_ROLLBACK_HOOK:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?SCRIPT?\");\n            }\n            break;\n        }\n      case DB_VERSION:\n        {\n            int i;\n            for (i = 2; i < objc; i++) {\n                const char *zArg = Tcl_GetString(<recovery-expr>()[i]);\n                {\n                    Tcl_AppendResult(<recovery-expr>(), \"unknown argument: \", zArg, (char *)0);\n                }\n            }\n            if (i == 2) {\n            }\n            break;\n        }\n    }\n    return rc;\n}\n"
        }
    ],
    "total": 55,
    "visited": 1
}
