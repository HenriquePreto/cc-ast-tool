{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/cluster.c#6273:1#migrateCommand",
            "gotos": 6,
            "labels": 2,
            "body": "{\n    migrateCachedSocket *cs;\n    int copy = 0, replace = 0, j;\n    char *username;\n    char *password;\n    long timeout;\n    long dbid;\n    robj **ov;\n    robj **kv;\n    robj **newargv;\n    rio cmd, payload;\n    int may_retry = 1;\n    int write_error = 0;\n    int argv_rewritten = 0;\n    int first_key = 3;\n    int num_keys = 1;\n    for (j = 6; j < c->argc; j++) {\n        int moreargs = (c->argc - 1) - j;\n        if (!strcasecmp(c->argv[j]->ptr, \"copy\")) {\n            copy = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr, \"replace\")) {\n            replace = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr, \"auth\")) {\n            if (!moreargs) {\n                addReplyErrorObject(c, shared.syntaxerr);\n                return;\n            }\n            j++;\n            password = c->argv[j]->ptr;\n            redactClientCommandArgument(c, j);\n        } else if (!strcasecmp(c->argv[j]->ptr, \"auth2\")) {\n            if (moreargs < 2) {\n                addReplyErrorObject(c, shared.syntaxerr);\n                return;\n            }\n            username = c->argv[++j]->ptr;\n            redactClientCommandArgument(c, j);\n            password = c->argv[++j]->ptr;\n            redactClientCommandArgument(c, j);\n        } else if (!strcasecmp(c->argv[j]->ptr, \"keys\")) {\n            if (<recovery-expr>()(c->argv[3]->ptr) != 0) {\n                addReplyError(c, \"When using MIGRATE KEYS option, the key argument must be set to the empty string\");\n                return;\n            }\n            first_key = j + 1;\n            num_keys = c->argc - j - 1;\n            break;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n    if (<recovery-expr>()) {\n        return;\n    }\n    if (timeout <= 0)\n        timeout = 1000;\n    ov = <recovery-expr>()(ov, sizeof(robj *) * num_keys);\n    kv = <recovery-expr>()(kv, sizeof(robj *) * num_keys);\n    int oi = 0;\n    for (j = 0; j < num_keys; j++) {\n        if (<recovery-expr>()) {\n            kv[oi] = c->argv[first_key + j];\n            oi++;\n        }\n    }\n    num_keys = oi;\n    if (num_keys == 0) {\n        zfree(ov);\n        zfree(kv);\n        addReplySds(c, sdsnew(\"+NOKEY\\r\\n\"));\n        return;\n    }\n  try_again:\n    write_error = 0;\n    cs = migrateGetSocket(c, c->argv[1], c->argv[2], timeout);\n    if (<recovery-expr>()) {\n        zfree(ov);\n        zfree(kv);\n        return;\n    }\n    rioInitWithBuffer(&cmd, sdsempty());\n    if (password) {\n        int arity = username ? 3 : 2;\n        if (username) {\n        }\n    }\n    int select = cs->last_dbid != dbid;\n    if (select) {\n    }\n    int non_expired = 0;\n    for (j = 0; j < num_keys; j++) {\n        long long ttl = 0;\n        long long expireat = getExpire(c->db, kv[j]);\n        if (expireat != -1) {\n            ttl = expireat - commandTimeSnapshot();\n            if (ttl < 0) {\n                continue;\n            }\n            if (ttl < 1)\n                ttl = 1;\n        }\n        ov[non_expired] = ov[j];\n        kv[non_expired++] = kv[j];\n        createDumpPayload(&payload, ov[j], kv[j], dbid);\n        sdsfree(<recovery-expr>(payload).buffer.ptr);\n    }\n    num_keys = non_expired;\n    {\n        sds buf = <recovery-expr>(cmd).buffer.ptr;\n        int pos(int *), towrite(int *);\n        int nwritten = 0;\n        while ((towrite = <recovery-expr>()(buf) - <recovery-expr>()) > 0)\n            {\n                <recovery-expr>(towrite, (towrite > (64 * 1024) ? (64 * 1024) : towrite));\n                nwritten = <recovery-expr>()(cs->conn, buf + <recovery-expr>(), towrite, timeout);\n                if (nwritten != (int)towrite) {\n                    write_error = 1;\n                    goto socket_err;\n                }\n                <recovery-expr>() += nwritten;\n            }\n    }\n    char buf0[1024];\n    char buf1[1024];\n    char buf2[1024];\n    if (password && <recovery-expr>()(cs->conn, buf0, sizeof (buf0), timeout) <= 0)\n        goto socket_err;\n    if (select && <recovery-expr>()(cs->conn, buf1, sizeof (buf1), timeout) <= 0)\n        goto socket_err;\n    int error_from_target = 0;\n    int socket_error = 0;\n    int del_idx = 1;\n    if (!copy)\n        newargv = <recovery-expr>()(sizeof(robj *) * (num_keys + 1));\n    for (j = 0; j < num_keys; j++) {\n        if (<recovery-expr>()(cs->conn, buf2, sizeof (buf2), timeout) <= 0) {\n            socket_error = 1;\n            break;\n        }\n        if ((password && buf0[0] == '-') || (select && buf1[0] == '-') || buf2[0] == '-') {\n            if (!error_from_target) {\n                cs->last_dbid = -1;\n                char *errbuf;\n                if (password && buf0[0] == '-')\n                    errbuf = buf0;\n                else if (select && buf1[0] == '-')\n                    errbuf = buf1;\n                else\n                    errbuf = buf2;\n                error_from_target = 1;\n                addReplyErrorFormat(c, \"Target instance replied with error: %s\", errbuf + 1);\n            }\n        } else {\n            if (!copy) {\n                dbDelete(c->db, kv[j]);\n                signalModifiedKey(c, c->db, kv[j]);\n                notifyKeyspaceEvent((1 << 2), \"del\", kv[j], c->db->id);\n                server.dirty++;\n                newargv[del_idx++] = kv[j];\n                incrRefCount(kv[j]);\n            }\n        }\n    }\n    if (<recovery-expr>()) {\n        goto socket_err;\n    }\n    if (socket_error)\n        migrateCloseSocket(c->argv[1], c->argv[2]);\n    if (!copy) {\n        if (del_idx > 1) {\n            newargv[0] = createStringObject(\"DEL\", 3);\n            replaceClientCommandVector(c, del_idx, newargv);\n            argv_rewritten = 1;\n        } else {\n            zfree(newargv);\n        }\n    }\n    if (!error_from_target && socket_error) {\n        may_retry = 0;\n        goto socket_err;\n    }\n    if (!error_from_target) {\n        cs->last_dbid = dbid;\n        addReply(c, shared.ok);\n    } else {\n    }\n    sdsfree(<recovery-expr>(cmd).buffer.ptr);\n    zfree(ov);\n    zfree(kv);\n    zfree(newargv);\n    return;\n  socket_err:\n    sdsfree(<recovery-expr>(cmd).buffer.ptr);\n    if (!argv_rewritten)\n        migrateCloseSocket(c->argv[1], c->argv[2]);\n    zfree(newargv);\n    if (<recovery-expr>()) {\n        may_retry = 0;\n        goto try_again;\n    }\n    zfree(ov);\n    zfree(kv);\n    addReplyErrorSds(c, sdscatprintf(sdsempty(), \"-IOERR error or timeout %s to target instance\", write_error ? \"writing\" : \"reading\"));\n    return;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/cluster.c#424:1#clusterSaveConfig",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    sds ci, tmpfilename;\n    int content_size(int *), offset(int *);\n    int fd = -1;\n    int retval = -1;\n    server.cluster->todo_before_sleep &= ~(1 << 2);\n    ci = clusterGenNodesDescription(32, 0);\n    ci = sdscatprintf(ci, \"vars currentEpoch %llu lastVoteEpoch %llu\\n\", (unsigned long long)<recovery-expr>(server.cluster), (unsigned long long)<recovery-expr>(server.cluster));\n    content_size = <recovery-expr>()(ci);\n    tmpfilename = sdscatfmt(sdsempty(), \"%s.tmp-%i-%I\", server.cluster_configfile, (int)getpid(), mstime());\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    while (<recovery-expr>() < content_size)\n        {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    continue;\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                goto cleanup;\n            }\n        }\n    if (do_fsync) {\n        server.cluster->todo_before_sleep &= ~(1 << 3);\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto cleanup;\n        }\n    }\n    if (rename(tmpfilename, server.cluster_configfile) == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    if (do_fsync) {\n        if (fsyncFileDir(server.cluster_configfile) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto cleanup;\n        }\n    }\n    retval = 0;\n  cleanup:\n    if (fd != -1)\n        close(fd);\n    if (retval)\n        unlink(tmpfilename);\n    sdsfree(tmpfilename);\n    sdsfree(ci);\n    return retval;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/cluster.c#148:1#clusterLoadConfig",
            "gotos": 10,
            "labels": 1,
            "body": "{\n    struct stat sb;\n    char *line;\n    int maxline, j;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            return -1;\n        } else {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            exit(1);\n        }\n    }\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        exit(1);\n    }\n    if (<recovery-expr>().st_size == 0) {\n        return -1;\n    }\n    maxline = 1024 + 16384 * 128;\n    line = <recovery-expr>()(maxline);\n    while (<recovery-expr>())\n        {\n            int argc;\n            sds *argv;\n            clusterNode *n, *master;\n            char *p, *s;\n            if (line[0] == '\\n' || line[0] == '\\x00')\n                continue;\n            argv = sdssplitargs(line, &argc);\n            if (<recovery-expr>())\n                goto fmterr;\n            if (strcasecmp(argv[0], \"vars\") == 0) {\n                if (!(argc % 2))\n                    goto fmterr;\n                for (j = 1; j < argc; j += 2) {\n                    if (strcasecmp(argv[j], \"currentEpoch\") == 0) {\n                    } else if (strcasecmp(argv[j], \"lastVoteEpoch\") == 0) {\n                    } else {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"Skipping unknown cluster config variable '%s'\", argv[j]);\n                        } while (0);\n                    }\n                }\n                sdsfreesplitres(argv, argc);\n                continue;\n            }\n            if (argc < 8) {\n                sdsfreesplitres(argv, argc);\n                goto fmterr;\n            }\n            if (verifyClusterNodeId(argv[0], <recovery-expr>()(argv[0])) == -1) {\n                sdsfreesplitres(argv, argc);\n                goto fmterr;\n            }\n            n = clusterLookupNode(argv[0], <recovery-expr>()(argv[0]));\n            if (!n) {\n                n = createClusterNode(argv[0], 0);\n                clusterAddNode(n);\n            }\n            char *hostname = strchr(argv[1], ',');\n            if (hostname) {\n                *hostname = '\\x00';\n                hostname++;\n                n->hostname = sdscpy(n->hostname, hostname);\n            } else if (<recovery-expr>()(n->hostname) != 0) {\n                sdsclear(n->hostname);\n            }\n            if (<recovery-expr>()) {\n                sdsfreesplitres(argv, argc);\n                goto fmterr;\n            }\n            *p = '\\x00';\n            memcpy(n->ip, argv[1], strlen(argv[1]) + 1);\n            char *port = p + 1;\n            char *busp = strchr(port, '@');\n            if (busp) {\n                *busp = '\\x00';\n                busp++;\n            }\n            n->port = atoi(port);\n            n->cport = busp ? atoi(busp) : n->port + 10000;\n            p = s = argv[2];\n            while (p)\n                {\n                    p = strchr(s, ',');\n                    if (p)\n                        *p = '\\x00';\n                    if (!strcasecmp(s, \"myself\")) {\n                        myself = server.cluster->myself = n;\n                        n->flags |= 16;\n                    } else if (!strcasecmp(s, \"master\")) {\n                        n->flags |= 1;\n                    } else if (!strcasecmp(s, \"slave\")) {\n                        n->flags |= 2;\n                    } else if (!strcasecmp(s, \"fail?\")) {\n                        n->flags |= 4;\n                    } else if (!strcasecmp(s, \"fail\")) {\n                        n->flags |= 8;\n                        n->fail_time = mstime();\n                    } else if (!strcasecmp(s, \"handshake\")) {\n                        n->flags |= 32;\n                    } else if (!strcasecmp(s, \"noaddr\")) {\n                        n->flags |= 64;\n                    } else if (!strcasecmp(s, \"nofailover\")) {\n                        n->flags |= 512;\n                    } else if (!strcasecmp(s, \"noflags\")) {\n                    } else {\n                        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/cluster.c\", 302, \"Unknown flag in redis cluster config file\") , __builtin_unreachable();\n                    }\n                    if (p)\n                        s = p + 1;\n                }\n            if (argv[3][0] != '-') {\n                if (verifyClusterNodeId(argv[3], <recovery-expr>()(argv[3])) == -1) {\n                    sdsfreesplitres(argv, argc);\n                    goto fmterr;\n                }\n                master = clusterLookupNode(argv[3], <recovery-expr>()(argv[3]));\n                if (!master) {\n                    master = createClusterNode(argv[3], 0);\n                    clusterAddNode(master);\n                }\n                n->slaveof = master;\n                clusterNodeAddSlave(master, n);\n            }\n            if (atoi(argv[4]))\n                n->ping_sent = mstime();\n            if (atoi(argv[5]))\n                n->pong_received = mstime();\n            for (j = 8; j < argc; j++) {\n                int start, stop;\n                if (argv[j][0] == '[') {\n                    int slot;\n                    char direction;\n                    clusterNode *cn;\n                    p = strchr(argv[j], '-');\n                    *p = '\\x00';\n                    direction = p[1];\n                    slot = atoi(argv[j] + 1);\n                    if (slot < 0 || slot >= 16384) {\n                        sdsfreesplitres(argv, argc);\n                        goto fmterr;\n                    }\n                    p += 3;\n                    char *pr = strchr(p, ']');\n                    int node_len(int *);\n                    if (<recovery-expr>()) {\n                        sdsfreesplitres(argv, argc);\n                        goto fmterr;\n                    }\n                    cn = clusterLookupNode(p, 40);\n                    if (!cn) {\n                        cn = createClusterNode(p, 0);\n                        clusterAddNode(cn);\n                    }\n                    if (direction == '>') {\n                        server.cluster->migrating_slots_to[slot] = cn;\n                    } else {\n                        server.cluster->importing_slots_from[slot] = cn;\n                    }\n                    continue;\n                } else if (<recovery-expr>()) {\n                    *p = '\\x00';\n                    start = atoi(argv[j]);\n                    stop = atoi(p + 1);\n                } else {\n                    start = stop = atoi(argv[j]);\n                }\n                if (start < 0 || start >= 16384 || stop < 0 || stop >= 16384) {\n                    sdsfreesplitres(argv, argc);\n                    goto fmterr;\n                }\n                while (start <= stop)\n                    clusterAddSlot(n, start++);\n            }\n            sdsfreesplitres(argv, argc);\n        }\n    if (<recovery-expr>())\n        goto fmterr;\n    zfree(line);\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"Node configuration loaded, I'm %.40s\", myself->name);\n    } while (0);\n    if (<recovery-expr>()() > <recovery-expr>(server.cluster)) {\n        <recovery-expr>(server.cluster) = <recovery-expr>()();\n    }\n    return 0;\n  fmterr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Unrecoverable error: corrupted cluster config file.\");\n    } while (0);\n    zfree(line);\n    exit(1);\n}\n"
        }
    ],
    "total": 207,
    "visited": 3
}
