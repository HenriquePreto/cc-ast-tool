{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#3122:1#xclaimCommand",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    streamCG *group;\n    robj *o = lookupKeyRead(c->db, c->argv[1]);\n    long long minidle;\n    long long retrycount = -1;\n    mstime_t deliverytime = -1;\n    int force = 0;\n    int justid = 0;\n    if (o) {\n        if (checkType(c, o, 6))\n            return;\n        group = streamLookupCG(o->ptr, c->argv[2]->ptr);\n    }\n    if (<recovery-expr>()) {\n        addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer group '%s'\", (char *)c->argv[1]->ptr, (char *)c->argv[2]->ptr);\n        return;\n    }\n    if (getLongLongFromObjectOrReply(c, c->argv[4], &minidle, \"Invalid min-idle-time argument for XCLAIM\") != 0)\n        return;\n    if (minidle < 0)\n        minidle = 0;\n    int j;\n    streamID static_ids[8];\n    streamID *ids = static_ids;\n    int id_count = c->argc - 5;\n    if (id_count > 8)\n        ids = <recovery-expr>()(sizeof(streamID) * id_count);\n    for (j = 5; j < c->argc; j++) {\n        if (<recovery-expr>())\n            break;\n    }\n    int last_id_arg = j - 1;\n    mstime_t now = commandTimeSnapshot();\n    streamID last_id = <recovery-expr>({0, 0});\n    int propagate_last_id = 0;\n    for (; j < c->argc; j++) {\n        int moreargs = (c->argc - 1) - j;\n        char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt, \"FORCE\")) {\n            force = 1;\n        } else if (!strcasecmp(opt, \"JUSTID\")) {\n            justid = 1;\n        } else if (!strcasecmp(opt, \"IDLE\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c, c->argv[j], &deliverytime, \"Invalid IDLE option argument for XCLAIM\") != 0)\n                goto cleanup;\n            deliverytime = now - deliverytime;\n        } else if (!strcasecmp(opt, \"TIME\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c, c->argv[j], &deliverytime, \"Invalid TIME option argument for XCLAIM\") != 0)\n                goto cleanup;\n        } else if (!strcasecmp(opt, \"RETRYCOUNT\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c, c->argv[j], &retrycount, \"Invalid RETRYCOUNT option argument for XCLAIM\") != 0)\n                goto cleanup;\n        } else if (!strcasecmp(opt, \"LASTID\") && moreargs) {\n            j++;\n            if (<recovery-expr>())\n                goto cleanup;\n        } else {\n            addReplyErrorFormat(c, \"Unrecognized XCLAIM option '%s'\", opt);\n            goto cleanup;\n        }\n    }\n    if (streamCompareID(&last_id, &<recovery-expr>(group)) > 0) {\n        <recovery-expr>(group) = last_id;\n        propagate_last_id = 1;\n    }\n    if (deliverytime != -1) {\n        if (deliverytime < 0 || deliverytime > now)\n            deliverytime = now;\n    } else {\n        deliverytime = now;\n    }\n    streamConsumer *consumer;\n    void *arraylenptr = addReplyDeferredLen(c);\n    int arraylen(int *);\n    sds name = c->argv[3]->ptr;\n    for (int j = 5; j <= last_id_arg; j++) {\n        streamID id = ids[j - 5];\n        unsigned char buf[1];\n        streamEncodeID(buf, &id);\n        streamNACK *nack = <recovery-expr>()(group->pel, buf, sizeof (buf));\n        if (!streamEntryExists(o->ptr, &id)) {\n            if (nack != raxNotFound) {\n                streamPropagateXCLAIM(c, c->argv[1], group, c->argv[2], c->argv[j], nack);\n                propagate_last_id = 0;\n                server.dirty++;\n                streamFreeNACK(nack);\n            }\n            continue;\n        }\n        if (force && nack == raxNotFound) {\n        }\n        if (nack != raxNotFound) {\n            if (nack->consumer && minidle) {\n                mstime_t this_idle = now - nack->delivery_time;\n                if (this_idle < minidle)\n                    continue;\n            }\n            if (<recovery-expr>()) {\n                consumer = streamCreateConsumer(group, name, c->argv[1], c->db->id, 0);\n            }\n            if (nack->consumer != consumer) {\n            }\n            nack->delivery_time = deliverytime;\n            if (retrycount >= 0) {\n                <recovery-expr>(nack) = retrycount;\n            } else if (!justid) {\n                <recovery-expr>(nack)++;\n            }\n            if (nack->consumer != consumer) {\n                nack->consumer = consumer;\n            }\n            if (justid) {\n                addReplyStreamID(c, &id);\n            } else {\n            }\n            <recovery-expr>()++;\n            streamPropagateXCLAIM(c, c->argv[1], group, c->argv[2], c->argv[j], nack);\n            propagate_last_id = 0;\n            server.dirty++;\n        }\n    }\n    if (propagate_last_id) {\n        streamPropagateGroupID(c, c->argv[1], group, c->argv[2]);\n        server.dirty++;\n    }\n    setDeferredArrayLen(c, arraylenptr, <recovery-expr>());\n    preventCommandPropagation(c);\n  cleanup:\n    if (ids != static_ids)\n        zfree(ids);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#2823:1#xackCommand",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    streamCG *group;\n    robj *o = lookupKeyRead(c->db, c->argv[1]);\n    if (o) {\n        if (checkType(c, o, 6))\n            return;\n        group = streamLookupCG(o->ptr, c->argv[2]->ptr);\n    }\n    if (<recovery-expr>()) {\n        addReply(c, shared.czero);\n        return;\n    }\n    streamID static_ids[8];\n    streamID *ids = static_ids;\n    int id_count = c->argc - 3;\n    if (id_count > 8)\n        ids = <recovery-expr>()(sizeof(streamID) * id_count);\n    for (int j = 3; j < c->argc; j++) {\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    int acknowledged = 0;\n    for (int j = 3; j < c->argc; j++) {\n        unsigned char buf[1];\n        streamEncodeID(buf, &ids[j - 3]);\n        streamNACK *nack = <recovery-expr>()(group->pel, buf, sizeof (buf));\n        if (nack != raxNotFound) {\n            streamFreeNACK(nack);\n            acknowledged++;\n            server.dirty++;\n        }\n    }\n    addReplyLongLong(c, acknowledged);\n  cleanup:\n    if (ids != static_ids)\n        zfree(ids);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#2167:1#xreadCommand",
            "gotos": 8,
            "labels": 1,
            "body": "{\n    long long timeout = -1;\n    long long count = 0;\n    int streams_count = 0;\n    int streams_arg = 0;\n    int noack = 0;\n    streamID static_ids[8];\n    streamID *ids = static_ids;\n    streamCG **groups;\n    int xreadgroup = <recovery-expr>()(c->argv[0]->ptr) == 10;\n    robj *groupname;\n    robj *consumername;\n    for (int i = 1; i < c->argc; i++) {\n        int moreargs = c->argc - i - 1;\n        char *o = c->argv[i]->ptr;\n        if (!strcasecmp(o, \"BLOCK\") && moreargs) {\n            if (<recovery-expr>(c) & (1 << 8)) {\n                addReplyErrorFormat(c, \"%s command is not allowed with BLOCK option from scripts\", (char *)c->argv[0]->ptr);\n                return;\n            }\n            i++;\n            if (getTimeoutFromObjectOrReply(c, c->argv[i], &timeout, 1) != 0)\n                return;\n        } else if (!strcasecmp(o, \"COUNT\") && moreargs) {\n            i++;\n            if (<recovery-expr>())\n                return;\n            if (count < 0)\n                count = 0;\n        } else if (!strcasecmp(o, \"STREAMS\") && moreargs) {\n            streams_arg = i + 1;\n            streams_count = (c->argc - streams_arg);\n            if ((streams_count % 2) != 0) {\n                addReplyError(c, \"Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified.\");\n                return;\n            }\n            streams_count /= 2;\n            break;\n        } else if (!strcasecmp(o, \"GROUP\") && moreargs >= 2) {\n            if (!xreadgroup) {\n                addReplyError(c, \"The GROUP option is only supported by XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            groupname = c->argv[i + 1];\n            consumername = c->argv[i + 2];\n            i += 2;\n        } else if (!strcasecmp(o, \"NOACK\")) {\n            if (!xreadgroup) {\n                addReplyError(c, \"The NOACK option is only supported by XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            noack = 1;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n    if (streams_arg == 0) {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n    if (<recovery-expr>()) {\n        addReplyError(c, \"Missing GROUP option for XREADGROUP\");\n        return;\n    }\n    if (streams_count > 8)\n        ids = <recovery-expr>()(sizeof(streamID) * streams_count);\n    if (groupname)\n        groups = <recovery-expr>()(sizeof(streamCG *) * streams_count);\n    for (int i = streams_arg + streams_count; i < c->argc; i++) {\n        int id_idx = i - streams_arg - streams_count;\n        robj *key = c->argv[i - streams_count];\n        robj *o = lookupKeyRead(c->db, key);\n        if (checkType(c, o, 6))\n            goto cleanup;\n        streamCG *group;\n        if (groupname) {\n            if (<recovery-expr>()) {\n                addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer group '%s' in XREADGROUP with GROUP option\", (char *)key->ptr, (char *)groupname->ptr);\n                goto cleanup;\n            }\n            groups[id_idx] = group;\n        }\n        if (strcmp(c->argv[i]->ptr, \"$\") == 0) {\n            if (xreadgroup) {\n                addReplyError(c, \"The $ ID is meaningless in the context of XREADGROUP: you want to read the history of this consumer by specifying a proper ID, or use the > ID to get new messages. The $ ID would just return an empty result set.\");\n                goto cleanup;\n            }\n            if (o) {\n                stream *s = o->ptr;\n                ids[id_idx] = <recovery-expr>(s);\n            } else {\n                <recovery-expr>(ids[id_idx]) = 0;\n                <recovery-expr>(ids[id_idx]) = 0;\n            }\n            continue;\n        } else if (strcmp(c->argv[i]->ptr, \">\") == 0) {\n            if (!xreadgroup) {\n                addReplyError(c, \"The > ID can be specified only when calling XREADGROUP using the GROUP <group> <consumer> option.\");\n                goto cleanup;\n            }\n            continue;\n        }\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    int arraylen(int *);\n    void *arraylen_ptr;\n    for (int i = 0; i < streams_count; i++) {\n        robj *o = lookupKeyRead(c->db, c->argv[streams_arg + i]);\n        if (<recovery-expr>())\n            continue;\n        stream *s = o->ptr;\n        streamID *gt = ids + i;\n        int serve_synchronously = 0;\n        int serve_history = 0;\n        if (groups) {\n            if (<recovery-expr>()) {\n                serve_synchronously = 1;\n                serve_history = 1;\n            } else if (<recovery-expr>(s)) {\n                streamID maxid, *last = &<recovery-expr>(groups[i]);\n                streamLastValidID(s, &maxid);\n                if (streamCompareID(&maxid, last) > 0) {\n                    serve_synchronously = 1;\n                    *gt = *last;\n                }\n            }\n        } else if (<recovery-expr>(s)) {\n            streamID maxid;\n            streamLastValidID(s, &maxid);\n            if (streamCompareID(&maxid, gt) > 0) {\n                serve_synchronously = 1;\n            }\n        }\n        if (serve_synchronously) {\n            <recovery-expr>()++;\n            if (<recovery-expr>() == 1)\n                arraylen_ptr = addReplyDeferredLen(c);\n            streamID start = *gt;\n            streamIncrID(&start);\n            if (c->resp == 2)\n                addReplyArrayLen(c, 2);\n            addReplyBulk(c, c->argv[streams_arg + i]);\n            streamConsumer *consumer;\n            streamPropInfo spi = {c->argv[i + streams_arg], groupname};\n            if (groups) {\n                consumer = streamLookupConsumer(groups[i], consumername->ptr, 0);\n                if (<recovery-expr>()) {\n                    consumer = streamCreateConsumer(groups[i], consumername->ptr, c->argv[streams_arg + i], c->db->id, 0);\n                    if (noack)\n                        streamPropagateConsumerCreation(c, spi.keyname, spi.groupname, consumer->name);\n                }\n            }\n            int flags = 0;\n            if (noack)\n                flags |= (1 << 0);\n            if (serve_history)\n                flags |= (1 << 2);\n            if (groups)\n                server.dirty++;\n        }\n    }\n    if (<recovery-expr>()) {\n        if (c->resp == 2)\n            setDeferredArrayLen(c, arraylen_ptr, <recovery-expr>());\n        else\n            setDeferredMapLen(c, arraylen_ptr, <recovery-expr>());\n        goto cleanup;\n    }\n    if (timeout != -1) {\n        if (<recovery-expr>(c) & (1ULL << 41)) {\n            addReplyNullArray(c);\n            goto cleanup;\n        }\n        <recovery-expr>(c).xread_count = count ? count : 1000;\n        if (groupname) {\n            incrRefCount(groupname);\n            incrRefCount(consumername);\n            <recovery-expr>(c).xread_group = groupname;\n            <recovery-expr>(c).xread_consumer = consumername;\n            <recovery-expr>(c).xread_group_noack = noack;\n        } else {\n        }\n        goto cleanup;\n    }\n    addReplyNullArray(c);\n  cleanup:\n    preventCommandPropagation(c);\n    if (ids != static_ids)\n        zfree(ids);\n    zfree(groups);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#1879:1#streamGenericParseIDOrReply",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    char buf[128];\n    if (<recovery-expr>()(o->ptr) > sizeof (buf) - 1)\n        goto invalid;\n    memcpy(buf, o->ptr, <recovery-expr>()(o->ptr) + 1);\n    if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\\x00')\n        goto invalid;\n    if (<recovery-expr>()) {\n        *seq_given = 1;\n    }\n    if (buf[0] == '-' && buf[1] == '\\x00') {\n        <recovery-expr>(id) = 0;\n        <recovery-expr>(id) = 0;\n        return 0;\n    } else if (buf[0] == '+' && buf[1] == '\\x00') {\n        return 0;\n    }\n    unsigned long long ms, seq;\n    char *dot = strchr(buf, '-');\n    if (dot)\n        *dot = '\\x00';\n    if (string2ull(buf, &ms) == 0)\n        goto invalid;\n    if (dot) {\n        int seqlen(int *);\n        if (<recovery-expr>()) {\n            seq = 0;\n            *seq_given = 0;\n        } else if (string2ull(dot + 1, &seq) == 0) {\n            goto invalid;\n        }\n    } else {\n        seq = <recovery-expr>();\n    }\n    <recovery-expr>(id) = ms;\n    <recovery-expr>(id) = seq;\n    return 0;\n  invalid:\n    if (c)\n        addReplyError(c, \"Invalid stream ID specified as stream command argument\");\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#3518:1#xdelCommand",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    robj *o;\n    if (<recovery-expr>())\n        return;\n    stream *s = o->ptr;\n    streamID static_ids[8];\n    streamID *ids = static_ids;\n    int id_count = c->argc - 2;\n    if (id_count > 8)\n        ids = <recovery-expr>()(sizeof(streamID) * id_count);\n    for (int j = 2; j < c->argc; j++) {\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    int deleted = 0;\n    int first_entry = 0;\n    for (int j = 2; j < c->argc; j++) {\n        streamID *id = &ids[j - 2];\n        if (streamDeleteItem(s, id)) {\n            if (streamCompareID(id, &<recovery-expr>(s)) == 0) {\n                first_entry = 1;\n            }\n            if (streamCompareID(id, &<recovery-expr>(s)) > 0) {\n                <recovery-expr>(s) = *id;\n            }\n            deleted++;\n        }\n        ;\n    }\n    if (deleted) {\n        if (<recovery-expr>(s) == 0) {\n            <recovery-expr>(s).ms = 0;\n            <recovery-expr>(s).seq = 0;\n        } else if (first_entry) {\n            streamGetEdgeID(s, 1, 1, &<recovery-expr>(s));\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent((1 << 10), \"xdel\", c->argv[1], c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c, deleted);\n  cleanup:\n    if (ids != static_ids)\n        zfree(ids);\n}\n"
        }
    ],
    "total": 124,
    "visited": 5
}
