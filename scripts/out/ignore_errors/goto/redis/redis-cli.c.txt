{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#7315:1#clusterManagerCommandBackup",
            "gotos": 2,
            "labels": 2,
            "body": "{\n    ((void)argc);\n    int success = 1, port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(refnode))\n        return 0;\n    int no_issues = clusterManagerCheckCluster(0);\n    int cluster_errors_count = (no_issues ? 0 : ((cluster_manager.errors)->len));\n    config.cluster_manager_command.backup_dir = argv[1];\n    sds json = sdsnew(\"[\\n\");\n    int first_node = 0;\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            if (!first_node)\n                first_node = 1;\n            else\n                json = sdscat(json, \",\\n\");\n            clusterManagerNode *node = ln->value;\n            sds node_json = clusterManagerNodeGetJSON(node, cluster_errors_count);\n            json = sdscat(json, node_json);\n            sdsfree(node_json);\n            if (node->replicate)\n                continue;\n            clusterManagerLog(1, \">>> Node %s:%d -> Saving RDB...\\n\", node->ip, node->port);\n            getRDB(node);\n        }\n    json = sdscat(json, \"\\n]\");\n    sds jsonpath = sdsnew(config.cluster_manager_command.backup_dir);\n    if (jsonpath[<recovery-expr>()(jsonpath) - 1] != '/')\n        jsonpath = sdscat(jsonpath, \"/\");\n    jsonpath = sdscat(jsonpath, \"nodes.json\");\n    clusterManagerLog(1, \"Saving cluster configuration to: %s\\n\", jsonpath);\n    if (<recovery-expr>()) {\n        clusterManagerLog(3, \"Could not save nodes to: %s\\n\", jsonpath);\n        success = 0;\n        goto cleanup;\n    }\n  cleanup:\n    sdsfree(json);\n    sdsfree(jsonpath);\n    if (success) {\n        if (!no_issues) {\n            clusterManagerLog(2, \"*** Cluster seems to have some problems, please be aware of it if you're going to restore this backup.\\n\");\n        }\n        clusterManagerLog(4, \"[OK] Backup created into: %s\\n\", config.cluster_manager_command.backup_dir);\n    } else\n        clusterManagerLog(4, \"[ERR] Failed to back cluster!\\n\");\n    return success;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#7271:1#clusterManagerCommandCall",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int port = 0, i;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(refnode))\n        return 0;\n    argc--;\n    argv++;\n    clusterManagerLog(1, \">>> Calling\");\n    for (i = 0; i < argc; i++) {\n        printf(\" %s\", argv[i]);\n    }\n    printf(\"\\n\");\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (<recovery-expr>())\n                continue;\n            if (<recovery-expr>())\n                continue;\n            if (!<recovery-expr>(n) && !clusterManagerNodeConnect(n))\n                continue;\n            int status;\n            if (<recovery-expr>())\n                printf(\"%s:%d: Failed!\\n\", n->ip, n->port);\n            else {\n                sds formatted_reply;\n                printf(\"%s:%d: %s\\n\", n->ip, n->port, (char *)formatted_reply);\n                sdsfree(formatted_reply);\n            }\n        }\n    return 1;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#7116:1#clusterManagerCommandImport",
            "gotos": 10,
            "labels": 2,
            "body": "{\n    int success = 1;\n    int port = 0, src_port = 0;\n    char *ip, *src_ip;\n    char *invalid_args_msg;\n    sds cmdfmt;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) {\n        invalid_args_msg = \"[ERR] Invalid arguments: you need to pass either a valid address (ie. 120.0.0.1:7000) or space separated IP and port (ie. 120.0.0.1 7000)\\n\";\n        goto invalid_args;\n    }\n    if (<recovery-expr>()) {\n        invalid_args_msg = \"[ERR] Option '--cluster-from' is required for subcommand 'import'.\\n\";\n        goto invalid_args;\n    }\n    char *src_host[] = {config.cluster_manager_command.from};\n    if (!getClusterHostFromCmdArgs(1, src_host, &src_ip, &src_port)) {\n        invalid_args_msg = \"[ERR] Invalid --cluster-from host. You need to pass a valid address (ie. 120.0.0.1:7000).\\n\";\n        goto invalid_args;\n    }\n    clusterManagerLog(1, \">>> Importing data from %s:%d to cluster %s:%d\\n\", src_ip, src_port, ip, port);\n    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(refnode))\n        return 0;\n    if (!clusterManagerCheckCluster(0))\n        return 0;\n    char *reply_err;\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    char *from_user = config.cluster_manager_command.from_user;\n    char *from_pass = config.cluster_manager_command.from_pass;\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        clusterManagerLog(3, \"[ERR] The source node should not be a cluster node.\\n\");\n        success = 0;\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    int size, i;\n    clusterManagerLog(2, \"*** Importing %d keys from DB 0\\n\", size);\n    clusterManagerNode *slots_map[16384];\n    memset(slots_map, 0, sizeof (slots_map));\n    listIter li;\n    listNode *ln;\n    for (i = 0; i < 16384; i++) {\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n->flags & 1 << 1)\n                    continue;\n                if (n->slots_count == 0)\n                    continue;\n                if (<recovery-expr>(n)[i]) {\n                    slots_map[i] = n;\n                    break;\n                }\n            }\n    }\n    cmdfmt = sdsnew(\"MIGRATE %s %d %s %d %d\");\n    if (config.conn_info.auth) {\n        if (config.conn_info.user) {\n            cmdfmt = sdscatfmt(cmdfmt, \" AUTH2 %s %s\", config.conn_info.user, config.conn_info.auth);\n        } else {\n            cmdfmt = sdscatfmt(cmdfmt, \" AUTH %s\", config.conn_info.auth);\n        }\n    }\n    if (config.cluster_manager_command.flags & 1 << 7)\n        cmdfmt = sdscat(cmdfmt, \" COPY\");\n    if (config.cluster_manager_command.flags & 1 << 6)\n        cmdfmt = sdscat(cmdfmt, \" REPLACE\");\n    int cursor = -999, timeout = config.cluster_manager_command.timeout;\n    while (cursor != 0)\n        {\n            if (cursor < 0)\n                cursor = 0;\n            if (<recovery-expr>()) {\n                success = 0;\n                goto cleanup;\n            }\n            int keycount;\n            for (i = 0; i < keycount; i++) {\n                char *key;\n                clusterManagerNode *target;\n                printf(\"Migrating %s to %s:%d: \", key, target->ip, target->port);\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    }\n                    success = 0;\n                }\n                if (!success)\n                    goto cleanup;\n                clusterManagerLog(4, \"OK\\n\");\n            }\n        }\n  cleanup:\n    if (reply_err)\n        clusterManagerLog(3, \"Source %s:%d replied with error:\\n%s\\n\", src_ip, src_port, reply_err);\n    if (cmdfmt)\n        sdsfree(cmdfmt);\n    return success;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#7058:1#clusterManagerCommandSetTimeout",
            "gotos": 5,
            "labels": 2,
            "body": "{\n    ((void)argc);\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    int timeout = atoi(argv[1]);\n    if (timeout < 100) {\n        return 0;\n    }\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    int ok_count = 0, err_count = 0;\n    clusterManagerLog(1, \">>> Reconfiguring node timeout in every cluster node...\\n\");\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            char *err;\n            if (<recovery-expr>())\n                goto reply_err;\n            int ok;\n            if (!ok)\n                goto reply_err;\n            if (<recovery-expr>())\n                goto reply_err;\n            if (!ok)\n                goto reply_err;\n            clusterManagerLog(2, \"*** New timeout set for %s:%d\\n\", n->ip, n->port);\n            ok_count++;\n            continue;\n          reply_err:\n            ;\n            int need_free = 0;\n            if (<recovery-expr>())\n                err = \"\";\n            else\n                need_free = 1;\n            clusterManagerLog(3, \"ERR setting node-timeout for %s:%d: %s\\n\", n->ip, n->port, err);\n            if (need_free)\n                zfree(err);\n            err_count++;\n        }\n    clusterManagerLog(1, \">>> New node timeout set. %d OK, %d ERR.\\n\", ok_count, err_count);\n    return 1;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6863:1#clusterManagerCommandRebalance",
            "gotos": 9,
            "labels": 3,
            "body": "{\n    int port = 0;\n    char *ip;\n    clusterManagerNode **weightedNodes;\n    list *involved;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    int result = 1, i;\n    if (<recovery-expr>()) {\n        for (i = 0; i < config.cluster_manager_command.weight_argc; i++) {\n            char *name = config.cluster_manager_command.weight[i];\n            char *p = strchr(name, '=');\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \"*** invalid input %s\\n\", name);\n                result = 0;\n                goto cleanup;\n            }\n            *p = '\\x00';\n            float w = atof(++p);\n            clusterManagerNode *n = clusterManagerNodeByAbbreviatedName(name);\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \"*** No such master node %s\\n\", name);\n                result = 0;\n                goto cleanup;\n            }\n            n->weight = w;\n        }\n    }\n    float total_weight = 0;\n    int nodes_involved = 0;\n    int use_empty = config.cluster_manager_command.flags & 1 << 4;\n    involved = listCreate();\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (n->flags & 1 << 1 || n->replicate)\n                continue;\n            if (!use_empty && n->slots_count == 0) {\n                n->weight = 0;\n                continue;\n            }\n            total_weight += n->weight;\n            nodes_involved++;\n            listAddNodeTail(involved, n);\n        }\n    weightedNodes = <recovery-expr>()(nodes_involved * sizeof(clusterManagerNode *));\n    if (<recovery-expr>())\n        goto cleanup;\n    clusterManagerCheckCluster(1);\n    if (cluster_manager.errors && ((cluster_manager.errors)->len) > 0) {\n        clusterManagerLog(3, \"*** Please fix your cluster problems before rebalancing\\n\");\n        result = 0;\n        goto cleanup;\n    }\n    int threshold_reached = 0, total_balance = 0;\n    float threshold = config.cluster_manager_command.threshold;\n    i = 0;\n    listRewind(involved, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            weightedNodes[i++] = n;\n            int expected = (int)(((float)16384 / total_weight) * n->weight);\n            n->balance = n->slots_count - expected;\n            total_balance += n->balance;\n            int over_threshold = 0;\n            if (threshold > 0) {\n                if (n->slots_count > 0) {\n                    float err_perc = fabs((100 - (100. * expected / n->slots_count)));\n                    if (err_perc > threshold)\n                        over_threshold = 1;\n                } else if (expected > 1) {\n                    over_threshold = 1;\n                }\n            }\n            if (over_threshold)\n                threshold_reached = 1;\n        }\n    if (!threshold_reached) {\n        clusterManagerLog(2, \"*** No rebalancing needed! All nodes are within the %.2f%% threshold.\\n\", config.cluster_manager_command.threshold);\n        goto cleanup;\n    }\n    while (total_balance > 0)\n        {\n            listRewind(involved, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    if (n->balance <= 0 && total_balance > 0) {\n                        n->balance--;\n                        total_balance--;\n                    }\n                }\n        }\n    qsort(weightedNodes, nodes_involved, sizeof(clusterManagerNode *), clusterManagerCompareNodeBalance);\n    clusterManagerLog(1, \">>> Rebalancing across %d nodes. Total weight = %.2f\\n\", nodes_involved, total_weight);\n    if (config.verbose) {\n        for (i = 0; i < nodes_involved; i++) {\n            clusterManagerNode *n = weightedNodes[i];\n            printf(\"%s:%d balance is %d slots\\n\", n->ip, n->port, n->balance);\n        }\n    }\n    int dst_idx = 0;\n    int src_idx = nodes_involved - 1;\n    int simulate = config.cluster_manager_command.flags & 1 << 5;\n    while (dst_idx < src_idx)\n        {\n            clusterManagerNode *dst = weightedNodes[dst_idx];\n            clusterManagerNode *src = weightedNodes[src_idx];\n            int db = abs(dst->balance);\n            int sb = abs(src->balance);\n            int numslots = (db < sb ? db : sb);\n            if (numslots > 0) {\n                printf(\"Moving %d slots from %s:%d to %s:%d\\n\", numslots, src->ip, src->port, dst->ip, dst->port);\n                list *lsrc = listCreate(), *table;\n                listAddNodeTail(lsrc, src);\n                table = clusterManagerComputeReshardTable(lsrc, numslots);\n                listRelease(lsrc);\n                int table_len = (int)((table)->len);\n                if (!table || table_len != numslots) {\n                    clusterManagerLog(3, \"*** Assertion failed: Reshard table != number of slots\");\n                    result = 0;\n                    goto end_move;\n                }\n                if (simulate) {\n                    for (i = 0; i < table_len; i++)\n                        printf(\"#\");\n                } else {\n                    int opts = 1 << 6 | 1 << 2;\n                    listRewind(table, &li);\n                    while (<recovery-expr>())\n                        {\n                            clusterManagerReshardTableItem *item = ln->value;\n                            char *err;\n                            result = clusterManagerMoveSlot(item->source, dst, item->slot, opts, &err);\n                            if (!result) {\n                                clusterManagerLog(3, \"*** clusterManagerMoveSlot: %s\\n\", err);\n                                zfree(err);\n                                goto end_move;\n                            }\n                            printf(\"#\");\n                        }\n                }\n                printf(\"\\n\");\n              end_move:\n                clusterManagerReleaseReshardTable(table);\n                if (!result)\n                    goto cleanup;\n            }\n            dst->balance += numslots;\n            src->balance -= numslots;\n            if (dst->balance == 0)\n                dst_idx++;\n            if (src->balance == 0)\n                src_idx--;\n        }\n  cleanup:\n    if (<recovery-expr>())\n        listRelease(involved);\n    if (<recovery-expr>())\n        zfree(weightedNodes);\n    return result;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6676:1#clusterManagerCommandReshard",
            "gotos": 7,
            "labels": 2,
            "body": "{\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    clusterManagerCheckCluster(0);\n    if (cluster_manager.errors && ((cluster_manager.errors)->len) > 0) {\n        return 0;\n    }\n    int slots = config.cluster_manager_command.slots;\n    if (!slots) {\n        while (slots <= 0 || slots > 16384)\n            {\n                printf(\"How many slots do you want to move (from 1 to %d)? \", 16384);\n                char buf[6];\n                int nread;\n                if (nread <= 0)\n                    continue;\n                int last_idx = nread - 1;\n                if (buf[last_idx] != '\\n') {\n                    int ch;\n                    while (<recovery-expr>())\n                        {\n                        }\n                }\n                buf[last_idx] = '\\x00';\n                slots = atoi(buf);\n            }\n    }\n    char buf[255];\n    char *to = config.cluster_manager_command.to, *from = config.cluster_manager_command.from;\n    while (<recovery-expr>())\n        {\n            printf(\"What is the receiving node ID? \");\n            int nread;\n            if (nread <= 0)\n                continue;\n            int last_idx = nread - 1;\n            if (buf[last_idx] != '\\n') {\n                int ch;\n                while (<recovery-expr>())\n                    {\n                    }\n            }\n            buf[last_idx] = '\\x00';\n            if (strlen(buf) > 0)\n                to = buf;\n        }\n    int raise_err = 0;\n    clusterManagerNode *target;\n    if (<recovery-expr>())\n        return 0;\n    list *sources = listCreate();\n    list *table;\n    int all = 0, result = 1;\n    if (<recovery-expr>()) {\n        printf(\"Please enter all the source node IDs.\\n\");\n        printf(\"  Type 'all' to use all the nodes as source nodes for the hash slots.\\n\");\n        printf(\"  Type 'done' once you entered all the source nodes IDs.\\n\");\n        while (1)\n            {\n                printf(\"Source node #%lu: \", ((sources)->len) + 1);\n                int nread;\n                if (nread <= 0)\n                    continue;\n                int last_idx = nread - 1;\n                if (buf[last_idx] != '\\n') {\n                    int ch;\n                    while (<recovery-expr>())\n                        {\n                        }\n                }\n                buf[last_idx] = '\\x00';\n                if (!strcmp(buf, \"done\"))\n                    break;\n                else if (!strcmp(buf, \"all\")) {\n                    all = 1;\n                    break;\n                } else {\n                    clusterManagerNode *src = clusterNodeForResharding(buf, target, &raise_err);\n                    if (<recovery-expr>())\n                        listAddNodeTail(sources, src);\n                    else if (raise_err) {\n                        result = 0;\n                        goto cleanup;\n                    }\n                }\n            }\n    } else {\n        char *p;\n        while (<recovery-expr>())\n            {\n                *p = '\\x00';\n                if (!strcmp(from, \"all\")) {\n                    all = 1;\n                    break;\n                } else {\n                    clusterManagerNode *src = clusterNodeForResharding(from, target, &raise_err);\n                    if (<recovery-expr>())\n                        listAddNodeTail(sources, src);\n                    else if (raise_err) {\n                        result = 0;\n                        goto cleanup;\n                    }\n                }\n                from = p + 1;\n            }\n        if (!all && strlen(from) > 0) {\n            if (!strcmp(from, \"all\"))\n                all = 1;\n            if (!all) {\n                clusterManagerNode *src = clusterNodeForResharding(from, target, &raise_err);\n                if (<recovery-expr>())\n                    listAddNodeTail(sources, src);\n                else if (raise_err) {\n                    result = 0;\n                    goto cleanup;\n                }\n            }\n        }\n    }\n    listIter li;\n    listNode *ln;\n    if (all) {\n        listEmpty(sources);\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n->flags & 1 << 1 || n->replicate)\n                    continue;\n                if (!sdscmp(n->name, target->name))\n                    continue;\n                listAddNodeTail(sources, n);\n            }\n    }\n    if (((sources)->len) == 0) {\n        result = 0;\n        goto cleanup;\n    }\n    printf(\"\\nReady to move %d slots.\\n\", slots);\n    printf(\"  Source nodes:\\n\");\n    listRewind(sources, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *src = ln->value;\n            sds info = clusterManagerNodeInfo(src, 4);\n            printf(\"%s\\n\", info);\n            sdsfree(info);\n        }\n    printf(\"  Destination node:\\n\");\n    sds info = clusterManagerNodeInfo(target, 4);\n    printf(\"%s\\n\", info);\n    sdsfree(info);\n    table = clusterManagerComputeReshardTable(sources, slots);\n    printf(\"  Resharding plan:\\n\");\n    clusterManagerShowReshardTable(table);\n    if (!(config.cluster_manager_command.flags & 1 << 2)) {\n        printf(\"Do you want to proceed with the proposed reshard plan (yes/no)? \");\n        char buf[4];\n        int nread;\n        buf[3] = '\\x00';\n        if (nread <= 0 || strcmp(\"yes\", buf) != 0) {\n            result = 0;\n            goto cleanup;\n        }\n    }\n    int opts = 1 << 7;\n    listRewind(table, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerReshardTableItem *item = ln->value;\n            char *err;\n            result = clusterManagerMoveSlot(item->source, target, item->slot, opts, &err);\n            if (!result) {\n                if (<recovery-expr>()) {\n                    clusterManagerLog(3, \"clusterManagerMoveSlot failed: %s\\n\", err);\n                    zfree(err);\n                }\n                goto cleanup;\n            }\n        }\n  cleanup:\n    listRelease(sources);\n    clusterManagerReleaseReshardTable(table);\n    return result;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#5205:1#clusterManagerFixSlotsCoverage",
            "gotos": 9,
            "labels": 1,
            "body": "{\n    int force_fix = config.cluster_manager_command.flags & 1 << 10;\n    if (cluster_manager.unreachable_masters > 0 && !force_fix) {\n        clusterManagerLog(2, \"*** Fixing slots coverage with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\\n\", cluster_manager.unreachable_masters);\n        exit(1);\n    }\n    int i, fixed = 0;\n    list *none, *single, *multi;\n    clusterManagerLog(1, \">>> Fixing slots coverage...\\n\");\n    for (i = 0; i < 16384; i++) {\n        int covered = all_slots[i];\n        if (!covered) {\n            sds slot = sdsfromlonglong((long long)i);\n            list *slot_nodes = listCreate();\n            sds slot_nodes_str = sdsempty();\n            listIter li;\n            listNode *ln;\n            listRewind(cluster_manager.nodes, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    if (n->flags & 1 << 1 || n->replicate)\n                        continue;\n                    if (<recovery-expr>()) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    if (<recovery-expr>()) {\n                        listAddNodeTail(slot_nodes, n);\n                        if (((slot_nodes)->len) > 1)\n                            slot_nodes_str = sdscat(slot_nodes_str, \", \");\n                        slot_nodes_str = sdscatfmt(slot_nodes_str, \"%s:%u\", n->ip, n->port);\n                    }\n                }\n            sdsfree(slot_nodes_str);\n            dictAdd(clusterManagerUncoveredSlots, slot, slot_nodes);\n        }\n    }\n    none = listCreate();\n    single = listCreate();\n    multi = listCreate();\n    dictIterator *iter = dictGetIterator(clusterManagerUncoveredSlots);\n    dictEntry *entry;\n    while (<recovery-expr>())\n        {\n            sds slot = (sds)((entry)->key);\n            list *nodes = (list *)(<recovery-expr>((entry)).val);\n            switch (((nodes)->len)) {\n              case 0:\n                listAddNodeTail(none, slot);\n                break;\n              case 1:\n                listAddNodeTail(single, slot);\n                break;\n              default:\n                listAddNodeTail(multi, slot);\n                break;\n            }\n        }\n    dictReleaseIterator(iter);\n    int ignore_force = 1;\n    if (((none)->len) > 0) {\n        printf(\"The following uncovered slots have no keys across the cluster:\\n\");\n        clusterManagerPrintSlotsList(none);\n        if (confirmWithYes(\"Fix these slots by covering with a random node?\", ignore_force)) {\n            listIter li;\n            listNode *ln;\n            listRewind(none, &li);\n            while (<recovery-expr>())\n                {\n                    sds slot = ln->value;\n                    int s = atoi(slot);\n                    clusterManagerNode *n = clusterManagerNodeMasterRandom();\n                    clusterManagerLog(1, \">>> Covering slot %s with %s:%d\\n\", slot, n->ip, n->port);\n                    if (!clusterManagerSetSlotOwner(n, s, 0)) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    <recovery-expr>(n)[s] = 1;\n                    fixed++;\n                }\n        }\n    }\n    if (((single)->len) > 0) {\n        printf(\"The following uncovered slots have keys in just one node:\\n\");\n        clusterManagerPrintSlotsList(single);\n        if (confirmWithYes(\"Fix these slots by covering with those nodes?\", ignore_force)) {\n            listIter li;\n            listNode *ln;\n            listRewind(single, &li);\n            while (<recovery-expr>())\n                {\n                    sds slot = ln->value;\n                    int s = atoi(slot);\n                    dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);\n                    list *nodes = (list *)(<recovery-expr>((entry)).val);\n                    listNode *fn = ((nodes)->head);\n                    clusterManagerNode *n = fn->value;\n                    clusterManagerLog(1, \">>> Covering slot %s with %s:%d\\n\", slot, n->ip, n->port);\n                    if (!clusterManagerSetSlotOwner(n, s, 0)) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    <recovery-expr>(n)[atoi(slot)] = 1;\n                    fixed++;\n                }\n        }\n    }\n    if (((multi)->len) > 0) {\n        printf(\"The following uncovered slots have keys in multiple nodes:\\n\");\n        clusterManagerPrintSlotsList(multi);\n        if (confirmWithYes(\"Fix these slots by moving keys into a single node?\", ignore_force)) {\n            listIter li;\n            listNode *ln;\n            listRewind(multi, &li);\n            while (<recovery-expr>())\n                {\n                    sds slot = ln->value;\n                    dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);\n                    list *nodes = (list *)(<recovery-expr>((entry)).val);\n                    int s = atoi(slot);\n                    clusterManagerNode *target;\n                    if (<recovery-expr>()) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    clusterManagerLog(1, \">>> Covering slot %s moving keys to %s:%d\\n\", slot, target->ip, target->port);\n                    if (!clusterManagerSetSlotOwner(target, s, 1)) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    <recovery-expr>(target)[atoi(slot)] = 1;\n                    listIter nli;\n                    listNode *nln;\n                    listRewind(nodes, &nli);\n                    while (<recovery-expr>())\n                        {\n                            clusterManagerNode *src = nln->value;\n                            if (src == target)\n                                continue;\n                            if (<recovery-expr>())\n                                fixed = -1;\n                            if (fixed < 0)\n                                goto cleanup;\n                            if (<recovery-expr>())\n                                fixed = -1;\n                            if (fixed < 0)\n                                goto cleanup;\n                            int opts = 1 << 7 | 1 << 1;\n                            if (<recovery-expr>()) {\n                                fixed = -1;\n                                goto cleanup;\n                            }\n                            if (!clusterManagerClearSlotStatus(src, s))\n                                fixed = -1;\n                            if (fixed < 0)\n                                goto cleanup;\n                        }\n                    fixed++;\n                }\n        }\n    }\n  cleanup:\n    if (none)\n        listRelease(none);\n    if (single)\n        listRelease(single);\n    if (multi)\n        listRelease(multi);\n    return fixed;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4872:1#clusterManagerGetConfigSignature",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    sds signature;\n    int node_count = 0, i = 0, name_len = 0;\n    char **node_configs;\n    if (<recovery-expr>())\n        goto cleanup;\n    char *lines, *p, *line;\n    while (<recovery-expr>())\n        {\n            i = 0;\n            *p = '\\x00';\n            line = lines;\n            lines = p + 1;\n            char *nodename;\n            int tot_size = 0;\n            while (<recovery-expr>())\n                {\n                    *p = '\\x00';\n                    char *token = line;\n                    line = p + 1;\n                    if (i == 0) {\n                        nodename = token;\n                        tot_size = (p - token);\n                        name_len = tot_size++;\n                    }\n                    if (++i == 8)\n                        break;\n                }\n            if (i != 8)\n                continue;\n            if (<recovery-expr>())\n                continue;\n            int remaining = strlen(line);\n            if (remaining == 0)\n                continue;\n            char **slots;\n            int c = 0;\n            while (remaining > 0)\n                {\n                    p = strchr(line, ' ');\n                    if (<recovery-expr>())\n                        p = line + remaining;\n                    int size = (p - line);\n                    remaining -= size;\n                    tot_size += size;\n                    char *slotsdef = line;\n                    *p = '\\x00';\n                    if (remaining) {\n                        line = p + 1;\n                        remaining--;\n                    } else\n                        line = p;\n                    if (slotsdef[0] != '[') {\n                        c++;\n                        slots = <recovery-expr>()(slots, (c * sizeof(char *)));\n                        slots[c - 1] = slotsdef;\n                    }\n                }\n            if (c > 0) {\n                if (c > 1)\n                    qsort(slots, c, sizeof(char *), clusterManagerSlotCompare);\n                node_count++;\n                node_configs = <recovery-expr>()(node_configs, (node_count * sizeof(char *)));\n                tot_size += (sizeof(char) * (c - 1));\n                char *cfg = <recovery-expr>()((sizeof(char) * tot_size) + 1);\n                memcpy(cfg, nodename, name_len);\n                char *sp = cfg + name_len;\n                *(sp++) = ':';\n                for (i = 0; i < c; i++) {\n                    if (i > 0)\n                        *(sp++) = ',';\n                    int slen = strlen(slots[i]);\n                    memcpy(sp, slots[i], slen);\n                    sp += slen;\n                }\n                *(sp++) = '\\x00';\n                node_configs[node_count - 1] = cfg;\n            }\n            zfree(slots);\n        }\n    if (node_count > 0) {\n        if (node_count > 1) {\n            qsort(node_configs, node_count, sizeof(char *), clusterManagerSlotCompare);\n        }\n        signature = sdsempty();\n        for (i = 0; i < node_count; i++) {\n            if (i > 0)\n                signature = sdscatprintf(signature, \"%c\", '|');\n            signature = sdscatfmt(signature, \"%s\", node_configs[i]);\n        }\n    }\n  cleanup:\n    ;\n    if (<recovery-expr>()) {\n        for (i = 0; i < node_count; i++)\n            zfree(node_configs[i]);\n        zfree(node_configs);\n    }\n    return signature;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4599:1#clusterManagerNodeLoadInfo",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    int success = 1;\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    int getfriends = (opts & 1 << 0);\n    char *lines, *p, *line;\n    while (<recovery-expr>())\n        {\n            *p = '\\x00';\n            line = lines;\n            lines = p + 1;\n            char *name, *addr, *flags, *master_id, *ping_sent, *ping_recv, *config_epoch, *link_status;\n            ((void)link_status);\n            int i = 0;\n            while (<recovery-expr>())\n                {\n                    *p = '\\x00';\n                    char *token = line;\n                    line = p + 1;\n                    switch (i++) {\n                      case 0:\n                        name = token;\n                        break;\n                      case 1:\n                        addr = token;\n                        break;\n                      case 2:\n                        flags = token;\n                        break;\n                      case 3:\n                        master_id = token;\n                        break;\n                      case 4:\n                        ping_sent = token;\n                        break;\n                      case 5:\n                        ping_recv = token;\n                        break;\n                      case 6:\n                        config_epoch = token;\n                        break;\n                      case 7:\n                        link_status = token;\n                        break;\n                    }\n                    if (i == 8)\n                        break;\n                }\n            if (!flags) {\n                success = 0;\n                goto cleanup;\n            }\n            char *ip;\n            int port = 0, bus_port = 0;\n            if (<recovery-expr>()) {\n                success = 0;\n                goto cleanup;\n            }\n            int myself;\n            clusterManagerNode *currentNode;\n            if (myself) {\n                node->bus_port = bus_port;\n                node->flags |= 1 << 0;\n                currentNode = node;\n                clusterManagerNodeResetSlots(node);\n                if (i == 8) {\n                    int remaining = strlen(line);\n                    while (remaining > 0)\n                        {\n                            p = strchr(line, ' ');\n                            if (<recovery-expr>())\n                                p = line + remaining;\n                            remaining -= (p - line);\n                            char *slotsdef = line;\n                            *p = '\\x00';\n                            if (remaining) {\n                                line = p + 1;\n                                remaining--;\n                            } else\n                                line = p;\n                            char *dash;\n                            if (slotsdef[0] == '[') {\n                                slotsdef++;\n                                if ((p = strstr(slotsdef, \"->-\"))) {\n                                    *p = '\\x00';\n                                    p += 3;\n                                    char *closing_bracket = strchr(p, ']');\n                                    if (closing_bracket)\n                                        *closing_bracket = '\\x00';\n                                    sds slot = sdsnew(slotsdef);\n                                    sds dst = sdsnew(p);\n                                    node->migrating_count += 2;\n                                    node->migrating = <recovery-expr>()(node->migrating, (node->migrating_count * sizeof(sds)));\n                                    node->migrating[node->migrating_count - 2] = slot;\n                                    node->migrating[node->migrating_count - 1] = dst;\n                                } else if ((p = strstr(slotsdef, \"-<-\"))) {\n                                    *p = '\\x00';\n                                    p += 3;\n                                    char *closing_bracket = strchr(p, ']');\n                                    if (closing_bracket)\n                                        *closing_bracket = '\\x00';\n                                    sds slot = sdsnew(slotsdef);\n                                    sds src = sdsnew(p);\n                                    node->importing_count += 2;\n                                    node->importing = <recovery-expr>()(node->importing, (node->importing_count * sizeof(sds)));\n                                    node->importing[node->importing_count - 2] = slot;\n                                    node->importing[node->importing_count - 1] = src;\n                                }\n                            } else if (<recovery-expr>()) {\n                                p = dash;\n                                int start, stop;\n                                *p = '\\x00';\n                                start = atoi(slotsdef);\n                                stop = atoi(p + 1);\n                                node->slots_count += (stop - (start - 1));\n                                while (start <= stop)\n                                    <recovery-expr>(node)[start++] = 1;\n                            } else if (p > slotsdef) {\n                                <recovery-expr>(node)[atoi(slotsdef)] = 1;\n                                node->slots_count++;\n                            }\n                        }\n                }\n                node->dirty = 0;\n            } else if (!getfriends) {\n                if (!(node->flags & 1 << 0))\n                    continue;\n                else\n                    break;\n            } else {\n                currentNode = clusterManagerNewNode(sdsnew(ip), port, bus_port);\n                currentNode->flags |= 1 << 2;\n                if (<recovery-expr>())\n                    node->friends = listCreate();\n                listAddNodeTail(node->friends, currentNode);\n            }\n            if (<recovery-expr>()) {\n                if (currentNode->name)\n                    sdsfree(currentNode->name);\n                currentNode->name = sdsnew(name);\n            }\n            if (<recovery-expr>())\n                freeClusterManagerNodeFlags(currentNode->flags_str);\n            currentNode->flags_str = listCreate();\n            int flag_len;\n            while ((flag_len = strlen(flags)) > 0)\n                {\n                    sds flag;\n                    char *fp = strchr(flags, ',');\n                    if (fp) {\n                        *fp = '\\x00';\n                        flag = sdsnew(flags);\n                        flags = fp + 1;\n                    } else {\n                        flag = sdsnew(flags);\n                        flags += flag_len;\n                    }\n                    if (strcmp(flag, \"noaddr\") == 0)\n                        currentNode->flags |= 1 << 3;\n                    else if (strcmp(flag, \"disconnected\") == 0)\n                        currentNode->flags |= 1 << 4;\n                    else if (strcmp(flag, \"fail\") == 0)\n                        currentNode->flags |= 1 << 5;\n                    else if (strcmp(flag, \"slave\") == 0) {\n                        currentNode->flags |= 1 << 1;\n                        if (<recovery-expr>()) {\n                            if (currentNode->replicate)\n                                sdsfree(currentNode->replicate);\n                            currentNode->replicate = sdsnew(master_id);\n                        }\n                    }\n                    listAddNodeTail(currentNode->flags_str, flag);\n                }\n            if (<recovery-expr>())\n                <recovery-expr>(currentNode) = atoll(config_epoch);\n            if (<recovery-expr>())\n                <recovery-expr>(currentNode) = atoll(ping_sent);\n            if (<recovery-expr>())\n                <recovery-expr>(currentNode) = atoll(ping_recv);\n            if (!getfriends && myself)\n                break;\n        }\n  cleanup:\n    ;\n    return success;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4992:1#clusterManagerGetDisconnectedLinks",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    list *links;\n    if (<recovery-expr>())\n        goto cleanup;\n    links = listCreate();\n    char *lines, *p, *line;\n    while (<recovery-expr>())\n        {\n            int i = 0;\n            *p = '\\x00';\n            line = lines;\n            lines = p + 1;\n            char *nodename, *addr, *flags, *link_status;\n            while (<recovery-expr>())\n                {\n                    *p = '\\x00';\n                    char *token = line;\n                    line = p + 1;\n                    if (i == 0)\n                        nodename = token;\n                    else if (i == 1)\n                        addr = token;\n                    else if (i == 2)\n                        flags = token;\n                    else if (i == 7)\n                        link_status = token;\n                    else if (i == 8)\n                        break;\n                    i++;\n                }\n            if (i == 7)\n                link_status = line;\n            if (<recovery-expr>())\n                continue;\n            if (<recovery-expr>())\n                continue;\n            int disconnected;\n            int handshaking;\n            if (disconnected || handshaking) {\n                clusterManagerLink *link = <recovery-expr>()(sizeof (*link));\n                link->node_name = sdsnew(nodename);\n                link->node_addr = sdsnew(addr);\n                link->connected = 0;\n                link->handshaking = handshaking;\n                listAddNodeTail(links, link);\n            }\n        }\n  cleanup:\n    ;\n    return links;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4508:1#clusterManagerFlushNodeConfig",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    if (!node->dirty)\n        return 0;\n    int is_err = 0, success = 1;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n            }\n            success = 0;\n            goto cleanup;\n        }\n    } else {\n        int added = clusterManagerAddSlots(node, err);\n        if (<recovery-expr>())\n            success = 0;\n    }\n    node->dirty = 0;\n  cleanup:\n    ;\n    return success;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3999:1#clusterManagerSetSlot",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    if (<recovery-expr>()) {\n        if (err)\n            *err = zstrdup(\"CLUSTER SETSLOT failed to run\");\n        return 0;\n    }\n    int success = 1;\n    if (<recovery-expr>()) {\n        success = 0;\n        if (<recovery-expr>()) {\n        } else\n            ;\n        ;\n        goto cleanup;\n    }\n  cleanup:\n    ;\n    return success;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3905:1#clusterManagerAddSlots",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    void *_reply;\n    int success = 1;\n    int argc = node->slots_count + 2;\n    sds *argv = <recovery-expr>()(argc * sizeof (*argv));\n    argv[0] = \"CLUSTER\";\n    argv[1] = \"ADDSLOTS\";\n    int i, argv_idx = 2;\n    for (i = 0; i < 16384; i++) {\n        if (argv_idx >= argc)\n            break;\n        if (<recovery-expr>(node)[i]) {\n            argv[argv_idx] = sdsfromlonglong((long long)i);\n            argv_idx++;\n        }\n    }\n    if (argv_idx == 2) {\n        success = 0;\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n  cleanup:\n    ;\n    if (<recovery-expr>()) {\n        for (i = 2; i < argc; i++)\n            sdsfree(argv[i]);\n        zfree(argv);\n    }\n    return success;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3457:1#clusterManagerNodeIsEmpty",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    int is_empty = 1;\n    if (<recovery-expr>())\n        return 0;\n    if (<recovery-expr>()) {\n        is_empty = 0;\n        goto result;\n    }\n    if (<recovery-expr>()) {\n        is_empty = 0;\n        goto result;\n    }\n    long known_nodes;\n    is_empty = (known_nodes == 1);\n  result:\n    ;\n    return is_empty;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4122:1#clusterManagerCompareKeysValues",
            "gotos": 3,
            "labels": 1,
            "body": "{\n    static const char *hash_zero = \"0000000000000000000000000000000000000000\";\n    char **argv;\n    argv[0] = \"DEBUG\";\n    argv[1] = \"DIGEST-VALUE\";\n    int success = 0;\n    void *_reply1, *_reply2;\n    if (!success)\n        goto cleanup;\n    if (!success)\n        goto cleanup;\n    if (<recovery-expr>()) {\n        ;\n        success = 0;\n    }\n    if (<recovery-expr>()) {\n        ;\n        success = 0;\n    }\n    if (!success)\n        goto cleanup;\n  cleanup:\n    ;\n    zfree(argv);\n    return success;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3296:1#clusterManagerExecTransaction",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int success;\n    if (success) {\n        if (<recovery-expr>()) {\n            success = 0;\n            goto cleanup;\n        }\n    }\n  cleanup:\n    ;\n    return success;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4184:1#clusterManagerMigrateKeysInReply",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    char **argv;\n    int c = (replace ? 8 : 7);\n    if (config.conn_info.auth)\n        c += 2;\n    if (config.conn_info.user)\n        c += 1;\n    char portstr[255];\n    char timeoutstr[255];\n    snprintf(portstr, 10, \"%d\", target->port);\n    snprintf(timeoutstr, 10, \"%d\", timeout);\n    argv[0] = \"MIGRATE\";\n    argv[1] = target->ip;\n    argv[2] = portstr;\n    argv[3] = \"\";\n    argv[4] = \"0\";\n    argv[5] = timeoutstr;\n    if (replace) {\n    }\n    if (config.conn_info.auth) {\n        if (config.conn_info.user) {\n        } else {\n        }\n    }\n    if (dots)\n        dots[<recovery-expr>()->elements] = '\\x00';\n    void *_reply;\n    int success;\n    if (!success)\n        goto cleanup;\n  cleanup:\n    zfree(argv);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4775:1#clusterManagerLoadInfoFromNode",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    if (<recovery-expr>()) {\n        freeClusterManagerNode(node);\n        return 0;\n    }\n    char *e;\n    if (!clusterManagerNodeIsCluster(node, &e)) {\n        clusterManagerPrintNotClusterNodeError(node, e);\n        if (e)\n            zfree(e);\n        freeClusterManagerNode(node);\n        return 0;\n    }\n    if (!clusterManagerNodeLoadInfo(node, 1 << 0, &e)) {\n        if (e) {\n            clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (node)->ip, (node)->port, (e));\n            ;\n            zfree(e);\n        }\n        freeClusterManagerNode(node);\n        return 0;\n    }\n    listIter li;\n    listNode *ln;\n    if (<recovery-expr>()) {\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            freeClusterManagerNode((clusterManagerNode *)ln->value);\n        listRelease(cluster_manager.nodes);\n    }\n    cluster_manager.nodes = listCreate();\n    listAddNodeTail(cluster_manager.nodes, node);\n    if (<recovery-expr>()) {\n        listRewind(node->friends, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *friend = ln->value;\n                if (!friend->ip || !friend->port)\n                    goto invalid_friend;\n                if (!<recovery-expr>(friend) && !clusterManagerNodeConnect(friend))\n                    goto invalid_friend;\n                if (clusterManagerNodeLoadInfo(friend, 0, &e)) {\n                    if (friend->flags & (1 << 3 | 1 << 4 | 1 << 5)) {\n                        goto invalid_friend;\n                    }\n                    listAddNodeTail(cluster_manager.nodes, friend);\n                } else {\n                    clusterManagerLog(3, \"[ERR] Unable to load info for node %s:%d\\n\", friend->ip, friend->port);\n                    goto invalid_friend;\n                }\n                continue;\n              invalid_friend:\n                if (!(friend->flags & 1 << 1))\n                    cluster_manager.unreachable_masters++;\n                freeClusterManagerNode(friend);\n            }\n        listRelease(node->friends);\n    }\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (<recovery-expr>()) {\n                clusterManagerNode *master = clusterManagerNodeByName(n->replicate);\n                if (<recovery-expr>()) {\n                    clusterManagerLog(2, \"*** WARNING: %s:%d claims to be slave of unknown node ID %s.\\n\", n->ip, n->port, n->replicate);\n                } else\n                    master->replicas_count++;\n            }\n        }\n    return 1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6130:1#clusterManagerCommandCreate",
            "gotos": 6,
            "labels": 2,
            "body": "{\n    int i, j, success = 1;\n    cluster_manager.nodes = listCreate();\n    for (i = 0; i < argc; i++) {\n        char *addr = argv[i];\n        char *ip;\n        int port = 0;\n        if (<recovery-expr>()) {\n            return 0;\n        }\n        clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n        if (!clusterManagerNodeConnect(node)) {\n            freeClusterManagerNode(node);\n            return 0;\n        }\n        char *err;\n        if (!clusterManagerNodeIsCluster(node, &err)) {\n            clusterManagerPrintNotClusterNodeError(node, err);\n            if (err)\n                zfree(err);\n            freeClusterManagerNode(node);\n            return 0;\n        }\n        if (!clusterManagerNodeLoadInfo(node, 0, &err)) {\n            if (err) {\n                clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (node)->ip, (node)->port, (err));\n                ;\n                zfree(err);\n            }\n            freeClusterManagerNode(node);\n            return 0;\n        }\n        if (!clusterManagerNodeIsEmpty(node, &err)) {\n            clusterManagerPrintNotEmptyNodeError(node, err);\n            if (err)\n                zfree(err);\n            freeClusterManagerNode(node);\n            return 0;\n        }\n        listAddNodeTail(cluster_manager.nodes, node);\n    }\n    int node_len = cluster_manager.nodes->len;\n    int replicas = config.cluster_manager_command.replicas;\n    int masters_count = ((node_len) / ((replicas) + 1));\n    if (masters_count < 3) {\n        clusterManagerLog(3, \"*** ERROR: Invalid configuration for cluster creation.\\n*** Redis Cluster requires at least 3 master nodes.\\n*** This is not possible with %d nodes and %d replicas per node.\", node_len, replicas);\n        clusterManagerLog(3, \"\\n*** At least %d nodes are required.\\n\", 3 * (replicas + 1));\n        return 0;\n    }\n    clusterManagerLog(1, \">>> Performing hash slots allocation on %d nodes...\\n\", node_len);\n    int interleaved_len = 0, ip_count = 0;\n    clusterManagerNode **interleaved = <recovery-expr>()(node_len * sizeof (**interleaved));\n    char **ips = <recovery-expr>()(node_len * sizeof(char *));\n    clusterManagerNodeArray *ip_nodes = <recovery-expr>()(node_len * sizeof (*ip_nodes));\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            int found = 0;\n            for (i = 0; i < ip_count; i++) {\n                char *ip = ips[i];\n                if (!strcmp(ip, n->ip)) {\n                    found = 1;\n                    break;\n                }\n            }\n            if (!found) {\n                ips[ip_count++] = n->ip;\n            }\n            clusterManagerNodeArray *node_array = &(ip_nodes[i]);\n            if (<recovery-expr>())\n                clusterManagerNodeArrayInit(node_array, node_len);\n            clusterManagerNodeArrayAdd(node_array, n);\n        }\n    while (interleaved_len < node_len)\n        {\n            for (i = 0; i < ip_count; i++) {\n                clusterManagerNodeArray *node_array = &(ip_nodes[i]);\n                if (node_array->count > 0) {\n                    clusterManagerNode *n;\n                    clusterManagerNodeArrayShift(node_array, &n);\n                    interleaved[interleaved_len++] = n;\n                }\n            }\n        }\n    clusterManagerNode **masters = interleaved;\n    interleaved += masters_count;\n    interleaved_len -= masters_count;\n    float slots_per_node = 16384 / (float)masters_count;\n    long first = 0;\n    float cursor = 0.F;\n    for (i = 0; i < masters_count; i++) {\n        clusterManagerNode *master = masters[i];\n        long last = lround(cursor + slots_per_node - 1);\n        if (last > 16384 || i == (masters_count - 1))\n            last = 16384 - 1;\n        if (last < first)\n            last = first;\n        printf(\"Master[%d] -> Slots %ld - %ld\\n\", i, first, last);\n        master->slots_count = 0;\n        for (j = first; j <= last; j++) {\n            <recovery-expr>(master)[j] = 1;\n            master->slots_count++;\n        }\n        master->dirty = 1;\n        first = last + 1;\n        cursor += slots_per_node;\n    }\n    clusterManagerNode *first_node = interleaved[0];\n    for (i = 0; i < (interleaved_len - 1); i++)\n        interleaved[i] = interleaved[i + 1];\n    interleaved[interleaved_len - 1] = first_node;\n    int assign_unused = 0, available_count = interleaved_len;\n  assign_replicas:\n    for (i = 0; i < masters_count; i++) {\n        clusterManagerNode *master = masters[i];\n        int assigned_replicas = 0;\n        while (assigned_replicas < replicas)\n            {\n                if (available_count == 0)\n                    break;\n                clusterManagerNode *found, *slave;\n                int firstNodeIdx = -1;\n                for (j = 0; j < interleaved_len; j++) {\n                    clusterManagerNode *n = interleaved[j];\n                    if (<recovery-expr>())\n                        continue;\n                    if (strcmp(n->ip, master->ip)) {\n                        found = n;\n                        break;\n                    }\n                    if (firstNodeIdx < 0)\n                        firstNodeIdx = j;\n                }\n                if (found)\n                    slave = found;\n                else if (firstNodeIdx >= 0) {\n                    slave = interleaved[firstNodeIdx];\n                    interleaved_len -= (firstNodeIdx + 1);\n                    interleaved += (firstNodeIdx + 1);\n                }\n                if (<recovery-expr>()) {\n                    assigned_replicas++;\n                    available_count--;\n                    if (slave->replicate)\n                        sdsfree(slave->replicate);\n                    slave->replicate = sdsnew(master->name);\n                    slave->dirty = 1;\n                } else\n                    break;\n                printf(\"Adding replica %s:%d to %s:%d\\n\", slave->ip, slave->port, master->ip, master->port);\n                if (assign_unused)\n                    break;\n            }\n    }\n    if (!assign_unused && available_count > 0) {\n        assign_unused = 1;\n        printf(\"Adding extra replicas...\\n\");\n        goto assign_replicas;\n    }\n    for (i = 0; i < ip_count; i++) {\n        clusterManagerNodeArray *node_array = ip_nodes + i;\n        clusterManagerNodeArrayReset(node_array);\n    }\n    clusterManagerOptimizeAntiAffinity(ip_nodes, ip_count);\n    clusterManagerShowNodes();\n    int ignore_force = 0;\n    if (confirmWithYes(\"Can I set the above configuration?\", ignore_force)) {\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n                char *err;\n                int flushed = clusterManagerFlushNodeConfig(node, &err);\n                if (!flushed && node->dirty && !node->replicate) {\n                    if (<recovery-expr>()) {\n                        clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (node)->ip, (node)->port, (err));\n                        ;\n                        zfree(err);\n                    }\n                    success = 0;\n                    goto cleanup;\n                } else if (<recovery-expr>())\n                    zfree(err);\n            }\n        clusterManagerLog(1, \">>> Nodes configuration updated\\n\");\n        clusterManagerLog(1, \">>> Assign a different config epoch to each node\\n\");\n        int config_epoch = 1;\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n            }\n        clusterManagerLog(1, \">>> Sending CLUSTER MEET messages to join the cluster\\n\");\n        clusterManagerNode *first;\n        char first_ip[46];\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n                if (<recovery-expr>()) {\n                    first = node;\n                    if (<recovery-expr>()) {\n                        success = 0;\n                        goto cleanup;\n                    }\n                    continue;\n                }\n                if (first->bus_port == 0 || (first->bus_port == first->port + 10000)) {\n                } else {\n                }\n                int is_err = 0;\n                if (<recovery-expr>()) {\n                    ;\n                } else {\n                    is_err = 1;\n                }\n                if (is_err) {\n                    success = 0;\n                    goto cleanup;\n                }\n            }\n        sleep(1);\n        clusterManagerWaitForClusterJoin();\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n                if (!node->dirty)\n                    continue;\n                char *err;\n                int flushed = clusterManagerFlushNodeConfig(node, &err);\n                if (!flushed && !node->replicate) {\n                    if (<recovery-expr>()) {\n                        clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (node)->ip, (node)->port, (err));\n                        ;\n                        zfree(err);\n                    }\n                    success = 0;\n                    goto cleanup;\n                } else if (<recovery-expr>()) {\n                    zfree(err);\n                }\n            }\n        listRewind(cluster_manager.nodes, &li);\n        clusterManagerNode *first_node;\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n                if (!first_node)\n                    first_node = node;\n                else\n                    freeClusterManagerNode(node);\n            }\n        listEmpty(cluster_manager.nodes);\n        if (!clusterManagerLoadInfoFromNode(first_node)) {\n            success = 0;\n            goto cleanup;\n        }\n        clusterManagerCheckCluster(0);\n    }\n  cleanup:\n    zfree(masters);\n    zfree(ips);\n    for (i = 0; i < node_len; i++) {\n        clusterManagerNodeArray *node_array = ip_nodes + i;\n        zfree((node_array)->alloc);\n    }\n    zfree(ip_nodes);\n    return success;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6578:1#clusterManagerCommandDeleteNode",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    ((void)argc);\n    int success = 1;\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    char *node_id = argv[1];\n    clusterManagerLog(1, \">>> Removing node %s from cluster %s:%d\\n\", node_id, ip, port);\n    clusterManagerNode *ref_node = clusterManagerNewNode(ip, port, 0);\n    clusterManagerNode *node;\n    if (!clusterManagerLoadInfoFromNode(ref_node))\n        return 0;\n    node = clusterManagerNodeByName(node_id);\n    if (<recovery-expr>()) {\n        clusterManagerLog(3, \"[ERR] No such node ID %s\\n\", node_id);\n        return 0;\n    }\n    if (node->slots_count != 0) {\n        clusterManagerLog(3, \"[ERR] Node %s:%d is not empty! Reshard data away and try again.\\n\", node->ip, node->port);\n        return 0;\n    }\n    clusterManagerLog(1, \">>> Sending CLUSTER FORGET messages to the cluster...\\n\");\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (n == node)\n                continue;\n            if (n->replicate && !strcasecmp(n->replicate, node_id)) {\n                clusterManagerNode *master = clusterManagerNodeWithLeastReplicas();\n                clusterManagerLog(1, \">>> %s:%d as replica of %s:%d\\n\", n->ip, n->port, master->ip, master->port);\n                if (!success)\n                    return 0;\n            }\n            if (!success)\n                return 0;\n        }\n    clusterManagerLog(1, \">>> Sending CLUSTER RESET SOFT to the deleted node.\\n\");\n    return success;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6645:1#clusterManagerCommandInfo",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    clusterManagerShowClusterInfo();\n    return 1;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6423:1#clusterManagerCommandAddNode",
            "gotos": 12,
            "labels": 2,
            "body": "{\n    int success = 1;\n    char *ref_ip, *ip;\n    int ref_port = 0, port = 0;\n    if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &ref_ip, &ref_port))\n        goto invalid_args;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerLog(1, \">>> Adding node %s:%d to cluster %s:%d\\n\", ip, port, ref_ip, ref_port);\n    clusterManagerNode *refnode = clusterManagerNewNode(ref_ip, ref_port, 0);\n    if (!clusterManagerLoadInfoFromNode(refnode))\n        return 0;\n    if (!clusterManagerCheckCluster(0))\n        return 0;\n    clusterManagerNode *master_node;\n    if (config.cluster_manager_command.flags & 1 << 1) {\n        char *master_id = config.cluster_manager_command.master_id;\n        if (<recovery-expr>()) {\n            master_node = clusterManagerNodeByName(master_id);\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \"[ERR] No such master ID %s\\n\", master_id);\n                return 0;\n            }\n        } else {\n            master_node = clusterManagerNodeWithLeastReplicas();\n            printf(\"Automatically selected master %s:%d\\n\", master_node->ip, master_node->port);\n        }\n    }\n    clusterManagerNode *new_node = clusterManagerNewNode(ip, port, 0);\n    int added = 0;\n    if (!clusterManagerNodeConnect(new_node)) {\n        clusterManagerLog(3, \"[ERR] Sorry, can't connect to node %s:%d\\n\", ip, port);\n        success = 0;\n        goto cleanup;\n    }\n    char *err;\n    if (!(success = clusterManagerNodeIsCluster(new_node, &err))) {\n        clusterManagerPrintNotClusterNodeError(new_node, err);\n        if (err)\n            zfree(err);\n        goto cleanup;\n    }\n    if (!clusterManagerNodeLoadInfo(new_node, 0, &err)) {\n        if (err) {\n            clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (new_node)->ip, (new_node)->port, (err));\n            ;\n            zfree(err);\n        }\n        success = 0;\n        goto cleanup;\n    }\n    if (!(success = clusterManagerNodeIsEmpty(new_node, &err))) {\n        clusterManagerPrintNotEmptyNodeError(new_node, err);\n        if (err)\n            zfree(err);\n        goto cleanup;\n    }\n    clusterManagerNode *first = ((cluster_manager.nodes)->head)->value;\n    listAddNodeTail(cluster_manager.nodes, new_node);\n    added = 1;\n    if (!master_node) {\n        clusterManagerLog(1, \">>> Getting functions from cluster\\n\");\n        if (<recovery-expr>()) {\n            clusterManagerLog(1, \">>> Failed retrieving Functions from the cluster, skip this step as Redis version do not support function command (error = '%s')\\n\", err ? err : \"NULL reply\");\n            if (err)\n                zfree(err);\n        } else {\n            clusterManagerLog(1, \">>> Send FUNCTION LIST to %s:%d to verify there is no functions in it\\n\", ip, port);\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \">>> Failed on CLUSTER LIST (error = '%s')\\r\\n\", err ? err : \"NULL reply\");\n                if (err)\n                    zfree(err);\n                success = 0;\n                goto cleanup;\n            }\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \">>> New node already contains functions and can not be added to the cluster. Use FUNCTION FLUSH and try again.\\r\\n\");\n                success = 0;\n                goto cleanup;\n            }\n            clusterManagerLog(1, \">>> Send FUNCTION RESTORE to %s:%d\\n\", ip, port);\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \">>> Failed loading functions to the new node (error = '%s')\\r\\n\", err ? err : \"NULL reply\");\n                if (err)\n                    zfree(err);\n                success = 0;\n                goto cleanup;\n            }\n        }\n    }\n    clusterManagerLog(1, \">>> Send CLUSTER MEET to node %s:%d to make it join the cluster.\\n\", ip, port);\n    char first_ip[46];\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    if (first->bus_port == 0 || (first->bus_port == first->port + 10000)) {\n    } else {\n    }\n    if (<recovery-expr>())\n        goto cleanup;\n    if (master_node) {\n        sleep(1);\n        clusterManagerWaitForClusterJoin();\n        clusterManagerLog(1, \">>> Configure node as replica of %s:%d.\\n\", master_node->ip, master_node->port);\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    clusterManagerLog(4, \"[OK] New node added correctly.\\n\");\n  cleanup:\n    if (!added && new_node)\n        freeClusterManagerNode(new_node);\n    return success;\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6658:1#clusterManagerCommandCheck",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    clusterManagerShowClusterInfo();\n    return clusterManagerCheckCluster(0);\n  invalid_args:\n    ;\n    return 0;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3579:1#clusterManagerOptimizeAntiAffinity",
            "gotos": 1,
            "labels": 1,
            "body": "{\n    clusterManagerNode **offenders;\n    int score;\n    if (score == 0)\n        goto cleanup;\n    clusterManagerLog(1, \">>> Trying to optimize slaves allocation for anti-affinity\\n\");\n    int node_len = cluster_manager.nodes->len;\n    int maxiter = 500 * node_len;\n    while (maxiter > 0)\n        {\n            int offending_len = 0;\n            if (<recovery-expr>()) {\n                zfree(offenders);\n            }\n            score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count, &offenders, &offending_len);\n            if (score == 0 || offending_len == 0)\n                break;\n            int rand_idx = rand() % offending_len;\n            clusterManagerNode *first = offenders[rand_idx], *second;\n            clusterManagerNode **other_replicas = <recovery-expr>()((node_len - 1) * sizeof (*other_replicas));\n            int other_replicas_count = 0;\n            listIter li;\n            listNode *ln;\n            listRewind(cluster_manager.nodes, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    if (<recovery-expr>())\n                        other_replicas[other_replicas_count++] = n;\n                }\n            if (other_replicas_count == 0) {\n                zfree(other_replicas);\n                break;\n            }\n            rand_idx = rand() % other_replicas_count;\n            second = other_replicas[rand_idx];\n            char *first_master = first->replicate, *second_master = second->replicate;\n            first->replicate = second_master , first->dirty = 1;\n            second->replicate = first_master , second->dirty = 1;\n            int new_score;\n            if (new_score > score) {\n                first->replicate = first_master;\n                second->replicate = second_master;\n            }\n            zfree(other_replicas);\n            maxiter--;\n        }\n    char *msg;\n    int perfect = (score == 0);\n    int log_level = (perfect ? 4 : 2);\n    if (perfect)\n        msg = \"[OK] Perfect anti-affinity obtained!\";\n    else if (score >= 10000)\n        msg = (\"[WARNING] Some slaves are in the same host as their master\");\n    else\n        msg = (\"[WARNING] Some slaves of the same master are in the same host\");\n    clusterManagerLog(log_level, \"%s\\n\", msg);\n  cleanup:\n    zfree(offenders);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4267:1#clusterManagerMigrateKeysInSlot",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    int success = 1;\n    int do_fix = config.cluster_manager_command.flags & 1 << 0;\n    int do_replace = config.cluster_manager_command.flags & 1 << 6;\n    while (1)\n        {\n            char *dots;\n            if (!success)\n                return 0;\n            if (<recovery-expr>()) {\n                success = 0;\n                if (<recovery-expr>()) {\n                    clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (source)->ip, (source)->port, (*err));\n                    ;\n                }\n                goto next;\n            }\n            if (<recovery-expr>()) {\n                break;\n            }\n            if (<recovery-expr>())\n                goto next;\n            if (<recovery-expr>()) {\n                int is_busy;\n                int not_served = 0;\n                if (!is_busy) {\n                    char *get_owner_err;\n                    clusterManagerNode *served_by = clusterManagerGetSlotOwner(source, slot, &get_owner_err);\n                    if (!served_by) {\n                        if (<recovery-expr>())\n                            not_served = 1;\n                        else {\n                            clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (source)->ip, (source)->port, (get_owner_err));\n                            ;\n                            zfree(get_owner_err);\n                        }\n                    }\n                }\n                if (is_busy || not_served) {\n                    if (do_fix && not_served) {\n                        clusterManagerLog(2, \"*** Slot was not served, setting owner to node %s:%d.\\n\", target->ip, target->port);\n                    }\n                    if (is_busy) {\n                        clusterManagerLog(2, \"\\n*** Target key exists\\n\");\n                        if (!do_replace) {\n                            clusterManagerLog(2, \"*** Checking key values on both nodes...\\n\");\n                            list *diffs = listCreate();\n                            if (!success) {\n                                clusterManagerLog(3, \"*** Value check failed!\\n\");\n                                listRelease(diffs);\n                                goto next;\n                            }\n                            if (((diffs)->len) > 0) {\n                                success = 0;\n                                clusterManagerLog(3, \"*** Found %d key(s) in both source node and target node having different values.\\n    Source node: %s:%d\\n    Target node: %s:%d\\n    Keys(s):\\n\", ((diffs)->len), source->ip, source->port, target->ip, target->port);\n                                listIter dli;\n                                listNode *dln;\n                                listRewind(diffs, &dli);\n                                while (<recovery-expr>())\n                                    {\n                                        char *k = dln->value;\n                                        clusterManagerLog(3, \"    - %s\\n\", k);\n                                    }\n                                clusterManagerLog(3, \"Please fix the above key(s) manually and try again or relaunch the command \\nwith --cluster-replace option to force key overriding.\\n\");\n                                listRelease(diffs);\n                                goto next;\n                            }\n                            listRelease(diffs);\n                        }\n                        clusterManagerLog(2, \"*** Replacing target keys...\\n\");\n                    }\n                } else\n                    success = 0;\n                if (!success) {\n                    if (<recovery-expr>()) {\n                        if (err) {\n                        }\n                        printf(\"\\n\");\n                        ;\n                    }\n                    goto next;\n                }\n            }\n            if (verbose) {\n                printf(\"%s\", dots);\n            }\n          next:\n            ;\n            if (dots)\n                zfree(dots);\n            if (!success)\n                break;\n        }\n    return success;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#5407:1#clusterManagerFixOpenSlot",
            "gotos": 18,
            "labels": 2,
            "body": "{\n    int force_fix = config.cluster_manager_command.flags & 1 << 10;\n    if (cluster_manager.unreachable_masters > 0 && !force_fix) {\n        clusterManagerLog(2, \"*** Fixing open slots with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\\n\", cluster_manager.unreachable_masters);\n        exit(1);\n    }\n    clusterManagerLog(1, \">>> Fixing open slot %d\\n\", slot);\n    int success = 1;\n    list *owners = listCreate();\n    list *migrating = listCreate();\n    list *importing = listCreate();\n    sds migrating_str = sdsempty();\n    sds importing_str = sdsempty();\n    clusterManagerNode *owner;\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (n->flags & 1 << 1)\n                continue;\n            if (<recovery-expr>(n)[slot]) {\n                listAddNodeTail(owners, n);\n            } else {\n                if (<recovery-expr>()) {\n                    clusterManagerLog(2, \"*** Found keys about slot %d in non-owner node %s:%d!\\n\", slot, n->ip, n->port);\n                    listAddNodeTail(owners, n);\n                }\n                if (!success)\n                    goto cleanup;\n            }\n        }\n    if (((owners)->len) == 1)\n        owner = ((owners)->head)->value;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (n->flags & 1 << 1)\n                continue;\n            int is_migrating = 0, is_importing = 0;\n            if (n->migrating) {\n                for (int i = 0; i < n->migrating_count; i += 2) {\n                    sds migrating_slot = n->migrating[i];\n                    if (atoi(migrating_slot) == slot) {\n                        char *sep = (((migrating)->len) == 0 ? \"\" : \",\");\n                        migrating_str = sdscatfmt(migrating_str, \"%s%s:%u\", sep, n->ip, n->port);\n                        listAddNodeTail(migrating, n);\n                        is_migrating = 1;\n                        break;\n                    }\n                }\n            }\n            if (!is_migrating && n->importing) {\n                for (int i = 0; i < n->importing_count; i += 2) {\n                    sds importing_slot = n->importing[i];\n                    if (atoi(importing_slot) == slot) {\n                        char *sep = (((importing)->len) == 0 ? \"\" : \",\");\n                        importing_str = sdscatfmt(importing_str, \"%s%s:%u\", sep, n->ip, n->port);\n                        listAddNodeTail(importing, n);\n                        is_importing = 1;\n                        break;\n                    }\n                }\n            }\n            if (!is_migrating && !is_importing && n != owner) {\n                if (<recovery-expr>()) {\n                    clusterManagerLog(2, \"*** Found keys about slot %d in node %s:%d!\\n\", slot, n->ip, n->port);\n                    char *sep = (((importing)->len) == 0 ? \"\" : \",\");\n                    importing_str = sdscatfmt(importing_str, \"%s%s:%u\", sep, n->ip, n->port);\n                    listAddNodeTail(importing, n);\n                }\n                if (!success)\n                    goto cleanup;\n            }\n        }\n    if (<recovery-expr>()(migrating_str) > 0)\n        printf(\"Set as migrating in: %s\\n\", migrating_str);\n    if (<recovery-expr>()(importing_str) > 0)\n        printf(\"Set as importing in: %s\\n\", importing_str);\n    if (<recovery-expr>()) {\n        clusterManagerLog(1, \">>> No single clear owner for the slot, selecting an owner by # of keys...\\n\");\n        if (<recovery-expr>()) {\n            clusterManagerLog(3, \"[ERR] Can't select a slot owner. Impossible to fix.\\n\");\n            success = 0;\n            goto cleanup;\n        }\n        clusterManagerLog(2, \"*** Configuring %s:%d as the slot owner\\n\", owner->ip, owner->port);\n        success = clusterManagerClearSlotStatus(owner, slot);\n        if (!success)\n            goto cleanup;\n        success = clusterManagerSetSlotOwner(owner, slot, 0);\n        if (!success)\n            goto cleanup;\n        <recovery-expr>(owner)[slot] = 1;\n        clusterManagerRemoveNodeFromList(migrating, owner);\n        clusterManagerRemoveNodeFromList(importing, owner);\n    }\n    if (((owners)->len) > 1) {\n        listRewind(owners, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n == owner)\n                    continue;\n                success = clusterManagerDelSlot(n, slot, 1);\n                if (!success)\n                    goto cleanup;\n                <recovery-expr>(n)[slot] = 0;\n                if (!success)\n                    goto cleanup;\n                if (!success)\n                    goto cleanup;\n                clusterManagerRemoveNodeFromList(importing, n);\n                listAddNodeTail(importing, n);\n                clusterManagerRemoveNodeFromList(migrating, n);\n            }\n    }\n    int move_opts = 1 << 7;\n    if (((migrating)->len) == 1 && ((importing)->len) == 1) {\n        clusterManagerNode *src = ((migrating)->head)->value;\n        clusterManagerNode *dst = ((importing)->head)->value;\n        clusterManagerLog(1, \">>> Case 1: Moving slot %d from %s:%d to %s:%d\\n\", slot, src->ip, src->port, dst->ip, dst->port);\n        move_opts |= 1 << 2;\n    } else if (((migrating)->len) == 0 && ((importing)->len) > 0) {\n        clusterManagerLog(1, \">>> Case 2: Moving all the %d slot keys to its owner %s:%d\\n\", slot, owner->ip, owner->port);\n        move_opts |= 1 << 1;\n        listRewind(importing, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n == owner)\n                    continue;\n                if (!success)\n                    goto cleanup;\n                clusterManagerLog(1, \">>> Setting %d as STABLE in %s:%d\\n\", slot, n->ip, n->port);\n                success = clusterManagerClearSlotStatus(n, slot);\n                if (!success)\n                    goto cleanup;\n            }\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n == owner)\n                    continue;\n                if (n->flags & 1 << 1)\n                    continue;\n                if (!success)\n                    goto cleanup;\n            }\n    } else if (((migrating)->len) == 1 && ((importing)->len) > 1) {\n        int try_to_fix = 1;\n        clusterManagerNode *src = ((migrating)->head)->value;\n        clusterManagerNode *dst;\n        sds target_id;\n        for (int i = 0; i < src->migrating_count; i += 2) {\n            sds migrating_slot = src->migrating[i];\n            if (atoi(migrating_slot) == slot) {\n                target_id = src->migrating[i + 1];\n                break;\n            }\n        }\n        listIter li;\n        listNode *ln;\n        listRewind(importing, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                int count = clusterManagerCountKeysInSlot(n, slot);\n                if (count > 0) {\n                    try_to_fix = 0;\n                    break;\n                }\n                if (strcmp(n->name, target_id) == 0)\n                    dst = n;\n            }\n        if (!try_to_fix)\n            goto unhandled_case;\n        if (<recovery-expr>()) {\n            clusterManagerLog(1, \">>> Case 3: Moving slot %d from %s:%d to %s:%d and closing it on all the other importing nodes.\\n\", slot, src->ip, src->port, dst->ip, dst->port);\n            if (!success)\n                goto cleanup;\n            listRewind(importing, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    if (dst == n)\n                        continue;\n                    success = clusterManagerClearSlotStatus(n, slot);\n                    if (!success)\n                        goto cleanup;\n                }\n        } else {\n            clusterManagerLog(1, \">>> Case 3: Closing slot %d on both migrating and importing nodes.\\n\", slot);\n            success = clusterManagerClearSlotStatus(src, slot);\n            if (!success)\n                goto cleanup;\n            listRewind(importing, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    success = clusterManagerClearSlotStatus(n, slot);\n                    if (!success)\n                        goto cleanup;\n                }\n        }\n    } else {\n        int try_to_close_slot = (((importing)->len) == 0 && ((migrating)->len) == 1);\n        if (try_to_close_slot) {\n            clusterManagerNode *n = ((migrating)->head)->value;\n            if (!owner || owner != n) {\n                if (<recovery-expr>()) {\n                }\n                if (!success)\n                    goto cleanup;\n            }\n        }\n        if (try_to_close_slot) {\n            clusterManagerNode *n = ((migrating)->head)->value;\n            clusterManagerLog(1, \">>> Case 4: Closing slot %d on %s:%d\\n\", slot, n->ip, n->port);\n            if (!success)\n                goto cleanup;\n        } else {\n          unhandled_case:\n            success = 0;\n            clusterManagerLog(3, \"[ERR] Sorry, redis-cli can't fix this slot yet (work in progress). Slot is set as migrating in %s, as importing in %s, owner is %s:%d\\n\", migrating_str, importing_str, owner->ip, owner->port);\n        }\n    }\n  cleanup:\n    listRelease(owners);\n    listRelease(migrating);\n    listRelease(importing);\n    sdsfree(migrating_str);\n    sdsfree(importing_str);\n    return success;\n}\n"
        }
    ],
    "total": 230,
    "visited": 26
}
