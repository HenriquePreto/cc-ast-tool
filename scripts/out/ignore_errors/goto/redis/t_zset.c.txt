{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c#1837:1#zremrangeGenericCommand",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    robj *key = c->argv[1];\n    robj *zobj;\n    int keyremoved = 0;\n    unsigned long deleted = 0;\n    zrangespec range;\n    zlexrangespec lexrange;\n    long start, end, llen;\n    char *notify_type;\n    if (rangetype == ZRANGE_RANK) {\n        notify_type = \"zremrangebyrank\";\n        if (<recovery-expr>())\n            return;\n    } else if (rangetype == ZRANGE_SCORE) {\n        notify_type = \"zremrangebyscore\";\n        if (zslParseRange(c->argv[2], c->argv[3], &range) != 0) {\n            addReplyError(c, \"min or max is not a float\");\n            return;\n        }\n    } else if (rangetype == ZRANGE_LEX) {\n        notify_type = \"zremrangebylex\";\n        if (zslParseLexRange(c->argv[2], c->argv[3], &lexrange) != 0) {\n            addReplyError(c, \"min or max not valid string range item\");\n            return;\n        }\n    } else {\n        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c\", 1866, \"unknown rangetype %d\", (int)rangetype) , __builtin_unreachable();\n    }\n    if (<recovery-expr>())\n        goto cleanup;\n    if (rangetype == ZRANGE_RANK) {\n        llen = zsetLength(zobj);\n        if (start < 0)\n            start = llen + start;\n        if (end < 0)\n            end = llen + end;\n        if (start < 0)\n            start = 0;\n        if (start > end || start >= llen) {\n            addReply(c, shared.czero);\n            goto cleanup;\n        }\n        if (end >= llen)\n            end = llen - 1;\n    }\n    if (zobj->encoding == 11) {\n        switch (rangetype) {\n          case ZRANGE_AUTO:\n          case ZRANGE_RANK:\n            zobj->ptr = zzlDeleteRangeByRank(zobj->ptr, start + 1, end + 1, &deleted);\n            break;\n          case ZRANGE_SCORE:\n            zobj->ptr = zzlDeleteRangeByScore(zobj->ptr, &range, &deleted);\n            break;\n          case ZRANGE_LEX:\n            zobj->ptr = zzlDeleteRangeByLex(zobj->ptr, &lexrange, &deleted);\n            break;\n        }\n        if (zzlLength(zobj->ptr) == 0) {\n            dbDelete(c->db, key);\n            keyremoved = 1;\n        }\n    } else if (zobj->encoding == 7) {\n        zset *zs = zobj->ptr;\n        switch (rangetype) {\n          case ZRANGE_AUTO:\n          case ZRANGE_RANK:\n            deleted = zslDeleteRangeByRank(zs->zsl, start + 1, end + 1, zs->dict);\n            break;\n          case ZRANGE_SCORE:\n            deleted = zslDeleteRangeByScore(zs->zsl, &range, zs->dict);\n            break;\n          case ZRANGE_LEX:\n            deleted = zslDeleteRangeByLex(zs->zsl, &lexrange, zs->dict);\n            break;\n        }\n        if (htNeedsResize(zs->dict))\n            dictResize(zs->dict);\n        if (((zs->dict)->ht_used[0] + (zs->dict)->ht_used[1]) == 0) {\n            dbDelete(c->db, key);\n            keyremoved = 1;\n        }\n    } else {\n        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c\", 1927, \"Unknown sorted set encoding\") , __builtin_unreachable();\n    }\n    if (deleted) {\n        signalModifiedKey(c, c->db, key);\n        notifyKeyspaceEvent((1 << 7), notify_type, key, c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent((1 << 2), \"del\", key, c->db->id);\n    }\n    server.dirty += deleted;\n    addReplyLongLong(c, deleted);\n  cleanup:\n    if (rangetype == ZRANGE_LEX)\n        zslFreeLexRange(&lexrange);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c#1666:1#zaddGenericCommand",
            "gotos": 4,
            "labels": 2,
            "body": "{\n    static char *nanerr = \"resulting score is not a number (NaN)\";\n    robj *key = c->argv[1];\n    robj *zobj;\n    sds ele;\n    double score = 0, *scores;\n    int j, elements, ch = 0;\n    int scoreidx = 0;\n    int added = 0;\n    int updated = 0;\n    int processed = 0;\n    scoreidx = 2;\n    while (scoreidx < c->argc)\n        {\n            char *opt = c->argv[scoreidx]->ptr;\n            if (!strcasecmp(opt, \"nx\"))\n                flags |= (1 << 1);\n            else if (!strcasecmp(opt, \"xx\"))\n                flags |= (1 << 2);\n            else if (!strcasecmp(opt, \"ch\"))\n                ch = 1;\n            else if (!strcasecmp(opt, \"incr\"))\n                flags |= (1 << 0);\n            else if (!strcasecmp(opt, \"gt\"))\n                flags |= (1 << 3);\n            else if (!strcasecmp(opt, \"lt\"))\n                flags |= (1 << 4);\n            else\n                break;\n            scoreidx++;\n        }\n    int incr = (flags & (1 << 0)) != 0;\n    int nx = (flags & (1 << 1)) != 0;\n    int xx = (flags & (1 << 2)) != 0;\n    int gt = (flags & (1 << 3)) != 0;\n    int lt = (flags & (1 << 4)) != 0;\n    elements = c->argc - scoreidx;\n    if (elements % 2 || !elements) {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n    elements /= 2;\n    if (nx && xx) {\n        addReplyError(c, \"XX and NX options at the same time are not compatible\");\n        return;\n    }\n    if ((gt && nx) || (lt && nx) || (gt && lt)) {\n        addReplyError(c, \"GT, LT, and/or NX options at the same time are not compatible\");\n        return;\n    }\n    if (incr && elements > 1) {\n        addReplyError(c, \"INCR option supports a single increment-element pair\");\n        return;\n    }\n    scores = <recovery-expr>()(sizeof(double) * elements);\n    for (j = 0; j < elements; j++) {\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    zobj = lookupKeyWrite(c->db, key);\n    if (checkType(c, zobj, 3))\n        goto cleanup;\n    if (<recovery-expr>()) {\n        if (xx)\n            goto reply_to_client;\n        if (<recovery-expr>(server) == 0 || <recovery-expr>(server) < <recovery-expr>()(c->argv[scoreidx + 1]->ptr)) {\n            zobj = createZsetObject();\n        } else {\n            zobj = createZsetListpackObject();\n        }\n        dbAdd(c->db, key, zobj);\n    }\n    for (j = 0; j < elements; j++) {\n        double newscore;\n        score = scores[j];\n        int retflags = 0;\n        ele = c->argv[scoreidx + 1 + j * 2]->ptr;\n        int retval = zsetAdd(zobj, score, ele, flags, &retflags, &newscore);\n        if (retval == 0) {\n            addReplyError(c, nanerr);\n            goto cleanup;\n        }\n        if (retflags & (1 << 2))\n            added++;\n        if (retflags & (1 << 3))\n            updated++;\n        if (!(retflags & (1 << 0)))\n            processed++;\n        score = newscore;\n    }\n    server.dirty += (added + updated);\n  reply_to_client:\n    if (incr) {\n        if (processed)\n            addReplyDouble(c, score);\n        else\n            addReplyNull(c);\n    } else {\n        addReplyLongLong(c, ch ? added + updated : added);\n    }\n  cleanup:\n    zfree(scores);\n    if (added || updated) {\n        signalModifiedKey(c, c->db, key);\n        notifyKeyspaceEvent((1 << 7), incr ? \"zincr\" : \"zadd\", key, c->db->id);\n    }\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c#3571:1#zrangeGenericCommand",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    client *c = handler->client;\n    robj *key = c->argv[argc_start];\n    robj *zobj;\n    zrangespec range;\n    zlexrangespec lexrange;\n    int minidx = argc_start + 1;\n    int maxidx = argc_start + 2;\n    long opt_start = 0;\n    long opt_end = 0;\n    int opt_withscores = 0;\n    long opt_offset = 0;\n    long opt_limit = -1;\n    for (int j = argc_start + 3; j < c->argc; j++) {\n        int leftargs = c->argc - j - 1;\n        if (!store && !strcasecmp(c->argv[j]->ptr, \"withscores\")) {\n            opt_withscores = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr, \"limit\") && leftargs >= 2) {\n            if (<recovery-expr>()) {\n                return;\n            }\n            j += 2;\n        } else if (direction == ZRANGE_DIRECTION_AUTO && !strcasecmp(c->argv[j]->ptr, \"rev\")) {\n            direction = ZRANGE_DIRECTION_REVERSE;\n        } else if (rangetype == ZRANGE_AUTO && !strcasecmp(c->argv[j]->ptr, \"bylex\")) {\n            rangetype = ZRANGE_LEX;\n        } else if (rangetype == ZRANGE_AUTO && !strcasecmp(c->argv[j]->ptr, \"byscore\")) {\n            rangetype = ZRANGE_SCORE;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n    if (direction == ZRANGE_DIRECTION_AUTO)\n        direction = ZRANGE_DIRECTION_FORWARD;\n    if (rangetype == ZRANGE_AUTO)\n        rangetype = ZRANGE_RANK;\n    if (opt_limit != -1 && rangetype == ZRANGE_RANK) {\n        addReplyError(c, \"syntax error, LIMIT is only supported in combination with either BYSCORE or BYLEX\");\n        return;\n    }\n    if (opt_withscores && rangetype == ZRANGE_LEX) {\n        addReplyError(c, \"syntax error, WITHSCORES not supported in combination with BYLEX\");\n        return;\n    }\n    if (direction == ZRANGE_DIRECTION_REVERSE && ((ZRANGE_SCORE == rangetype) || (ZRANGE_LEX == rangetype))) {\n        int tmp = maxidx;\n        maxidx = minidx;\n        minidx = tmp;\n    }\n    switch (rangetype) {\n      case ZRANGE_AUTO:\n      case ZRANGE_RANK:\n        if (<recovery-expr>()) {\n            return;\n        }\n        break;\n      case ZRANGE_SCORE:\n        if (zslParseRange(c->argv[minidx], c->argv[maxidx], &range) != 0) {\n            addReplyError(c, \"min or max is not a float\");\n            return;\n        }\n        break;\n      case ZRANGE_LEX:\n        if (zslParseLexRange(c->argv[minidx], c->argv[maxidx], &lexrange) != 0) {\n            addReplyError(c, \"min or max not valid string range item\");\n            return;\n        }\n        break;\n    }\n    if (opt_withscores || store) {\n        zrangeResultHandlerScoreEmissionEnable(handler);\n    }\n    zobj = lookupKeyRead(c->db, key);\n    if (<recovery-expr>()) {\n        if (store) {\n            handler->beginResultEmission(handler, -1);\n            handler->finalizeResultEmission(handler, 0);\n        } else {\n            addReply(c, shared.emptyarray);\n        }\n        goto cleanup;\n    }\n    if (checkType(c, zobj, 3))\n        goto cleanup;\n    switch (rangetype) {\n      case ZRANGE_AUTO:\n      case ZRANGE_RANK:\n        genericZrangebyrankCommand(handler, zobj, opt_start, opt_end, opt_withscores || store, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n      case ZRANGE_SCORE:\n        genericZrangebyscoreCommand(handler, &range, zobj, opt_offset, opt_limit, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n      case ZRANGE_LEX:\n        genericZrangebylexCommand(handler, &lexrange, zobj, opt_withscores || store, opt_offset, opt_limit, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n    }\n  cleanup:\n    if (rangetype == ZRANGE_LEX) {\n        zslFreeLexRange(&lexrange);\n    }\n}\n"
        }
    ],
    "total": 191,
    "visited": 3
}
