{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/replication.c#723:1#masterTryPartialResynchronization",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    long long psync_len;\n    char *master_replid = c->argv[1]->ptr;\n    char buf[128];\n    int buflen;\n    if (strcasecmp(master_replid, server.replid) && (strcasecmp(master_replid, server.replid2) || psync_offset > server.second_replid_offset)) {\n        if (master_replid[0] != '?') {\n            if (strcasecmp(master_replid, server.replid) && strcasecmp(master_replid, server.replid2)) {\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"Partial resynchronization not accepted: Replication ID mismatch (Replica asked for '%s', my replication IDs are '%s' and '%s')\", master_replid, server.replid, server.replid2);\n                } while (0);\n            } else {\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"Partial resynchronization not accepted: Requested offset for second ID was %lld, but I can reply up to %lld\", psync_offset, server.second_replid_offset);\n                } while (0);\n            }\n        } else {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Full resync requested by replica %s\", replicationGetSlaveName(c));\n            } while (0);\n        }\n        goto need_full_resync;\n    }\n    if (!server.repl_backlog || psync_offset < server.repl_backlog->offset || psync_offset > (server.repl_backlog->offset + server.repl_backlog->histlen)) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Unable to partial resync with replica %s for lack of backlog (Replica request was: %lld).\", replicationGetSlaveName(c), psync_offset);\n        } while (0);\n        if (psync_offset > server.master_repl_offset) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Warning: replica %s tried to PSYNC with an offset that is greater than the master replication offset.\", replicationGetSlaveName(c));\n            } while (0);\n        }\n        goto need_full_resync;\n    }\n    <recovery-expr>(c) |= (1 << 0);\n    c->replstate = 9;\n    c->repl_ack_time = <recovery-expr>(server);\n    c->repl_start_cmd_stream_on_ack = 0;\n    listAddNodeTail(server.slaves, c);\n    if (c->slave_capa & (1 << 1)) {\n        buflen = snprintf(buf, sizeof (buf), \"+CONTINUE %s\\r\\n\", server.replid);\n    } else {\n        buflen = snprintf(buf, sizeof (buf), \"+CONTINUE\\r\\n\");\n    }\n    if (<recovery-expr>()(c->conn, buf, buflen) != buflen) {\n        freeClientAsync(c);\n        return 0;\n    }\n    psync_len = addReplyReplicationBacklog(c, psync_offset);\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.\", replicationGetSlaveName(c), psync_len, psync_offset);\n    } while (0);\n    refreshGoodSlavesCount();\n    return 0;\n  need_full_resync:\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/replication.c#2568:1#syncWithMaster",
            "gotos": 20,
            "labels": 3,
            "body": "{\n    char tmpfile[256], *err;\n    int dfd = -1, maxtries = 5;\n    int psync_result;\n    if (server.repl_state == REPL_STATE_NONE) {\n        connClose(conn);\n        return;\n    }\n    if (connGetState(conn) != CONN_STATE_CONNECTED) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Error condition on socket for SYNC: %s\", connGetLastError(conn));\n        } while (0);\n        goto error;\n    }\n    if (server.repl_state == REPL_STATE_CONNECTING) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Non blocking connect for SYNC fired the event.\");\n        } while (0);\n        connSetReadHandler(conn, syncWithMaster);\n        server.repl_state = REPL_STATE_RECEIVE_PING_REPLY;\n        if (err)\n            goto write_error;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_PING_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] != '+' && strncmp(err, \"-NOAUTH\", 7) != 0 && strncmp(err, \"-NOPERM\", 7) != 0 && strncmp(err, \"-ERR operation not permitted\", 28) != 0) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Error reply to PING from master: '%s'\", err);\n            } while (0);\n            sdsfree(err);\n            goto error;\n        } else {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Master replied to PING, replication can continue...\");\n            } while (0);\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_SEND_HANDSHAKE;\n    }\n    if (server.repl_state == REPL_STATE_SEND_HANDSHAKE) {\n        if (server.masterauth) {\n            char *args[3];\n            int lens;\n            int argc = 1;\n            if (server.masteruser) {\n                args[argc] = server.masteruser;\n                <recovery-expr>()[argc] = strlen(server.masteruser);\n                argc++;\n            }\n            args[argc] = server.masterauth;\n            <recovery-expr>()[argc] = <recovery-expr>()(server.masterauth);\n            argc++;\n            err = sendCommandArgv(conn, argc, args, <recovery-expr>());\n            if (err)\n                goto write_error;\n        }\n        {\n            int port;\n            if (server.slave_announce_port)\n                port = server.slave_announce_port;\n            else if (server.tls_replication && server.tls_port)\n                port = server.tls_port;\n            else\n                port = server.port;\n            sds portstr = sdsfromlonglong(port);\n            sdsfree(portstr);\n            if (err)\n                goto write_error;\n        }\n        if (server.slave_announce_ip) {\n            if (err)\n                goto write_error;\n        }\n        if (err)\n            goto write_error;\n        server.repl_state = REPL_STATE_RECEIVE_AUTH_REPLY;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_AUTH_REPLY && !server.masterauth)\n        server.repl_state = REPL_STATE_RECEIVE_PORT_REPLY;\n    if (server.repl_state == REPL_STATE_RECEIVE_AUTH_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] == '-') {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Unable to AUTH to MASTER: %s\", err);\n            } while (0);\n            sdsfree(err);\n            goto error;\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_RECEIVE_PORT_REPLY;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_PORT_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] == '-') {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"(Non critical) Master does not understand REPLCONF listening-port: %s\", err);\n            } while (0);\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_RECEIVE_IP_REPLY;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_IP_REPLY && !server.slave_announce_ip)\n        server.repl_state = REPL_STATE_RECEIVE_CAPA_REPLY;\n    if (server.repl_state == REPL_STATE_RECEIVE_IP_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] == '-') {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"(Non critical) Master does not understand REPLCONF ip-address: %s\", err);\n            } while (0);\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_RECEIVE_CAPA_REPLY;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_CAPA_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] == '-') {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"(Non critical) Master does not understand REPLCONF capa: %s\", err);\n            } while (0);\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_SEND_PSYNC;\n    }\n    if (server.repl_state == REPL_STATE_SEND_PSYNC) {\n        if (slaveTryPartialResynchronization(conn, 0) == 0) {\n            err = sdsnew(\"Write error sending the PSYNC command.\");\n            abortFailover(\"Write error to failover target\");\n            goto write_error;\n        }\n        server.repl_state = REPL_STATE_RECEIVE_PSYNC_REPLY;\n        return;\n    }\n    if (server.repl_state != REPL_STATE_RECEIVE_PSYNC_REPLY) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"syncWithMaster(): state machine error, state should be RECEIVE_PSYNC but is %d\", server.repl_state);\n        } while (0);\n        goto error;\n    }\n    psync_result = slaveTryPartialResynchronization(conn, 1);\n    if (psync_result == 1)\n        return;\n    if (server.failover_state == FAILOVER_IN_PROGRESS) {\n        if (psync_result == 2 || psync_result == 3) {\n            clearFailoverState();\n        } else {\n            abortFailover(\"Failover target rejected psync request\");\n            return;\n        }\n    }\n    if (psync_result == 5)\n        goto error;\n    if (psync_result == 2) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"MASTER <-> REPLICA sync: Master accepted a Partial Resynchronization.\");\n        } while (0);\n        if (server.supervised_mode == 2) {\n            redisCommunicateSystemd(\"STATUS=MASTER <-> REPLICA sync: Partial Resynchronization accepted. Ready to accept connections in read-write mode.\\n\");\n        }\n        return;\n    }\n    if (psync_result == 4) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Retrying with SYNC...\");\n        } while (0);\n        if (<recovery-expr>()(conn, \"SYNC\\r\\n\", 6, server.repl_syncio_timeout * 1000) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto error;\n        }\n    }\n    if (!useDisklessLoad()) {\n        while (maxtries--)\n            {\n                snprintf(tmpfile, 256, \"temp-%d.%ld.rdb\", (int)<recovery-expr>(server), (long)getpid());\n                if (dfd != -1)\n                    break;\n                sleep(1);\n            }\n        if (dfd == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto error;\n        }\n        server.repl_transfer_tmpfile = zstrdup(tmpfile);\n        server.repl_transfer_fd = dfd;\n    }\n    if (connSetReadHandler(conn, readSyncBulkPayload) == -1) {\n        char conninfo[32];\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto error;\n    }\n    server.repl_state = REPL_STATE_TRANSFER;\n    <recovery-expr>(server) = -1;\n    <recovery-expr>(server) = 0;\n    <recovery-expr>(server) = 0;\n    <recovery-expr>(server) = <recovery-expr>(server);\n    return;\n  no_response_error:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Master did not respond to command during SYNC handshake\");\n    } while (0);\n  error:\n    if (dfd != -1)\n        close(dfd);\n    connClose(conn);\n    if (server.repl_transfer_fd != -1)\n        close(server.repl_transfer_fd);\n    if (server.repl_transfer_tmpfile)\n        zfree(server.repl_transfer_tmpfile);\n    server.repl_transfer_fd = -1;\n    server.repl_state = REPL_STATE_CONNECT;\n    return;\n  write_error:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Sending command to master in replication handshake: %s\", err);\n    } while (0);\n    sdsfree(err);\n    goto error;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/replication.c#1817:1#readSyncBulkPayload",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    char buf[16384];\n    int use_diskless_load = useDisklessLoad();\n    redisDb *diskless_load_tempDb;\n    functionsLibCtx *temp_functions_lib_ctx;\n    int empty_db_flags = server.repl_slave_lazy_flush ? (1 << 0) : 0;\n    static char eofmark[40];\n    static char lastbytes[40];\n    static int usemark = 0;\n    if (<recovery-expr>(server) == -1) {\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto error;\n        } else {\n        }\n        if (buf[0] == '-') {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"MASTER aborted replication with an error: %s\", buf + 1);\n            } while (0);\n            goto error;\n        } else if (buf[0] == '\\x00') {\n            <recovery-expr>(server) = <recovery-expr>(server);\n            return;\n        } else if (buf[0] != '$') {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?\", buf);\n            } while (0);\n            goto error;\n        }\n        if (strncmp(buf + 1, \"EOF:\", 4) == 0 && strlen(buf + 5) >= 40) {\n            usemark = 1;\n            memcpy(eofmark, buf + 5, 40);\n            memset(lastbytes, 0, 40);\n            <recovery-expr>(server) = 0;\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"MASTER <-> REPLICA sync: receiving streamed RDB from master with EOF %s\", use_diskless_load ? \"to parser\" : \"to disk\");\n            } while (0);\n        } else {\n            usemark = 0;\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"MASTER <-> REPLICA sync: receiving %lld bytes from master %s\", (long long)<recovery-expr>(server), use_diskless_load ? \"to parser\" : \"to disk\");\n            } while (0);\n        }\n        return;\n    }\n    if (!use_diskless_load) {\n        if (usemark) {\n        } else {\n        }\n        if (<recovery-expr>()) {\n            if (connGetState(conn) == CONN_STATE_CONNECTED) {\n                return;\n            }\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            cancelReplicationHandshake(1);\n            return;\n        }\n        int eof_reached = 0;\n        if (usemark) {\n            if (<recovery-expr>()) {\n            } else {\n                int rem;\n            }\n            if (memcmp(lastbytes, eofmark, 40) == 0)\n                eof_reached = 1;\n        }\n        <recovery-expr>(server) = <recovery-expr>(server);\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto error;\n        }\n        if (usemark && eof_reached) {\n            if (ftruncate(server.repl_transfer_fd, <recovery-expr>(server) - 40) == -1) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                goto error;\n            }\n        }\n        if (<recovery-expr>(server) >= <recovery-expr>(server) + (1024 * 1024 * 8)) {\n        }\n        if (!usemark) {\n            if (<recovery-expr>(server) == <recovery-expr>(server))\n                eof_reached = 1;\n        }\n        if (!eof_reached)\n            return;\n    }\n    if (server.aof_state != 0)\n        stopAppendOnly();\n    if (server.child_type == 1) {\n        if (!use_diskless_load) {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Replica is about to load the RDB file received from the master, but there is a pending RDB child running. Killing process %ld and removing its temp file to avoid any race\", (long)<recovery-expr>(server));\n            } while (0);\n        }\n        killRDBChild();\n    }\n    if (use_diskless_load && server.repl_diskless_load == 2) {\n        diskless_load_tempDb = disklessLoadInitTempDb();\n        temp_functions_lib_ctx = functionsLibCtxCreate();\n    } else {\n        replicationAttachToNewMaster();\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"MASTER <-> REPLICA sync: Flushing old data\");\n        } while (0);\n        emptyData(-1, empty_db_flags, replicationEmptyDbCallback);\n    }\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"MASTER <-> REPLICA sync: Loading DB in memory\");\n    } while (0);\n    rdbSaveInfo rsi = {-1, 0, \"0000000000000000000000000000000000000000\", -1};\n    if (use_diskless_load) {\n        rio rdb;\n        redisDb *dbarray;\n        functionsLibCtx *functions_lib_ctx;\n        int asyncLoading = 0;\n        if (server.repl_diskless_load == 2) {\n            if (memcmp(server.replid, server.master_replid, 40) == 0) {\n                asyncLoading = 1;\n            }\n            dbarray = diskless_load_tempDb;\n            functions_lib_ctx = temp_functions_lib_ctx;\n        } else {\n            dbarray = server.db;\n            functions_lib_ctx = functionsLibCtxGetCurrent();\n            functionsLibCtxClear(functions_lib_ctx);\n        }\n        <recovery-expr>()(&rdb, conn, <recovery-expr>(server));\n        connBlock(conn);\n        connRecvTimeout(conn, server.repl_timeout * 1000);\n        startLoading(<recovery-expr>(server), (1 << 1), asyncLoading);\n        int loadingFailed = 0;\n        rdbLoadingCtx loadingCtx = {.dbarray = dbarray, .functions_lib_ctx = functions_lib_ctx};\n        if (rdbLoadRioWithLoadingCtx(&rdb, (1 << 1), &rsi, &loadingCtx) != 0) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Failed trying to load the MASTER synchronization DB from socket, check server logs.\");\n            } while (0);\n            loadingFailed = 1;\n        } else if (usemark) {\n            if (!<recovery-expr>()(&rdb, buf, 40) || memcmp(buf, eofmark, 40) != 0) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Replication stream EOF marker is broken\");\n                } while (0);\n                loadingFailed = 1;\n            }\n        }\n        if (loadingFailed) {\n            stopLoading(0);\n            cancelReplicationHandshake(1);\n            if (server.repl_diskless_load == 2) {\n                disklessLoadDiscardTempDb(diskless_load_tempDb);\n                functionsLibCtxFree(temp_functions_lib_ctx);\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"MASTER <-> REPLICA sync: Discarding temporary DB in background\");\n                } while (0);\n            } else {\n                emptyData(-1, empty_db_flags, replicationEmptyDbCallback);\n            }\n            return;\n        }\n        if (server.repl_diskless_load == 2) {\n            replicationAttachToNewMaster();\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"MASTER <-> REPLICA sync: Swapping active DB with loaded DB\");\n            } while (0);\n            swapMainDbWithTempDb(diskless_load_tempDb);\n            functionsLibCtxSwapWithCurrent(temp_functions_lib_ctx);\n            disklessLoadDiscardTempDb(diskless_load_tempDb);\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"MASTER <-> REPLICA sync: Discarding old DB in background\");\n            } while (0);\n        }\n        server.dirty++;\n        stopLoading(1);\n        connNonBlock(conn);\n        connRecvTimeout(conn, 0);\n    } else {\n        if (fsync(server.repl_transfer_fd) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            cancelReplicationHandshake(1);\n            return;\n        }\n        int old_rdb_fd;\n        if (rename(server.repl_transfer_tmpfile, server.rdb_filename) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            cancelReplicationHandshake(1);\n            if (old_rdb_fd != -1)\n                close(old_rdb_fd);\n            return;\n        }\n        if (old_rdb_fd != -1)\n            bioCreateCloseJob(old_rdb_fd, 0);\n        if (fsyncFileDir(server.rdb_filename) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            cancelReplicationHandshake(1);\n            return;\n        }\n        if (rdbLoad(server.rdb_filename, &rsi, (1 << 1)) != 0) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Failed trying to load the MASTER synchronization DB from disk, check server logs.\");\n            } while (0);\n            cancelReplicationHandshake(1);\n            if (server.rdb_del_sync_files && allPersistenceDisabled()) {\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"Removing the RDB file obtained from the master. This replica has persistence disabled\");\n                } while (0);\n                bg_unlink(server.rdb_filename);\n            }\n            return;\n        }\n        if (server.rdb_del_sync_files && allPersistenceDisabled()) {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Removing the RDB file obtained from the master. This replica has persistence disabled\");\n            } while (0);\n            bg_unlink(server.rdb_filename);\n        }\n        zfree(server.repl_transfer_tmpfile);\n        close(server.repl_transfer_fd);\n        server.repl_transfer_fd = -1;\n    }\n    replicationCreateMasterClient(server.repl_transfer_s, rsi.repl_stream_db);\n    server.repl_state = REPL_STATE_CONNECTED;\n    <recovery-expr>(server) = 0;\n    memcpy(server.replid, server.master->replid, sizeof (server.replid));\n    server.master_repl_offset = server.master->reploff;\n    clearReplicationId2();\n    if (<recovery-expr>())\n        createReplicationBacklog();\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"MASTER <-> REPLICA sync: Finished with success\");\n    } while (0);\n    if (server.supervised_mode == 2) {\n        redisCommunicateSystemd(\"STATUS=MASTER <-> REPLICA sync: Finished with success. Ready to accept connections in read-write mode.\\n\");\n    }\n    if (usemark)\n        replicationSendAck();\n    if (server.aof_enabled)\n        restartAOFAfterSYNC();\n    return;\n  error:\n    cancelReplicationHandshake(1);\n    return;\n}\n"
        }
    ],
    "total": 134,
    "visited": 3
}
