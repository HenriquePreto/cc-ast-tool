{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#2873:1#rdbLoadRioWithLoadingCtx",
            "gotos": 19,
            "labels": 1,
            "body": "{\n    int type, rdbver;\n    redisDb *db = rdb_loading_ctx->dbarray + 0;\n    char buf[1024];\n    int error;\n    long long empty_keys_skipped = 0;\n    rdb->update_cksum = rdbLoadProgressCallback;\n    <recovery-expr>(rdb) = <recovery-expr>(server);\n    if (<recovery-expr>()(rdb, buf, 9) == 0)\n        goto eoferr;\n    buf[9] = '\\x00';\n    if (memcmp(buf, \"REDIS\", 5) != 0) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Wrong signature trying to load DB from file\");\n        } while (0);\n        return -1;\n    }\n    rdbver = atoi(buf + 5);\n    if (rdbver < 1 || rdbver > 10) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Can't handle RDB format version %d\", rdbver);\n        } while (0);\n        return -1;\n    }\n    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();\n    long long lru_clock = LRU_CLOCK();\n    while (1)\n        {\n            sds key;\n            robj *val;\n            if ((type = rdbLoadType(rdb)) == -1)\n                goto eoferr;\n            if (type == 253) {\n                expiretime = <recovery-expr>()(rdb);\n                expiretime *= 1000;\n                if (rioGetReadError(rdb))\n                    goto eoferr;\n                continue;\n            } else if (type == 252) {\n                expiretime = rdbLoadMillisecondTime(rdb, rdbver);\n                if (rioGetReadError(rdb))\n                    goto eoferr;\n                continue;\n            } else if (type == 249) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 248) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 255) {\n                break;\n            } else if (type == 254) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>()) {\n                    do {\n                        if (((3) & 255) < server.verbosity)\n                            break;\n                        _serverLog(3, \"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\\n\", server.dbnum);\n                    } while (0);\n                    exit(1);\n                }\n                continue;\n            } else if (type == 251) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 250) {\n                robj *auxkey, *auxval;\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>()) {\n                    decrRefCount(auxkey);\n                    goto eoferr;\n                }\n                if (((char *)auxkey->ptr)[0] == '%') {\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                        _serverLog(2, \"RDB '%s': %s\", (char *)auxkey->ptr, (char *)auxval->ptr);\n                    } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"repl-stream-db\")) {\n                    if (rsi)\n                        rsi->repl_stream_db = atoi(auxval->ptr);\n                } else if (!strcasecmp(auxkey->ptr, \"repl-id\")) {\n                    if (rsi && <recovery-expr>()(auxval->ptr) == 40) {\n                        memcpy(rsi->repl_id, auxval->ptr, 40 + 1);\n                        rsi->repl_id_is_set = 1;\n                    }\n                } else if (!strcasecmp(auxkey->ptr, \"repl-offset\")) {\n                } else if (!strcasecmp(auxkey->ptr, \"lua\")) {\n                } else if (!strcasecmp(auxkey->ptr, \"redis-ver\")) {\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                        _serverLog(2, \"Loading RDB produced by version %s\", (char *)auxval->ptr);\n                    } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"ctime\")) {\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                    } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"used-mem\")) {\n                    long long usedmem;\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                        _serverLog(2, \"RDB memory usage when created %.2f Mb\", (double)usedmem / (1024 * 1024));\n                    } while (0);\n                    <recovery-expr>(server) = usedmem;\n                } else if (!strcasecmp(auxkey->ptr, \"aof-preamble\")) {\n                    long long haspreamble;\n                    if (haspreamble)\n                        do {\n                            if (((2) & 255) < server.verbosity)\n                                break;\n                            _serverLog(2, \"RDB has an AOF tail\");\n                        } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"aof-base\")) {\n                    long long isbase;\n                    if (isbase)\n                        do {\n                            if (((2) & 255) < server.verbosity)\n                                break;\n                            _serverLog(2, \"RDB is base AOF\");\n                        } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"redis-bits\")) {\n                } else {\n                    do {\n                        if (((0) & 255) < server.verbosity)\n                            break;\n                        _serverLog(0, \"Unrecognized RDB AUX field: '%s'\", (char *)auxkey->ptr);\n                    } while (0);\n                }\n                decrRefCount(auxkey);\n                decrRefCount(auxval);\n                continue;\n            } else if (type == 247) {\n                int when_opcode;\n                int when;\n                if (rioGetReadError(rdb))\n                    goto eoferr;\n                if (when_opcode != 2) {\n                    rdbReportError(0, 3030, \"bad when_opcode\");\n                    goto eoferr;\n                }\n                moduleType *mt;\n                char name[10];\n                if (<recovery-expr>()) {\n                    do {\n                        if (((3) & 255) < server.verbosity)\n                            break;\n                        _serverLog(3, \"The RDB file contains AUX module data I can't load: no matching module '%s'\", name);\n                    } while (0);\n                    exit(1);\n                } else if (<recovery-expr>()) {\n                    if (!mt->aux_load) {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"The RDB file contains module AUX data, but the module '%s' doesn't seem to support it.\", name);\n                        } while (0);\n                        exit(1);\n                    }\n                    RedisModuleIO io;\n                    do {\n                        io.rio = rdb;\n                        io.type = mt;\n                        <recovery-expr>(io) = 0;\n                        io.error = 0;\n                        io.dbid = -1;\n                    } while (0);\n                    int rc;\n                    if (io.ctx) {\n                        moduleFreeContext(io.ctx);\n                        zfree(io.ctx);\n                    }\n                    if (rc != 0 || io.error) {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n                        } while (0);\n                        goto eoferr;\n                    }\n                    if (<recovery-expr>()) {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                        } while (0);\n                        goto eoferr;\n                    }\n                    continue;\n                } else {\n                    robj *aux = rdbLoadCheckModuleValue(rdb, name);\n                    decrRefCount(aux);\n                    continue;\n                }\n            } else if (type == 246) {\n                rdbReportError(1, 3075, \"Pre-release function format not supported.\");\n                exit(1);\n            } else if (type == 245) {\n                sds err;\n                if (rdbFunctionLoad(rdb, rdbver, rdb_loading_ctx->functions_lib_ctx, rdbflags, &err) != 0) {\n                    do {\n                        if (((3) & 255) < server.verbosity)\n                            break;\n                        _serverLog(3, \"Failed loading library, %s\", err);\n                    } while (0);\n                    sdsfree(err);\n                    goto eoferr;\n                }\n                continue;\n            }\n            if (<recovery-expr>())\n                goto eoferr;\n            val = rdbLoadObject(type, rdb, key, db->id, &error);\n            if (<recovery-expr>()) {\n                if (error == 1) {\n                    if (empty_keys_skipped++ < 10)\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"rdbLoadObject skipping empty key: %s\", key);\n                        } while (0);\n                    sdsfree(key);\n                } else {\n                    sdsfree(key);\n                    goto eoferr;\n                }\n            } else if (iAmMaster() && !(rdbflags & (1 << 0)) && expiretime != -1 && expiretime < now) {\n                if (rdbflags & (1 << 3)) {\n                    robj keyobj;\n                    do {\n                        keyobj.type = 0;\n                        keyobj.encoding = 0;\n                        keyobj.ptr = key;\n                    } while (0);\n                    robj *argv[2];\n                    argv[0] = server.lazyfree_lazy_expire ? shared.unlink : shared.del;\n                    argv[1] = &keyobj;\n                }\n                sdsfree(key);\n                decrRefCount(val);\n                server.rdb_last_load_keys_expired++;\n            } else {\n                robj keyobj;\n                do {\n                    keyobj.type = 0;\n                    keyobj.encoding = 0;\n                    keyobj.ptr = key;\n                } while (0);\n                int added = dbAddRDBLoad(db, key, val);\n                server.rdb_last_load_keys_loaded++;\n                if (!added) {\n                    if (rdbflags & (1 << 2)) {\n                        dbSyncDelete(db, &keyobj);\n                        dbAddRDBLoad(db, key, val);\n                    } else {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"RDB has duplicated key '%s' in DB %d\", key, db->id);\n                        } while (0);\n                        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c\", 3150, \"Duplicated key found in RDB file\") , __builtin_unreachable();\n                    }\n                }\n                if (expiretime != -1) {\n                }\n                objectSetLRUOrLFU(val, lfu_freq, lru_idle, lru_clock, 1000);\n                moduleNotifyKeyspaceEvent((1 << 12), \"loaded\", &keyobj, db->id);\n            }\n            if (server.key_load_delay)\n                debugDelay(server.key_load_delay);\n            expiretime = -1;\n            lfu_freq = -1;\n            lru_idle = -1;\n        }\n    if (rdbver >= 5) {\n        if (<recovery-expr>())\n            goto eoferr;\n        if (server.rdb_checksum && !server.skip_checksum_validation) {\n            ((void)(0));\n            if (<recovery-expr>()) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"RDB file was saved with checksum disabled: no check performed.\");\n                } while (0);\n            } else if (<recovery-expr>()) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                rdbReportError(1, 3191, \"RDB CRC error\");\n                return -1;\n            }\n        }\n    }\n    if (empty_keys_skipped) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Done loading RDB, keys loaded: %lld, keys expired: %lld, empty keys skipped: %lld.\", server.rdb_last_load_keys_loaded, server.rdb_last_load_keys_expired, empty_keys_skipped);\n        } while (0);\n    } else {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Done loading RDB, keys loaded: %lld, keys expired: %lld.\", server.rdb_last_load_keys_loaded, server.rdb_last_load_keys_expired);\n        } while (0);\n    }\n    return 0;\n  eoferr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Short read or OOM loading DB. Unrecoverable error, aborting now.\");\n    } while (0);\n    rdbReportError(0, 3215, \"Unexpected EOF reading RDB file\");\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#2822:1#rdbFunctionLoad",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    ((void)ver);\n    sds error;\n    sds final_payload;\n    int res = -1;\n    if (<recovery-expr>()) {\n        error = sdsnew(\"Failed loading library payload\");\n        goto done;\n    }\n    if (lib_ctx) {\n        sds library_name;\n        if (!(library_name = functionsCreateWithLibraryCtx(final_payload, rdbflags & (1 << 2), &error, lib_ctx))) {\n            if (!error) {\n                error = sdsnew(\"Failed creating the library\");\n            }\n            goto done;\n        }\n        sdsfree(library_name);\n    }\n    res = 0;\n  done:\n    if (final_payload)\n        sdsfree(final_payload);\n    if (error) {\n        if (err) {\n            *err = error;\n        } else {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Failed creating function, %s\", error);\n            } while (0);\n            sdsfree(error);\n        }\n    }\n    return res;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1750:1#rdbLoadObject",
            "gotos": 11,
            "labels": 1,
            "body": "{\n    robj *o, *ele, *dec;\n    unsigned int i;\n    if (error)\n        *error = 2;\n    int deep_integrity_validation = server.sanitize_dump_payload == 1;\n    if (server.sanitize_dump_payload == 2) {\n        int skip = <recovery-expr>(server) || (server.current_client && (<recovery-expr>(server.current_client) & (1 << 1)));\n        if (!skip && server.current_client && server.current_client->user)\n            skip = !!(<recovery-expr>(server.current_client->user) & (1 << 4));\n        deep_integrity_validation = !skip;\n    }\n    if (rdbtype == 0) {\n        o = tryObjectEncoding(o);\n    } else if (rdbtype == 1) {\n        if (<recovery-expr>())\n            goto emptykey;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_listpack_size, server.list_compress_depth);\n        while (<recovery-expr>())\n            {\n                if (<recovery-expr>()) {\n                    decrRefCount(o);\n                }\n                dec = getDecodedObject(ele);\n                int len(int *);\n                <recovery-expr>()(o->ptr, dec->ptr, <recovery-expr>());\n                decrRefCount(dec);\n                decrRefCount(ele);\n            }\n    } else if (rdbtype == 2) {\n        if (<recovery-expr>())\n            goto emptykey;\n        int max_entries(int *);\n        if (<recovery-expr>() >= 1 << 30)\n            <recovery-expr>() = 1 << 30;\n        if (<recovery-expr>()) {\n            o = createSetObject();\n            if (<recovery-expr>()) {\n                decrRefCount(o);\n            }\n        } else {\n            o = createIntsetObject();\n        }\n    } else if (rdbtype == 5 || rdbtype == 3) {\n        int maxelelen(int *), totelelen(int *);\n        zset *zs;\n        if (<recovery-expr>())\n            goto emptykey;\n        o = createZsetObject();\n        zs = o->ptr;\n        if (<recovery-expr>()) {\n            decrRefCount(o);\n        }\n        while (<recovery-expr>())\n            {\n                sds sdsele;\n                double score;\n                zskiplistNode *znode;\n                if (<recovery-expr>()) {\n                    decrRefCount(o);\n                }\n                if (rdbtype == 5) {\n                    if (rdbLoadBinaryDoubleValue(rdb, &score) == -1) {\n                        decrRefCount(o);\n                        sdsfree(sdsele);\n                    }\n                } else {\n                    if (rdbLoadDoubleValue(rdb, &score) == -1) {\n                        decrRefCount(o);\n                        sdsfree(sdsele);\n                    }\n                }\n                if (isnan(score)) {\n                    rdbReportError(1, 1904, \"Zset with NAN score detected\");\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                }\n                if (<recovery-expr>()(sdsele) > <recovery-expr>())\n                    <recovery-expr>() = <recovery-expr>()(sdsele);\n                <recovery-expr>() += <recovery-expr>()(sdsele);\n                znode = zslInsert(zs->zsl, score, sdsele);\n                if (dictAdd(zs->dict, sdsele, &znode->score) != 0) {\n                    rdbReportError(1, 1916, \"Duplicate zset fields detected\");\n                    decrRefCount(o);\n                }\n            }\n        if (<recovery-expr>()) {\n            zsetConvert(o, 11);\n        }\n    } else if (rdbtype == 4) {\n        int ret;\n        sds field, value;\n        dict *dupSearchDict;\n        if (<recovery-expr>())\n            goto emptykey;\n        o = createHashObject();\n        if (<recovery-expr>())\n            hashTypeConvert(o, 2);\n        else if (deep_integrity_validation) {\n            dupSearchDict = dictCreate(&hashDictType);\n        }\n        while (<recovery-expr>())\n            {\n                if (<recovery-expr>()) {\n                    decrRefCount(o);\n                    if (dupSearchDict)\n                        dictRelease(dupSearchDict);\n                }\n                if (<recovery-expr>()) {\n                    sdsfree(field);\n                    decrRefCount(o);\n                    if (dupSearchDict)\n                        dictRelease(dupSearchDict);\n                }\n                if (dupSearchDict) {\n                    sds field_dup = sdsdup(field);\n                    if (<recovery-expr>()) {\n                        rdbReportError(1, 1973, \"Hash with dup elements\");\n                        dictRelease(dupSearchDict);\n                        decrRefCount(o);\n                        sdsfree(field_dup);\n                        sdsfree(field);\n                        sdsfree(value);\n                    }\n                }\n                if (<recovery-expr>()(field) > <recovery-expr>(server) || <recovery-expr>()(value) > <recovery-expr>(server) || !lpSafeToAdd(o->ptr, <recovery-expr>()(field) + <recovery-expr>()(value))) {\n                    hashTypeConvert(o, 2);\n                    ret = dictAdd((dict *)o->ptr, field, value);\n                    if (ret == 1) {\n                        rdbReportError(1, 1991, \"Duplicate hash fields detected\");\n                        if (dupSearchDict)\n                            dictRelease(dupSearchDict);\n                        sdsfree(value);\n                        sdsfree(field);\n                        decrRefCount(o);\n                    }\n                    break;\n                }\n                o->ptr = <recovery-expr>()(o->ptr, (unsigned char *)field, <recovery-expr>()(field));\n                o->ptr = <recovery-expr>()(o->ptr, (unsigned char *)value, <recovery-expr>()(value));\n                sdsfree(field);\n                sdsfree(value);\n            }\n        if (dupSearchDict) {\n            dictRelease(dupSearchDict);\n        }\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n                decrRefCount(o);\n            }\n        }\n        while (<recovery-expr>())\n            {\n                if (<recovery-expr>()) {\n                    decrRefCount(o);\n                }\n                if (<recovery-expr>()) {\n                    sdsfree(field);\n                    decrRefCount(o);\n                }\n                ret = dictAdd((dict *)o->ptr, field, value);\n                if (ret == 1) {\n                    rdbReportError(1, 2041, \"Duplicate hash fields detected\");\n                    sdsfree(value);\n                    sdsfree(field);\n                    decrRefCount(o);\n                }\n            }\n    } else if (rdbtype == 14 || rdbtype == 18) {\n        if (<recovery-expr>())\n            goto emptykey;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_listpack_size, server.list_compress_depth);\n        while (<recovery-expr>())\n            {\n                unsigned char *lp;\n                int encoded_len(int *);\n                if (rdbtype == 18) {\n                    if (<recovery-expr>()) {\n                        decrRefCount(o);\n                    }\n                    if (<recovery-expr>()) {\n                        rdbReportError(1, 2070, \"Quicklist integrity check failed.\");\n                        decrRefCount(o);\n                    }\n                }\n                unsigned char *data = rdbGenericLoadStringObject(rdb, (1 << 1), &encoded_len);\n                if (<recovery-expr>()) {\n                    zfree(data);\n                    decrRefCount(o);\n                }\n                if (<recovery-expr>()) {\n                    <recovery-expr>()(o->ptr, data, encoded_len);\n                    continue;\n                }\n                if (rdbtype == 18) {\n                    lp = data;\n                    if (deep_integrity_validation)\n                        server.stat_dump_payload_sanitizations++;\n                    if (<recovery-expr>()) {\n                        rdbReportError(1, 2093, \"Listpack integrity check failed.\");\n                        decrRefCount(o);\n                        zfree(lp);\n                    }\n                } else {\n                    lp = lpNew(encoded_len);\n                    if (!<recovery-expr>()(data, encoded_len, 1, _ziplistEntryConvertAndValidate, &lp)) {\n                        rdbReportError(1, 2103, \"Ziplist integrity check failed.\");\n                        decrRefCount(o);\n                        zfree(data);\n                        zfree(lp);\n                    }\n                    zfree(data);\n                    lp = lpShrinkToFit(lp);\n                }\n                if (lpLength(lp) == 0) {\n                    zfree(lp);\n                    continue;\n                } else {\n                    quicklistAppendListpack(o->ptr, lp);\n                }\n            }\n        if (quicklistCount(o->ptr) == 0) {\n            decrRefCount(o);\n            goto emptykey;\n        }\n    } else if (rdbtype == 9 || rdbtype == 10 || rdbtype == 11 || rdbtype == 12 || rdbtype == 17 || rdbtype == 13 || rdbtype == 16) {\n        int encoded_len(int *);\n        unsigned char *encoded = rdbGenericLoadStringObject(rdb, (1 << 1), &encoded_len);\n        o = createObject(0, encoded);\n        switch (rdbtype) {\n          case 9:\n            if (!<recovery-expr>()(encoded, encoded_len, 1)) {\n                rdbReportError(1, 2152, \"Zipmap integrity check failed.\");\n                zfree(encoded);\n                decrRefCount(o);\n            }\n            {\n                unsigned char *lp = lpNew(0);\n                unsigned char *zi = zipmapRewind(o->ptr);\n                unsigned char *fstr, *vstr;\n                unsigned int flen, vlen;\n                unsigned int maxlen = 0;\n                dict *dupSearchDict = dictCreate(&hashDictType);\n                while (<recovery-expr>())\n                    {\n                        if (flen > maxlen)\n                            maxlen = flen;\n                        if (vlen > maxlen)\n                            maxlen = vlen;\n                        sds field = <recovery-expr>()(fstr, flen);\n                        if (<recovery-expr>()) {\n                            rdbReportError(1, 2176, \"Hash zipmap with dup elements, or big length (%u)\", flen);\n                            dictRelease(dupSearchDict);\n                            sdsfree(field);\n                            zfree(encoded);\n                            decrRefCount(o);\n                        }\n                        lp = <recovery-expr>()(lp, fstr, flen);\n                        lp = <recovery-expr>()(lp, vstr, vlen);\n                    }\n                dictRelease(dupSearchDict);\n                zfree(o->ptr);\n                o->ptr = lp;\n                o->type = 4;\n                o->encoding = 11;\n                if (hashTypeLength(o) > <recovery-expr>(server) || maxlen > <recovery-expr>(server)) {\n                    hashTypeConvert(o, 2);\n                }\n            }\n            break;\n          case 10:\n            {\n                quicklist *ql = quicklistNew(server.list_max_listpack_size, server.list_compress_depth);\n                if (!<recovery-expr>()(encoded, encoded_len, 1, _listZiplistEntryConvertAndValidate, ql)) {\n                    rdbReportError(1, 2210, \"List ziplist integrity check failed.\");\n                    zfree(encoded);\n                    decrRefCount(o);\n                    quicklistRelease(ql);\n                }\n                if (ql->len == 0) {\n                    zfree(encoded);\n                    decrRefCount(o);\n                    quicklistRelease(ql);\n                    goto emptykey;\n                }\n                zfree(encoded);\n                o->type = 1;\n                o->ptr = ql;\n                o->encoding = 9;\n                break;\n            }\n          case 11:\n            if (deep_integrity_validation)\n                server.stat_dump_payload_sanitizations++;\n            if (!<recovery-expr>()(encoded, encoded_len, deep_integrity_validation)) {\n                rdbReportError(1, 2235, \"Intset integrity check failed.\");\n                zfree(encoded);\n                decrRefCount(o);\n            }\n            o->type = 2;\n            o->encoding = 6;\n            if (<recovery-expr>()(o->ptr) > <recovery-expr>(server))\n                setTypeConvert(o, 2);\n            break;\n          case 12:\n            {\n                unsigned char *lp = lpNew(encoded_len);\n                if (!ziplistPairsConvertAndValidateIntegrity(encoded, encoded_len, &lp)) {\n                    rdbReportError(1, 2250, \"Zset ziplist integrity check failed.\");\n                    zfree(lp);\n                    zfree(encoded);\n                    decrRefCount(o);\n                }\n                zfree(o->ptr);\n                o->type = 3;\n                o->ptr = lp;\n                o->encoding = 11;\n                if (zsetLength(o) == 0) {\n                    decrRefCount(o);\n                    goto emptykey;\n                }\n                if (zsetLength(o) > <recovery-expr>(server))\n                    zsetConvert(o, 7);\n                else\n                    o->ptr = lpShrinkToFit(o->ptr);\n                break;\n            }\n          case 17:\n            if (deep_integrity_validation)\n                server.stat_dump_payload_sanitizations++;\n            if (!lpPairsValidateIntegrityAndDups(encoded, encoded_len, deep_integrity_validation)) {\n                rdbReportError(1, 2276, \"Zset listpack integrity check failed.\");\n                zfree(encoded);\n                decrRefCount(o);\n            }\n            o->type = 3;\n            o->encoding = 11;\n            if (zsetLength(o) == 0) {\n                decrRefCount(o);\n                goto emptykey;\n            }\n            if (zsetLength(o) > <recovery-expr>(server))\n                zsetConvert(o, 7);\n            break;\n          case 13:\n            {\n                unsigned char *lp = lpNew(encoded_len);\n                if (!ziplistPairsConvertAndValidateIntegrity(encoded, encoded_len, &lp)) {\n                    rdbReportError(1, 2296, \"Hash ziplist integrity check failed.\");\n                    zfree(lp);\n                    zfree(encoded);\n                    decrRefCount(o);\n                }\n                zfree(o->ptr);\n                o->ptr = lp;\n                o->type = 4;\n                o->encoding = 11;\n                if (hashTypeLength(o) == 0) {\n                    decrRefCount(o);\n                    goto emptykey;\n                }\n                if (hashTypeLength(o) > <recovery-expr>(server))\n                    hashTypeConvert(o, 2);\n                else\n                    o->ptr = lpShrinkToFit(o->ptr);\n                break;\n            }\n          case 16:\n            if (deep_integrity_validation)\n                server.stat_dump_payload_sanitizations++;\n            if (!lpPairsValidateIntegrityAndDups(encoded, encoded_len, deep_integrity_validation)) {\n                rdbReportError(1, 2322, \"Hash listpack integrity check failed.\");\n                zfree(encoded);\n                decrRefCount(o);\n            }\n            o->type = 4;\n            o->encoding = 11;\n            if (hashTypeLength(o) == 0) {\n                decrRefCount(o);\n                goto emptykey;\n            }\n            if (hashTypeLength(o) > <recovery-expr>(server))\n                hashTypeConvert(o, 2);\n            break;\n          default:\n            rdbReportError(1, 2340, \"Unknown RDB encoding type %d\", rdbtype);\n            break;\n        }\n    } else if (rdbtype == 15 || rdbtype == 19) {\n        o = createStreamObject();\n        stream *s = o->ptr;\n        if (<recovery-expr>()) {\n            rdbReportError(0, 2348, \"Stream listpacks len loading failed.\");\n            decrRefCount(o);\n        }\n        while (<recovery-expr>())\n            {\n                sds nodekey;\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2359, \"Stream master ID loading failed: invalid encoding or I/O error.\");\n                    decrRefCount(o);\n                }\n                if (<recovery-expr>()(nodekey) != sizeof(streamID)) {\n                    rdbReportError(1, 2365, \"Stream node key entry is not the size of a stream ID\");\n                    sdsfree(nodekey);\n                    decrRefCount(o);\n                }\n                int lp_size(int *);\n                unsigned char *lp = rdbGenericLoadStringObject(rdb, (1 << 1), &lp_size);\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2376, \"Stream listpacks loading failed.\");\n                    sdsfree(nodekey);\n                    decrRefCount(o);\n                }\n                if (deep_integrity_validation)\n                    server.stat_dump_payload_sanitizations++;\n                if (!streamValidateListpackIntegrity(lp, lp_size, deep_integrity_validation)) {\n                    rdbReportError(1, 2383, \"Stream listpack integrity check failed.\");\n                    sdsfree(nodekey);\n                    decrRefCount(o);\n                    zfree(lp);\n                }\n                unsigned char *first = lpFirst(lp);\n                if (<recovery-expr>()) {\n                    rdbReportError(1, 2395, \"Empty listpack inside stream\");\n                    sdsfree(nodekey);\n                    decrRefCount(o);\n                    zfree(lp);\n                }\n                int retval;\n                sdsfree(nodekey);\n                if (!retval) {\n                    rdbReportError(1, 2407, \"Listpack re-added with existing key\");\n                    decrRefCount(o);\n                    zfree(lp);\n                }\n            }\n        if (rdbtype == 19) {\n        } else {\n            <recovery-expr>(s).ms = 0;\n            <recovery-expr>(s).seq = 0;\n            <recovery-expr>(s) = <recovery-expr>(s);\n            streamGetEdgeID(s, 1, 1, &<recovery-expr>(s));\n        }\n        if (rioGetReadError(rdb)) {\n            rdbReportError(0, 2445, \"Stream object metadata loading failed.\");\n            decrRefCount(o);\n        }\n        if (<recovery-expr>(s) && !<recovery-expr>()(s->rax)) {\n            rdbReportError(1, 2451, \"Stream length inconsistent with rax entries\");\n            decrRefCount(o);\n        }\n        if (<recovery-expr>()) {\n            rdbReportError(0, 2459, \"Stream cgroup count loading failed.\");\n            decrRefCount(o);\n        }\n        while (<recovery-expr>())\n            {\n                streamID cg_id;\n                sds cgname;\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2471, \"Error reading the consumer group name from Stream\");\n                    decrRefCount(o);\n                }\n                if (rioGetReadError(rdb)) {\n                    rdbReportError(0, 2479, \"Stream cgroup ID loading failed.\");\n                    sdsfree(cgname);\n                    decrRefCount(o);\n                }\n                if (rdbtype == 19) {\n                    if (rioGetReadError(rdb)) {\n                        rdbReportError(0, 2490, \"Stream cgroup offset loading failed.\");\n                        sdsfree(cgname);\n                        decrRefCount(o);\n                    }\n                } else {\n                }\n                streamCG *cgroup;\n                if (<recovery-expr>()) {\n                    rdbReportError(1, 2502, \"Duplicated consumer group name %s\", cgname);\n                    decrRefCount(o);\n                    sdsfree(cgname);\n                }\n                sdsfree(cgname);\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2516, \"Stream PEL size loading failed.\");\n                    decrRefCount(o);\n                }\n                while (<recovery-expr>())\n                    {\n                        unsigned char rawid[1];\n                        if (<recovery-expr>()(rdb, rawid, sizeof (rawid)) == 0) {\n                            rdbReportError(0, 2523, \"Stream PEL ID loading failed.\");\n                            decrRefCount(o);\n                        }\n                        streamNACK *nack;\n                        nack->delivery_time = rdbLoadMillisecondTime(rdb, 10);\n                        if (rioGetReadError(rdb)) {\n                            rdbReportError(0, 2531, \"Stream PEL NACK loading failed.\");\n                            decrRefCount(o);\n                            streamFreeNACK(nack);\n                        }\n                        if (<recovery-expr>()) {\n                            rdbReportError(1, 2538, \"Duplicated global PEL entry loading stream consumer group\");\n                            decrRefCount(o);\n                            streamFreeNACK(nack);\n                        }\n                    }\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2549, \"Stream consumers num loading failed.\");\n                    decrRefCount(o);\n                }\n                while (<recovery-expr>())\n                    {\n                        sds cname;\n                        if (<recovery-expr>()) {\n                            rdbReportError(0, 2557, \"Error reading the consumer name from Stream group.\");\n                            decrRefCount(o);\n                        }\n                        streamConsumer *consumer;\n                        sdsfree(cname);\n                        if (!consumer) {\n                            rdbReportError(1, 2565, \"Duplicate stream consumer detected.\");\n                            decrRefCount(o);\n                        }\n                        consumer->seen_time = rdbLoadMillisecondTime(rdb, 10);\n                        if (rioGetReadError(rdb)) {\n                            rdbReportError(0, 2571, \"Stream short read reading seen time.\");\n                            decrRefCount(o);\n                        }\n                        if (<recovery-expr>()) {\n                            rdbReportError(0, 2581, \"Stream consumer PEL num loading failed.\");\n                            decrRefCount(o);\n                        }\n                        while (<recovery-expr>())\n                            {\n                                unsigned char rawid[1];\n                                if (<recovery-expr>()(rdb, rawid, sizeof (rawid)) == 0) {\n                                    rdbReportError(0, 2589, \"Stream short read reading PEL streamID.\");\n                                    decrRefCount(o);\n                                }\n                                streamNACK *nack = <recovery-expr>()(cgroup->pel, rawid, sizeof (rawid));\n                                if (nack == raxNotFound) {\n                                    rdbReportError(1, 2596, \"Consumer entry not found in group global PEL\");\n                                    decrRefCount(o);\n                                }\n                                nack->consumer = consumer;\n                                if (<recovery-expr>()) {\n                                    rdbReportError(1, 2608, \"Duplicated consumer PEL entry  loading a stream consumer group\");\n                                    decrRefCount(o);\n                                    streamFreeNACK(nack);\n                                }\n                            }\n                    }\n                if (deep_integrity_validation) {\n                    raxIterator ri_cg_pel;\n                    raxStart(&ri_cg_pel, cgroup->pel);\n                    while (raxNext(&ri_cg_pel))\n                        {\n                            streamNACK *nack = ri_cg_pel.data;\n                            if (!nack->consumer) {\n                                raxStop(&ri_cg_pel);\n                                rdbReportError(1, 2625, \"Stream CG PEL entry without consumer\");\n                                decrRefCount(o);\n                            }\n                        }\n                    raxStop(&ri_cg_pel);\n                }\n            }\n    } else if (rdbtype == 6) {\n        rdbReportError(1, 2634, \"Pre-release module format not supported\");\n    } else if (rdbtype == 7) {\n        if (rioGetReadError(rdb)) {\n            rdbReportError(0, 2639, \"Short read module id\");\n        }\n        moduleType *mt;\n        if (rdbCheckMode) {\n            char name[10];\n            return rdbLoadCheckModuleValue(rdb, name);\n        }\n        if (<recovery-expr>()) {\n            char name[10];\n            rdbReportError(1, 2653, \"The RDB file contains module data I can't load: no matching module type '%s'\", name);\n        }\n        RedisModuleIO io;\n        robj keyobj;\n        do {\n            keyobj.type = 0;\n            keyobj.encoding = 0;\n            keyobj.ptr = key;\n        } while (0);\n        do {\n            io.rio = rdb;\n            io.type = mt;\n            <recovery-expr>(io) = 0;\n            io.error = 0;\n            io.key = &keyobj;\n            io.dbid = dbid;\n        } while (0);\n        void *ptr;\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n        if (<recovery-expr>()) {\n            if (ptr) {\n                o = createModuleObject(mt, ptr);\n                decrRefCount(o);\n            }\n        }\n        if (<recovery-expr>()) {\n            rdbReportError(1, 2679, \"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", moduleTypeModuleName(mt));\n            if (ptr) {\n                o = createModuleObject(mt, ptr);\n                decrRefCount(o);\n            }\n        }\n        if (<recovery-expr>()) {\n            rdbReportError(1, 2690, \"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", moduleTypeModuleName(mt));\n        }\n        o = createModuleObject(mt, ptr);\n    } else {\n        rdbReportError(0, 2695, \"Unknown RDB encoding type %d\", rdbtype);\n    }\n    if (error)\n        *error = 0;\n    return o;\n  emptykey:\n    if (error)\n        *error = 1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1346:1#rdbSaveRio",
            "gotos": 8,
            "labels": 1,
            "body": "{\n    char magic[10];\n    long key_counter = 0;\n    int j;\n    if (server.rdb_checksum)\n        rdb->update_cksum = <recovery-expr>();\n    snprintf(magic, sizeof (magic), \"REDIS%04d\", 10);\n    if (<recovery-expr>()(rdb, magic, 9) == -1)\n        goto werr;\n    if (rdbSaveInfoAuxFields(rdb, rdbflags, rsi) == -1)\n        goto werr;\n    if (!(req & (1 << 0)) && <recovery-expr>()(rdb, (1 << 0)) == -1)\n        goto werr;\n    if (!(req & (1 << 1)) && <recovery-expr>()(rdb) == -1)\n        goto werr;\n    if (!(req & (1 << 0))) {\n        for (j = 0; j < server.dbnum; j++) {\n            if (<recovery-expr>()(rdb, j, rdbflags, &key_counter) == -1)\n                goto werr;\n        }\n    }\n    if (!(req & (1 << 0)) && <recovery-expr>()(rdb, (1 << 1)) == -1)\n        goto werr;\n    if (rdbSaveType(rdb, 255) == -1)\n        goto werr;\n    ((void)(0));\n    if (<recovery-expr>())\n        goto werr;\n    return 0;\n  werr:\n    ;\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1249:1#rdbSaveFunctions",
            "gotos": 2,
            "labels": 1,
            "body": "{\n    dict *functions = functionsLibGet();\n    dictIterator *iter = dictGetIterator(functions);\n    dictEntry *entry;\n    while ((entry = dictNext(iter)))\n        {\n            if (<recovery-expr>())\n                goto werr;\n            functionLibInfo *li = (<recovery-expr>((entry)).val);\n            if (<recovery-expr>())\n                goto werr;\n        }\n    dictReleaseIterator(iter);\n  werr:\n    dictReleaseIterator(iter);\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#384:1#rdbLoadLzfStringObject",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    int plain = flags & (1 << 1);\n    int sds = flags & (1 << 2);\n    unsigned char *c;\n    char *val;\n    if (<recovery-expr>()) {\n        do {\n            if (<recovery-expr>())\n                break;\n        } while (0);\n        goto err;\n    }\n    if (plain) {\n    } else {\n    }\n    if (!val) {\n        do {\n            if (<recovery-expr>())\n                break;\n        } while (0);\n        goto err;\n    }\n    if (<recovery-expr>())\n        goto err;\n    if (<recovery-expr>()) {\n        rdbReportError(1, 414, \"Invalid LZF compressed string\");\n        goto err;\n    }\n    zfree(c);\n    if (plain || sds) {\n        return val;\n    } else {\n        return createObject(0, val);\n    }\n  err:\n    zfree(c);\n    if (plain)\n        zfree(val);\n    else\n        sdsfree(val);\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#338:1#rdbSaveLzfBlob",
            "gotos": 4,
            "labels": 1,
            "body": "{\n    unsigned char byte;\n    byte = (3 << 6) | 3;\n    if (<recovery-expr>())\n        goto writeerr;\n    if (<recovery-expr>())\n        goto writeerr;\n    if (<recovery-expr>())\n        goto writeerr;\n    if (<recovery-expr>())\n        goto writeerr;\n  writeerr:\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1416:1#rdbSave",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    char tmpfile[256];\n    char cwd;\n    rio rdb;\n    int error = 0;\n    char *err_op;\n    snprintf(tmpfile, 256, \"temp-%d.rdb\", (int)getpid());\n    if (<recovery-expr>()) {\n        char *str_err;\n        char *cwdp;\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Failed opening the temp RDB file %s (in server root dir %s) for saving: %s\", tmpfile, cwdp ? cwdp : \"unknown\", str_err);\n        } while (0);\n        return -1;\n    }\n    startSaving(0);\n    if (server.rdb_save_incremental_fsync)\n        <recovery-expr>()(&rdb, (1024 * 1024 * 4));\n    if (rdbSaveRio(req, &rdb, &error, 0, rsi) == -1) {\n        err_op = \"rdbSaveRio\";\n        goto werr;\n    }\n    if (<recovery-expr>()) {\n        err_op = \"fflush\";\n        goto werr;\n    }\n    if (<recovery-expr>()) {\n        err_op = \"fsync\";\n        goto werr;\n    }\n    if (<recovery-expr>()) {\n        err_op = \"fclose\";\n        goto werr;\n    }\n    if (rename(tmpfile, filename) == -1) {\n        char *str_err;\n        char *cwdp;\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Error moving temp DB file %s on the final destination %s (in server root dir %s): %s\", tmpfile, filename, cwdp ? cwdp : \"unknown\", str_err);\n        } while (0);\n        unlink(tmpfile);\n        stopSaving(0);\n        return -1;\n    }\n    if (fsyncFileDir(filename) == -1) {\n        err_op = \"fsyncFileDir\";\n        goto werr;\n    }\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"DB saved on disk\");\n    } while (0);\n    server.dirty = 0;\n    server.lastbgsave_status = 0;\n    stopSaving(1);\n    return 0;\n  werr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n    } while (0);\n    unlink(tmpfile);\n    stopSaving(0);\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1186:1#rdbSaveSingleModuleAux",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    RedisModuleIO io;\n    int retval = 0;\n    do {\n        io.rio = rdb;\n        io.type = mt;\n        <recovery-expr>(io) = 0;\n        io.error = 0;\n        io.dbid = -1;\n    } while (0);\n    rio aux_save_headers_rio;\n    rioInitWithBuffer(&aux_save_headers_rio, sdsempty());\n    if (rdbSaveType(&aux_save_headers_rio, 247) == -1)\n        goto error;\n    if (<recovery-expr>()(&aux_save_headers_rio, <recovery-expr>(mt)) == -1)\n        goto error;\n    if (<recovery-expr>()(&aux_save_headers_rio, 2) == -1)\n        goto error;\n    if (<recovery-expr>()(&aux_save_headers_rio, when) == -1)\n        goto error;\n    if (mt->aux_save2) {\n        io.pre_flush_buffer = <recovery-expr>(aux_save_headers_rio).buffer.ptr;\n        mt->aux_save2(&io, when);\n        if (io.pre_flush_buffer) {\n            sdsfree(io.pre_flush_buffer);\n            return 0;\n        }\n    } else {\n        retval = <recovery-expr>()(rdb, <recovery-expr>(aux_save_headers_rio).buffer.ptr, <recovery-expr>()(<recovery-expr>(aux_save_headers_rio).buffer.ptr));\n        if (retval == -1)\n            goto error;\n        <recovery-expr>(io) += retval;\n        sdsfree(<recovery-expr>(aux_save_headers_rio).buffer.ptr);\n        mt->aux_save(&io, when);\n    }\n    retval = <recovery-expr>()(rdb, 0);\n    ((!io.pre_flush_buffer) ? (void)0 : (_serverAssert(\"!io.pre_flush_buffer\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c\", 1231) , __builtin_unreachable()));\n    if (retval == -1)\n        io.error = 1;\n    else\n        <recovery-expr>(io) += retval;\n    if (io.ctx) {\n        moduleFreeContext(io.ctx);\n        zfree(io.ctx);\n    }\n    if (io.error)\n        return -1;\n    return <recovery-expr>(io);\n  error:\n    sdsfree(<recovery-expr>(aux_save_headers_rio).buffer.ptr);\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1394:1#rdbSaveRioWithEOFMark",
            "gotos": 5,
            "labels": 1,
            "body": "{\n    char eofmark[40];\n    startSaving((1 << 1));\n    getRandomHexChars(eofmark, 40);\n    if (error)\n        *error = 0;\n    if (<recovery-expr>()(rdb, \"$EOF:\", 5) == 0)\n        goto werr;\n    if (<recovery-expr>()(rdb, eofmark, 40) == 0)\n        goto werr;\n    if (<recovery-expr>()(rdb, \"\\r\\n\", 2) == 0)\n        goto werr;\n    if (rdbSaveRio(req, rdb, error, 0, rsi) == -1)\n        goto werr;\n    if (<recovery-expr>()(rdb, eofmark, 40) == 0)\n        goto werr;\n    stopSaving(1);\n    return 0;\n  werr:\n    ;\n    stopSaving(0);\n    return -1;\n}\n"
        },
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1270:1#rdbSaveDb",
            "gotos": 6,
            "labels": 1,
            "body": "{\n    dictIterator *di;\n    dictEntry *de;\n    static long long info_updated_time = 0;\n    char *pname = (rdbflags & (1 << 0)) ? \"AOF rewrite\" : \"RDB\";\n    redisDb *db = server.db + dbid;\n    dict *d = db->dict;\n    if (((d)->ht_used[0] + (d)->ht_used[1]) == 0)\n        return 0;\n    di = dictGetSafeIterator(d);\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    while (<recovery-expr>())\n        {\n            sds keystr = ((de)->key);\n            robj key, *o = (<recovery-expr>((de)).val);\n            long long expire;\n            int rdb_bytes_before_key(int *);\n            do {\n                key.type = 0;\n                key.encoding = 0;\n                key.ptr = keystr;\n            } while (0);\n            expire = getExpire(db, &key);\n            if (<recovery-expr>())\n                goto werr;\n            int dump_size(int *);\n            if (server.in_fork_child)\n                dismissObject(o, <recovery-expr>());\n            if (((*key_counter)++ & 1023) == 0) {\n                long long now = mstime();\n                if (now - info_updated_time >= 1000) {\n                    sendChildInfo(CHILD_INFO_TYPE_CURRENT_INFO, *key_counter, pname);\n                    info_updated_time = now;\n                }\n            }\n        }\n    dictReleaseIterator(di);\n  werr:\n    dictReleaseIterator(di);\n    return -1;\n}\n"
        }
    ],
    "total": 126,
    "visited": 11
}
