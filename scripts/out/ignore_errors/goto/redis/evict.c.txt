{
    "functions": [
        {
            "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/evict.c#538:1#performEvictions",
            "gotos": 3,
            "labels": 2,
            "body": "{\n    if (!isSafeToPerformEvictions())\n        return 0;\n    int keys_freed = 0;\n    int mem_reported(int *), mem_tofree(int *);\n    long long mem_freed;\n    mstime_t latency, eviction_latency;\n    long long delta;\n    int slaves = ((server.slaves)->len);\n    int result = 2;\n    if (<recovery-expr>()) {\n        result = 0;\n        goto update_metrics;\n    }\n    if (server.maxmemory_policy == (7 << 8)) {\n        result = 2;\n        goto update_metrics;\n    }\n    unsigned long eviction_time_limit_us = evictionTimeLimitUs();\n    mem_freed = 0;\n    if (server.latency_monitor_threshold) {\n        latency = mstime();\n    } else {\n        latency = 0;\n    }\n    ;\n    monotime evictionTimer;\n    elapsedStart(&evictionTimer);\n    int prev_core_propagates = server.core_propagates;\n    ((server.also_propagate.numops == 0) ? (void)0 : (_serverAssert(\"server.also_propagate.numops == 0\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/evict.c\", 573) , __builtin_unreachable()));\n    server.core_propagates = 1;\n    server.in_nested_call++;\n    while (mem_freed < (long long)mem_tofree)\n        {\n            int j, k, i;\n            static unsigned int next_db = 0;\n            sds bestkey;\n            int bestdbid;\n            redisDb *db;\n            dict *dict;\n            dictEntry *de;\n            if (server.maxmemory_policy & ((1 << 0) | (1 << 1)) || server.maxmemory_policy == (2 << 8)) {\n                struct evictionPoolEntry *pool = EvictionPoolLRU;\n                while (<recovery-expr>())\n                    {\n                        unsigned long total_keys = 0, keys;\n                        for (i = 0; i < server.dbnum; i++) {\n                            db = server.db + i;\n                            dict = (server.maxmemory_policy & (1 << 2)) ? db->dict : db->expires;\n                            if ((keys = ((dict)->ht_used[0] + (dict)->ht_used[1])) != 0) {\n                                evictionPoolPopulate(i, dict, db->dict, pool);\n                                total_keys += keys;\n                            }\n                        }\n                        if (!total_keys)\n                            break;\n                        for (k = 16 - 1; k >= 0; k--) {\n                            if (<recovery-expr>())\n                                continue;\n                            bestdbid = pool[k].dbid;\n                            if (server.maxmemory_policy & (1 << 2)) {\n                                de = dictFind(server.db[bestdbid].dict, pool[k].key);\n                            } else {\n                                de = dictFind(server.db[bestdbid].expires, pool[k].key);\n                            }\n                            if (pool[k].key != pool[k].cached)\n                                sdsfree(pool[k].key);\n                            pool[k].idle = 0;\n                            if (de) {\n                                bestkey = ((de)->key);\n                                break;\n                            } else {\n                            }\n                        }\n                    }\n            } else if (server.maxmemory_policy == ((6 << 8) | (1 << 2)) || server.maxmemory_policy == (3 << 8)) {\n                for (i = 0; i < server.dbnum; i++) {\n                    j = (++next_db) % server.dbnum;\n                    db = server.db + j;\n                    dict = (server.maxmemory_policy == ((6 << 8) | (1 << 2))) ? db->dict : db->expires;\n                    if (((dict)->ht_used[0] + (dict)->ht_used[1]) != 0) {\n                        de = dictGetRandomKey(dict);\n                        bestkey = ((de)->key);\n                        bestdbid = j;\n                        break;\n                    }\n                }\n            }\n            if (bestkey) {\n                db = server.db + bestdbid;\n                robj *keyobj = createStringObject(bestkey, <recovery-expr>()(bestkey));\n                delta = (long long)<recovery-expr>()();\n                if (server.latency_monitor_threshold) {\n                    eviction_latency = mstime();\n                } else {\n                    eviction_latency = 0;\n                }\n                ;\n                if (server.lazyfree_lazy_eviction)\n                    dbAsyncDelete(db, keyobj);\n                else\n                    dbSyncDelete(db, keyobj);\n                if (server.latency_monitor_threshold) {\n                    eviction_latency = mstime() - eviction_latency;\n                }\n                ;\n                if (server.latency_monitor_threshold && (eviction_latency) >= server.latency_monitor_threshold)\n                    latencyAddSample((\"eviction-del\"), (eviction_latency));\n                ;\n                delta -= (long long)<recovery-expr>()();\n                mem_freed += delta;\n                server.stat_evictedkeys++;\n                notifyKeyspaceEvent((1 << 9), \"evicted\", keyobj, db->id);\n                propagateDeletion(db, keyobj, server.lazyfree_lazy_eviction);\n                propagatePendingCommands();\n                decrRefCount(keyobj);\n                keys_freed++;\n                if (keys_freed % 16 == 0) {\n                    if (slaves)\n                        flushSlavesOutputBuffers();\n                    if (server.lazyfree_lazy_eviction) {\n                        if (<recovery-expr>()) {\n                            break;\n                        }\n                    }\n                    if (<recovery-expr>()(evictionTimer) > eviction_time_limit_us) {\n                        startEvictionTimeProc();\n                        break;\n                    }\n                }\n            } else {\n                goto cant_free;\n            }\n        }\n    result = (isEvictionProcRunning) ? 1 : 0;\n  cant_free:\n    if (result == 2) {\n        mstime_t lazyfree_latency;\n        if (server.latency_monitor_threshold) {\n            lazyfree_latency = mstime();\n        } else {\n            lazyfree_latency = 0;\n        }\n        ;\n        while (bioPendingJobsOfType(2) && <recovery-expr>()(evictionTimer) < eviction_time_limit_us)\n            {\n                if (<recovery-expr>()) {\n                    result = 0;\n                    break;\n                }\n                usleep(eviction_time_limit_us < 1000 ? eviction_time_limit_us : 1000);\n            }\n        if (server.latency_monitor_threshold) {\n            lazyfree_latency = mstime() - lazyfree_latency;\n        }\n        ;\n        if (server.latency_monitor_threshold && (lazyfree_latency) >= server.latency_monitor_threshold)\n            latencyAddSample((\"eviction-lazyfree\"), (lazyfree_latency));\n        ;\n    }\n    ((server.core_propagates) ? (void)0 : (_serverAssert(\"server.core_propagates\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/evict.c\", 753) , __builtin_unreachable()));\n    server.core_propagates = prev_core_propagates;\n    server.in_nested_call--;\n    if (server.latency_monitor_threshold) {\n        latency = mstime() - latency;\n    }\n    ;\n    if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n        latencyAddSample((\"eviction-cycle\"), (latency));\n    ;\n  update_metrics:\n    if (result == 1 || result == 2) {\n        if (server.stat_last_eviction_exceeded_time == 0)\n            elapsedStart(&server.stat_last_eviction_exceeded_time);\n    } else if (result == 0) {\n        if (server.stat_last_eviction_exceeded_time != 0) {\n            server.stat_total_eviction_exceeded_time += <recovery-expr>()(server.stat_last_eviction_exceeded_time);\n            server.stat_last_eviction_exceeded_time = 0;\n        }\n    }\n    return result;\n}\n"
        }
    ],
    "total": 67,
    "visited": 1
}
