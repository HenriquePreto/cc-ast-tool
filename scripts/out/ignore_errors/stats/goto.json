[
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/tactic/tactical.cpp#900:5#repeat_tactical::operator()",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    _Bool models_enabled = <recovery-expr>()->models_enabled();\n    _Bool proofs_enabled = <recovery-expr>()->proofs_enabled();\n    _Bool cores_enabled = <recovery-expr>()->unsat_core_enabled();\n    int &m;\n    int r1;\n    int g;\n    unsigned int r1_size = 0;\n    <recovery-expr>().reset();\n  try_goal:\n    <recovery-expr>().reset();\n    if (depth > this->m_max_depth) {\n        <recovery-expr>().push_back(<recovery-expr>().get());\n        return;\n    }\n    {\n        int orig_in;\n        <recovery-expr>().copy_from(*(<recovery-expr>().get()));\n        if (<recovery-expr>().size() == 1 && is_equal(<recovery-expr>(), *(<recovery-expr>()[0]))) {\n            <recovery-expr>().push_back(<recovery-expr>()[0]);\n            return;\n        }\n    }\n    r1_size = <recovery-expr>().size();\n    <recovery-expr>(SASSERT, r1_size > 0);\n    if (r1_size == 1) {\n        if (<recovery-expr>()[0]->is_decided()) {\n            <recovery-expr>().push_back(<recovery-expr>()[0]);\n            return;\n        }\n        <recovery-expr>() = <recovery-expr>()[0];\n        depth++;\n        goto try_goal;\n    }\n    int r2;\n    for (unsigned int i = 0; i < r1_size; i++) {\n        int g;\n        <recovery-expr>().reset();\n        if (is_decided(<recovery-expr>())) {\n            SASSERT(<recovery-expr>().size() == 1);\n            if (is_decided_sat(<recovery-expr>())) {\n                <recovery-expr>().push_back(<recovery-expr>()[0]);\n                return;\n            } else {\n                SASSERT(is_decided_unsat(<recovery-expr>()));\n            }\n        } else {\n            <recovery-expr>().append(<recovery-expr>().size(), <recovery-expr>().data());\n        }\n    }\n    if (<recovery-expr>().empty()) {\n        <recovery-expr>()->reset_all();\n        int pr;\n        int core;\n        if (proofs_enabled) {\n            apply(<recovery-expr>(), <recovery-expr>()->pc(), <recovery-expr>());\n        }\n        if (cores_enabled && <recovery-expr>()->dc()) {\n            <recovery-expr>() = (*<recovery-expr>()->dc())();\n        }\n        <recovery-expr>()->assert_expr(<recovery-expr>().mk_false(), <recovery-expr>(), <recovery-expr>());\n        <recovery-expr>().push_back(<recovery-expr>().get());\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/smt/tactic/ctx_solver_simplify_tactic.cpp#162:5#ctx_solver_simplify_tactic::reduce",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int names;\n    int todo;\n    int fresh_vars;\n    int res;\n    int cache;\n    unsigned int id = 1, child_id = 0;\n    int n2;\n    unsigned int parent_pos = 0, self_pos = 0, self_idx = 0;\n    int *a;\n    unsigned int sz;\n    expr_pos path_r;\n    int args;\n    int n;\n    <recovery-expr>().push_back(<recovery-expr>());\n    while (<recovery-expr>())\n        {\n            int res;\n            <recovery-expr>().reset();\n            int *e;\n            self_pos = <recovery-expr>().back().m_self;\n            parent_pos = <recovery-expr>().back().m_parent;\n            self_idx = <recovery-expr>().back().m_idx;\n            <recovery-expr>() = <recovery-expr>().back();\n            _Bool found = false;\n            if (<recovery-expr>().contains(<recovery-expr>())) {\n                goto done;\n            }\n            if (<recovery-expr>()) {\n                <recovery-expr>() = <recovery-expr>();\n                goto done;\n            }\n            if (<recovery-expr>()) {\n                goto done;\n            }\n            if (!is_app(<recovery-expr>())) {\n                <recovery-expr>() = <recovery-expr>();\n                goto done;\n            }\n            <recovery-expr>() = to_app(<recovery-expr>());\n            sz = <recovery-expr>()->get_num_args();\n            <recovery-expr>() = nullptr;\n            for (unsigned int i = 0; i < sz; ++i) {\n                int *arg;\n                if (<recovery-expr>().find(<recovery-expr>(), path_r) && path_r.m_parent == self_pos && path_r.m_idx == i) {\n                    <recovery-expr>().push_back(<recovery-expr>(path_r));\n                    found = true;\n                    continue;\n                }\n                <recovery-expr>().push_back(<recovery-expr>());\n            }\n            if (!found) {\n                <recovery-expr>().reset();\n                for (unsigned int i = 0; i < sz; ++i) {\n                    int *arg;\n                    if (<recovery-expr>()) {\n                        <recovery-expr>().push_back(expr_pos(self_pos, ++child_id, i, <recovery-expr>()));\n                        <recovery-expr>().push_back(<recovery-expr>());\n                        <recovery-expr>().push_back(<recovery-expr>());\n                    } else {\n                        <recovery-expr>().push_back(<recovery-expr>());\n                    }\n                }\n            }\n            if (<recovery-expr>()) {\n                <recovery-expr>(SASSERT, !found);\n                continue;\n            }\n          done:\n            if (<recovery-expr>()) {\n                <recovery-expr>().insert(<recovery-expr>(), expr_pos(parent_pos, self_pos, self_idx, <recovery-expr>()));\n            }\n            <recovery-expr>().pop_back();\n            <recovery-expr>().pop_back();\n        }\n    if (<recovery-expr>()) {\n        <recovery-expr>() = <recovery-expr>(path_r);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/tactic/core/tseitin_cnf_tactic.cpp#794:9#tseitin_cnf_tactic::imp::process",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    _Bool visited = true;\n    if (visited) {\n        int l;\n        return;\n    }\n    int *root;\n    int *t;\n    _Bool first;\n    mres r;\n    while (<recovery-expr>())\n        {\n          loop:\n            this->checkpoint();\n            frame &fr;\n            <recovery-expr>() = <recovery-expr>(fr);\n            first = fr.m_first;\n            fr.m_first = false;\n            if (r == CONT)\n                goto loop;\n            if (r == DONE) {\n                continue;\n            }\n            ;\n            if (r == CONT)\n                goto loop;\n            if (r == DONE) {\n                continue;\n            }\n            ;\n            if (r == CONT)\n                goto loop;\n            if (r == DONE) {\n                continue;\n            }\n            ;\n            if (r == CONT)\n                goto loop;\n            if (r == DONE) {\n                continue;\n            }\n            ;\n            if (r == CONT)\n                goto loop;\n            if (r == DONE) {\n                continue;\n            }\n            ;\n            if (r == CONT)\n                goto loop;\n            if (r == DONE) {\n                continue;\n            }\n            ;\n            <recovery-expr>(UNREACHABLE);\n        }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/tactic/core/tseitin_cnf_tactic.cpp#202:9#tseitin_cnf_tactic::imp::visit",
    "gotos": 1,
    "labels": 1,
    "body": "{\n  start:\n    if (!is_app(<recovery-expr>()))\n        return;\n    if (<recovery-expr>())\n        return;\n    if (to_app(<recovery-expr>())->get_num_args() == 0)\n        return;\n    int *f;\n    if (<recovery-expr>())\n        return;\n    switch (<recovery-expr>()->get_decl_kind()) {\n        if (root) {\n            visited = false;\n            return;\n        } else {\n            <recovery-expr>() = to_app(<recovery-expr>())->get_arg(0);\n            goto start;\n        }\n        visited = false;\n        return;\n        if (<recovery-expr>()) {\n            visited = false;\n        }\n        return;\n        this->throw_op_not_handled();\n      default:\n        return;\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/tactic/core/tseitin_cnf_tactic.cpp#160:9#tseitin_cnf_tactic::imp::get_lit",
    "gotos": 1,
    "labels": 1,
    "body": "{\n  start:\n    if (!is_app(<recovery-expr>()) || to_app(<recovery-expr>())->get_num_args() == 0) {\n        return;\n    }\n    int *f;\n    if (<recovery-expr>()) {\n        return;\n    }\n    int *l;\n    switch (<recovery-expr>()->get_decl_kind()) {\n        <recovery-expr>() = to_app(<recovery-expr>())->get_arg(0);\n        sign = !sign;\n        goto start;\n        <recovery-expr>() = nullptr;\n        SASSERT(<recovery-expr>() != 0);\n        return;\n        if (<recovery-expr>()) {\n            <recovery-expr>() = nullptr;\n            SASSERT(<recovery-expr>() != 0);\n            return;\n        }\n        return;\n      default:\n        ;\n        <recovery-expr>(UNREACHABLE);\n        return;\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/solver/parallel_tactic.cpp#511:5#parallel_tactic::cube_and_conquer",
    "gotos": 3,
    "labels": 2,
    "body": "{\n    int &m;\n    int cube;\n    int vars;\n    unsigned int num_simplifications = 0;\n  cube_again:\n    if (this->canceled(s))\n        return;\n    <recovery-expr>().reset();\n    <recovery-expr>().append(<recovery-expr>(s)(1));\n    SASSERT(<recovery-expr>().size() <= 1);\n    {\n    }\n    if (!<recovery-expr>().empty()) {\n        <recovery-expr>(s)(<recovery-expr>().get(0).cube());\n        <recovery-expr>().reset();\n        <recovery-expr>().append(<recovery-expr>().get(0).vars());\n    }\n    num_simplifications = 0;\n  simplify_again:\n    ++num_simplifications;\n    s.inc_depth(1);\n    if (this->canceled(s))\n        return;\n    switch (<recovery-expr>(s)()) {\n        break;\n        return;\n        this->report_unsat(s);\n        return;\n    }\n    if (this->canceled(s))\n        return;\n    if (s.giveup()) {\n        return;\n    }\n    if (this->memory_pressure()) {\n        goto simplify_again;\n    }\n    s.set_cube_params();\n    int conquer;\n    unsigned int cutoff;\n    _Bool first = true;\n    unsigned int num_backtracks = 0, width = 0;\n    while (cutoff > 0 && !this->canceled(s))\n        {\n            int c;\n            if (<recovery-expr>().empty() || (<recovery-expr>().size() == 1 && <recovery-expr>().is_true(<recovery-expr>().back()))) {\n                if (num_simplifications > 1) {\n                    return;\n                }\n                goto simplify_again;\n            }\n            if (<recovery-expr>().is_false(<recovery-expr>().back())) {\n                break;\n            }\n            int is_sat;\n            if (!s.has_assumptions() && width >= this->m_conquer_delay && !<recovery-expr>()) {\n                <recovery-expr>() = <recovery-expr>(s)();\n                s.set_conquer_params(*<recovery-expr>().get());\n            }\n            if (<recovery-expr>()) {\n                <recovery-expr>() = <recovery-expr>()->check_sat(<recovery-expr>());\n            }\n            switch (<recovery-expr>()) {\n                cutoff = <recovery-expr>().size();\n                if (cutoff != <recovery-expr>().size()) {\n                    IF_VERBOSE(0, <recovery-expr>(verbose_stream) << \"(tactic.parallel :backtrack \" << cutoff << \" -> \" << <recovery-expr>().size() << \")\\n\");\n                    cutoff = <recovery-expr>().size();\n                }\n                this->inc_unsat(s);\n                break;\n                if (<recovery-expr>()) {\n                    this->collect_statistics(*<recovery-expr>().get());\n                }\n                return;\n                ++width;\n                IF_VERBOSE(2, <recovery-expr>(verbose_stream) << \"(tactic.parallel :cube \" << <recovery-expr>().size() << \" :vars \" << <recovery-expr>().size() << \")\\n\");\n                break;\n            }\n            if (<recovery-expr>()) {\n                first = false;\n            }\n        }\n    if (<recovery-expr>()) {\n        this->collect_statistics(*<recovery-expr>().get());\n    }\n    if (<recovery-expr>()) {\n        this->report_unsat(s);\n    } else if (<recovery-expr>()) {\n        this->dec_branch();\n    } else {\n        s.inc_width(width);\n        goto cube_again;\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/ast/rewriter/der.cpp#193:1#der_sort_vars",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    <recovery-expr>().reset();\n    _Bool found = false;\n    for (unsigned int i = 0; i < <recovery-expr>().size(); i++) {\n        int *v;\n        int *t;\n        if (<recovery-expr>() == nullptr || has_quantifiers(<recovery-expr>()) || occurs(<recovery-expr>(), <recovery-expr>()))\n            <recovery-expr>()[i] = nullptr;\n        else\n            found = true;\n    }\n    if (!found)\n        return;\n    typedef int frame;\n    int todo;\n    int visiting;\n    int done;\n    unsigned int vidx, num;\n    for (unsigned int i = 0; i < <recovery-expr>().size(); i++) {\n        if (!<recovery-expr>().get(i))\n            continue;\n        int *v;\n        SASSERT(<recovery-expr>()->get_idx() == i);\n        SASSERT(<recovery-expr>().empty());\n        <recovery-expr>().push_back(frame(<recovery-expr>(), 0));\n        while (!<recovery-expr>().empty())\n            {\n              start:\n                frame &fr = <recovery-expr>().back();\n                int *t;\n                if (<recovery-expr>().is_marked(<recovery-expr>())) {\n                    <recovery-expr>().pop_back();\n                    continue;\n                }\n                switch (<recovery-expr>()->get_kind()) {\n                    vidx = to_var(<recovery-expr>())->get_idx();\n                    if (<recovery-expr>(fr) == 0) {\n                        if (<recovery-expr>().get(vidx, nullptr) != nullptr) {\n                            if (<recovery-expr>().is_marked(<recovery-expr>())) {\n                                <recovery-expr>().reset_mark(<recovery-expr>());\n                                <recovery-expr>()[vidx] = nullptr;\n                            } else {\n                                <recovery-expr>().mark(<recovery-expr>());\n                                <recovery-expr>(fr) = 1;\n                                <recovery-expr>().push_back(frame(<recovery-expr>().get(vidx), 0));\n                                goto start;\n                            }\n                        }\n                    } else {\n                        SASSERT(<recovery-expr>(fr) == 1);\n                        if (<recovery-expr>().get(vidx, nullptr) != nullptr) {\n                            <recovery-expr>().reset_mark(<recovery-expr>());\n                            <recovery-expr>().push_back(vidx);\n                        } else {\n                        }\n                    }\n                    <recovery-expr>().mark(<recovery-expr>());\n                    <recovery-expr>().pop_back();\n                    break;\n                    <recovery-expr>(UNREACHABLE);\n                    <recovery-expr>().pop_back();\n                    break;\n                    num = to_app(<recovery-expr>())->get_num_args();\n                    while (<recovery-expr>(fr) < num)\n                        {\n                            int *arg;\n                            <recovery-expr>(fr)++;\n                            if (<recovery-expr>().is_marked(<recovery-expr>()))\n                                continue;\n                            <recovery-expr>().push_back(frame(<recovery-expr>(), 0));\n                            goto start;\n                        }\n                    <recovery-expr>().mark(<recovery-expr>());\n                    <recovery-expr>().pop_back();\n                    break;\n                  default:\n                    <recovery-expr>(UNREACHABLE);\n                    <recovery-expr>().pop_back();\n                    break;\n                }\n            }\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/tactic/bv/max_bv_sharing_tactic.cpp#96:9#max_bv_sharing_tactic::rw_cfg::reduce_ac_app",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    set &s;\n    if (num_args == 2) {\n        if (<recovery-expr>())\n            <recovery-expr>(s)(expr_pair(<recovery-expr>()[0], <recovery-expr>()[1]));\n    }\n    int _args;\n    _Bool first = false;\n    int *num;\n    for (unsigned int i = 0; i < num_args; i++) {\n        int *arg;\n        if (<recovery-expr>()) {\n            if (i == 0)\n                first = true;\n            <recovery-expr>() = <recovery-expr>();\n        } else {\n            <recovery-expr>().push_back(<recovery-expr>());\n        }\n    }\n    num_args = <recovery-expr>().size();\n  try_to_reuse:\n    if (num_args > 1 && num_args < this->m_max_args) {\n        for (unsigned int i = 0; i < num_args - 1; i++) {\n            for (unsigned int j = i + 1; j < num_args; j++) {\n                int *r;\n                if (<recovery-expr>() != nullptr) {\n                    <recovery-expr>()[i] = <recovery-expr>();\n                    <recovery-expr>(SASSERT, num_args > 1);\n                    for (unsigned int w = j; w < num_args - 1; w++) {\n                        <recovery-expr>()[w] = <recovery-expr>()[w + 1];\n                    }\n                    num_args--;\n                    goto try_to_reuse;\n                }\n            }\n        }\n    }\n    while (true)\n        {\n            unsigned int j = 0;\n            for (unsigned int i = 0; i < num_args; i += 2 , j++) {\n                if (i == num_args - 1) {\n                    <recovery-expr>()[j] = <recovery-expr>()[i];\n                } else {\n                    <recovery-expr>(s)(expr_pair(<recovery-expr>()[i], <recovery-expr>()[i + 1]));\n                }\n            }\n            num_args = j;\n            if (num_args == 1) {\n                if (<recovery-expr>() == nullptr) {\n                    <recovery-expr>() = <recovery-expr>()[0];\n                } else {\n                }\n            }\n        }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/sat/smt/q_mam.cpp#2262:5#q::interpreter::execute_core",
    "gotos": 98,
    "labels": 3,
    "body": "{\n    unsigned int since_last_check = 0;\n    if (<recovery-expr>())\n        return false;\n    this->m_max_generation = <recovery-expr>()->generation();\n    this->m_pc = t->get_root();\n    this->m_top = 0;\n  main_loop:\n    ;\n    switch (this->m_pc->m_opcode) {\n      case INIT1:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT2:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT3:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT4:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT5:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT6:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INITN:\n        ;\n        if (this->m_num_args != static_cast<const initn *>(this->m_pc)->m_num_args)\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case COMPARE:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case CHECK:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case CFILTER:\n      case FILTER:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case PFILTER:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case CHOOSE:\n        ;\n        this->m_top++;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case NOOP:\n        <recovery-expr>(SASSERT, static_cast<const choose *>(this->m_pc)->m_alt == 0);\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND1:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND2:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND3:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND4:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND5:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND6:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BINDN:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_num_args = static_cast<const bind *>(this->m_pc)->m_num_args;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case YIELD1:\n        ;\n        if (<recovery-expr>())\n            return false;\n        goto backtrack;\n      case YIELD2:\n        ;\n        if (<recovery-expr>())\n            return false;\n        goto backtrack;\n      case YIELD3:\n        ;\n        if (<recovery-expr>())\n            return false;\n        goto backtrack;\n      case YIELD4:\n        ;\n        if (<recovery-expr>())\n            return false;\n        goto backtrack;\n      case YIELD5:\n        ;\n        if (<recovery-expr>())\n            return false;\n        goto backtrack;\n      case YIELD6:\n        ;\n        if (<recovery-expr>())\n            return false;\n        goto backtrack;\n      case YIELDN:\n        this->m_num_args = static_cast<const yield *>(this->m_pc)->m_num_bindings;\n        if (<recovery-expr>())\n            return false;\n        goto backtrack;\n      case GET_ENODE:\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case GET_CGR1:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        goto cgr_common;\n      case GET_CGR2:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        goto cgr_common;\n      case GET_CGR3:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        goto cgr_common;\n      case GET_CGR4:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        goto cgr_common;\n      case GET_CGR5:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        goto cgr_common;\n      case GET_CGR6:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        goto cgr_common;\n      case GET_CGRN:\n        this->m_num_args = static_cast<const get_cgr *>(this->m_pc)->m_num_args;\n        goto cgr_common;\n      case IS_CGR:\n        if (!this->exec_is_cgr(static_cast<const is_cgr *>(this->m_pc)))\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case CONTINUE:\n        this->m_num_args = static_cast<const cont *>(this->m_pc)->m_num_args;\n        this->m_oreg = static_cast<const cont *>(this->m_pc)->m_oreg;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n    }\n    goto backtrack;\n  cgr_common:\n    ;\n    if (<recovery-expr>())\n        goto backtrack;\n    this->m_pc = this->m_pc->m_next;\n    goto main_loop;\n  backtrack:\n    ;\n    if (this->m_top == 0) {\n        return true;\n    }\n    backtrack_point &bp;\n    this->m_max_generation = bp.m_old_max_generation;\n    if (since_last_check++ > 100) {\n        since_last_check = 0;\n        if (<recovery-expr>()) {\n            while (this->m_top != 0)\n                {\n                    backtrack_point &bp;\n                    this->m_top--;\n                }\n            return false;\n        }\n    }\n    switch (bp.m_instr->m_opcode) {\n      case CHOOSE:\n        this->m_pc = static_cast<const choose *>(bp.m_instr)->m_alt;\n        <recovery-expr>(SASSERT, this->m_pc != 0);\n        this->m_top--;\n        goto main_loop;\n      case BIND1:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND2:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND3:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND4:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND5:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND6:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BINDN:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_num_args = this->m_b->m_num_args;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case CONTINUE:\n        ++<recovery-expr>(bp);\n        for (; <recovery-expr>(bp) != <recovery-expr>(bp); ++<recovery-expr>(bp)) {\n            const cont *c = static_cast<const cont *>(bp.m_instr);\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                }\n                this->m_num_args = c->m_num_args;\n                this->m_oreg = c->m_oreg;\n                this->m_pc = c->m_next;\n                goto main_loop;\n            }\n        }\n        this->m_top--;\n        goto backtrack;\n      default:\n        <recovery-expr>(UNREACHABLE);\n    }\n    return false;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/sat/smt/q_mam.cpp#2116:5#q::interpreter::init_continue",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int *lbl;\n    unsigned int min_sz;\n    unsigned short num_args = c->m_num_args;\n    int *r;\n    for (unsigned int i = 0; i < num_args; i++) {\n        void *bare = <recovery-expr>(c)[i];\n        int *n;\n        switch (<recovery-expr>(GET_TAG, bare)) {\n          case 0:\n            goto non_depth1;\n          case 1:\n            ;\n            break;\n          case 2:\n            ;\n            break;\n          case 3:\n            goto non_depth1;\n        }\n        <recovery-expr>() = <recovery-expr>()->get_root();\n        if (this->m_use_filters && <recovery-expr>()->get_plbls().empty_intersection(<recovery-expr>(c)))\n            return nullptr;\n        if (<recovery-expr>()->num_parents() == 0)\n            return nullptr;\n      non_depth1:\n        ;\n    }\n    int *best_v;\n    for (unsigned int i = 0; i < num_args; i++) {\n        int *bare;\n        int *curr_v;\n        switch (GET_TAG(<recovery-expr>())) {\n          case 0:\n            <recovery-expr>() = nullptr;\n            break;\n          case 1:\n            ;\n            break;\n          case 2:\n            ;\n            break;\n          case 3:\n            ;\n            break;\n        }\n        if (<recovery-expr>() != nullptr) {\n            if (<recovery-expr>()->size() < min_sz && (<recovery-expr>() == nullptr || <recovery-expr>()->size() < <recovery-expr>()->size())) {\n                <recovery-expr>() = <recovery-expr>();\n                if (<recovery-expr>()->empty()) {\n                    return nullptr;\n                }\n            } else {\n            }\n        }\n    }\n    backtrack_point &bp;\n    <recovery-expr>(bp.m_instr, c);\n    bp.m_old_max_generation = this->m_max_generation;\n    if (<recovery-expr>() == nullptr) {\n        <recovery-expr>(bp) = nullptr;\n    } else {\n        SASSERT(!<recovery-expr>()->empty());\n        <recovery-expr>(bp) = <recovery-expr>();\n        <recovery-expr>(bp) = <recovery-expr>()->begin();\n        <recovery-expr>(bp) = <recovery-expr>()->end();\n    }\n    for (; <recovery-expr>(bp) != <recovery-expr>(bp); ++<recovery-expr>(bp)) {\n        int *curr;\n        if (<recovery-expr>())\n            break;\n    }\n    if (<recovery-expr>(bp) == <recovery-expr>(bp)) {\n        return nullptr;\n    }\n    this->m_top++;\n    return *(<recovery-expr>(bp));\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/qe/lite/qe_lite.cpp#117:9#qel::eq_der::der_sort_vars",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    <recovery-expr>().reset();\n    _Bool found = false;\n    for (unsigned int i = 0; i < <recovery-expr>().size(); i++) {\n        int *v;\n        int *t;\n        if (<recovery-expr>())\n            <recovery-expr>()[i] = nullptr;\n        else\n            found = true;\n    }\n    if (!found)\n        return;\n    typedef int frame;\n    int todo;\n    int visiting;\n    int done;\n    unsigned int vidx, num;\n    for (unsigned int i = 0; i < <recovery-expr>().size(); i++) {\n        if (<recovery-expr>()[i] == nullptr)\n            continue;\n        int *v;\n        SASSERT(<recovery-expr>()->get_idx() == i);\n        SASSERT(<recovery-expr>().empty());\n        <recovery-expr>().push_back(frame(<recovery-expr>(), 0));\n        while (!<recovery-expr>().empty())\n            {\n              start:\n                frame &fr = <recovery-expr>().back();\n                int *t;\n                if (<recovery-expr>().is_marked(<recovery-expr>())) {\n                    <recovery-expr>().pop_back();\n                    continue;\n                }\n                switch (<recovery-expr>()->get_kind()) {\n                    vidx = to_var(<recovery-expr>())->get_idx();\n                    if (<recovery-expr>(fr) == 0) {\n                        if (<recovery-expr>().get(vidx, nullptr) != nullptr) {\n                            if (<recovery-expr>().is_marked(<recovery-expr>())) {\n                                <recovery-expr>().reset_mark(<recovery-expr>());\n                                <recovery-expr>()[vidx] = nullptr;\n                            } else if (<recovery-expr>()) {\n                                <recovery-expr>().push_back(vidx);\n                                <recovery-expr>().mark(<recovery-expr>()[vidx]);\n                            } else {\n                                <recovery-expr>().mark(<recovery-expr>());\n                                <recovery-expr>(fr) = 1;\n                                <recovery-expr>().push_back(frame(<recovery-expr>()[vidx], 0));\n                                goto start;\n                            }\n                        }\n                    } else {\n                        SASSERT(<recovery-expr>(fr) == 1);\n                        <recovery-expr>().reset_mark(<recovery-expr>());\n                        if (!<recovery-expr>().is_marked(<recovery-expr>()) && <recovery-expr>().get(vidx, nullptr) != nullptr) {\n                            <recovery-expr>().push_back(vidx);\n                        }\n                    }\n                    <recovery-expr>().mark(<recovery-expr>());\n                    <recovery-expr>().pop_back();\n                    break;\n                    <recovery-expr>(UNREACHABLE);\n                    break;\n                    num = to_app(<recovery-expr>())->get_num_args();\n                    while (<recovery-expr>(fr) < num)\n                        {\n                            int *arg;\n                            <recovery-expr>(fr)++;\n                            if (<recovery-expr>().is_marked(<recovery-expr>()))\n                                continue;\n                            <recovery-expr>().push_back(frame(<recovery-expr>(), 0));\n                            goto start;\n                        }\n                    <recovery-expr>().mark(<recovery-expr>());\n                    <recovery-expr>().pop_back();\n                    break;\n                  default:\n                    <recovery-expr>(UNREACHABLE);\n                    break;\n                }\n            }\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/smt/mam.cpp#2126:5#(anonymous namespace)::interpreter::init_continue",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int *lbl;\n    unsigned int min_sz;\n    unsigned short num_args = c->m_num_args;\n    int *r;\n    for (unsigned int i = 0; i < num_args; i++) {\n        void *bare = <recovery-expr>(c)[i];\n        int *n;\n        switch (<recovery-expr>(GET_TAG, bare)) {\n          case 0:\n            goto non_depth1;\n          case 1:\n            ;\n            break;\n          case 2:\n            ;\n            break;\n          case 3:\n            goto non_depth1;\n        }\n        <recovery-expr>() = <recovery-expr>()->get_root();\n        if (this->m_use_filters && <recovery-expr>()->get_plbls().empty_intersection(<recovery-expr>(c)))\n            return nullptr;\n        if (<recovery-expr>()->get_num_parents() == 0)\n            return nullptr;\n      non_depth1:\n        ;\n    }\n    int *best_v;\n    for (unsigned int i = 0; i < num_args; i++) {\n        int *bare;\n        int *curr_v;\n        switch (GET_TAG(<recovery-expr>())) {\n          case 0:\n            <recovery-expr>() = nullptr;\n            break;\n          case 1:\n            ;\n            break;\n          case 2:\n            ;\n            break;\n          case 3:\n            ;\n            break;\n        }\n        if (<recovery-expr>() != nullptr) {\n            if (<recovery-expr>()->size() < min_sz && (<recovery-expr>() == nullptr || <recovery-expr>()->size() < <recovery-expr>()->size())) {\n                <recovery-expr>() = <recovery-expr>();\n                if (<recovery-expr>()->empty()) {\n                    return nullptr;\n                }\n            } else {\n            }\n        }\n    }\n    backtrack_point &bp;\n    <recovery-expr>(bp.m_instr, c);\n    bp.m_old_max_generation = this->m_max_generation;\n    if (<recovery-expr>() == nullptr) {\n        <recovery-expr>(bp) = nullptr;\n    } else {\n        SASSERT(!<recovery-expr>()->empty());\n        <recovery-expr>(bp) = <recovery-expr>();\n        <recovery-expr>(bp) = <recovery-expr>()->begin();\n        <recovery-expr>(bp) = <recovery-expr>()->end();\n    }\n    for (; <recovery-expr>(bp) != <recovery-expr>(bp); ++<recovery-expr>(bp)) {\n        int *curr;\n        if (<recovery-expr>())\n            break;\n    }\n    if (<recovery-expr>(bp) == <recovery-expr>(bp)) {\n        if (<recovery-expr>()) {\n            <recovery-expr>(bp) = nullptr;\n        }\n        return nullptr;\n    }\n    this->m_top++;\n    return *(<recovery-expr>(bp));\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/smt/mam.cpp#2278:5#(anonymous namespace)::interpreter::execute_core",
    "gotos": 103,
    "labels": 2,
    "body": "{\n    unsigned int since_last_check = 0;\n    this->m_max_generation = <recovery-expr>()->get_generation();\n    if (<recovery-expr>()) {\n    }\n    this->m_pc = t->get_root();\n    this->m_top = 0;\n  main_loop:\n    if (!this->m_pc)\n        goto backtrack;\n    switch (this->m_pc->m_opcode) {\n      case INIT1:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT2:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT3:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT4:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT5:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INIT6:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case INITN:\n        ;\n        if (this->m_num_args != static_cast<const initn *>(this->m_pc)->m_num_args)\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case COMPARE:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case CHECK:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case CFILTER:\n      case FILTER:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case PFILTER:\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case CHOOSE:\n        ;\n        this->m_top++;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case NOOP:\n        <recovery-expr>(SASSERT, static_cast<const choose *>(this->m_pc)->m_alt == 0);\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND1:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND2:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND3:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND4:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND5:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BIND6:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case BINDN:\n        ;\n        this->m_oreg = static_cast<const bind *>(this->m_pc)->m_oreg;\n        this->m_curr_max_generation = this->m_max_generation;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_top++;\n        ;\n        this->m_num_args = static_cast<const bind *>(this->m_pc)->m_num_args;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case YIELD1:\n        ;\n        if (<recovery-expr>()) {\n            return false;\n        }\n        goto backtrack;\n      case YIELD2:\n        ;\n        if (<recovery-expr>()) {\n            return false;\n        }\n        goto backtrack;\n      case YIELD3:\n        ;\n        if (<recovery-expr>()) {\n            return false;\n        }\n        goto backtrack;\n      case YIELD4:\n        ;\n        if (<recovery-expr>()) {\n            return false;\n        }\n        goto backtrack;\n      case YIELD5:\n        ;\n        if (<recovery-expr>()) {\n            return false;\n        }\n        goto backtrack;\n      case YIELD6:\n        ;\n        if (<recovery-expr>()) {\n            return false;\n        }\n        goto backtrack;\n      case YIELDN:\n        this->m_num_args = static_cast<const yield *>(this->m_pc)->m_num_bindings;\n        if (<recovery-expr>()) {\n            return false;\n        }\n        goto backtrack;\n      case GET_ENODE:\n        ;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case GET_CGR1:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n            for (unsigned int i = 0; i < static_cast<const get_cgr *>(this->m_pc)->m_num_args; ++i) {\n            }\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n        ;\n      case GET_CGR2:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n            for (unsigned int i = 0; i < static_cast<const get_cgr *>(this->m_pc)->m_num_args; ++i) {\n            }\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n        ;\n      case GET_CGR3:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n            for (unsigned int i = 0; i < static_cast<const get_cgr *>(this->m_pc)->m_num_args; ++i) {\n            }\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n        ;\n      case GET_CGR4:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n            for (unsigned int i = 0; i < static_cast<const get_cgr *>(this->m_pc)->m_num_args; ++i) {\n            }\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n        ;\n      case GET_CGR5:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n            for (unsigned int i = 0; i < static_cast<const get_cgr *>(this->m_pc)->m_num_args; ++i) {\n            }\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n        ;\n      case GET_CGR6:\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>()) {\n            goto backtrack;\n        }\n        ;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n            for (unsigned int i = 0; i < static_cast<const get_cgr *>(this->m_pc)->m_num_args; ++i) {\n            }\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n        ;\n      case GET_CGRN:\n        this->m_num_args = static_cast<const get_cgr *>(this->m_pc)->m_num_args;\n        if (<recovery-expr>())\n            goto backtrack;\n        if (<recovery-expr>()) {\n            for (unsigned int i = 0; i < static_cast<const get_cgr *>(this->m_pc)->m_num_args; ++i) {\n            }\n        }\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n        ;\n      case IS_CGR:\n        if (!this->exec_is_cgr(static_cast<const is_cgr *>(this->m_pc)))\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n      case CONTINUE:\n        this->m_num_args = static_cast<const cont *>(this->m_pc)->m_num_args;\n        this->m_oreg = static_cast<const cont *>(this->m_pc)->m_oreg;\n        if (<recovery-expr>())\n            goto backtrack;\n        this->m_pc = this->m_pc->m_next;\n        goto main_loop;\n    }\n  backtrack:\n    ;\n    if (this->m_top == 0) {\n        return true;\n    }\n    backtrack_point &bp;\n    this->m_max_generation = bp.m_old_max_generation;\n    if (since_last_check++ > 100) {\n        since_last_check = 0;\n        if (<recovery-expr>()) {\n            while (this->m_top != 0)\n                {\n                    backtrack_point &bp;\n                    this->m_top--;\n                }\n            return false;\n        }\n    }\n    switch (bp.m_instr->m_opcode) {\n      case CHOOSE:\n        this->m_pc = static_cast<const choose *>(bp.m_instr)->m_alt;\n        <recovery-expr>(SASSERT, this->m_pc != 0);\n        this->m_top--;\n        goto main_loop;\n      case BIND1:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND2:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND3:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND4:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND5:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BIND6:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case BINDN:\n        this->m_b = static_cast<const bind *>(bp.m_instr);\n        if (<recovery-expr>()) {\n            this->m_top--;\n            goto backtrack;\n        }\n        this->m_oreg = this->m_b->m_oreg;\n        this->m_num_args = this->m_b->m_num_args;\n        this->m_pc = this->m_b->m_next;\n        goto main_loop;\n      case CONTINUE:\n        ++<recovery-expr>(bp);\n        for (; <recovery-expr>(bp) != <recovery-expr>(bp); ++<recovery-expr>(bp)) {\n            const cont *c = static_cast<const cont *>(bp.m_instr);\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                }\n                this->m_num_args = c->m_num_args;\n                this->m_oreg = c->m_oreg;\n                this->m_pc = c->m_next;\n                goto main_loop;\n            }\n        }\n        this->m_top--;\n        goto backtrack;\n      default:\n        <recovery-expr>(UNREACHABLE);\n    }\n    return false;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/util/scoped_timer.cpp#51:1#thread_func",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    <recovery-expr>().lock();\n    while (true)\n        {\n            <recovery-expr>(s).wait(<recovery-expr>(), [=] {\n            });\n            <recovery-expr>().unlock();\n            if (<recovery-expr>(s) == EXITING)\n                return;\n            auto end;\n            while (!<recovery-expr>(s).try_lock_until(<recovery-expr>()))\n                {\n                    if (<recovery-expr>()) {\n                        goto next;\n                    }\n                }\n            <recovery-expr>(s).unlock();\n          next:\n            <recovery-expr>(s) = IDLE;\n            <recovery-expr>().lock();\n        }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/tactic/core/propagate_values_tactic.cpp#133:5#(anonymous namespace)::propagate_values_tactic::run",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    int report;\n    _Bool forward = true;\n    int new_curr;\n    int new_pr;\n    unsigned int size;\n    this->m_idx = 0;\n    this->m_modified = false;\n    unsigned int round = 0;\n    if (<recovery-expr>())\n        goto end;\n    if (this->m_max_rounds == 0)\n        goto end;\n    if (<recovery-expr>())\n        goto end;\n    while (true)\n        {\n            if (forward) {\n                for (; this->m_idx < size; this->m_idx++) {\n                    this->process_current();\n                    if (<recovery-expr>())\n                        goto end;\n                }\n                if (<recovery-expr>())\n                    goto end;\n                forward = false;\n            } else {\n                while (this->m_idx > 0)\n                    {\n                        this->m_idx--;\n                        this->process_current();\n                        if (<recovery-expr>())\n                            goto end;\n                    }\n                if (!this->m_modified)\n                    goto end;\n                this->m_modified = false;\n                this->m_idx = 0;\n                forward = true;\n            }\n            round++;\n            if (round >= this->m_max_rounds)\n                break;\n        }\n  end:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/tactic/bv/bit_blaster_model_converter.cpp#94:5#bit_blaster_model_converter::mk_bvs",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int util;\n    int val;\n    int two;\n    unsigned int sz;\n    for (unsigned int i = 0; i < sz; i++) {\n        int *new_val;\n        if (<recovery-expr>()) {\n            continue;\n        }\n        int *bs;\n        <recovery-expr>().reset();\n        unsigned int bv_sz = to_app(<recovery-expr>())->get_num_args();\n        if (TO_BOOL) {\n            unsigned int j = bv_sz;\n            while (j > 0)\n                {\n                    --j;\n                    <recovery-expr>() *= <recovery-expr>();\n                    int *bit;\n                    SASSERT(is_uninterp_const(<recovery-expr>()));\n                    int *bit_decl;\n                    int *bit_val;\n                    if (<recovery-expr>())\n                        goto bail;\n                    if (<recovery-expr>())\n                        <recovery-expr>()++;\n                }\n        } else {\n            for (unsigned int j = 0; j < bv_sz; j++) {\n                <recovery-expr>() *= <recovery-expr>();\n                int *bit;\n                SASSERT(<recovery-expr>().is_bv(<recovery-expr>()));\n                SASSERT(<recovery-expr>().get_bv_size(<recovery-expr>()) == 1);\n                SASSERT(is_uninterp_const(<recovery-expr>()));\n                int *bit_decl;\n                int *bit_val;\n                if (<recovery-expr>() && !<recovery-expr>().is_one(<recovery-expr>()) && !<recovery-expr>().is_zero(<recovery-expr>()))\n                    goto bail;\n                if (<recovery-expr>() && <recovery-expr>().is_one(<recovery-expr>()))\n                    <recovery-expr>()++;\n            }\n        }\n        <recovery-expr>() = <recovery-expr>().mk_numeral(<recovery-expr>(), bv_sz);\n        continue;\n      bail:\n        int vals;\n        if (TO_BOOL)\n            <recovery-expr>() = <recovery-expr>().mk_bv(<recovery-expr>().size(), <recovery-expr>().data());\n        else\n            <recovery-expr>() = <recovery-expr>().mk_concat(<recovery-expr>());\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/z3/src/ast/ast_lt.cpp#58:1#lt",
    "gotos": 11,
    "labels": 1,
    "body": "{\n    unsigned int num;\n  start:\n    if (<recovery-expr>() == <recovery-expr>())\n        return false;\n    if (<recovery-expr>()->get_kind() != <recovery-expr>()->get_kind())\n        return <recovery-expr>()->get_kind() < <recovery-expr>()->get_kind();\n    switch (<recovery-expr>()->get_kind()) {\n        if (to_sort(<recovery-expr>())->get_num_parameters() != to_sort(<recovery-expr>())->get_num_parameters())\n            return to_sort(<recovery-expr>())->get_num_parameters() < to_sort(<recovery-expr>())->get_num_parameters();\n        num = to_sort(<recovery-expr>())->get_num_parameters();\n        <recovery-expr>(SASSERT, num > 0);\n        for (unsigned int i = 0; i < num; i++) {\n            int p1;\n            int p2;\n            {\n                if (<recovery-expr>().get_kind() != <recovery-expr>().get_kind())\n                    return <recovery-expr>().get_kind() < <recovery-expr>().get_kind();\n                switch (<recovery-expr>().get_kind()) {\n                    if (<recovery-expr>().get_int() != <recovery-expr>().get_int())\n                        return <recovery-expr>().get_int() < <recovery-expr>().get_int();\n                    break;\n                    if (<recovery-expr>().get_ast() != <recovery-expr>().get_ast()) {\n                        <recovery-expr>() = <recovery-expr>().get_ast();\n                        <recovery-expr>() = <recovery-expr>().get_ast();\n                        goto start;\n                    }\n                    ;\n                    break;\n                    break;\n                    if (<recovery-expr>().get_rational() != <recovery-expr>().get_rational())\n                        return <recovery-expr>().get_rational() < <recovery-expr>().get_rational();\n                    break;\n                    if (<recovery-expr>().get_double() != <recovery-expr>().get_double())\n                        return <recovery-expr>().get_double() < <recovery-expr>().get_double();\n                    break;\n                    if (<recovery-expr>().get_ext_id() != <recovery-expr>().get_ext_id())\n                        return <recovery-expr>().get_ext_id() < <recovery-expr>().get_ext_id();\n                    break;\n                    if (<recovery-expr>().get_zstring() != <recovery-expr>().get_zstring())\n                        return <recovery-expr>().get_zstring() < <recovery-expr>().get_zstring();\n                    break;\n                  default:\n                    <recovery-expr>(UNREACHABLE);\n                    break;\n                }\n            }\n            ;\n        }\n        <recovery-expr>(UNREACHABLE);\n        return false;\n        if (to_func_decl(<recovery-expr>())->get_arity() != to_func_decl(<recovery-expr>())->get_arity())\n            return to_func_decl(<recovery-expr>())->get_arity() < to_func_decl(<recovery-expr>())->get_arity();\n        if (to_func_decl(<recovery-expr>())->get_num_parameters() != to_func_decl(<recovery-expr>())->get_num_parameters())\n            return to_func_decl(<recovery-expr>())->get_num_parameters() < to_func_decl(<recovery-expr>())->get_num_parameters();\n        num = to_func_decl(<recovery-expr>())->get_num_parameters();\n        for (unsigned int i = 0; i < num; i++) {\n            int p1;\n            int p2;\n            {\n                if (<recovery-expr>().get_kind() != <recovery-expr>().get_kind())\n                    return <recovery-expr>().get_kind() < <recovery-expr>().get_kind();\n                switch (<recovery-expr>().get_kind()) {\n                    if (<recovery-expr>().get_int() != <recovery-expr>().get_int())\n                        return <recovery-expr>().get_int() < <recovery-expr>().get_int();\n                    break;\n                    if (<recovery-expr>().get_ast() != <recovery-expr>().get_ast()) {\n                        <recovery-expr>() = <recovery-expr>().get_ast();\n                        <recovery-expr>() = <recovery-expr>().get_ast();\n                        goto start;\n                    }\n                    ;\n                    break;\n                    break;\n                    if (<recovery-expr>().get_rational() != <recovery-expr>().get_rational())\n                        return <recovery-expr>().get_rational() < <recovery-expr>().get_rational();\n                    break;\n                    if (<recovery-expr>().get_double() != <recovery-expr>().get_double())\n                        return <recovery-expr>().get_double() < <recovery-expr>().get_double();\n                    break;\n                    if (<recovery-expr>().get_ext_id() != <recovery-expr>().get_ext_id())\n                        return <recovery-expr>().get_ext_id() < <recovery-expr>().get_ext_id();\n                    break;\n                    if (<recovery-expr>().get_zstring() != <recovery-expr>().get_zstring())\n                        return <recovery-expr>().get_zstring() < <recovery-expr>().get_zstring();\n                    break;\n                  default:\n                    <recovery-expr>(UNREACHABLE);\n                    break;\n                }\n            }\n            ;\n        }\n        num = to_func_decl(<recovery-expr>())->get_arity();\n        for (unsigned int i = 0; i < num; i++) {\n            int *d1;\n            int *d2;\n            if (<recovery-expr>() != <recovery-expr>()) {\n                <recovery-expr>() = <recovery-expr>();\n                <recovery-expr>() = <recovery-expr>();\n                goto start;\n            }\n            ;\n        }\n        <recovery-expr>() = to_func_decl(<recovery-expr>())->get_range();\n        <recovery-expr>() = to_func_decl(<recovery-expr>())->get_range();\n        goto start;\n        if (to_app(<recovery-expr>())->get_num_args() != to_app(<recovery-expr>())->get_num_args())\n            return to_app(<recovery-expr>())->get_num_args() < to_app(<recovery-expr>())->get_num_args();\n        if (to_app(<recovery-expr>())->get_depth() != to_app(<recovery-expr>())->get_depth())\n            return to_app(<recovery-expr>())->get_depth() < to_app(<recovery-expr>())->get_depth();\n        if (to_app(<recovery-expr>())->get_decl() != to_app(<recovery-expr>())->get_decl()) {\n            <recovery-expr>() = to_app(<recovery-expr>())->get_decl();\n            <recovery-expr>() = to_app(<recovery-expr>())->get_decl();\n            goto start;\n        }\n        ;\n        num = to_app(<recovery-expr>())->get_num_args();\n        for (unsigned int i = 0; i < num; i++) {\n            int *arg1;\n            int *arg2;\n            if (<recovery-expr>() != <recovery-expr>()) {\n                <recovery-expr>() = <recovery-expr>();\n                <recovery-expr>() = <recovery-expr>();\n                goto start;\n            }\n            ;\n        }\n        <recovery-expr>(UNREACHABLE);\n        return false;\n        if (to_quantifier(<recovery-expr>())->get_kind() != to_quantifier(<recovery-expr>())->get_kind())\n            return to_quantifier(<recovery-expr>())->get_kind() < to_quantifier(<recovery-expr>())->get_kind();\n        if (to_quantifier(<recovery-expr>())->get_num_decls() != to_quantifier(<recovery-expr>())->get_num_decls())\n            return to_quantifier(<recovery-expr>())->get_num_decls() < to_quantifier(<recovery-expr>())->get_num_decls();\n        if (to_quantifier(<recovery-expr>())->get_num_patterns() != to_quantifier(<recovery-expr>())->get_num_patterns())\n            return to_quantifier(<recovery-expr>())->get_num_patterns() < to_quantifier(<recovery-expr>())->get_num_patterns();\n        if (to_quantifier(<recovery-expr>())->get_num_no_patterns() != to_quantifier(<recovery-expr>())->get_num_no_patterns())\n            return to_quantifier(<recovery-expr>())->get_num_no_patterns() < to_quantifier(<recovery-expr>())->get_num_no_patterns();\n        if (to_quantifier(<recovery-expr>())->get_weight() != to_quantifier(<recovery-expr>())->get_weight())\n            return to_quantifier(<recovery-expr>())->get_weight() < to_quantifier(<recovery-expr>())->get_weight();\n        num = to_quantifier(<recovery-expr>())->get_num_decls();\n        for (unsigned int i = 0; i < num; i++) {\n            if (to_quantifier(<recovery-expr>())->get_decl_sort(i) != to_quantifier(<recovery-expr>())->get_decl_sort(i)) {\n                <recovery-expr>() = to_quantifier(<recovery-expr>())->get_decl_sort(i);\n                <recovery-expr>() = to_quantifier(<recovery-expr>())->get_decl_sort(i);\n                goto start;\n            }\n            ;\n        }\n        num = to_quantifier(<recovery-expr>())->get_num_patterns();\n        for (unsigned int i = 0; i < num; i++) {\n            if (to_quantifier(<recovery-expr>())->get_pattern(i) != to_quantifier(<recovery-expr>())->get_pattern(i)) {\n                <recovery-expr>() = to_quantifier(<recovery-expr>())->get_pattern(i);\n                <recovery-expr>() = to_quantifier(<recovery-expr>())->get_pattern(i);\n                goto start;\n            }\n            ;\n        }\n        num = to_quantifier(<recovery-expr>())->get_num_no_patterns();\n        for (unsigned int i = 0; i < num; i++) {\n            if (to_quantifier(<recovery-expr>())->get_no_pattern(i) != to_quantifier(<recovery-expr>())->get_no_pattern(i)) {\n                <recovery-expr>() = to_quantifier(<recovery-expr>())->get_no_pattern(i);\n                <recovery-expr>() = to_quantifier(<recovery-expr>())->get_no_pattern(i);\n                goto start;\n            }\n            ;\n        }\n        <recovery-expr>() = to_quantifier(<recovery-expr>())->get_expr();\n        <recovery-expr>() = to_quantifier(<recovery-expr>())->get_expr();\n        goto start;\n        if (to_var(<recovery-expr>())->get_idx() != to_var(<recovery-expr>())->get_idx())\n            return to_var(<recovery-expr>())->get_idx() < to_var(<recovery-expr>())->get_idx();\n        <recovery-expr>() = to_var(<recovery-expr>())->get_sort();\n        <recovery-expr>() = to_var(<recovery-expr>())->get_sort();\n        goto start;\n      default:\n        <recovery-expr>(UNREACHABLE);\n        return false;\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/encoding.c#2619:1#xmlCharEncOutFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int ret;\n    int written;\n    int writtentot = 0;\n    int toconv;\n    if (<recovery-expr>())\n        return (-1);\n    if (<recovery-expr>())\n        return (-1);\n  retry:\n    written = <recovery-expr>()->size - <recovery-expr>()->use;\n    if (written > 0)\n        written--;\n    if (<recovery-expr>()) {\n        toconv = 0;\n        <recovery-expr>()->use += written;\n        <recovery-expr>()->content[<recovery-expr>()->use] = 0;\n        return (0);\n    }\n    toconv = <recovery-expr>()->use;\n    if (toconv == 0)\n        return (0);\n    if (toconv * 4 >= written) {\n        xmlBufferGrow(<recovery-expr>(), toconv * 4);\n        written = <recovery-expr>()->size - <recovery-expr>()->use - 1;\n    }\n    ret = <recovery-expr>()(<recovery-expr>(), &<recovery-expr>()->content[<recovery-expr>()->use], &written, <recovery-expr>()->content, &toconv);\n    xmlBufferShrink(<recovery-expr>(), toconv);\n    <recovery-expr>()->use += written;\n    writtentot += written;\n    <recovery-expr>()->content[<recovery-expr>()->use] = 0;\n    if (ret == -1) {\n        if (written > 0) {\n            goto retry;\n        }\n        ret = -3;\n    }\n    switch (ret) {\n      case 0:\n        break;\n      case -1:\n        break;\n      case -3:\n        break;\n      case -4:\n        ;\n        ret = -1;\n        break;\n      case -2:\n        {\n            int len = <recovery-expr>()->use;\n            const int *utf;\n            int cur, charrefLen;\n            cur = xmlGetUTF8Char(<recovery-expr>(), &len);\n            if (cur <= 0)\n                break;\n            xmlBufferShrink(<recovery-expr>(), len);\n            xmlBufferGrow(<recovery-expr>(), charrefLen * 4);\n            written = <recovery-expr>()->size - <recovery-expr>()->use - 1;\n            toconv = charrefLen;\n            if ((ret < 0) || (toconv != charrefLen)) {\n                char buf[50];\n                snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\", <recovery-expr>()->content[0], <recovery-expr>()->content[1], <recovery-expr>()->content[2], <recovery-expr>()->content[3]);\n                buf[49] = 0;\n                if (<recovery-expr>())\n                    <recovery-expr>()->content[0] = ' ';\n                break;\n            }\n            <recovery-expr>()->use += written;\n            writtentot += written;\n            <recovery-expr>()->content[<recovery-expr>()->use] = 0;\n            goto retry;\n        }\n    }\n    return (writtentot ? writtentot : ret);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/encoding.c#1509:1#xmlRegisterCharEncodingHandler",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>())\n        xmlInitCharEncodingHandlers();\n    if (<recovery-expr>()) {\n        goto free_handler;\n    }\n    if (nbCharEncodingHandler >= 50) {\n        goto free_handler;\n    }\n    return;\n  free_handler:\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            xmlFree(<recovery-expr>()->name);\n        }\n        xmlFree(<recovery-expr>());\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/xpath.c#159:1#xmlXPathCmpNodesExt",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int depth1, depth2;\n    int misc = 0, precedence1 = 0, precedence2 = 0;\n    if (<recovery-expr>())\n        return (-2);\n    if (<recovery-expr>() == <recovery-expr>())\n        return (0);\n    switch (<recovery-expr>()->type) {\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    return (1);\n                if (<recovery-expr>())\n                    return (-1);\n            } else\n                goto turtle_comparison;\n        }\n        break;\n        precedence1 = 1;\n        <recovery-expr>() = <recovery-expr>()->parent;\n        misc = 1;\n        break;\n        {\n            if (<recovery-expr>()) {\n                do {\n                    <recovery-expr>() = <recovery-expr>()->prev;\n                    if (<recovery-expr>()) {\n                        precedence1 = 3;\n                        break;\n                    }\n                    if (<recovery-expr>()) {\n                        precedence1 = 2;\n                        <recovery-expr>() = <recovery-expr>()->parent;\n                        break;\n                    }\n                } while (1);\n            } else {\n                precedence1 = 2;\n                <recovery-expr>() = <recovery-expr>()->parent;\n            }\n            if (<recovery-expr>()) {\n                precedence1 = 0;\n            } else\n                misc = 1;\n        }\n        break;\n        return (1);\n      default:\n        break;\n    }\n    switch (<recovery-expr>()->type) {\n        break;\n        precedence2 = 1;\n        <recovery-expr>() = <recovery-expr>()->parent;\n        misc = 1;\n        break;\n        {\n            if (<recovery-expr>()) {\n                do {\n                    <recovery-expr>() = <recovery-expr>()->prev;\n                    if (<recovery-expr>()) {\n                        precedence2 = 3;\n                        break;\n                    }\n                    if (<recovery-expr>()) {\n                        precedence2 = 2;\n                        <recovery-expr>() = <recovery-expr>()->parent;\n                        break;\n                    }\n                } while (1);\n            } else {\n                precedence2 = 2;\n                <recovery-expr>() = <recovery-expr>()->parent;\n            }\n            if (<recovery-expr>()) {\n                precedence2 = 0;\n            } else\n                misc = 1;\n        }\n        break;\n        return (1);\n      default:\n        break;\n    }\n    if (misc) {\n        if (<recovery-expr>() == <recovery-expr>()) {\n            if (precedence1 == precedence2) {\n                while (<recovery-expr>())\n                    {\n                        if (<recovery-expr>())\n                            return (1);\n                        if (<recovery-expr>())\n                            return (-1);\n                    }\n                return (-1);\n            } else {\n                if (precedence1 < precedence2)\n                    return (1);\n                else\n                    return (-1);\n            }\n        }\n        if ((precedence2 == 3) && (precedence1 > 1)) {\n            while (<recovery-expr>())\n                {\n                    if (<recovery-expr>())\n                        return (1);\n                }\n        }\n        if ((precedence1 == 3) && (precedence2 > 1)) {\n            while (<recovery-expr>())\n                {\n                    if (<recovery-expr>())\n                        return (-1);\n                }\n        }\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            return (1);\n        if (<recovery-expr>())\n            return (-1);\n    }\n  turtle_comparison:\n    if (<recovery-expr>() == <recovery-expr>()->prev)\n        return (1);\n    if (<recovery-expr>() == <recovery-expr>()->next)\n        return (-1);\n    if (<recovery-expr>()) {\n        return (-2);\n    }\n    while (depth1 > depth2)\n        {\n            depth1--;\n            <recovery-expr>() = <recovery-expr>()->parent;\n        }\n    while (depth2 > depth1)\n        {\n            depth2--;\n            <recovery-expr>() = <recovery-expr>()->parent;\n        }\n    while (<recovery-expr>()->parent != <recovery-expr>()->parent)\n        {\n            <recovery-expr>() = <recovery-expr>()->parent;\n            <recovery-expr>() = <recovery-expr>()->parent;\n            if (<recovery-expr>())\n                return (-2);\n        }\n    if (<recovery-expr>() == <recovery-expr>()->prev)\n        return (1);\n    if (<recovery-expr>() == <recovery-expr>()->next)\n        return (-1);\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            return (1);\n        if (<recovery-expr>())\n            return (-1);\n    }\n    return (-1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/xmlmemory.c#311:1#xmlReallocLoc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    MEMHDR *p, *tmp;\n    unsigned long number;\n    if (<recovery-expr>())\n        return (<recovery-expr>()(<recovery-expr>(), file, line));\n    if (!xmlMemInitialized)\n        xmlInitMemory();\n    p = ((void *)(((char *)(ptr)) - (((sizeof(MEMHDR) + (sizeof(double) - 1)) / sizeof(double)) * sizeof(double))));\n    number = p->mh_number;\n    if (xmlMemStopAtBlock == number)\n        xmlMallocBreakpoint();\n    if (p->mh_tag != 23205U) {\n        debugmem_tag_error(p);\n        ;\n        goto error;\n    }\n    p->mh_tag = ~23205U;\n    xmlMutexLock(<recovery-expr>());\n    debugMemSize -= <recovery-expr>(p);\n    debugMemBlocks--;\n    xmlMutexUnlock(<recovery-expr>());\n    if (<recovery-expr>()) {\n        xmlMemoryDump();\n    }\n    tmp = (MEMHDR *)realloc(p, (((sizeof(MEMHDR) + (sizeof(double) - 1)) / sizeof(double)) * sizeof(double)) + <recovery-expr>());\n    if (!tmp) {\n        free(p);\n        goto error;\n    }\n    p = tmp;\n    if (xmlMemTraceBlockAt == ptr) {\n        xmlMallocBreakpoint();\n    }\n    p->mh_tag = 23205U;\n    p->mh_number = number;\n    p->mh_type = 2;\n    <recovery-expr>(p) = <recovery-expr>();\n    p->mh_file = file;\n    p->mh_line = line;\n    xmlMutexLock(<recovery-expr>());\n    debugMemSize += <recovery-expr>();\n    debugMemBlocks++;\n    if (debugMemSize > debugMaxMemSize)\n        debugMaxMemSize = debugMemSize;\n    xmlMutexUnlock(<recovery-expr>());\n    return (((void *)(((char *)(p)) + (((sizeof(MEMHDR) + (sizeof(double) - 1)) / sizeof(double)) * sizeof(double)))));\n  error:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/xmlmemory.c#489:1#xmlMemStrdupLoc",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    char *s;\n    MEMHDR *p;\n    if (!xmlMemInitialized)\n        xmlInitMemory();\n    if (<recovery-expr>()) {\n        xmlMemoryDump();\n    }\n    if (!p) {\n        goto error;\n    }\n    p->mh_tag = 23205U;\n    p->mh_type = 3;\n    p->mh_file = file;\n    p->mh_line = line;\n    xmlMutexLock(<recovery-expr>());\n    p->mh_number = ++block;\n    debugMemBlocks++;\n    if (debugMemSize > debugMaxMemSize)\n        debugMaxMemSize = debugMemSize;\n    xmlMutexUnlock(<recovery-expr>());\n    s = (char *)((void *)(((char *)(p)) + (((sizeof(MEMHDR) + (sizeof(double) - 1)) / sizeof(double)) * sizeof(double))));\n    if (xmlMemStopAtBlock == p->mh_number)\n        xmlMallocBreakpoint();\n    strcpy(s, str);\n    if (xmlMemTraceBlockAt == s) {\n        xmlMallocBreakpoint();\n    }\n    return (s);\n  error:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/xmlmemory.c#413:1#xmlMemFree",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    MEMHDR *p;\n    char *target;\n    if (<recovery-expr>())\n        return;\n    if (ptr == (void *)-1) {\n        goto error;\n    }\n    if (xmlMemTraceBlockAt == ptr) {\n        xmlMallocBreakpoint();\n    }\n    target = (char *)ptr;\n    p = ((void *)(((char *)(ptr)) - (((sizeof(MEMHDR) + (sizeof(double) - 1)) / sizeof(double)) * sizeof(double))));\n    if (p->mh_tag != 23205U) {\n        debugmem_tag_error(p);\n        ;\n        goto error;\n    }\n    if (xmlMemStopAtBlock == p->mh_number)\n        xmlMallocBreakpoint();\n    p->mh_tag = ~23205U;\n    memset(target, -1, <recovery-expr>(p));\n    xmlMutexLock(<recovery-expr>());\n    debugMemSize -= <recovery-expr>(p);\n    debugMemBlocks--;\n    xmlMutexUnlock(<recovery-expr>());\n    free(p);\n    return;\n  error:\n    ;\n    xmlMallocBreakpoint();\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/dict.c#245:1#xmlDictAddString",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    xmlDictStringsPtr pool;\n    const int *ret;\n    pool = <recovery-expr>()->strings;\n    while (<recovery-expr>())\n        {\n            if (<recovery-expr>())\n                goto found_pool;\n            pool = pool->next;\n        }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n        }\n        <recovery-expr>(pool) = 0;\n        <recovery-expr>(pool) = &<recovery-expr>(pool)[0];\n        pool->next = <recovery-expr>()->strings;\n        <recovery-expr>()->strings = pool;\n    }\n  found_pool:\n    <recovery-expr>() = <recovery-expr>(pool);\n    memcpy(<recovery-expr>(pool), <recovery-expr>(), namelen);\n    <recovery-expr>(pool) += namelen;\n    *(<recovery-expr>(pool)++) = 0;\n    <recovery-expr>(pool)++;\n    return (<recovery-expr>());\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/dict.c#309:1#xmlDictAddQString",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    xmlDictStringsPtr pool;\n    const int *ret;\n    if (<recovery-expr>())\n        return (<recovery-expr>()(<recovery-expr>(), <recovery-expr>(), namelen));\n    pool = <recovery-expr>()->strings;\n    while (<recovery-expr>())\n        {\n            if (<recovery-expr>())\n                goto found_pool;\n            pool = pool->next;\n        }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n        }\n        <recovery-expr>(pool) = 0;\n        <recovery-expr>(pool) = &<recovery-expr>(pool)[0];\n        pool->next = <recovery-expr>()->strings;\n        <recovery-expr>()->strings = pool;\n    }\n  found_pool:\n    <recovery-expr>() = <recovery-expr>(pool);\n    memcpy(<recovery-expr>(pool), <recovery-expr>(), plen);\n    <recovery-expr>(pool) += plen;\n    *(<recovery-expr>(pool)++) = ':';\n    memcpy(<recovery-expr>(pool), <recovery-expr>(), namelen);\n    <recovery-expr>(pool) += namelen;\n    *(<recovery-expr>(pool)++) = 0;\n    <recovery-expr>(pool)++;\n    return (<recovery-expr>());\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/xmllint.c#3080:1#main",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int i, acount;\n    int files = 0;\n    int version = 0;\n    const char *indent;\n    if (argc <= 1) {\n        return (XMLLINT_ERR_UNCLASS);\n    }\n    for (i = 1; i < argc; i++) {\n        if (argv[i][0] != '-')\n            continue;\n        if ((!strcmp(argv[i], \"-maxmem\")) || (!strcmp(argv[i], \"--maxmem\"))) {\n            i++;\n            if ((i >= argc) || (sscanf(argv[i], \"%d\", &maxmem) != 1)) {\n                maxmem = 0;\n            }\n        }\n    }\n    if (maxmem != 0)\n        xmlMemSetup(myFreeFunc, <recovery-expr>(), <recovery-expr>(), myStrdupFunc);\n    if (<recovery-expr>()) {\n    }\n    <recovery-expr>() = xmlGetExternalEntityLoader();\n    xmlSetExternalEntityLoader(<recovery-expr>());\n    if ((htmlout) && (!nowrap)) {\n    }\n    for (i = 1; i < argc; i++) {\n        if ((!strcmp(argv[i], \"-encode\")) || (!strcmp(argv[i], \"--encode\"))) {\n            i++;\n            continue;\n        } else if ((!strcmp(argv[i], \"-o\")) || (!strcmp(argv[i], \"-output\")) || (!strcmp(argv[i], \"--output\"))) {\n            i++;\n            continue;\n        }\n        if ((!strcmp(argv[i], \"-relaxng\")) || (!strcmp(argv[i], \"--relaxng\"))) {\n            i++;\n            continue;\n        }\n        if ((!strcmp(argv[i], \"-maxmem\")) || (!strcmp(argv[i], \"--maxmem\"))) {\n            i++;\n            continue;\n        }\n        if ((!strcmp(argv[i], \"-pretty\")) || (!strcmp(argv[i], \"--pretty\"))) {\n            i++;\n            continue;\n        }\n        if ((!strcmp(argv[i], \"-schema\")) || (!strcmp(argv[i], \"--schema\"))) {\n            i++;\n            continue;\n        }\n        if ((!strcmp(argv[i], \"-schematron\")) || (!strcmp(argv[i], \"--schematron\"))) {\n            i++;\n            continue;\n        }\n        if ((timing) && (repeat))\n            startTimer();\n        if ((argv[i][0] != '-') || (strcmp(argv[i], \"-\") == 0)) {\n            if (repeat) {\n                for (acount = 0; acount < repeat; acount++) {\n                    if (sax) {\n                        testSAX(argv[i]);\n                    } else {\n                    }\n                }\n            } else {\n                nbregister = 0;\n                if (sax) {\n                    testSAX(argv[i]);\n                } else {\n                }\n                if ((chkregister) && (nbregister != 0)) {\n                    progresult = XMLLINT_ERR_RDREGIS;\n                }\n            }\n            files++;\n            if ((timing) && (repeat)) {\n                endTimer(\"%d iterations\", repeat);\n            }\n        }\n    }\n    if ((htmlout) && (!nowrap)) {\n    }\n    if ((files == 0) && (!generate) && (version == 0)) {\n        progresult = XMLLINT_ERR_UNCLASS;\n    }\n    goto error;\n  error:\n    xmlCleanupParser();\n    xmlMemoryDump();\n    return (progresult);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#10010:1#xmlDOMWrapAdoptAttr",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    int adoptStr = 1;\n    if (<recovery-expr>())\n        return (-1);\n    <recovery-expr>()->doc = <recovery-expr>();\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n        }\n        if (<recovery-expr>()) {\n        } else if (<recovery-expr>()) {\n        } else {\n            if (<recovery-expr>())\n                goto internal_error;\n            if (<recovery-expr>()) {\n            }\n        }\n        if (<recovery-expr>())\n            goto internal_error;\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()->dict) {\n            const int *old;\n            <recovery-expr>()->name = xmlDictLookup(<recovery-expr>()->dict, <recovery-expr>()->name, -1);\n            if (<recovery-expr>())\n                xmlFree((char *)<recovery-expr>());\n        } else if ((<recovery-expr>()) && (<recovery-expr>()->dict) && xmlDictOwns(<recovery-expr>()->dict, <recovery-expr>()->name)) {\n        }\n    }\n    ;\n    <recovery-expr>()->atype = 0;\n    if (<recovery-expr>())\n        return (0);\n    if (<recovery-expr>())\n        goto internal_error;\n    while (<recovery-expr>())\n        {\n            switch (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                }\n                break;\n                if ((<recovery-expr>()->intSubset) || (<recovery-expr>()->extSubset)) {\n                    if (<recovery-expr>()) {\n                    }\n                }\n                break;\n              default:\n                break;\n            }\n            if (<recovery-expr>()) {\n                continue;\n            }\n          next_sibling:\n            if (<recovery-expr>())\n                break;\n            if (<recovery-expr>())\n                ;\n            else {\n                goto next_sibling;\n            }\n        }\n    return (0);\n  internal_error:\n    return (-1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#9114:1#xmlDOMWrapAdoptBranch",
    "gotos": 13,
    "labels": 4,
    "body": "{\n    int ret = 0;\n    xmlNsMapPtr nsMap;\n    xmlNsMapItemPtr mi;\n    int depth = -1, adoptStr = 1;\n    int parnsdone;\n    int ancestorsOnly = 0;\n    if (<recovery-expr>())\n        adoptStr = 0;\n    else\n        adoptStr = 1;\n    if (<recovery-expr>())\n        nsMap = (xmlNsMapPtr)<recovery-expr>()->namespaceMap;\n    if (<recovery-expr>()) {\n        parnsdone = 1;\n    } else\n        parnsdone = 0;\n    if (<recovery-expr>())\n        goto internal_error;\n    while (<recovery-expr>())\n        {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    goto leave_node;\n                do {\n                    if (<recovery-expr>())\n                        break;\n                } while (<recovery-expr>());\n                if (<recovery-expr>())\n                    goto leave_node;\n            }\n            switch (<recovery-expr>()) {\n                return (-1);\n                depth++;\n                if (<recovery-expr>()) {\n                    if (!parnsdone) {\n                        if (<recovery-expr>()(&nsMap, <recovery-expr>()) == -1)\n                            goto internal_error;\n                        parnsdone = 1;\n                    }\n                }\n                if (<recovery-expr>())\n                    goto ns_end;\n                if (!parnsdone) {\n                    if (<recovery-expr>()(&nsMap, <recovery-expr>()) == -1)\n                        goto internal_error;\n                    parnsdone = 1;\n                }\n                if (<recovery-expr>()) {\n                }\n                if ((<recovery-expr>()) && (<recovery-expr>()->getNsForNodeFunc)) {\n                    if (<recovery-expr>())\n                        goto internal_error;\n                } else {\n                    if (<recovery-expr>())\n                        goto internal_error;\n                }\n              ns_end:\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()->dict) {\n                        const int *old;\n                        if (<recovery-expr>())\n                            xmlFree((char *)<recovery-expr>());\n                    } else if (<recovery-expr>()) {\n                    }\n                }\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                        continue;\n                    }\n                } else {\n                    if (<recovery-expr>()) {\n                    }\n                }\n                break;\n                if (<recovery-expr>()) {\n                }\n                goto leave_node;\n                if ((<recovery-expr>()->intSubset) || (<recovery-expr>()->extSubset)) {\n                    if (<recovery-expr>()) {\n                    }\n                }\n                goto leave_node;\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()->dict) {\n                        const int *old;\n                        if (<recovery-expr>())\n                            xmlFree((char *)<recovery-expr>());\n                    } else if (<recovery-expr>()) {\n                    }\n                }\n                if (<recovery-expr>()) {\n                }\n                break;\n                break;\n              default:\n                goto internal_error;\n            }\n            if (<recovery-expr>()) {\n                continue;\n            }\n          leave_node:\n            if (<recovery-expr>())\n                break;\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    while (<recovery-expr>())\n                        {\n                            mi = (nsMap)->last;\n                            (nsMap)->last = (mi)->prev;\n                            (mi)->next = (nsMap)->pool;\n                            (nsMap)->pool = mi;\n                        }\n                }\n                depth--;\n            }\n            if (<recovery-expr>())\n                ;\n            else if (<recovery-expr>()) {\n            } else {\n                goto leave_node;\n            }\n        }\n    goto exit;\n  internal_error:\n    ret = -1;\n  exit:\n    if (<recovery-expr>()) {\n        if ((<recovery-expr>()) && (<recovery-expr>()->namespaceMap == nsMap)) {\n            if (nsMap->first) {\n                if (nsMap->pool)\n                    nsMap->last->next = nsMap->pool;\n                nsMap->pool = nsMap->first;\n            }\n        } else\n            xmlDOMWrapNsMapFree(nsMap);\n    }\n    return (ret);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#8851:1#xmlDOMWrapReconcileNamespaces",
    "gotos": 10,
    "labels": 6,
    "body": "{\n    int depth = -1, adoptns = 0, parnsdone = 0;\n    xmlNsMapPtr nsMap;\n    xmlNsMapItemPtr mi;\n    int ancestorsOnly = 0;\n    int optRemoveRedundantNS;\n    int sizeRedund = 0, nbRedund = 0, ret, i, j;\n    if (<recovery-expr>())\n        return (-1);\n    do {\n        switch (<recovery-expr>()) {\n            adoptns = 1;\n            depth++;\n            if (<recovery-expr>()) {\n                while (<recovery-expr>())\n                    {\n                        if (!parnsdone) {\n                            if (<recovery-expr>()) {\n                                if (<recovery-expr>())\n                                    goto internal_error;\n                            }\n                            parnsdone = 1;\n                        }\n                        if (<recovery-expr>()) {\n                        }\n                        if (<recovery-expr>())\n                            adoptns = 0;\n                        if (<recovery-expr>()) {\n                        }\n                        if (<recovery-expr>())\n                            goto internal_error;\n                      next_ns_decl:\n                        ;\n                    }\n            }\n            if (!adoptns)\n                goto ns_end;\n            if (<recovery-expr>())\n                goto ns_end;\n            if (!parnsdone) {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>())\n                        goto internal_error;\n                }\n                parnsdone = 1;\n            }\n            if (<recovery-expr>()) {\n                for (i = 0 , j = 0; i < nbRedund; i++ , j += 2) {\n                    if (<recovery-expr>()) {\n                        break;\n                    }\n                }\n            }\n            if (<recovery-expr>()) {\n            }\n            if (<recovery-expr>())\n                goto internal_error;\n          ns_end:\n            if (<recovery-expr>()) {\n                continue;\n            }\n            break;\n          default:\n            goto next_sibling;\n        }\n      into_content:\n        if (<recovery-expr>()) {\n            continue;\n        }\n      next_sibling:\n        if (<recovery-expr>())\n            break;\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n                while (<recovery-expr>())\n                    {\n                        mi = (nsMap)->last;\n                        (nsMap)->last = (mi)->prev;\n                        (mi)->next = (nsMap)->pool;\n                        (nsMap)->pool = mi;\n                    }\n            }\n            depth--;\n        }\n        if (<recovery-expr>())\n            ;\n        else {\n            if (<recovery-expr>()) {\n                goto into_content;\n            }\n            goto next_sibling;\n        }\n    } while (<recovery-expr>());\n    ret = 0;\n    goto exit;\n  internal_error:\n    ret = -1;\n  exit:\n    if (<recovery-expr>()) {\n        for (i = 0 , j = 0; i < nbRedund; i++ , j += 2) {\n        }\n    }\n    if (<recovery-expr>())\n        xmlDOMWrapNsMapFree(nsMap);\n    return (ret);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#8630:1#xmlDOMWrapNSNormDeclareNsForced",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    char buf[50];\n    const int *pref;\n    int counter = 0;\n    <recovery-expr>() = <recovery-expr>();\n    while (1)\n        {\n            if (<recovery-expr>())\n                goto ns_next_prefix;\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    goto ns_next_prefix;\n            }\n            if (<recovery-expr>())\n                ;\n            else {\n            }\n          ns_next_prefix:\n            counter++;\n            if (<recovery-expr>()) {\n                snprintf((char *)buf, sizeof (buf), \"ns_%d\", counter);\n            } else\n                snprintf((char *)buf, sizeof (buf), \"%.30s_%d\", (char *)<recovery-expr>(), counter);\n        }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#8330:1#xmlDOMWrapRemoveNode",
    "gotos": 6,
    "labels": 3,
    "body": "{\n    int sizeList, nbList, i, j;\n    if (<recovery-expr>())\n        return (-1);\n    if (<recovery-expr>())\n        return (0);\n    switch (<recovery-expr>()->type) {\n        <recovery-expr>()(<recovery-expr>());\n        return (0);\n        break;\n      default:\n        return (1);\n    }\n    <recovery-expr>()(<recovery-expr>());\n    do {\n        switch (<recovery-expr>()->type) {\n            if (<recovery-expr>()) {\n                do {\n                    if (<recovery-expr>())\n                        goto internal_error;\n                } while (<recovery-expr>());\n            }\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    for (i = 0 , j = 0; i < nbList; i++ , j += 2) {\n                        if (<recovery-expr>()) {\n                            goto next_node;\n                        }\n                    }\n                }\n                if (<recovery-expr>()) {\n                } else {\n                    if (<recovery-expr>())\n                        goto internal_error;\n                }\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>())\n                        goto internal_error;\n                }\n            }\n            if (<recovery-expr>()) {\n                continue;\n            }\n            break;\n          default:\n            goto next_sibling;\n        }\n      next_node:\n        if (<recovery-expr>()) {\n            <recovery-expr>() = <recovery-expr>()->children;\n            continue;\n        }\n      next_sibling:\n        if (<recovery-expr>())\n            break;\n        if (<recovery-expr>())\n            <recovery-expr>() = <recovery-expr>()->next;\n        else {\n            <recovery-expr>() = <recovery-expr>()->parent;\n            goto next_sibling;\n        }\n    } while (<recovery-expr>());\n    return (0);\n  internal_error:\n    ;\n    return (-1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#1268:1#xmlStringLenGetNodeList",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    const int *cur;\n    const int *q;\n    <recovery-expr>() = <recovery-expr>();\n    <recovery-expr>() = <recovery-expr>();\n    while (<recovery-expr>())\n        {\n            if (<recovery-expr>()[0] == '&') {\n                int charval = 0;\n                if (<recovery-expr>() != <recovery-expr>()) {\n                    if (<recovery-expr>())\n                        goto out;\n                }\n                <recovery-expr>() = <recovery-expr>();\n                if (<recovery-expr>()) {\n                    <recovery-expr>() += 3;\n                    while (<recovery-expr>())\n                        {\n                            if (<recovery-expr>())\n                                ;\n                            else if (<recovery-expr>())\n                                ;\n                            else if (<recovery-expr>())\n                                ;\n                            else {\n                                charval = 0;\n                                break;\n                            }\n                            <recovery-expr>()++;\n                        }\n                    if (<recovery-expr>())\n                        <recovery-expr>()++;\n                    <recovery-expr>() = <recovery-expr>();\n                } else if (<recovery-expr>()) {\n                    <recovery-expr>() += 2;\n                    while (<recovery-expr>())\n                        {\n                            if (<recovery-expr>())\n                                ;\n                            else {\n                                charval = 0;\n                                break;\n                            }\n                            <recovery-expr>()++;\n                        }\n                    if (<recovery-expr>())\n                        <recovery-expr>()++;\n                    <recovery-expr>() = <recovery-expr>();\n                } else {\n                    <recovery-expr>()++;\n                    <recovery-expr>() = <recovery-expr>();\n                    while (<recovery-expr>())\n                        <recovery-expr>()++;\n                    if (<recovery-expr>()) {\n                        goto out;\n                    }\n                    if (<recovery-expr>() != <recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                            if (<recovery-expr>())\n                                goto out;\n                        } else {\n                            if (<recovery-expr>()) {\n                                if (<recovery-expr>()) {\n                                    goto out;\n                                }\n                                if (<recovery-expr>()) {\n                                } else {\n                                }\n                            }\n                            if (<recovery-expr>()) {\n                                goto out;\n                            } else if (<recovery-expr>()) {\n                                while (<recovery-expr>())\n                                    {\n                                    }\n                            }\n                            if (<recovery-expr>()) {\n                            } else {\n                            }\n                        }\n                    }\n                    <recovery-expr>()++;\n                    <recovery-expr>() = <recovery-expr>();\n                }\n                if (charval != 0) {\n                    int l;\n                    if (<recovery-expr>())\n                        goto out;\n                    charval = 0;\n                }\n            } else\n                <recovery-expr>()++;\n        }\n    if (<recovery-expr>() != <recovery-expr>()) {\n        if (<recovery-expr>())\n            goto out;\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            goto out;\n        if (<recovery-expr>()) {\n        } else {\n        }\n    } else if (<recovery-expr>()) {\n    }\n  out:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#4251:1#xmlStaticCopyNode",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    switch (<recovery-expr>()->type) {\n        break;\n    }\n    if (<recovery-expr>()) {\n        xmlTreeErrMemory(\"copying node\");\n    }\n    if (<recovery-expr>()->name == <recovery-expr>())\n        ;\n    else if (<recovery-expr>()->name == <recovery-expr>())\n        ;\n    else if (<recovery-expr>()->name == <recovery-expr>())\n        ;\n    else if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>()) {\n    } else {\n    }\n    if (<recovery-expr>()) {\n    }\n    if (!extended)\n        goto out;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n            } else {\n            }\n        } else {\n        }\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n        } else {\n        }\n    } else if (<recovery-expr>()) {\n        while (<recovery-expr>())\n            {\n                if (<recovery-expr>()) {\n                }\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else {\n                    }\n                }\n                if (<recovery-expr>()) {\n                    continue;\n                }\n                while (1)\n                    {\n                        if (<recovery-expr>()) {\n                            break;\n                        }\n                        if (<recovery-expr>()) {\n                            break;\n                        }\n                    }\n            }\n    }\n  out:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#9482:1#xmlDOMWrapCloneNode",
    "gotos": 20,
    "labels": 5,
    "body": "{\n    int ret = 0;\n    xmlNsMapPtr nsMap;\n    xmlNsMapItemPtr mi;\n    int depth = -1;\n    int parnsdone = 0;\n    int ancestorsOnly = 0;\n    if (<recovery-expr>())\n        return (-1);\n    if (<recovery-expr>())\n        return (1);\n    if (<recovery-expr>()) {\n        return (-1);\n    }\n    if (<recovery-expr>())\n        <recovery-expr>() = <recovery-expr>()->doc;\n    if (<recovery-expr>())\n        return (-1);\n    if (<recovery-expr>())\n        nsMap = (xmlNsMapPtr)<recovery-expr>()->namespaceMap;\n    if (<recovery-expr>())\n        return (-1);\n    while (<recovery-expr>())\n        {\n            if (<recovery-expr>()) {\n                goto internal_error;\n            }\n            switch (<recovery-expr>()) {\n                goto internal_error;\n                break;\n                if (<recovery-expr>()) {\n                    xmlTreeErrMemory(\"xmlDOMWrapCloneNode(): allocating a node\");\n                    goto internal_error;\n                }\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else\n                        ;\n                } else\n                    ;\n                break;\n                if (<recovery-expr>()) {\n                    xmlTreeErrMemory(\"xmlDOMWrapCloneNode(): allocating an attr-node\");\n                    goto internal_error;\n                }\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else\n                        ;\n                } else\n                    ;\n                break;\n              default:\n                goto internal_error;\n            }\n            if (<recovery-expr>())\n                ;\n            else if (<recovery-expr>())\n                ;\n            else if (<recovery-expr>())\n                ;\n            else if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else\n                        ;\n                }\n                ;\n            }\n            switch (<recovery-expr>()) {\n                return (-1);\n                depth++;\n                if (<recovery-expr>()) {\n                    if (!parnsdone) {\n                        if (<recovery-expr>()) {\n                            if (<recovery-expr>()(&nsMap, <recovery-expr>()) == -1)\n                                goto internal_error;\n                        }\n                        parnsdone = 1;\n                    }\n                }\n                break;\n                break;\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else\n                        ;\n                }\n                ;\n                goto leave_node;\n                goto leave_node;\n                if (<recovery-expr>() != <recovery-expr>()) {\n                    if ((<recovery-expr>()->intSubset) || (<recovery-expr>()->extSubset)) {\n                        if (<recovery-expr>()) {\n                        }\n                    }\n                } else {\n                }\n                goto leave_node;\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else\n                        ;\n                }\n                ;\n                goto leave_node;\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else\n                        ;\n                }\n                ;\n                goto leave_node;\n              default:\n                goto internal_error;\n            }\n            if (<recovery-expr>())\n                goto end_ns_reference;\n            if (!parnsdone) {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()(&nsMap, <recovery-expr>()) == -1)\n                        goto internal_error;\n                }\n                parnsdone = 1;\n            }\n            if (<recovery-expr>()) {\n            }\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    goto internal_error;\n            } else {\n                if (<recovery-expr>())\n                    goto internal_error;\n            }\n          end_ns_reference:\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                            goto internal_error;\n                        }\n                    }\n                }\n            }\n            if (<recovery-expr>()) {\n                continue;\n            }\n          into_content:\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    continue;\n                }\n            }\n          leave_node:\n            if (<recovery-expr>())\n                break;\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    while (<recovery-expr>())\n                        {\n                            mi = (nsMap)->last;\n                            (nsMap)->last = (mi)->prev;\n                            (mi)->next = (nsMap)->pool;\n                            (nsMap)->pool = mi;\n                        }\n                }\n                depth--;\n            }\n            if (<recovery-expr>()) {\n            } else if (<recovery-expr>()) {\n                goto leave_node;\n            } else {\n                goto into_content;\n            }\n        }\n    goto exit;\n  internal_error:\n    ret = -1;\n  exit:\n    if (<recovery-expr>()) {\n        if ((<recovery-expr>()) && (<recovery-expr>()->namespaceMap == nsMap)) {\n            if (nsMap->first) {\n                if (nsMap->pool)\n                    nsMap->last->next = nsMap->pool;\n                nsMap->pool = nsMap->first;\n            }\n        } else\n            xmlDOMWrapNsMapFree(nsMap);\n    }\n    return (ret);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/tree.c#1491:1#xmlStringGetNodeList",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    const int *cur;\n    const int *q;\n    <recovery-expr>() = <recovery-expr>();\n    while (*<recovery-expr>() != 0)\n        {\n            if (<recovery-expr>()[0] == '&') {\n                int charval = 0;\n                if (<recovery-expr>() != <recovery-expr>()) {\n                    if (<recovery-expr>())\n                        goto out;\n                }\n                <recovery-expr>() = <recovery-expr>();\n                if ((<recovery-expr>()[1] == '#') && (<recovery-expr>()[2] == 'x')) {\n                    <recovery-expr>() += 3;\n                    while (<recovery-expr>())\n                        {\n                            if (<recovery-expr>())\n                                ;\n                            else if (<recovery-expr>())\n                                ;\n                            else if (<recovery-expr>())\n                                ;\n                            else {\n                                charval = 0;\n                                break;\n                            }\n                            <recovery-expr>()++;\n                        }\n                    if (<recovery-expr>())\n                        <recovery-expr>()++;\n                    <recovery-expr>() = <recovery-expr>();\n                } else if (<recovery-expr>()[1] == '#') {\n                    <recovery-expr>() += 2;\n                    while (<recovery-expr>())\n                        {\n                            if (<recovery-expr>())\n                                ;\n                            else {\n                                charval = 0;\n                                break;\n                            }\n                            <recovery-expr>()++;\n                        }\n                    if (<recovery-expr>())\n                        <recovery-expr>()++;\n                    <recovery-expr>() = <recovery-expr>();\n                } else {\n                    <recovery-expr>()++;\n                    <recovery-expr>() = <recovery-expr>();\n                    while ((*<recovery-expr>() != 0) && (*<recovery-expr>() != ';'))\n                        <recovery-expr>()++;\n                    if (*<recovery-expr>() == 0) {\n                        goto out;\n                    }\n                    if (<recovery-expr>() != <recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                            if (<recovery-expr>())\n                                goto out;\n                        } else {\n                            if (<recovery-expr>()) {\n                                if (<recovery-expr>()) {\n                                    goto out;\n                                }\n                                if (<recovery-expr>()) {\n                                } else {\n                                }\n                            }\n                            if (<recovery-expr>()) {\n                                goto out;\n                            } else if (<recovery-expr>()) {\n                                while (<recovery-expr>())\n                                    {\n                                    }\n                            }\n                            if (<recovery-expr>()) {\n                            } else {\n                            }\n                        }\n                    }\n                    <recovery-expr>()++;\n                    <recovery-expr>() = <recovery-expr>();\n                }\n                if (charval != 0) {\n                    int len;\n                    if (<recovery-expr>())\n                        goto out;\n                    charval = 0;\n                }\n            } else\n                <recovery-expr>()++;\n        }\n    if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n        }\n        if (<recovery-expr>()) {\n        } else {\n        }\n    }\n  out:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/python/libxml.c#2338:1#libxml_xmlRegisterXPathFunction",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int c_retval = 0;\n    int i;\n    if (libxml_xpathCallbacksInitialized == 0)\n        libxml_xpathCallbacksInitialize();\n    if (<recovery-expr>()) {\n    }\n    for (i = 0; i < libxml_xpathCallbacksNb; i++) {\n        if (<recovery-expr>()) {\n            Py_XDECREF(<recovery-expr>((*libxml_xpathCallbacks)[i]));\n            c_retval = 1;\n            goto done;\n        }\n    }\n    if (libxml_xpathCallbacksNb >= libxml_xpathCallbacksAllocd) {\n        libxml_xpathCallbacksAllocd += 10;\n        libxml_xpathCallbacks = (libxml_xpathCallbackArray *)xmlRealloc(libxml_xpathCallbacks, libxml_xpathCallbacksAllocd * sizeof(libxml_xpathCallback));\n    }\n    i = libxml_xpathCallbacksNb++;\n    c_retval = 1;\n  done:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/python/libxml.c#121:1#libxml_xmlDebugMemory",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int activate;\n    long ret;\n    if (activate != 0) {\n        if (libxmlMemoryDebug == 0) {\n            if (<recovery-expr>()) {\n                libxmlMemoryAllocatedBase = xmlMemUsed();\n            } else {\n                xmlCleanupParser();\n                if (ret < 0)\n                    goto error;\n                libxmlMemoryAllocatedBase = xmlMemUsed();\n                xmlInitParser();\n                libxml_xmlErrorInitialize();\n            }\n            ret = 0;\n        } else if (libxmlMemoryDebugActivated == 0) {\n            libxmlMemoryAllocatedBase = xmlMemUsed();\n            ret = 0;\n        } else {\n            ret = xmlMemUsed() - libxmlMemoryAllocatedBase;\n        }\n        libxmlMemoryDebug = 1;\n        libxmlMemoryDebugActivated = 1;\n    } else {\n        if (libxmlMemoryDebugActivated == 1)\n            ret = xmlMemUsed() - libxmlMemoryAllocatedBase;\n        else\n            ret = 0;\n        libxmlMemoryDebugActivated = 0;\n    }\n  error:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/uri.c#2382:1#xmlCanonicPath",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    const int *absuri;\n    if ((<recovery-expr>()[0] == '/') && (<recovery-expr>()[1] == '/') && (<recovery-expr>()[2] != '/'))\n        <recovery-expr>()++;\n    if (<recovery-expr>()) {\n        return xmlStrdup(<recovery-expr>());\n    }\n    if (<recovery-expr>()) {\n        int l, j;\n        unsigned char c;\n        l = <recovery-expr>() - <recovery-expr>();\n        if ((l <= 0) || (l > 20))\n            goto path_processing;\n        for (j = 0; j < l; j++) {\n            c = <recovery-expr>()[j];\n            if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))\n                goto path_processing;\n        }\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n            }\n        }\n    }\n  path_processing:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/uri.c#2175:1#xmlBuildRelativeURI",
    "gotos": 11,
    "labels": 1,
    "body": "{\n    int ret;\n    int ix;\n    int nbslash = 0;\n    int len;\n    int remove_path = 0;\n    if (<recovery-expr>()[0] != '.') {\n        if (ret != 0)\n            goto done;\n    } else\n        ;\n    if (<recovery-expr>()) {\n        goto done;\n    }\n    if (<recovery-expr>())\n        goto done;\n    if (<recovery-expr>()[0] != '.') {\n        if (ret != 0)\n            goto done;\n    } else\n        ;\n    if (<recovery-expr>()) {\n        goto done;\n    }\n    if (<recovery-expr>()) {\n        goto done;\n    }\n    if (<recovery-expr>()) {\n        goto done;\n    }\n    if (<recovery-expr>()) {\n        remove_path = 1;\n    }\n    {\n        int pos = 0;\n        while (<recovery-expr>())\n            pos++;\n        if (<recovery-expr>()) {\n            goto done;\n        }\n        ix = pos;\n        for (; ix > 0; ix--) {\n            if (<recovery-expr>())\n                break;\n        }\n        if (<recovery-expr>()) {\n            goto done;\n        }\n    }\n    if (nbslash == 0) {\n        goto done;\n    }\n    if (<recovery-expr>()) {\n        xmlURIErrMemory(\"building relative URI\\n\");\n        goto done;\n    }\n    for (; nbslash > 0; nbslash--) {\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n        } else {\n        }\n    } else {\n    }\n  done:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/uri.c#1894:1#xmlBuildURI",
    "gotos": 12,
    "labels": 2,
    "body": "{\n    int ret, len, indx, cur, out;\n    if (<recovery-expr>())\n        ret = -1;\n    else {\n        if (*<recovery-expr>()) {\n            if (<recovery-expr>())\n                goto done;\n        } else\n            ret = 0;\n    }\n    if (ret != 0)\n        goto done;\n    if (<recovery-expr>()) {\n        goto done;\n    }\n    if (<recovery-expr>())\n        ret = -1;\n    else {\n        if (<recovery-expr>())\n            goto done;\n    }\n    if (ret != 0) {\n        goto done;\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n        }\n        goto done;\n    }\n    if (<recovery-expr>())\n        goto done;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            ;\n        else if (<recovery-expr>()) {\n        }\n        goto step_7;\n    }\n    if (<recovery-expr>()) {\n        goto done;\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            ;\n        else {\n        }\n        goto step_7;\n    }\n    if (<recovery-expr>())\n        ;\n    else if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>()) {\n        goto step_7;\n    }\n    len = 2;\n    if (<recovery-expr>()) {\n        xmlURIErrMemory(\"resolving URI against base\\n\");\n        goto done;\n    }\n    cur = 0;\n    out = 0;\n    if (<recovery-expr>()) {\n        while (<recovery-expr>())\n            {\n                while (<recovery-expr>())\n                    cur++;\n                if (<recovery-expr>())\n                    break;\n                cur++;\n                while (out < cur)\n                    {\n                        out++;\n                    }\n            }\n    }\n    if (<recovery-expr>()) {\n        indx = 0;\n        while (<recovery-expr>())\n            {\n            }\n    }\n  step_7:\n    ;\n  done:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/uri.c#1421:1#xmlNormalizeURIPath",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    char *cur, *out;\n    if (<recovery-expr>())\n        return (-1);\n    cur = path;\n    while (cur[0] == '/')\n        ++cur;\n    if (cur[0] == '\\x00')\n        return (0);\n    out = cur;\n    while (cur[0] != '\\x00')\n        {\n            if ((cur[0] == '.') && (cur[1] == '/')) {\n                cur += 2;\n                while (cur[0] == '/')\n                    cur++;\n                continue;\n            }\n            if ((cur[0] == '.') && (cur[1] == '\\x00'))\n                break;\n            while (cur[0] != '/')\n                {\n                    if (cur[0] == '\\x00')\n                        goto done_cd;\n                    (out++)[0] = (cur++)[0];\n                }\n            while ((cur[0] == '/') && (cur[1] == '/'))\n                cur++;\n            (out++)[0] = (cur++)[0];\n        }\n  done_cd:\n    out[0] = '\\x00';\n    cur = path;\n    while (cur[0] == '/')\n        ++cur;\n    if (cur[0] == '\\x00')\n        return (0);\n    while (1)\n        {\n            char *segp, *tmp;\n            segp = cur;\n            while ((segp[0] != '/') && (segp[0] != '\\x00'))\n                ++segp;\n            if (segp[0] == '\\x00')\n                break;\n            ++segp;\n            if (((cur[0] == '.') && (cur[1] == '.') && (segp == cur + 3)) || ((segp[0] != '.') || (segp[1] != '.') || ((segp[2] != '/') && (segp[2] != '\\x00')))) {\n                cur = segp;\n                continue;\n            }\n            if (segp[2] == '\\x00') {\n                cur[0] = '\\x00';\n                break;\n            }\n            tmp = cur;\n            segp += 3;\n            while ((*tmp++ = *segp++) != 0)\n                ;\n            segp = cur;\n            while ((segp > path) && ((--segp)[0] == '/'))\n                ;\n            if (segp == path)\n                continue;\n            cur = segp;\n            while ((cur > path) && (cur[-1] != '/'))\n                --cur;\n        }\n    out[0] = '\\x00';\n    if (path[0] == '/') {\n        cur = path;\n        while ((cur[0] == '/') && (cur[1] == '.') && (cur[2] == '.') && ((cur[3] == '/') || (cur[3] == '\\x00')))\n            cur += 3;\n        if (cur != path) {\n            out = path;\n            while (cur[0] != '\\x00')\n                (out++)[0] = (cur++)[0];\n            out[0] = 0;\n        }\n    }\n    return (0);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/uri.c#1067:1#xmlSaveUri",
    "gotos": 20,
    "labels": 1,
    "body": "{\n    const char *p;\n    int len;\n    int max;\n    max = 80;\n    if (<recovery-expr>()) {\n        xmlURIErrMemory(\"saving URI\\n\");\n    }\n    len = 0;\n    if (<recovery-expr>()) {\n        p = <recovery-expr>()->scheme;\n        while (*p != 0)\n            {\n                if (len >= max) {\n                    if (<recovery-expr>())\n                        goto mem_error;\n                }\n            }\n        if (len >= max) {\n            if (<recovery-expr>())\n                goto mem_error;\n        }\n    }\n    if (<recovery-expr>()) {\n        p = <recovery-expr>()->opaque;\n        while (*p != 0)\n            {\n                if (len + 3 >= max) {\n                    if (<recovery-expr>())\n                        goto mem_error;\n                }\n                if ((((*(p)) == ';') || ((*(p)) == '/') || ((*(p)) == '?') || ((*(p)) == ':') || ((*(p)) == '@') || ((*(p)) == '&') || ((*(p)) == '=') || ((*(p)) == '+') || ((*(p)) == '$') || ((*(p)) == ',') || ((*(p)) == '[') || ((*(p)) == ']')) || ((((((*(p)) >= 'a') && ((*(p)) <= 'z')) || (((*(p)) >= 'A') && ((*(p)) <= 'Z'))) || (((*(p)) >= '0') && ((*(p)) <= '9'))) || (((*(p)) == '-') || ((*(p)) == '_') || ((*(p)) == '.') || ((*(p)) == '!') || ((*(p)) == '~') || ((*(p)) == '*') || ((*(p)) == '\\'') || ((*(p)) == '(') || ((*(p)) == ')'))))\n                    ;\n                else {\n                    int val = *(unsigned char *)p++;\n                    int hi = val / 16, lo = val % 16;\n                }\n            }\n    } else {\n        if (<recovery-expr>()) {\n            if (len + 3 >= max) {\n                if (<recovery-expr>())\n                    goto mem_error;\n            }\n            if (<recovery-expr>()) {\n                p = <recovery-expr>()->user;\n                while (*p != 0)\n                    {\n                        if (len + 3 >= max) {\n                            if (<recovery-expr>())\n                                goto mem_error;\n                        }\n                        if ((((((((*(p)) >= 'a') && ((*(p)) <= 'z')) || (((*(p)) >= 'A') && ((*(p)) <= 'Z'))) || (((*(p)) >= '0') && ((*(p)) <= '9'))) || (((*(p)) == '-') || ((*(p)) == '_') || ((*(p)) == '.') || ((*(p)) == '!') || ((*(p)) == '~') || ((*(p)) == '*') || ((*(p)) == '\\'') || ((*(p)) == '(') || ((*(p)) == ')')))) || ((*(p) == ';')) || ((*(p) == ':')) || ((*(p) == '&')) || ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) || ((*(p) == ',')))\n                            ;\n                        else {\n                            int val = *(unsigned char *)p++;\n                            int hi = val / 16, lo = val % 16;\n                        }\n                    }\n                if (len + 3 >= max) {\n                    if (<recovery-expr>())\n                        goto mem_error;\n                }\n            }\n            if (<recovery-expr>()) {\n                p = <recovery-expr>()->server;\n                while (*p != 0)\n                    {\n                        if (len >= max) {\n                            if (<recovery-expr>())\n                                goto mem_error;\n                        }\n                    }\n                if (<recovery-expr>()->port > 0) {\n                    if (len + 10 >= max) {\n                        if (<recovery-expr>())\n                            goto mem_error;\n                    }\n                }\n            }\n        } else if (<recovery-expr>()) {\n            if (len + 3 >= max) {\n                if (<recovery-expr>())\n                    goto mem_error;\n            }\n            p = <recovery-expr>()->authority;\n            while (*p != 0)\n                {\n                    if (len + 3 >= max) {\n                        if (<recovery-expr>())\n                            goto mem_error;\n                    }\n                    if ((((((((*(p)) >= 'a') && ((*(p)) <= 'z')) || (((*(p)) >= 'A') && ((*(p)) <= 'Z'))) || (((*(p)) >= '0') && ((*(p)) <= '9'))) || (((*(p)) == '-') || ((*(p)) == '_') || ((*(p)) == '.') || ((*(p)) == '!') || ((*(p)) == '~') || ((*(p)) == '*') || ((*(p)) == '\\'') || ((*(p)) == '(') || ((*(p)) == ')')))) || ((*(p) == '$')) || ((*(p) == ',')) || ((*(p) == ';')) || ((*(p) == ':')) || ((*(p) == '@')) || ((*(p) == '&')) || ((*(p) == '=')) || ((*(p) == '+')))\n                        ;\n                    else {\n                        int val = *(unsigned char *)p++;\n                        int hi = val / 16, lo = val % 16;\n                    }\n                }\n        } else if (<recovery-expr>()) {\n            if (len + 3 >= max) {\n                if (<recovery-expr>())\n                    goto mem_error;\n            }\n        }\n        if (<recovery-expr>()) {\n            p = <recovery-expr>()->path;\n            if (<recovery-expr>()) {\n                if (len + 3 >= max) {\n                    if (<recovery-expr>())\n                        goto mem_error;\n                }\n            }\n            while (*p != 0)\n                {\n                    if (len + 3 >= max) {\n                        if (<recovery-expr>())\n                            goto mem_error;\n                    }\n                    if ((((((((*(p)) >= 'a') && ((*(p)) <= 'z')) || (((*(p)) >= 'A') && ((*(p)) <= 'Z'))) || (((*(p)) >= '0') && ((*(p)) <= '9'))) || (((*(p)) == '-') || ((*(p)) == '_') || ((*(p)) == '.') || ((*(p)) == '!') || ((*(p)) == '~') || ((*(p)) == '*') || ((*(p)) == '\\'') || ((*(p)) == '(') || ((*(p)) == ')')))) || ((*(p) == '/')) || ((*(p) == ';')) || ((*(p) == '@')) || ((*(p) == '&')) || ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) || ((*(p) == ',')))\n                        ;\n                    else {\n                        int val = *(unsigned char *)p++;\n                        int hi = val / 16, lo = val % 16;\n                    }\n                }\n        }\n        if (<recovery-expr>()) {\n            if (len + 1 >= max) {\n                if (<recovery-expr>())\n                    goto mem_error;\n            }\n            p = <recovery-expr>()->query_raw;\n            while (*p != 0)\n                {\n                    if (len + 1 >= max) {\n                        if (<recovery-expr>())\n                            goto mem_error;\n                    }\n                }\n        } else if (<recovery-expr>()) {\n            if (len + 3 >= max) {\n                if (<recovery-expr>())\n                    goto mem_error;\n            }\n            p = <recovery-expr>()->query;\n            while (*p != 0)\n                {\n                    if (len + 3 >= max) {\n                        if (<recovery-expr>())\n                            goto mem_error;\n                    }\n                    if ((((((((*(p)) >= 'a') && ((*(p)) <= 'z')) || (((*(p)) >= 'A') && ((*(p)) <= 'Z'))) || (((*(p)) >= '0') && ((*(p)) <= '9'))) || (((*(p)) == '-') || ((*(p)) == '_') || ((*(p)) == '.') || ((*(p)) == '!') || ((*(p)) == '~') || ((*(p)) == '*') || ((*(p)) == '\\'') || ((*(p)) == '(') || ((*(p)) == ')')))) || ((((*(p)) == ';') || ((*(p)) == '/') || ((*(p)) == '?') || ((*(p)) == ':') || ((*(p)) == '@') || ((*(p)) == '&') || ((*(p)) == '=') || ((*(p)) == '+') || ((*(p)) == '$') || ((*(p)) == ',') || ((*(p)) == '[') || ((*(p)) == ']'))))\n                        ;\n                    else {\n                        int val = *(unsigned char *)p++;\n                        int hi = val / 16, lo = val % 16;\n                    }\n                }\n        }\n    }\n    if (<recovery-expr>()) {\n        if (len + 3 >= max) {\n            if (<recovery-expr>())\n                goto mem_error;\n        }\n        p = <recovery-expr>()->fragment;\n        while (*p != 0)\n            {\n                if (len + 3 >= max) {\n                    if (<recovery-expr>())\n                        goto mem_error;\n                }\n                if ((((((((*(p)) >= 'a') && ((*(p)) <= 'z')) || (((*(p)) >= 'A') && ((*(p)) <= 'Z'))) || (((*(p)) >= '0') && ((*(p)) <= '9'))) || (((*(p)) == '-') || ((*(p)) == '_') || ((*(p)) == '.') || ((*(p)) == '!') || ((*(p)) == '~') || ((*(p)) == '*') || ((*(p)) == '\\'') || ((*(p)) == '(') || ((*(p)) == ')')))) || ((((*(p)) == ';') || ((*(p)) == '/') || ((*(p)) == '?') || ((*(p)) == ':') || ((*(p)) == '@') || ((*(p)) == '&') || ((*(p)) == '=') || ((*(p)) == '+') || ((*(p)) == '$') || ((*(p)) == ',') || ((*(p)) == '[') || ((*(p)) == ']'))))\n                    ;\n                else {\n                    int val = *(unsigned char *)p++;\n                    int hi = val / 16, lo = val % 16;\n                }\n            }\n    }\n    if (len >= max) {\n        if (<recovery-expr>())\n            goto mem_error;\n    }\n  mem_error:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/uri.c#441:1#xmlParse3986Host",
    "gotos": 9,
    "labels": 2,
    "body": "{\n    const char *cur = *str;\n    const char *host;\n    host = cur;\n    if (*cur == '[') {\n        cur++;\n        while ((*cur != ']') && (*cur != 0))\n            cur++;\n        if (*cur != ']')\n            return (1);\n        cur++;\n        goto found;\n    }\n    if (((*(cur) >= '0') && (*(cur) <= '9'))) {\n        if (xmlParse3986DecOctet(&cur) != 0)\n            goto not_ipv4;\n        if (*cur != '.')\n            goto not_ipv4;\n        cur++;\n        if (xmlParse3986DecOctet(&cur) != 0)\n            goto not_ipv4;\n        if (*cur != '.')\n            goto not_ipv4;\n        if (xmlParse3986DecOctet(&cur) != 0)\n            goto not_ipv4;\n        if (*cur != '.')\n            goto not_ipv4;\n        if (xmlParse3986DecOctet(&cur) != 0)\n            goto not_ipv4;\n        goto found;\n      not_ipv4:\n        cur = *str;\n    }\n    while ((((((*(cur) >= 'a') && (*(cur) <= 'z')) || ((*(cur) >= 'A') && (*(cur) <= 'Z')))) || (((*(cur) >= '0') && (*(cur) <= '9'))) || ((*(cur) == '-')) || ((*(cur) == '.')) || ((*(cur) == '_')) || ((*(cur) == '~'))) || ((*(cur) == '%') && ((((*(cur + 1) >= '0') && (*(cur + 1) <= '9')) || ((*(cur + 1) >= 'a') && (*(cur + 1) <= 'f')) || ((*(cur + 1) >= 'A') && (*(cur + 1) <= 'F')))) && ((((*(cur + 2) >= '0') && (*(cur + 2) <= '9')) || ((*(cur + 2) >= 'a') && (*(cur + 2) <= 'f')) || ((*(cur + 2) >= 'A') && (*(cur + 2) <= 'F'))))) || (((*(cur) == '!')) || ((*(cur) == '$')) || ((*(cur) == '&')) || ((*(cur) == '(')) || ((*(cur) == ')')) || ((*(cur) == '*')) || ((*(cur) == '+')) || ((*(cur) == ',')) || ((*(cur) == ';')) || ((*(cur) == '=')) || ((*(cur) == '\\''))))\n        ((*cur == '%') ? cur += 3 : cur++);\n  found:\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            xmlFree(<recovery-expr>()->authority);\n        if (<recovery-expr>())\n            xmlFree(<recovery-expr>()->server);\n        if (cur != host) {\n        } else\n            ;\n    }\n    *str = cur;\n    return (0);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#9327:1#xmlParseStartTag2",
    "gotos": 12,
    "labels": 2,
    "body": "{\n    const int *localname;\n    const int *prefix;\n    const int *attname;\n    const int *aprefix;\n    const int *nsname;\n    const int **atts;\n    int maxatts = <recovery-expr>()->maxatts;\n    int nratts, nbatts, nbdef, inputid;\n    int i, j, nbNs, attval;\n    unsigned long cur;\n    int nsNr = <recovery-expr>()->nsNr;\n    {\n        <recovery-expr>()->input->col++;\n        <recovery-expr>()->input->cur++;\n    }\n    ;\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    cur = <recovery-expr>()->input->cur - <recovery-expr>()->input->base;\n    inputid = <recovery-expr>()->input->id;\n    nbatts = 0;\n    nratts = 0;\n    nbdef = 0;\n    nbNs = 0;\n    attval = 0;\n    <recovery-expr>()->nsNr = nsNr;\n    <recovery-expr>() = <recovery-expr>()(<recovery-expr>(), &<recovery-expr>());\n    if (<recovery-expr>()) {\n    }\n    *tlen = <recovery-expr>()->input->cur - <recovery-expr>()->input->base - cur;\n    <recovery-expr>()(<recovery-expr>());\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    while (<recovery-expr>())\n        {\n            int id = <recovery-expr>()->input->id;\n            unsigned long cons = (<recovery-expr>()->input->consumed + (<recovery-expr>()->input->cur - <recovery-expr>()->input->base));\n            int len = -1, alloc = 0;\n            if (<recovery-expr>())\n                goto next_attr;\n            if (<recovery-expr>()) {\n                const int *URL;\n                if (<recovery-expr>()) {\n                    xmlErrMemory(<recovery-expr>(), \"dictionary allocation failure\");\n                    goto done;\n                }\n                if (*<recovery-expr>() != 0) {\n                    if (<recovery-expr>()) {\n                    } else {\n                        if (<recovery-expr>()) {\n                        }\n                    }\n                    if (<recovery-expr>() == <recovery-expr>()->str_xml_ns) {\n                        if (<recovery-expr>() != <recovery-expr>()->str_xml) {\n                        }\n                        goto next_attr;\n                    }\n                    if (<recovery-expr>()) {\n                        goto next_attr;\n                    }\n                }\n                for (j = 1; j <= nbNs; j++)\n                    if (<recovery-expr>())\n                        break;\n                if (j <= nbNs)\n                    ;\n                else if (<recovery-expr>())\n                    nbNs++;\n            } else if (<recovery-expr>() == <recovery-expr>()->str_xmlns) {\n                const int *URL;\n                if (<recovery-expr>() == <recovery-expr>()->str_xml) {\n                    if (<recovery-expr>() != <recovery-expr>()->str_xml_ns) {\n                    }\n                    goto next_attr;\n                }\n                if (<recovery-expr>() == <recovery-expr>()->str_xml_ns) {\n                    if (<recovery-expr>() != <recovery-expr>()->str_xml) {\n                    }\n                    goto next_attr;\n                }\n                if (<recovery-expr>() == <recovery-expr>()->str_xmlns) {\n                    goto next_attr;\n                }\n                if (<recovery-expr>()) {\n                    goto next_attr;\n                }\n                if (<recovery-expr>()) {\n                    goto next_attr;\n                } else {\n                    if (<recovery-expr>()) {\n                    } else {\n                        if (<recovery-expr>()) {\n                        }\n                    }\n                }\n                for (j = 1; j <= nbNs; j++)\n                    if (<recovery-expr>()->nsTab[<recovery-expr>()->nsNr - 2 * j] == <recovery-expr>())\n                        break;\n                if (j <= nbNs)\n                    <recovery-expr>()(<recovery-expr>(), <recovery-expr>(), <recovery-expr>());\n                else if (<recovery-expr>()(<recovery-expr>(), <recovery-expr>(), <recovery-expr>()) > 0)\n                    nbNs++;\n            } else {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()(<recovery-expr>(), nbatts + 5) < 0) {\n                        goto next_attr;\n                    }\n                    maxatts = <recovery-expr>()->maxatts;\n                    <recovery-expr>() = <recovery-expr>()->atts;\n                }\n                <recovery-expr>()->attallocs[nratts++] = alloc;\n                <recovery-expr>()[nbatts++] = <recovery-expr>();\n                <recovery-expr>()[nbatts++] = <recovery-expr>();\n                if (alloc)\n                    ;\n                else\n                    <recovery-expr>()[nbatts++] = <recovery-expr>()->input->base;\n                if (alloc != 0)\n                    attval = 1;\n            }\n          next_attr:\n            if (<recovery-expr>()) {\n            }\n            if (<recovery-expr>())\n                <recovery-expr>()(<recovery-expr>());\n            if (<recovery-expr>())\n                break;\n            if (((*<recovery-expr>()->input->cur) == '>') || ((((*<recovery-expr>()->input->cur) == '/') && (<recovery-expr>()->input->cur[(1)] == '>'))))\n                break;\n            if (<recovery-expr>()(<recovery-expr>()) == 0) {\n                break;\n            }\n            if (<recovery-expr>()) {\n                break;\n            }\n            if (<recovery-expr>())\n                <recovery-expr>()(<recovery-expr>());\n            ;\n        }\n    if (<recovery-expr>()->input->id != inputid) {\n        goto done;\n    }\n    for (i = 0 , j = 0; j < nratts; i += 5 , j++) {\n        if (<recovery-expr>()) {\n        }\n    }\n    if (<recovery-expr>()) {\n        xmlDefAttrsPtr defaults;\n        defaults = xmlHashLookup2(<recovery-expr>()->attsDefault, <recovery-expr>(), <recovery-expr>());\n        if (<recovery-expr>()) {\n            for (i = 0; i < <recovery-expr>(defaults); i++) {\n                <recovery-expr>() = <recovery-expr>(defaults)[5 * i];\n                <recovery-expr>() = <recovery-expr>(defaults)[5 * i + 1];\n                if (<recovery-expr>()) {\n                    for (j = 1; j <= nbNs; j++)\n                        if (<recovery-expr>())\n                            break;\n                    if (j <= nbNs)\n                        continue;\n                    if (<recovery-expr>() != <recovery-expr>(defaults)[5 * i + 2]) {\n                        if (<recovery-expr>())\n                            nbNs++;\n                    }\n                } else if (<recovery-expr>() == <recovery-expr>()->str_xmlns) {\n                    for (j = 1; j <= nbNs; j++)\n                        if (<recovery-expr>()->nsTab[<recovery-expr>()->nsNr - 2 * j] == <recovery-expr>())\n                            break;\n                    if (j <= nbNs)\n                        continue;\n                    <recovery-expr>() = <recovery-expr>()(<recovery-expr>(), <recovery-expr>());\n                    if (<recovery-expr>() != <recovery-expr>(defaults)[2]) {\n                        if (<recovery-expr>()(<recovery-expr>(), <recovery-expr>(), <recovery-expr>(defaults)[5 * i + 2]) > 0)\n                            nbNs++;\n                    }\n                } else {\n                    for (j = 0; j < nbatts; j += 5) {\n                        if ((<recovery-expr>() == <recovery-expr>()[j]) && (<recovery-expr>() == <recovery-expr>()[j + 1]))\n                            break;\n                    }\n                    if (j < nbatts)\n                        continue;\n                    if (<recovery-expr>()) {\n                        if (<recovery-expr>()(<recovery-expr>(), nbatts + 5) < 0) {\n                            goto done;\n                        }\n                        maxatts = <recovery-expr>()->maxatts;\n                        <recovery-expr>() = <recovery-expr>()->atts;\n                    }\n                    <recovery-expr>()[nbatts++] = <recovery-expr>();\n                    <recovery-expr>()[nbatts++] = <recovery-expr>();\n                    if (<recovery-expr>())\n                        ;\n                    else\n                        <recovery-expr>()[nbatts++] = <recovery-expr>()(<recovery-expr>(), <recovery-expr>());\n                    <recovery-expr>()[nbatts++] = <recovery-expr>(defaults)[5 * i + 2];\n                    <recovery-expr>()[nbatts++] = <recovery-expr>(defaults)[5 * i + 3];\n                    if (<recovery-expr>()) {\n                    }\n                    nbdef++;\n                }\n            }\n        }\n    }\n    for (i = 0; i < nbatts; i += 5) {\n        if (<recovery-expr>()) {\n            <recovery-expr>() = <recovery-expr>()(<recovery-expr>(), <recovery-expr>()[i + 1]);\n            if (<recovery-expr>()) {\n            }\n            <recovery-expr>()[i + 2] = <recovery-expr>();\n        } else\n            ;\n        for (j = 0; j < i; j += 5) {\n            if (<recovery-expr>()[i] == <recovery-expr>()[j]) {\n                if (<recovery-expr>()[i + 1] == <recovery-expr>()[j + 1]) {\n                    <recovery-expr>()(<recovery-expr>(), <recovery-expr>()[i + 1], <recovery-expr>()[i]);\n                    break;\n                }\n                if (<recovery-expr>()) {\n                    break;\n                }\n            }\n        }\n    }\n    <recovery-expr>() = <recovery-expr>()(<recovery-expr>(), <recovery-expr>());\n    if (<recovery-expr>()) {\n    }\n    *<recovery-expr>() = <recovery-expr>();\n    *<recovery-expr>() = <recovery-expr>();\n    if (<recovery-expr>()) {\n        if (nbNs > 0)\n            <recovery-expr>()->sax->startElementNs(<recovery-expr>()->userData, <recovery-expr>(), <recovery-expr>(), <recovery-expr>(), nbNs, &<recovery-expr>()->nsTab[<recovery-expr>()->nsNr - 2 * nbNs], nbatts / 5, nbdef, <recovery-expr>());\n        else\n            ;\n    }\n  done:\n    if (attval != 0) {\n    }\n    return (<recovery-expr>());\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#6751:1#xmlParseConditionalSections",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    int *inputIds;\n    while (<recovery-expr>())\n        {\n            if (((*<recovery-expr>()->input->cur) == '<') && (<recovery-expr>()->input->cur[(1)] == '!') && (<recovery-expr>()->input->cur[(2)] == '[')) {\n                int id = <recovery-expr>()->input->id;\n                do {\n                    <recovery-expr>()->input->cur += (3) , <recovery-expr>()->input->col += (3);\n                } while (0);\n                <recovery-expr>()(<recovery-expr>());\n                if (((((((unsigned char *)<recovery-expr>()->input->cur)[0] == 'I' && ((unsigned char *)<recovery-expr>()->input->cur)[1] == 'N' && ((unsigned char *)<recovery-expr>()->input->cur)[2] == 'C' && ((unsigned char *)<recovery-expr>()->input->cur)[3] == 'L') && ((unsigned char *)<recovery-expr>()->input->cur)[4] == 'U') && ((unsigned char *)<recovery-expr>()->input->cur)[5] == 'D') && ((unsigned char *)<recovery-expr>()->input->cur)[6] == 'E')) {\n                    do {\n                        <recovery-expr>()->input->cur += (7) , <recovery-expr>()->input->col += (7);\n                    } while (0);\n                    <recovery-expr>()(<recovery-expr>());\n                    if ((*<recovery-expr>()->input->cur) != '[') {\n                        <recovery-expr>()(<recovery-expr>());\n                        goto error;\n                    }\n                    if (<recovery-expr>()->input->id != id) {\n                    }\n                    xmlNextChar(<recovery-expr>());\n                    if (<recovery-expr>()) {\n                        int *tmp;\n                        if (<recovery-expr>()) {\n                            goto error;\n                        }\n                        inputIds = tmp;\n                    }\n                } else if ((((((unsigned char *)<recovery-expr>()->input->cur)[0] == 'I' && ((unsigned char *)<recovery-expr>()->input->cur)[1] == 'G' && ((unsigned char *)<recovery-expr>()->input->cur)[2] == 'N' && ((unsigned char *)<recovery-expr>()->input->cur)[3] == 'O') && ((unsigned char *)<recovery-expr>()->input->cur)[4] == 'R') && ((unsigned char *)<recovery-expr>()->input->cur)[5] == 'E')) {\n                    int state;\n                    do {\n                        <recovery-expr>()->input->cur += (6) , <recovery-expr>()->input->col += (6);\n                    } while (0);\n                    <recovery-expr>()(<recovery-expr>());\n                    if ((*<recovery-expr>()->input->cur) != '[') {\n                        <recovery-expr>()(<recovery-expr>());\n                        goto error;\n                    }\n                    if (<recovery-expr>()->input->id != id) {\n                    }\n                    xmlNextChar(<recovery-expr>());\n                    state = <recovery-expr>()->disableSAX;\n                    if (<recovery-expr>()->recovery == 0)\n                        <recovery-expr>()->disableSAX = 1;\n                    while ((*<recovery-expr>()->input->cur) != 0)\n                        {\n                            if (((*<recovery-expr>()->input->cur) == '<') && (<recovery-expr>()->input->cur[(1)] == '!') && (<recovery-expr>()->input->cur[(2)] == '[')) {\n                                do {\n                                    <recovery-expr>()->input->cur += (3) , <recovery-expr>()->input->col += (3);\n                                } while (0);\n                                if (<recovery-expr>()) {\n                                    goto error;\n                                }\n                            } else if (((*<recovery-expr>()->input->cur) == ']') && (<recovery-expr>()->input->cur[(1)] == ']') && (<recovery-expr>()->input->cur[(2)] == '>')) {\n                                if (<recovery-expr>())\n                                    break;\n                                do {\n                                    <recovery-expr>()->input->cur += (3) , <recovery-expr>()->input->col += (3);\n                                } while (0);\n                            } else {\n                                xmlNextChar(<recovery-expr>());\n                            }\n                        }\n                    <recovery-expr>()->disableSAX = state;\n                    if ((*<recovery-expr>()->input->cur) == 0) {\n                        goto error;\n                    }\n                    if (<recovery-expr>()->input->id != id) {\n                    }\n                    do {\n                        <recovery-expr>()->input->cur += (3) , <recovery-expr>()->input->col += (3);\n                    } while (0);\n                } else {\n                    <recovery-expr>()(<recovery-expr>());\n                    goto error;\n                }\n            } else if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                }\n                do {\n                    <recovery-expr>()->input->cur += (3) , <recovery-expr>()->input->col += (3);\n                } while (0);\n            } else {\n                int id = <recovery-expr>()->input->id;\n                unsigned long cons = (<recovery-expr>()->input->consumed + (<recovery-expr>()->input->cur - <recovery-expr>()->input->base));\n                xmlParseMarkupDecl(<recovery-expr>());\n                if ((id == <recovery-expr>()->input->id) && (cons == (<recovery-expr>()->input->consumed + (<recovery-expr>()->input->cur - <recovery-expr>()->input->base)))) {\n                    <recovery-expr>()(<recovery-expr>());\n                    goto error;\n                }\n            }\n            if (<recovery-expr>())\n                break;\n            <recovery-expr>()(<recovery-expr>());\n            if (<recovery-expr>())\n                <recovery-expr>()(<recovery-expr>());\n            ;\n        }\n  error:\n    xmlFree(inputIds);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#2650:1#xmlStringLenDecodeEntities",
    "gotos": 19,
    "labels": 2,
    "body": "{\n    const int *last;\n    int c, l;\n    <recovery-expr>() = <recovery-expr>() + len;\n    if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>())\n        goto mem_error;\n    if (<recovery-expr>() < <recovery-expr>())\n        c = xmlStringCurrentChar(<recovery-expr>(), <recovery-expr>(), &l);\n    else\n        c = 0;\n    while (<recovery-expr>())\n        {\n            if (c == 0)\n                break;\n            if ((c == '&') && (<recovery-expr>()[1] == '#')) {\n                int val = <recovery-expr>()(<recovery-expr>(), &<recovery-expr>());\n                if (val == 0)\n                    goto int_error;\n                if (<recovery-expr>()) {\n                    {\n                        if (<recovery-expr>())\n                            goto mem_error;\n                        if (<recovery-expr>())\n                            goto mem_error;\n                    }\n                    ;\n                }\n            } else if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                            {\n                                if (<recovery-expr>())\n                                    goto mem_error;\n                                if (<recovery-expr>())\n                                    goto mem_error;\n                            }\n                            ;\n                        }\n                    } else {\n                        goto int_error;\n                    }\n                } else if (<recovery-expr>()) {\n                    <recovery-expr>()->depth++;\n                    <recovery-expr>()->depth--;\n                    if (<recovery-expr>()) {\n                        goto int_error;\n                    }\n                    while (<recovery-expr>())\n                        {\n                            if (<recovery-expr>()) {\n                                if (<recovery-expr>())\n                                    goto int_error;\n                                {\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                }\n                                ;\n                            }\n                        }\n                } else if (<recovery-expr>()) {\n                    int i;\n                    const int *cur;\n                    if (<recovery-expr>()) {\n                        {\n                            if (<recovery-expr>())\n                                goto mem_error;\n                            if (<recovery-expr>())\n                                goto mem_error;\n                        }\n                        ;\n                    }\n                }\n            } else if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                        } else {\n                        }\n                    }\n                    <recovery-expr>()->depth++;\n                    <recovery-expr>()->depth--;\n                    if (<recovery-expr>()) {\n                        goto int_error;\n                    }\n                    while (<recovery-expr>())\n                        {\n                            if (<recovery-expr>()) {\n                                if (<recovery-expr>())\n                                    goto int_error;\n                                {\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                }\n                                ;\n                            }\n                        }\n                }\n            } else {\n                <recovery-expr>() += l;\n                if (<recovery-expr>()) {\n                    {\n                        if (<recovery-expr>())\n                            goto mem_error;\n                        if (<recovery-expr>())\n                            goto mem_error;\n                    }\n                    ;\n                }\n            }\n            if (<recovery-expr>() < <recovery-expr>())\n                c = xmlStringCurrentChar(<recovery-expr>(), <recovery-expr>(), &l);\n            else\n                c = 0;\n        }\n  mem_error:\n    ;\n  int_error:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#5437:1#xmlParseEntityDecl",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    const int *name;\n    const int *ndata;\n    int isParameter = 0;\n    if ((((((((unsigned char *)<recovery-expr>()->input->cur)[0] == '<' && ((unsigned char *)<recovery-expr>()->input->cur)[1] == '!' && ((unsigned char *)<recovery-expr>()->input->cur)[2] == 'E' && ((unsigned char *)<recovery-expr>()->input->cur)[3] == 'N') && ((unsigned char *)<recovery-expr>()->input->cur)[4] == 'T') && ((unsigned char *)<recovery-expr>()->input->cur)[5] == 'I') && ((unsigned char *)<recovery-expr>()->input->cur)[6] == 'T') && ((unsigned char *)<recovery-expr>()->input->cur)[7] == 'Y')) {\n        int inputid = <recovery-expr>()->input->id;\n        if (<recovery-expr>())\n            <recovery-expr>()(<recovery-expr>());\n        ;\n        do {\n            <recovery-expr>()->input->cur += (8) , <recovery-expr>()->input->col += (8);\n        } while (0);\n        if (<recovery-expr>()(<recovery-expr>()) == 0) {\n        }\n        if ((*<recovery-expr>()->input->cur) == '%') {\n            xmlNextChar(<recovery-expr>());\n            if (<recovery-expr>()(<recovery-expr>()) == 0) {\n            }\n            isParameter = 1;\n        }\n        <recovery-expr>() = <recovery-expr>()(<recovery-expr>());\n        if (<recovery-expr>()) {\n            return;\n        }\n        if (<recovery-expr>()) {\n        }\n        if (<recovery-expr>()(<recovery-expr>()) == 0) {\n        }\n        if (isParameter) {\n            if (((*<recovery-expr>()->input->cur) == '\"') || ((*<recovery-expr>()->input->cur) == '\\'')) {\n                if (<recovery-expr>()) {\n                }\n            } else {\n                if (<recovery-expr>()) {\n                }\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else {\n                        if (<recovery-expr>()) {\n                        } else {\n                        }\n                    }\n                }\n            }\n        } else {\n            if (((*<recovery-expr>()->input->cur) == '\"') || ((*<recovery-expr>()->input->cur) == '\\'')) {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                            xmlErrMemory(<recovery-expr>(), \"New Doc failed\");\n                            return;\n                        }\n                    }\n                }\n            } else {\n                if (<recovery-expr>()) {\n                }\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    } else {\n                        if (<recovery-expr>()) {\n                        }\n                    }\n                }\n                if (((*<recovery-expr>()->input->cur) != '>') && (<recovery-expr>()(<recovery-expr>()) == 0)) {\n                }\n                if (((((unsigned char *)<recovery-expr>()->input->cur)[0] == 'N' && ((unsigned char *)<recovery-expr>()->input->cur)[1] == 'D' && ((unsigned char *)<recovery-expr>()->input->cur)[2] == 'A' && ((unsigned char *)<recovery-expr>()->input->cur)[3] == 'T') && ((unsigned char *)<recovery-expr>()->input->cur)[4] == 'A')) {\n                    do {\n                        <recovery-expr>()->input->cur += (5) , <recovery-expr>()->input->col += (5);\n                    } while (0);\n                    if (<recovery-expr>()(<recovery-expr>()) == 0) {\n                    }\n                    <recovery-expr>() = <recovery-expr>()(<recovery-expr>());\n                } else {\n                    if (<recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                            if (<recovery-expr>()) {\n                                xmlErrMemory(<recovery-expr>(), \"New Doc failed\");\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (<recovery-expr>())\n            goto done;\n        <recovery-expr>()(<recovery-expr>());\n        if ((*<recovery-expr>()->input->cur) != '>') {\n            <recovery-expr>()(<recovery-expr>());\n        } else {\n            if (inputid != <recovery-expr>()->input->id) {\n            }\n            xmlNextChar(<recovery-expr>());\n        }\n        if (<recovery-expr>()) {\n            if (isParameter) {\n            } else {\n                if (<recovery-expr>()) {\n                }\n            }\n            if (<recovery-expr>()) {\n            }\n        }\n      done:\n        ;\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#4909:1#xmlParseComment",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    const int *in;\n    int ccol;\n    int inputid;\n    if (((*<recovery-expr>()->input->cur) != '<') || (<recovery-expr>()->input->cur[(1)] != '!') || (<recovery-expr>()->input->cur[(2)] != '-') || (<recovery-expr>()->input->cur[(3)] != '-'))\n        return;\n    inputid = <recovery-expr>()->input->id;\n    do {\n        <recovery-expr>()->input->cur += (4) , <recovery-expr>()->input->col += (4);\n    } while (0);\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    <recovery-expr>() = <recovery-expr>()->input->cur;\n    do {\n        if (*<recovery-expr>() == 10) {\n            do {\n                <recovery-expr>()->input->line++;\n                <recovery-expr>()->input->col = 1;\n                <recovery-expr>()++;\n            } while (*<recovery-expr>() == 10);\n        }\n      get_more:\n        ccol = <recovery-expr>()->input->col;\n        while (((*<recovery-expr>() > '-') && (*<recovery-expr>() <= 127)) || ((*<recovery-expr>() >= 32) && (*<recovery-expr>() < '-')) || (*<recovery-expr>() == 9))\n            {\n                <recovery-expr>()++;\n                ccol++;\n            }\n        <recovery-expr>()->input->col = ccol;\n        if (*<recovery-expr>() == 10) {\n            do {\n                <recovery-expr>()->input->line++;\n                <recovery-expr>()->input->col = 1;\n                <recovery-expr>()++;\n            } while (*<recovery-expr>() == 10);\n            goto get_more;\n        }\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                        return;\n                    }\n                } else if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                        return;\n                    }\n                }\n            }\n        }\n        if (<recovery-expr>()) {\n            return;\n        }\n        <recovery-expr>()->input->cur = <recovery-expr>();\n        if (*<recovery-expr>() == 10) {\n            <recovery-expr>()++;\n            <recovery-expr>()->input->line++;\n            <recovery-expr>()->input->col = 1;\n        }\n        if (*<recovery-expr>() == 13) {\n            <recovery-expr>()++;\n            if (*<recovery-expr>() == 10) {\n                <recovery-expr>()->input->cur = <recovery-expr>();\n                <recovery-expr>()++;\n                <recovery-expr>()->input->line++;\n                <recovery-expr>()->input->col = 1;\n                goto get_more;\n            }\n            <recovery-expr>()--;\n        }\n        if (<recovery-expr>())\n            <recovery-expr>()(<recovery-expr>());\n        ;\n        if (<recovery-expr>())\n            <recovery-expr>()(<recovery-expr>());\n        ;\n        if (<recovery-expr>()) {\n            return;\n        }\n        <recovery-expr>() = <recovery-expr>()->input->cur;\n        if (*<recovery-expr>() == '-') {\n            if (<recovery-expr>()[1] == '-') {\n                if (<recovery-expr>()[2] == '>') {\n                    if (<recovery-expr>()->input->id != inputid) {\n                    }\n                    do {\n                        <recovery-expr>()->input->cur += (3) , <recovery-expr>()->input->col += (3);\n                    } while (0);\n                    if (<recovery-expr>()) {\n                    }\n                    return;\n                }\n                if (<recovery-expr>()) {\n                } else\n                    ;\n                if (<recovery-expr>()) {\n                    return;\n                }\n                <recovery-expr>()++;\n                <recovery-expr>()->input->col++;\n            }\n            <recovery-expr>()++;\n            <recovery-expr>()->input->col++;\n            goto get_more;\n        }\n    } while (((*<recovery-expr>() >= 32) && (*<recovery-expr>() <= 127)) || (*<recovery-expr>() == 9) || (*<recovery-expr>() == 10));\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#4769:1#xmlParseCommentComplex",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    int inputid;\n    inputid = <recovery-expr>()->input->id;\n    if (<recovery-expr>()) {\n        <recovery-expr>() = 0;\n        <recovery-expr>() = 100;\n        if (<recovery-expr>()) {\n            return;\n        }\n    }\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    q = xmlCurrentChar(<recovery-expr>(), &ql);\n    if (q == 0)\n        goto not_terminated;\n    if (!IS_CHAR(q)) {\n        xmlFree(<recovery-expr>());\n        return;\n    }\n    do {\n        if (*(<recovery-expr>()->input->cur) == '\\n') {\n            <recovery-expr>()->input->line++;\n            <recovery-expr>()->input->col = 1;\n        } else\n            <recovery-expr>()->input->col++;\n        <recovery-expr>()->input->cur += ql;\n    } while (0);\n    r = xmlCurrentChar(<recovery-expr>(), &rl);\n    if (r == 0)\n        goto not_terminated;\n    if (!IS_CHAR(r)) {\n        xmlFree(<recovery-expr>());\n        return;\n    }\n    do {\n        if (*(<recovery-expr>()->input->cur) == '\\n') {\n            <recovery-expr>()->input->line++;\n            <recovery-expr>()->input->col = 1;\n        } else\n            <recovery-expr>()->input->col++;\n        <recovery-expr>()->input->cur += rl;\n    } while (0);\n    cur = xmlCurrentChar(<recovery-expr>(), &l);\n    if (cur == 0)\n        goto not_terminated;\n    while (IS_CHAR(cur) && ((cur != '>') || (r != '-') || (q != '-')))\n        {\n            if ((r == '-') && (q == '-')) {\n            }\n            if (<recovery-expr>() + 5 >= <recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    xmlFree(<recovery-expr>());\n                    return;\n                }\n            }\n            if (ql == 1)\n                <recovery-expr>()[<recovery-expr>()++] = q;\n            else\n                <recovery-expr>() += xmlCopyCharMultiByte(&<recovery-expr>()[<recovery-expr>()], q);\n            q = r;\n            ql = rl;\n            r = cur;\n            rl = l;\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    <recovery-expr>()(<recovery-expr>());\n                ;\n                if (<recovery-expr>())\n                    <recovery-expr>()(<recovery-expr>());\n                ;\n                if (<recovery-expr>()) {\n                    xmlFree(<recovery-expr>());\n                    return;\n                }\n            }\n            do {\n                if (*(<recovery-expr>()->input->cur) == '\\n') {\n                    <recovery-expr>()->input->line++;\n                    <recovery-expr>()->input->col = 1;\n                } else\n                    <recovery-expr>()->input->col++;\n                <recovery-expr>()->input->cur += l;\n            } while (0);\n            cur = xmlCurrentChar(<recovery-expr>(), &l);\n            if (cur == 0) {\n                if (<recovery-expr>())\n                    <recovery-expr>()(<recovery-expr>());\n                ;\n                if (<recovery-expr>())\n                    <recovery-expr>()(<recovery-expr>());\n                ;\n                cur = xmlCurrentChar(<recovery-expr>(), &l);\n            }\n            if (<recovery-expr>()) {\n                xmlFree(<recovery-expr>());\n                return;\n            }\n        }\n    <recovery-expr>()[<recovery-expr>()] = 0;\n    if (cur == 0) {\n    } else if (!IS_CHAR(cur)) {\n    } else {\n        if (inputid != <recovery-expr>()->input->id) {\n        }\n        xmlNextChar(<recovery-expr>());\n        if (<recovery-expr>())\n            <recovery-expr>()->sax->comment(<recovery-expr>()->userData, <recovery-expr>());\n    }\n    xmlFree(<recovery-expr>());\n    return;\n  not_terminated:\n    ;\n    xmlFree(<recovery-expr>());\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#9031:1#xmlParseAttValueInternal",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    const int *in;\n    int line, col;\n    int maxLength;\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    line = <recovery-expr>()->input->line;\n    col = <recovery-expr>()->input->col;\n    if (*<recovery-expr>() != '\"' && *<recovery-expr>() != '\\'') {\n    }\n    col++;\n    if (<recovery-expr>()) {\n        const int *oldbase;\n        if (<recovery-expr>())\n            <recovery-expr>()(<recovery-expr>());\n        ;\n        if (<recovery-expr>() != <recovery-expr>()->input->base) {\n        }\n    }\n    if (normalize) {\n        while (<recovery-expr>())\n            {\n                if (*<recovery-expr>() == 10) {\n                    line++;\n                    col = 1;\n                } else {\n                    col++;\n                }\n                <recovery-expr>()++;\n                if (<recovery-expr>()) {\n                    const int *oldbase;\n                    if (<recovery-expr>())\n                        <recovery-expr>()(<recovery-expr>());\n                    ;\n                    if (<recovery-expr>() != <recovery-expr>()->input->base) {\n                    }\n                    if (<recovery-expr>()) {\n                    }\n                }\n            }\n        while (<recovery-expr>())\n            {\n                col++;\n                if ((*<recovery-expr>()++ == 32) && (*<recovery-expr>() == 32))\n                    break;\n                if (<recovery-expr>()) {\n                    const int *oldbase;\n                    if (<recovery-expr>())\n                        <recovery-expr>()(<recovery-expr>());\n                    ;\n                    if (<recovery-expr>() != <recovery-expr>()->input->base) {\n                    }\n                    if (<recovery-expr>()) {\n                    }\n                }\n            }\n        while (<recovery-expr>())\n            {\n                if (*<recovery-expr>() == 10) {\n                    line++ , col = 1;\n                } else {\n                    col++;\n                }\n                <recovery-expr>()++;\n                if (<recovery-expr>()) {\n                    const int *oldbase;\n                    if (<recovery-expr>())\n                        <recovery-expr>()(<recovery-expr>());\n                    ;\n                    if (<recovery-expr>() != <recovery-expr>()->input->base) {\n                    }\n                    if (<recovery-expr>()) {\n                    }\n                }\n            }\n        if (<recovery-expr>()) {\n        }\n        if (<recovery-expr>())\n            goto need_complex;\n    } else {\n        while (<recovery-expr>())\n            {\n                <recovery-expr>()++;\n                col++;\n                if (<recovery-expr>()) {\n                    const int *oldbase;\n                    if (<recovery-expr>())\n                        <recovery-expr>()(<recovery-expr>());\n                    ;\n                    if (<recovery-expr>() != <recovery-expr>()->input->base) {\n                    }\n                    if (<recovery-expr>()) {\n                    }\n                }\n            }\n        if (<recovery-expr>()) {\n        }\n        if (<recovery-expr>())\n            goto need_complex;\n    }\n    <recovery-expr>()++;\n    col++;\n    if (<recovery-expr>()) {\n        if (alloc)\n            *alloc = 0;\n    } else {\n        if (alloc)\n            *alloc = 1;\n    }\n    <recovery-expr>()->input->cur = <recovery-expr>();\n    <recovery-expr>()->input->line = line;\n    <recovery-expr>()->input->col = col;\n  need_complex:\n    if (alloc)\n        *alloc = 1;\n    return <recovery-expr>()(<recovery-expr>(), len, normalize);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#3930:1#xmlParseAttValueComplex",
    "gotos": 21,
    "labels": 2,
    "body": "{\n    int c, l, in_space = 0;\n    if (<recovery-expr>()->input->cur[(0)] == '\"') {\n        xmlNextChar(<recovery-expr>());\n    } else if (<recovery-expr>()->input->cur[(0)] == '\\'') {\n        xmlNextChar(<recovery-expr>());\n    } else {\n    }\n    if (<recovery-expr>())\n        goto mem_error;\n    c = xmlCurrentChar(<recovery-expr>(), &l);\n    while (<recovery-expr>())\n        {\n            if (c == '&') {\n                in_space = 0;\n                if (<recovery-expr>()->input->cur[(1)] == '#') {\n                    int val = <recovery-expr>()(<recovery-expr>());\n                    if (val == '&') {\n                        if (<recovery-expr>()->replaceEntities) {\n                            if (<recovery-expr>()) {\n                                {\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                }\n                                ;\n                            }\n                        } else {\n                            if (<recovery-expr>()) {\n                                {\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                }\n                                ;\n                            }\n                        }\n                    } else if (val != 0) {\n                        if (<recovery-expr>()) {\n                            {\n                                if (<recovery-expr>())\n                                    goto mem_error;\n                                if (<recovery-expr>())\n                                    goto mem_error;\n                            }\n                            ;\n                        }\n                    }\n                } else {\n                    <recovery-expr>()->nbentities++;\n                    if (<recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                            {\n                                if (<recovery-expr>())\n                                    goto mem_error;\n                                if (<recovery-expr>())\n                                    goto mem_error;\n                            }\n                            ;\n                        }\n                        if (<recovery-expr>()) {\n                        } else {\n                        }\n                    } else if (<recovery-expr>()) {\n                        if (<recovery-expr>()) {\n                            ++<recovery-expr>()->depth;\n                            --<recovery-expr>()->depth;\n                            if (<recovery-expr>()) {\n                                while (<recovery-expr>())\n                                    {\n                                        if (<recovery-expr>()) {\n                                        } else\n                                            ;\n                                        if (<recovery-expr>()) {\n                                            {\n                                                if (<recovery-expr>())\n                                                    goto mem_error;\n                                                if (<recovery-expr>())\n                                                    goto mem_error;\n                                            }\n                                            ;\n                                        }\n                                    }\n                            }\n                        } else {\n                            if (<recovery-expr>()) {\n                                {\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                }\n                                ;\n                            }\n                        }\n                    } else if (<recovery-expr>()) {\n                        int i;\n                        const int *cur;\n                        if (<recovery-expr>()) {\n                            unsigned long oldnbent = <recovery-expr>()->nbentities, diff;\n                            ++<recovery-expr>()->depth;\n                            --<recovery-expr>()->depth;\n                            diff = <recovery-expr>()->nbentities - oldnbent + 1;\n                            if (<recovery-expr>()) {\n                            } else {\n                            }\n                        }\n                        while (<recovery-expr>())\n                            {\n                                {\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                    if (<recovery-expr>())\n                                        goto mem_error;\n                                }\n                                ;\n                            }\n                    }\n                }\n            } else {\n                if ((c == 32) || (c == 13) || (c == 10) || (c == 9)) {\n                    if (<recovery-expr>()) {\n                        if ((!normalize) || (!in_space)) {\n                            while (<recovery-expr>())\n                                {\n                                    {\n                                        if (<recovery-expr>())\n                                            goto mem_error;\n                                        if (<recovery-expr>())\n                                            goto mem_error;\n                                    }\n                                    ;\n                                }\n                        }\n                        in_space = 1;\n                    }\n                } else {\n                    in_space = 0;\n                    if (<recovery-expr>()) {\n                        {\n                            if (<recovery-expr>())\n                                goto mem_error;\n                            if (<recovery-expr>())\n                                goto mem_error;\n                        }\n                        ;\n                    }\n                }\n                do {\n                    if (*(<recovery-expr>()->input->cur) == '\\n') {\n                        <recovery-expr>()->input->line++;\n                        <recovery-expr>()->input->col = 1;\n                    } else\n                        <recovery-expr>()->input->col++;\n                    <recovery-expr>()->input->cur += l;\n                } while (0);\n            }\n            if (<recovery-expr>())\n                <recovery-expr>()(<recovery-expr>());\n            ;\n            c = xmlCurrentChar(<recovery-expr>(), &l);\n            if (<recovery-expr>()) {\n                goto mem_error;\n            }\n        }\n    if (<recovery-expr>())\n        goto error;\n    if ((in_space) && (normalize)) {\n    }\n    if ((*<recovery-expr>()->input->cur) == '<') {\n    } else if (<recovery-expr>()) {\n        if ((c != 0) && (!IS_CHAR(c))) {\n        } else {\n        }\n    } else\n        xmlNextChar(<recovery-expr>());\n  mem_error:\n    ;\n  error:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#1358:1#xmlAddSpecialAttr",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>()) {\n        <recovery-expr>()->attsSpecial = xmlHashCreateDict(10, <recovery-expr>()->dict);\n        if (<recovery-expr>())\n            goto mem_error;\n    }\n    if (<recovery-expr>())\n        return;\n    return;\n  mem_error:\n    ;\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#4442:1#xmlParseCharData",
    "gotos": 3,
    "labels": 2,
    "body": "{\n    const int *in;\n    int nbchar = 0;\n    int line = <recovery-expr>()->input->line;\n    int col = <recovery-expr>()->input->col;\n    int ccol;\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    if (!cdata) {\n        <recovery-expr>() = <recovery-expr>()->input->cur;\n        do {\n          get_more_space:\n            while (*<recovery-expr>() == 32)\n                {\n                    <recovery-expr>()++;\n                    <recovery-expr>()->input->col++;\n                }\n            if (*<recovery-expr>() == 10) {\n                do {\n                    <recovery-expr>()->input->line++;\n                    <recovery-expr>()->input->col = 1;\n                    <recovery-expr>()++;\n                } while (*<recovery-expr>() == 10);\n                goto get_more_space;\n            }\n            if (*<recovery-expr>() == '<') {\n                nbchar = <recovery-expr>() - <recovery-expr>()->input->cur;\n                if (nbchar > 0) {\n                    const int *tmp;\n                    <recovery-expr>()->input->cur = <recovery-expr>();\n                    if (<recovery-expr>()) {\n                        if (<recovery-expr>()(<recovery-expr>(), <recovery-expr>(), nbchar, 1)) {\n                            if (<recovery-expr>())\n                                <recovery-expr>()->sax->ignorableWhitespace(<recovery-expr>()->userData, <recovery-expr>(), nbchar);\n                        } else {\n                            if (<recovery-expr>())\n                                <recovery-expr>()->sax->characters(<recovery-expr>()->userData, <recovery-expr>(), nbchar);\n                            if (*<recovery-expr>()->space == -1)\n                                *<recovery-expr>()->space = -2;\n                        }\n                    } else if (<recovery-expr>()) {\n                        <recovery-expr>()->sax->characters(<recovery-expr>()->userData, <recovery-expr>(), nbchar);\n                    }\n                }\n                return;\n            }\n          get_more:\n            ccol = <recovery-expr>()->input->col;\n            while (test_char_data[*<recovery-expr>()])\n                {\n                    <recovery-expr>()++;\n                    ccol++;\n                }\n            <recovery-expr>()->input->col = ccol;\n            if (*<recovery-expr>() == 10) {\n                do {\n                    <recovery-expr>()->input->line++;\n                    <recovery-expr>()->input->col = 1;\n                    <recovery-expr>()++;\n                } while (*<recovery-expr>() == 10);\n                goto get_more;\n            }\n            if (*<recovery-expr>() == ']') {\n                if ((<recovery-expr>()[1] == ']') && (<recovery-expr>()[2] == '>')) {\n                    <recovery-expr>()->input->cur = <recovery-expr>() + 1;\n                    return;\n                }\n                <recovery-expr>()++;\n                <recovery-expr>()->input->col++;\n                goto get_more;\n            }\n            nbchar = <recovery-expr>() - <recovery-expr>()->input->cur;\n            if (nbchar > 0) {\n                if (<recovery-expr>()) {\n                    const int *tmp;\n                    <recovery-expr>()->input->cur = <recovery-expr>();\n                    if (<recovery-expr>()(<recovery-expr>(), <recovery-expr>(), nbchar, 0)) {\n                        if (<recovery-expr>())\n                            <recovery-expr>()->sax->ignorableWhitespace(<recovery-expr>()->userData, <recovery-expr>(), nbchar);\n                    } else {\n                        if (<recovery-expr>())\n                            <recovery-expr>()->sax->characters(<recovery-expr>()->userData, <recovery-expr>(), nbchar);\n                        if (*<recovery-expr>()->space == -1)\n                            *<recovery-expr>()->space = -2;\n                    }\n                    line = <recovery-expr>()->input->line;\n                    col = <recovery-expr>()->input->col;\n                } else if (<recovery-expr>()) {\n                    if (<recovery-expr>())\n                        <recovery-expr>()->sax->characters(<recovery-expr>()->userData, <recovery-expr>()->input->cur, nbchar);\n                    line = <recovery-expr>()->input->line;\n                    col = <recovery-expr>()->input->col;\n                }\n                if (<recovery-expr>())\n                    return;\n            }\n            <recovery-expr>()->input->cur = <recovery-expr>();\n            if (*<recovery-expr>() == 13) {\n                <recovery-expr>()++;\n                if (*<recovery-expr>() == 10) {\n                    <recovery-expr>()->input->cur = <recovery-expr>();\n                    <recovery-expr>()++;\n                    <recovery-expr>()->input->line++;\n                    <recovery-expr>()->input->col = 1;\n                    continue;\n                }\n                <recovery-expr>()--;\n            }\n            if (*<recovery-expr>() == '<') {\n                return;\n            }\n            if (*<recovery-expr>() == '&') {\n                return;\n            }\n            if (<recovery-expr>())\n                <recovery-expr>()(<recovery-expr>());\n            ;\n            if (<recovery-expr>())\n                <recovery-expr>()(<recovery-expr>());\n            ;\n            if (<recovery-expr>())\n                return;\n            <recovery-expr>() = <recovery-expr>()->input->cur;\n        } while (((*<recovery-expr>() >= 32) && (*<recovery-expr>() <= 127)) || (*<recovery-expr>() == 9) || (*<recovery-expr>() == 10));\n        nbchar = 0;\n    }\n    <recovery-expr>()->input->line = line;\n    <recovery-expr>()->input->col = col;\n    <recovery-expr>()(<recovery-expr>(), cdata);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#1479:1#xmlCheckLanguageID",
    "gotos": 10,
    "labels": 4,
    "body": "{\n    const int *cur;\n    if (<recovery-expr>())\n        return (0);\n    if (((<recovery-expr>()[0] == 'i') && (<recovery-expr>()[1] == '-')) || ((<recovery-expr>()[0] == 'I') && (<recovery-expr>()[1] == '-')) || ((<recovery-expr>()[0] == 'x') && (<recovery-expr>()[1] == '-')) || ((<recovery-expr>()[0] == 'X') && (<recovery-expr>()[1] == '-'))) {\n        <recovery-expr>() += 2;\n        while (((<recovery-expr>()[0] >= 'A') && (<recovery-expr>()[0] <= 'Z')) || ((<recovery-expr>()[0] >= 'a') && (<recovery-expr>()[0] <= 'z')))\n            <recovery-expr>()++;\n        return (<recovery-expr>()[0] == 0);\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            return (0);\n        return (1);\n    }\n    if (<recovery-expr>())\n        return (0);\n    if (<recovery-expr>())\n        return (1);\n    if (<recovery-expr>())\n        return (0);\n    if (<recovery-expr>())\n        goto region_m49;\n    if (<recovery-expr>())\n        goto script;\n    if (<recovery-expr>())\n        goto region;\n    if (<recovery-expr>())\n        goto variant;\n    if (<recovery-expr>())\n        return (0);\n    if (<recovery-expr>())\n        return (1);\n    if (<recovery-expr>())\n        return (0);\n    if (<recovery-expr>())\n        goto region_m49;\n    if (<recovery-expr>())\n        goto region;\n    if (<recovery-expr>())\n        goto variant;\n    if (<recovery-expr>())\n        return (0);\n  script:\n    if (<recovery-expr>())\n        return (1);\n    if (<recovery-expr>())\n        return (0);\n    if (<recovery-expr>())\n        goto region_m49;\n    if (<recovery-expr>())\n        goto variant;\n    if (<recovery-expr>())\n        return (0);\n  region:\n    if (<recovery-expr>())\n        return (1);\n    if (<recovery-expr>())\n        return (0);\n    if (<recovery-expr>())\n        return (0);\n  variant:\n    if (<recovery-expr>())\n        return (1);\n    if (<recovery-expr>())\n        return (0);\n    return (1);\n  region_m49:\n    if (<recovery-expr>()) {\n        goto region;\n    }\n    return (0);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#1247:1#xmlAddDefAttrs",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    xmlDefAttrsPtr defaults;\n    int len;\n    const int *name;\n    const int *prefix;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            return;\n    }\n    if (<recovery-expr>()) {\n        <recovery-expr>()->attsDefault = xmlHashCreateDict(10, <recovery-expr>()->dict);\n        if (<recovery-expr>())\n            goto mem_error;\n    }\n    <recovery-expr>() = xmlSplitQName3(<recovery-expr>(), &len);\n    if (<recovery-expr>()) {\n        <recovery-expr>() = xmlDictLookup(<recovery-expr>()->dict, <recovery-expr>(), -1);\n    } else {\n        <recovery-expr>() = xmlDictLookup(<recovery-expr>()->dict, <recovery-expr>(), -1);\n        <recovery-expr>() = xmlDictLookup(<recovery-expr>()->dict, <recovery-expr>(), len);\n    }\n    defaults = xmlHashLookup2(<recovery-expr>()->attsDefault, <recovery-expr>(), <recovery-expr>());\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            goto mem_error;\n        <recovery-expr>(defaults) = 0;\n        <recovery-expr>(defaults) = 4;\n        if (<recovery-expr>()) {\n            xmlFree(defaults);\n            goto mem_error;\n        }\n    } else if (<recovery-expr>(defaults) >= <recovery-expr>(defaults)) {\n        xmlDefAttrsPtr temp;\n        if (<recovery-expr>())\n            goto mem_error;\n        defaults = temp;\n        <recovery-expr>(defaults) *= 2;\n        if (<recovery-expr>()) {\n            xmlFree(defaults);\n            goto mem_error;\n        }\n    }\n    <recovery-expr>() = xmlSplitQName3(<recovery-expr>(), &len);\n    if (<recovery-expr>()) {\n        <recovery-expr>() = xmlDictLookup(<recovery-expr>()->dict, <recovery-expr>(), -1);\n    } else {\n        <recovery-expr>() = xmlDictLookup(<recovery-expr>()->dict, <recovery-expr>(), -1);\n        <recovery-expr>() = xmlDictLookup(<recovery-expr>()->dict, <recovery-expr>(), len);\n    }\n    <recovery-expr>(defaults)[5 * <recovery-expr>(defaults)] = <recovery-expr>();\n    <recovery-expr>(defaults)[5 * <recovery-expr>(defaults) + 1] = <recovery-expr>();\n    len = xmlStrlen(<recovery-expr>());\n    <recovery-expr>() = xmlDictLookup(<recovery-expr>()->dict, <recovery-expr>(), len);\n    <recovery-expr>(defaults)[5 * <recovery-expr>(defaults) + 2] = <recovery-expr>();\n    <recovery-expr>(defaults)[5 * <recovery-expr>(defaults) + 3] = <recovery-expr>() + len;\n    <recovery-expr>(defaults)++;\n    return;\n  mem_error:\n    ;\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#1875:1#nameNsPush",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>()->nameNr >= <recovery-expr>()->nameMax) {\n        const int **tmp;\n        <recovery-expr>()->nameMax *= 2;\n        if (<recovery-expr>()) {\n            <recovery-expr>()->nameMax /= 2;\n            goto mem_error;\n        }\n        <recovery-expr>()->nameTab = <recovery-expr>();\n        if (<recovery-expr>()) {\n            <recovery-expr>()->nameMax /= 2;\n            goto mem_error;\n        }\n    } else if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            goto mem_error;\n    }\n    <recovery-expr>()->nameTab[<recovery-expr>()->nameNr] = <recovery-expr>();\n    <recovery-expr>()->name = <recovery-expr>();\n    return (<recovery-expr>()->nameNr++);\n  mem_error:\n    ;\n    return (-1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#1955:1#namePush",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>())\n        return (-1);\n    if (<recovery-expr>()->nameNr >= <recovery-expr>()->nameMax) {\n        const int **tmp;\n        if (<recovery-expr>()) {\n            goto mem_error;\n        }\n        <recovery-expr>()->nameTab = <recovery-expr>();\n        <recovery-expr>()->nameMax *= 2;\n    }\n    <recovery-expr>()->nameTab[<recovery-expr>()->nameNr] = <recovery-expr>();\n    <recovery-expr>()->name = <recovery-expr>();\n    return (<recovery-expr>()->nameNr++);\n  mem_error:\n    ;\n    return (-1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#1707:1#xmlCtxtGrowAttrs",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    const int **atts;\n    int *attallocs;\n    int maxatts;\n    if (<recovery-expr>()) {\n        maxatts = 55;\n        if (<recovery-expr>())\n            goto mem_error;\n        <recovery-expr>()->atts = <recovery-expr>();\n        attallocs = (int *)xmlMalloc((maxatts / 5) * sizeof(int));\n        if (<recovery-expr>())\n            goto mem_error;\n        <recovery-expr>()->attallocs = attallocs;\n        <recovery-expr>()->maxatts = maxatts;\n    } else if (nr + 5 > <recovery-expr>()->maxatts) {\n        maxatts = (nr + 5) * 2;\n        if (<recovery-expr>())\n            goto mem_error;\n        <recovery-expr>()->atts = <recovery-expr>();\n        attallocs = (int *)xmlRealloc((void *)<recovery-expr>()->attallocs, (maxatts / 5) * sizeof(int));\n        if (<recovery-expr>())\n            goto mem_error;\n        <recovery-expr>()->attallocs = attallocs;\n        <recovery-expr>()->maxatts = maxatts;\n    }\n    return (<recovery-expr>()->maxatts);\n  mem_error:\n    ;\n    return (-1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#3776:1#xmlParseEntityValue",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    int len = 0;\n    int size = 100;\n    int c, l;\n    int maxLength;\n    const int *cur;\n    if ((*<recovery-expr>()->input->cur) == '\"')\n        ;\n    else if ((*<recovery-expr>()->input->cur) == '\\'')\n        ;\n    else {\n    }\n    if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>())\n        <recovery-expr>()(<recovery-expr>());\n    ;\n    if (<recovery-expr>())\n        goto error;\n    xmlNextChar(<recovery-expr>());\n    c = xmlCurrentChar(<recovery-expr>(), &l);\n    while (<recovery-expr>())\n        {\n            if (len + 5 >= size) {\n                size *= 2;\n                if (<recovery-expr>()) {\n                    goto error;\n                }\n            }\n            do {\n                if (*(<recovery-expr>()->input->cur) == '\\n') {\n                    <recovery-expr>()->input->line++;\n                    <recovery-expr>()->input->col = 1;\n                } else\n                    <recovery-expr>()->input->col++;\n                <recovery-expr>()->input->cur += l;\n            } while (0);\n            if (<recovery-expr>())\n                <recovery-expr>()(<recovery-expr>());\n            ;\n            c = xmlCurrentChar(<recovery-expr>(), &l);\n            if (c == 0) {\n                if (<recovery-expr>())\n                    <recovery-expr>()(<recovery-expr>());\n                ;\n                c = xmlCurrentChar(<recovery-expr>(), &l);\n            }\n            if (len > maxLength) {\n                goto error;\n            }\n        }\n    if (<recovery-expr>())\n        goto error;\n    if (<recovery-expr>()) {\n        goto error;\n    }\n    xmlNextChar(<recovery-expr>());\n    while (*<recovery-expr>() != 0)\n        {\n            if ((*<recovery-expr>() == '%') || ((*<recovery-expr>() == '&') && (<recovery-expr>()[1] != '#'))) {\n                int nameOk = 0;\n                <recovery-expr>()++;\n                if (<recovery-expr>()) {\n                    nameOk = 1;\n                }\n                if ((nameOk == 0) || (*<recovery-expr>() != ';')) {\n                    goto error;\n                }\n                if (<recovery-expr>()) {\n                    goto error;\n                }\n                if (*<recovery-expr>() == 0)\n                    break;\n            }\n            <recovery-expr>()++;\n        }\n    ++<recovery-expr>()->depth;\n    --<recovery-expr>()->depth;\n    if (<recovery-expr>()) {\n    }\n  error:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/parser.c#3472:1#xmlParseNCName",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    const int *in;\n    const int *ret;\n    <recovery-expr>() = <recovery-expr>()->input->cur;\n    if (<recovery-expr>()) {\n        <recovery-expr>()++;\n        while (<recovery-expr>())\n            <recovery-expr>()++;\n        if (<recovery-expr>())\n            goto complex;\n        if ((*<recovery-expr>() > 0) && (*<recovery-expr>() < 128)) {\n            if (<recovery-expr>()) {\n            }\n            <recovery-expr>()->input->cur = <recovery-expr>();\n            if (<recovery-expr>()) {\n            }\n            return (<recovery-expr>());\n        }\n    }\n  complex:\n    return (<recovery-expr>()(<recovery-expr>()));\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/libxml2/valid.c#3005:1#xmlAddRef",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>()) {\n    }\n    if (<recovery-expr>()) {\n        <recovery-expr>()(<recovery-expr>(), \"xmlAddRef: Table creation failed!\\n\");\n    }\n    if (<recovery-expr>()) {\n        <recovery-expr>()(<recovery-expr>(), \"malloc failed\");\n    }\n    if (xmlIsStreaming(<recovery-expr>())) {\n    } else {\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            goto failed;\n        }\n        if (<recovery-expr>()) {\n            goto failed;\n        }\n    }\n    if (<recovery-expr>()) {\n        goto failed;\n    }\n  failed:\n    if (<recovery-expr>()) {\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/ae.c#67:1#aeCreateEventLoop",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    aeEventLoop *eventLoop;\n    int i;\n    monotonicInit();\n    if (<recovery-expr>())\n        goto err;\n    eventLoop->events = <recovery-expr>()(sizeof(aeFileEvent) * setsize);\n    eventLoop->fired = <recovery-expr>()(sizeof(aeFiredEvent) * setsize);\n    if (<recovery-expr>())\n        goto err;\n    eventLoop->setsize = setsize;\n    eventLoop->timeEventNextId = 0;\n    eventLoop->stop = 0;\n    eventLoop->maxfd = -1;\n    eventLoop->flags = 0;\n    if (aeApiCreate(eventLoop) == -1)\n        goto err;\n    for (i = 0; i < setsize; i++)\n        eventLoop->events[i].mask = 0;\n    return eventLoop;\n  err:\n    if (eventLoop) {\n        zfree(eventLoop->events);\n        zfree(eventLoop->fired);\n        zfree(eventLoop);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/latency.c#642:1#latencyCommand",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    struct latencyTimeSeries *ts;\n    if (!strcasecmp(c->argv[1]->ptr, \"history\") && c->argc == 3) {\n        ts = dictFetchValue(server.latency_events, c->argv[2]->ptr);\n        if (<recovery-expr>()) {\n            addReplyArrayLen(c, 0);\n        } else {\n            latencyCommandReplyWithSamples(c, ts);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"graph\") && c->argc == 3) {\n        sds graph;\n        dictEntry *de;\n        char *event;\n        de = dictFind(server.latency_events, c->argv[2]->ptr);\n        if (<recovery-expr>())\n            goto nodataerr;\n        ts = (<recovery-expr>((de)).val);\n        event = ((de)->key);\n        graph = latencyCommandGenSparkeline(event, ts);\n        addReplyVerbatim(c, graph, <recovery-expr>()(graph), \"txt\");\n        sdsfree(graph);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"latest\") && c->argc == 2) {\n        latencyCommandReplyWithLatestEvents(c);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"doctor\") && c->argc == 2) {\n        sds report = createLatencyReport();\n        addReplyVerbatim(c, report, <recovery-expr>()(report), \"txt\");\n        sdsfree(report);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"reset\") && c->argc >= 2) {\n        if (c->argc == 2) {\n        } else {\n            int j, resets = 0;\n            for (j = 2; j < c->argc; j++)\n                resets += latencyResetEvent(c->argv[j]->ptr);\n            addReplyLongLong(c, resets);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"histogram\") && c->argc >= 2) {\n        if (c->argc == 2) {\n            int command_with_data = 0;\n            void *replylen = addReplyDeferredLen(c);\n            latencyAllCommandsFillCDF(c, server.commands, &command_with_data);\n            setDeferredMapLen(c, replylen, command_with_data);\n        } else {\n            latencySpecificCommandsFillCDF(c);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"help\") && c->argc == 2) {\n        const char *help[];\n        addReplyHelp(c, help);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n    return;\n  nodataerr:\n    addReplyErrorFormat(c, \"No samples available for event '%s'\", (char *)c->argv[2]->ptr);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#7315:1#clusterManagerCommandBackup",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    ((void)argc);\n    int success = 1, port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(refnode))\n        return 0;\n    int no_issues = clusterManagerCheckCluster(0);\n    int cluster_errors_count = (no_issues ? 0 : ((cluster_manager.errors)->len));\n    config.cluster_manager_command.backup_dir = argv[1];\n    sds json = sdsnew(\"[\\n\");\n    int first_node = 0;\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            if (!first_node)\n                first_node = 1;\n            else\n                json = sdscat(json, \",\\n\");\n            clusterManagerNode *node = ln->value;\n            sds node_json = clusterManagerNodeGetJSON(node, cluster_errors_count);\n            json = sdscat(json, node_json);\n            sdsfree(node_json);\n            if (node->replicate)\n                continue;\n            clusterManagerLog(1, \">>> Node %s:%d -> Saving RDB...\\n\", node->ip, node->port);\n            getRDB(node);\n        }\n    json = sdscat(json, \"\\n]\");\n    sds jsonpath = sdsnew(config.cluster_manager_command.backup_dir);\n    if (jsonpath[<recovery-expr>()(jsonpath) - 1] != '/')\n        jsonpath = sdscat(jsonpath, \"/\");\n    jsonpath = sdscat(jsonpath, \"nodes.json\");\n    clusterManagerLog(1, \"Saving cluster configuration to: %s\\n\", jsonpath);\n    if (<recovery-expr>()) {\n        clusterManagerLog(3, \"Could not save nodes to: %s\\n\", jsonpath);\n        success = 0;\n        goto cleanup;\n    }\n  cleanup:\n    sdsfree(json);\n    sdsfree(jsonpath);\n    if (success) {\n        if (!no_issues) {\n            clusterManagerLog(2, \"*** Cluster seems to have some problems, please be aware of it if you're going to restore this backup.\\n\");\n        }\n        clusterManagerLog(4, \"[OK] Backup created into: %s\\n\", config.cluster_manager_command.backup_dir);\n    } else\n        clusterManagerLog(4, \"[ERR] Failed to back cluster!\\n\");\n    return success;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#7271:1#clusterManagerCommandCall",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int port = 0, i;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(refnode))\n        return 0;\n    argc--;\n    argv++;\n    clusterManagerLog(1, \">>> Calling\");\n    for (i = 0; i < argc; i++) {\n        printf(\" %s\", argv[i]);\n    }\n    printf(\"\\n\");\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (<recovery-expr>())\n                continue;\n            if (<recovery-expr>())\n                continue;\n            if (!<recovery-expr>(n) && !clusterManagerNodeConnect(n))\n                continue;\n            int status;\n            if (<recovery-expr>())\n                printf(\"%s:%d: Failed!\\n\", n->ip, n->port);\n            else {\n                sds formatted_reply;\n                printf(\"%s:%d: %s\\n\", n->ip, n->port, (char *)formatted_reply);\n                sdsfree(formatted_reply);\n            }\n        }\n    return 1;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#7116:1#clusterManagerCommandImport",
    "gotos": 10,
    "labels": 2,
    "body": "{\n    int success = 1;\n    int port = 0, src_port = 0;\n    char *ip, *src_ip;\n    char *invalid_args_msg;\n    sds cmdfmt;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) {\n        invalid_args_msg = \"[ERR] Invalid arguments: you need to pass either a valid address (ie. 120.0.0.1:7000) or space separated IP and port (ie. 120.0.0.1 7000)\\n\";\n        goto invalid_args;\n    }\n    if (<recovery-expr>()) {\n        invalid_args_msg = \"[ERR] Option '--cluster-from' is required for subcommand 'import'.\\n\";\n        goto invalid_args;\n    }\n    char *src_host[] = {config.cluster_manager_command.from};\n    if (!getClusterHostFromCmdArgs(1, src_host, &src_ip, &src_port)) {\n        invalid_args_msg = \"[ERR] Invalid --cluster-from host. You need to pass a valid address (ie. 120.0.0.1:7000).\\n\";\n        goto invalid_args;\n    }\n    clusterManagerLog(1, \">>> Importing data from %s:%d to cluster %s:%d\\n\", src_ip, src_port, ip, port);\n    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(refnode))\n        return 0;\n    if (!clusterManagerCheckCluster(0))\n        return 0;\n    char *reply_err;\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    char *from_user = config.cluster_manager_command.from_user;\n    char *from_pass = config.cluster_manager_command.from_pass;\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        clusterManagerLog(3, \"[ERR] The source node should not be a cluster node.\\n\");\n        success = 0;\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    int size, i;\n    clusterManagerLog(2, \"*** Importing %d keys from DB 0\\n\", size);\n    clusterManagerNode *slots_map[16384];\n    memset(slots_map, 0, sizeof (slots_map));\n    listIter li;\n    listNode *ln;\n    for (i = 0; i < 16384; i++) {\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n->flags & 1 << 1)\n                    continue;\n                if (n->slots_count == 0)\n                    continue;\n                if (<recovery-expr>(n)[i]) {\n                    slots_map[i] = n;\n                    break;\n                }\n            }\n    }\n    cmdfmt = sdsnew(\"MIGRATE %s %d %s %d %d\");\n    if (config.conn_info.auth) {\n        if (config.conn_info.user) {\n            cmdfmt = sdscatfmt(cmdfmt, \" AUTH2 %s %s\", config.conn_info.user, config.conn_info.auth);\n        } else {\n            cmdfmt = sdscatfmt(cmdfmt, \" AUTH %s\", config.conn_info.auth);\n        }\n    }\n    if (config.cluster_manager_command.flags & 1 << 7)\n        cmdfmt = sdscat(cmdfmt, \" COPY\");\n    if (config.cluster_manager_command.flags & 1 << 6)\n        cmdfmt = sdscat(cmdfmt, \" REPLACE\");\n    int cursor = -999, timeout = config.cluster_manager_command.timeout;\n    while (cursor != 0)\n        {\n            if (cursor < 0)\n                cursor = 0;\n            if (<recovery-expr>()) {\n                success = 0;\n                goto cleanup;\n            }\n            int keycount;\n            for (i = 0; i < keycount; i++) {\n                char *key;\n                clusterManagerNode *target;\n                printf(\"Migrating %s to %s:%d: \", key, target->ip, target->port);\n                if (<recovery-expr>()) {\n                    if (<recovery-expr>()) {\n                    }\n                    success = 0;\n                }\n                if (!success)\n                    goto cleanup;\n                clusterManagerLog(4, \"OK\\n\");\n            }\n        }\n  cleanup:\n    if (reply_err)\n        clusterManagerLog(3, \"Source %s:%d replied with error:\\n%s\\n\", src_ip, src_port, reply_err);\n    if (cmdfmt)\n        sdsfree(cmdfmt);\n    return success;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#7058:1#clusterManagerCommandSetTimeout",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    ((void)argc);\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    int timeout = atoi(argv[1]);\n    if (timeout < 100) {\n        return 0;\n    }\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    int ok_count = 0, err_count = 0;\n    clusterManagerLog(1, \">>> Reconfiguring node timeout in every cluster node...\\n\");\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            char *err;\n            if (<recovery-expr>())\n                goto reply_err;\n            int ok;\n            if (!ok)\n                goto reply_err;\n            if (<recovery-expr>())\n                goto reply_err;\n            if (!ok)\n                goto reply_err;\n            clusterManagerLog(2, \"*** New timeout set for %s:%d\\n\", n->ip, n->port);\n            ok_count++;\n            continue;\n          reply_err:\n            ;\n            int need_free = 0;\n            if (<recovery-expr>())\n                err = \"\";\n            else\n                need_free = 1;\n            clusterManagerLog(3, \"ERR setting node-timeout for %s:%d: %s\\n\", n->ip, n->port, err);\n            if (need_free)\n                zfree(err);\n            err_count++;\n        }\n    clusterManagerLog(1, \">>> New node timeout set. %d OK, %d ERR.\\n\", ok_count, err_count);\n    return 1;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6863:1#clusterManagerCommandRebalance",
    "gotos": 9,
    "labels": 3,
    "body": "{\n    int port = 0;\n    char *ip;\n    clusterManagerNode **weightedNodes;\n    list *involved;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    int result = 1, i;\n    if (<recovery-expr>()) {\n        for (i = 0; i < config.cluster_manager_command.weight_argc; i++) {\n            char *name = config.cluster_manager_command.weight[i];\n            char *p = strchr(name, '=');\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \"*** invalid input %s\\n\", name);\n                result = 0;\n                goto cleanup;\n            }\n            *p = '\\x00';\n            float w = atof(++p);\n            clusterManagerNode *n = clusterManagerNodeByAbbreviatedName(name);\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \"*** No such master node %s\\n\", name);\n                result = 0;\n                goto cleanup;\n            }\n            n->weight = w;\n        }\n    }\n    float total_weight = 0;\n    int nodes_involved = 0;\n    int use_empty = config.cluster_manager_command.flags & 1 << 4;\n    involved = listCreate();\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (n->flags & 1 << 1 || n->replicate)\n                continue;\n            if (!use_empty && n->slots_count == 0) {\n                n->weight = 0;\n                continue;\n            }\n            total_weight += n->weight;\n            nodes_involved++;\n            listAddNodeTail(involved, n);\n        }\n    weightedNodes = <recovery-expr>()(nodes_involved * sizeof(clusterManagerNode *));\n    if (<recovery-expr>())\n        goto cleanup;\n    clusterManagerCheckCluster(1);\n    if (cluster_manager.errors && ((cluster_manager.errors)->len) > 0) {\n        clusterManagerLog(3, \"*** Please fix your cluster problems before rebalancing\\n\");\n        result = 0;\n        goto cleanup;\n    }\n    int threshold_reached = 0, total_balance = 0;\n    float threshold = config.cluster_manager_command.threshold;\n    i = 0;\n    listRewind(involved, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            weightedNodes[i++] = n;\n            int expected = (int)(((float)16384 / total_weight) * n->weight);\n            n->balance = n->slots_count - expected;\n            total_balance += n->balance;\n            int over_threshold = 0;\n            if (threshold > 0) {\n                if (n->slots_count > 0) {\n                    float err_perc = fabs((100 - (100. * expected / n->slots_count)));\n                    if (err_perc > threshold)\n                        over_threshold = 1;\n                } else if (expected > 1) {\n                    over_threshold = 1;\n                }\n            }\n            if (over_threshold)\n                threshold_reached = 1;\n        }\n    if (!threshold_reached) {\n        clusterManagerLog(2, \"*** No rebalancing needed! All nodes are within the %.2f%% threshold.\\n\", config.cluster_manager_command.threshold);\n        goto cleanup;\n    }\n    while (total_balance > 0)\n        {\n            listRewind(involved, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    if (n->balance <= 0 && total_balance > 0) {\n                        n->balance--;\n                        total_balance--;\n                    }\n                }\n        }\n    qsort(weightedNodes, nodes_involved, sizeof(clusterManagerNode *), clusterManagerCompareNodeBalance);\n    clusterManagerLog(1, \">>> Rebalancing across %d nodes. Total weight = %.2f\\n\", nodes_involved, total_weight);\n    if (config.verbose) {\n        for (i = 0; i < nodes_involved; i++) {\n            clusterManagerNode *n = weightedNodes[i];\n            printf(\"%s:%d balance is %d slots\\n\", n->ip, n->port, n->balance);\n        }\n    }\n    int dst_idx = 0;\n    int src_idx = nodes_involved - 1;\n    int simulate = config.cluster_manager_command.flags & 1 << 5;\n    while (dst_idx < src_idx)\n        {\n            clusterManagerNode *dst = weightedNodes[dst_idx];\n            clusterManagerNode *src = weightedNodes[src_idx];\n            int db = abs(dst->balance);\n            int sb = abs(src->balance);\n            int numslots = (db < sb ? db : sb);\n            if (numslots > 0) {\n                printf(\"Moving %d slots from %s:%d to %s:%d\\n\", numslots, src->ip, src->port, dst->ip, dst->port);\n                list *lsrc = listCreate(), *table;\n                listAddNodeTail(lsrc, src);\n                table = clusterManagerComputeReshardTable(lsrc, numslots);\n                listRelease(lsrc);\n                int table_len = (int)((table)->len);\n                if (!table || table_len != numslots) {\n                    clusterManagerLog(3, \"*** Assertion failed: Reshard table != number of slots\");\n                    result = 0;\n                    goto end_move;\n                }\n                if (simulate) {\n                    for (i = 0; i < table_len; i++)\n                        printf(\"#\");\n                } else {\n                    int opts = 1 << 6 | 1 << 2;\n                    listRewind(table, &li);\n                    while (<recovery-expr>())\n                        {\n                            clusterManagerReshardTableItem *item = ln->value;\n                            char *err;\n                            result = clusterManagerMoveSlot(item->source, dst, item->slot, opts, &err);\n                            if (!result) {\n                                clusterManagerLog(3, \"*** clusterManagerMoveSlot: %s\\n\", err);\n                                zfree(err);\n                                goto end_move;\n                            }\n                            printf(\"#\");\n                        }\n                }\n                printf(\"\\n\");\n              end_move:\n                clusterManagerReleaseReshardTable(table);\n                if (!result)\n                    goto cleanup;\n            }\n            dst->balance += numslots;\n            src->balance -= numslots;\n            if (dst->balance == 0)\n                dst_idx++;\n            if (src->balance == 0)\n                src_idx--;\n        }\n  cleanup:\n    if (<recovery-expr>())\n        listRelease(involved);\n    if (<recovery-expr>())\n        zfree(weightedNodes);\n    return result;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6676:1#clusterManagerCommandReshard",
    "gotos": 7,
    "labels": 2,
    "body": "{\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    clusterManagerCheckCluster(0);\n    if (cluster_manager.errors && ((cluster_manager.errors)->len) > 0) {\n        return 0;\n    }\n    int slots = config.cluster_manager_command.slots;\n    if (!slots) {\n        while (slots <= 0 || slots > 16384)\n            {\n                printf(\"How many slots do you want to move (from 1 to %d)? \", 16384);\n                char buf[6];\n                int nread;\n                if (nread <= 0)\n                    continue;\n                int last_idx = nread - 1;\n                if (buf[last_idx] != '\\n') {\n                    int ch;\n                    while (<recovery-expr>())\n                        {\n                        }\n                }\n                buf[last_idx] = '\\x00';\n                slots = atoi(buf);\n            }\n    }\n    char buf[255];\n    char *to = config.cluster_manager_command.to, *from = config.cluster_manager_command.from;\n    while (<recovery-expr>())\n        {\n            printf(\"What is the receiving node ID? \");\n            int nread;\n            if (nread <= 0)\n                continue;\n            int last_idx = nread - 1;\n            if (buf[last_idx] != '\\n') {\n                int ch;\n                while (<recovery-expr>())\n                    {\n                    }\n            }\n            buf[last_idx] = '\\x00';\n            if (strlen(buf) > 0)\n                to = buf;\n        }\n    int raise_err = 0;\n    clusterManagerNode *target;\n    if (<recovery-expr>())\n        return 0;\n    list *sources = listCreate();\n    list *table;\n    int all = 0, result = 1;\n    if (<recovery-expr>()) {\n        printf(\"Please enter all the source node IDs.\\n\");\n        printf(\"  Type 'all' to use all the nodes as source nodes for the hash slots.\\n\");\n        printf(\"  Type 'done' once you entered all the source nodes IDs.\\n\");\n        while (1)\n            {\n                printf(\"Source node #%lu: \", ((sources)->len) + 1);\n                int nread;\n                if (nread <= 0)\n                    continue;\n                int last_idx = nread - 1;\n                if (buf[last_idx] != '\\n') {\n                    int ch;\n                    while (<recovery-expr>())\n                        {\n                        }\n                }\n                buf[last_idx] = '\\x00';\n                if (!strcmp(buf, \"done\"))\n                    break;\n                else if (!strcmp(buf, \"all\")) {\n                    all = 1;\n                    break;\n                } else {\n                    clusterManagerNode *src = clusterNodeForResharding(buf, target, &raise_err);\n                    if (<recovery-expr>())\n                        listAddNodeTail(sources, src);\n                    else if (raise_err) {\n                        result = 0;\n                        goto cleanup;\n                    }\n                }\n            }\n    } else {\n        char *p;\n        while (<recovery-expr>())\n            {\n                *p = '\\x00';\n                if (!strcmp(from, \"all\")) {\n                    all = 1;\n                    break;\n                } else {\n                    clusterManagerNode *src = clusterNodeForResharding(from, target, &raise_err);\n                    if (<recovery-expr>())\n                        listAddNodeTail(sources, src);\n                    else if (raise_err) {\n                        result = 0;\n                        goto cleanup;\n                    }\n                }\n                from = p + 1;\n            }\n        if (!all && strlen(from) > 0) {\n            if (!strcmp(from, \"all\"))\n                all = 1;\n            if (!all) {\n                clusterManagerNode *src = clusterNodeForResharding(from, target, &raise_err);\n                if (<recovery-expr>())\n                    listAddNodeTail(sources, src);\n                else if (raise_err) {\n                    result = 0;\n                    goto cleanup;\n                }\n            }\n        }\n    }\n    listIter li;\n    listNode *ln;\n    if (all) {\n        listEmpty(sources);\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n->flags & 1 << 1 || n->replicate)\n                    continue;\n                if (!sdscmp(n->name, target->name))\n                    continue;\n                listAddNodeTail(sources, n);\n            }\n    }\n    if (((sources)->len) == 0) {\n        result = 0;\n        goto cleanup;\n    }\n    printf(\"\\nReady to move %d slots.\\n\", slots);\n    printf(\"  Source nodes:\\n\");\n    listRewind(sources, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *src = ln->value;\n            sds info = clusterManagerNodeInfo(src, 4);\n            printf(\"%s\\n\", info);\n            sdsfree(info);\n        }\n    printf(\"  Destination node:\\n\");\n    sds info = clusterManagerNodeInfo(target, 4);\n    printf(\"%s\\n\", info);\n    sdsfree(info);\n    table = clusterManagerComputeReshardTable(sources, slots);\n    printf(\"  Resharding plan:\\n\");\n    clusterManagerShowReshardTable(table);\n    if (!(config.cluster_manager_command.flags & 1 << 2)) {\n        printf(\"Do you want to proceed with the proposed reshard plan (yes/no)? \");\n        char buf[4];\n        int nread;\n        buf[3] = '\\x00';\n        if (nread <= 0 || strcmp(\"yes\", buf) != 0) {\n            result = 0;\n            goto cleanup;\n        }\n    }\n    int opts = 1 << 7;\n    listRewind(table, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerReshardTableItem *item = ln->value;\n            char *err;\n            result = clusterManagerMoveSlot(item->source, target, item->slot, opts, &err);\n            if (!result) {\n                if (<recovery-expr>()) {\n                    clusterManagerLog(3, \"clusterManagerMoveSlot failed: %s\\n\", err);\n                    zfree(err);\n                }\n                goto cleanup;\n            }\n        }\n  cleanup:\n    listRelease(sources);\n    clusterManagerReleaseReshardTable(table);\n    return result;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#5205:1#clusterManagerFixSlotsCoverage",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    int force_fix = config.cluster_manager_command.flags & 1 << 10;\n    if (cluster_manager.unreachable_masters > 0 && !force_fix) {\n        clusterManagerLog(2, \"*** Fixing slots coverage with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\\n\", cluster_manager.unreachable_masters);\n        exit(1);\n    }\n    int i, fixed = 0;\n    list *none, *single, *multi;\n    clusterManagerLog(1, \">>> Fixing slots coverage...\\n\");\n    for (i = 0; i < 16384; i++) {\n        int covered = all_slots[i];\n        if (!covered) {\n            sds slot = sdsfromlonglong((long long)i);\n            list *slot_nodes = listCreate();\n            sds slot_nodes_str = sdsempty();\n            listIter li;\n            listNode *ln;\n            listRewind(cluster_manager.nodes, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    if (n->flags & 1 << 1 || n->replicate)\n                        continue;\n                    if (<recovery-expr>()) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    if (<recovery-expr>()) {\n                        listAddNodeTail(slot_nodes, n);\n                        if (((slot_nodes)->len) > 1)\n                            slot_nodes_str = sdscat(slot_nodes_str, \", \");\n                        slot_nodes_str = sdscatfmt(slot_nodes_str, \"%s:%u\", n->ip, n->port);\n                    }\n                }\n            sdsfree(slot_nodes_str);\n            dictAdd(clusterManagerUncoveredSlots, slot, slot_nodes);\n        }\n    }\n    none = listCreate();\n    single = listCreate();\n    multi = listCreate();\n    dictIterator *iter = dictGetIterator(clusterManagerUncoveredSlots);\n    dictEntry *entry;\n    while (<recovery-expr>())\n        {\n            sds slot = (sds)((entry)->key);\n            list *nodes = (list *)(<recovery-expr>((entry)).val);\n            switch (((nodes)->len)) {\n              case 0:\n                listAddNodeTail(none, slot);\n                break;\n              case 1:\n                listAddNodeTail(single, slot);\n                break;\n              default:\n                listAddNodeTail(multi, slot);\n                break;\n            }\n        }\n    dictReleaseIterator(iter);\n    int ignore_force = 1;\n    if (((none)->len) > 0) {\n        printf(\"The following uncovered slots have no keys across the cluster:\\n\");\n        clusterManagerPrintSlotsList(none);\n        if (confirmWithYes(\"Fix these slots by covering with a random node?\", ignore_force)) {\n            listIter li;\n            listNode *ln;\n            listRewind(none, &li);\n            while (<recovery-expr>())\n                {\n                    sds slot = ln->value;\n                    int s = atoi(slot);\n                    clusterManagerNode *n = clusterManagerNodeMasterRandom();\n                    clusterManagerLog(1, \">>> Covering slot %s with %s:%d\\n\", slot, n->ip, n->port);\n                    if (!clusterManagerSetSlotOwner(n, s, 0)) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    <recovery-expr>(n)[s] = 1;\n                    fixed++;\n                }\n        }\n    }\n    if (((single)->len) > 0) {\n        printf(\"The following uncovered slots have keys in just one node:\\n\");\n        clusterManagerPrintSlotsList(single);\n        if (confirmWithYes(\"Fix these slots by covering with those nodes?\", ignore_force)) {\n            listIter li;\n            listNode *ln;\n            listRewind(single, &li);\n            while (<recovery-expr>())\n                {\n                    sds slot = ln->value;\n                    int s = atoi(slot);\n                    dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);\n                    list *nodes = (list *)(<recovery-expr>((entry)).val);\n                    listNode *fn = ((nodes)->head);\n                    clusterManagerNode *n = fn->value;\n                    clusterManagerLog(1, \">>> Covering slot %s with %s:%d\\n\", slot, n->ip, n->port);\n                    if (!clusterManagerSetSlotOwner(n, s, 0)) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    <recovery-expr>(n)[atoi(slot)] = 1;\n                    fixed++;\n                }\n        }\n    }\n    if (((multi)->len) > 0) {\n        printf(\"The following uncovered slots have keys in multiple nodes:\\n\");\n        clusterManagerPrintSlotsList(multi);\n        if (confirmWithYes(\"Fix these slots by moving keys into a single node?\", ignore_force)) {\n            listIter li;\n            listNode *ln;\n            listRewind(multi, &li);\n            while (<recovery-expr>())\n                {\n                    sds slot = ln->value;\n                    dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);\n                    list *nodes = (list *)(<recovery-expr>((entry)).val);\n                    int s = atoi(slot);\n                    clusterManagerNode *target;\n                    if (<recovery-expr>()) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    clusterManagerLog(1, \">>> Covering slot %s moving keys to %s:%d\\n\", slot, target->ip, target->port);\n                    if (!clusterManagerSetSlotOwner(target, s, 1)) {\n                        fixed = -1;\n                        goto cleanup;\n                    }\n                    <recovery-expr>(target)[atoi(slot)] = 1;\n                    listIter nli;\n                    listNode *nln;\n                    listRewind(nodes, &nli);\n                    while (<recovery-expr>())\n                        {\n                            clusterManagerNode *src = nln->value;\n                            if (src == target)\n                                continue;\n                            if (<recovery-expr>())\n                                fixed = -1;\n                            if (fixed < 0)\n                                goto cleanup;\n                            if (<recovery-expr>())\n                                fixed = -1;\n                            if (fixed < 0)\n                                goto cleanup;\n                            int opts = 1 << 7 | 1 << 1;\n                            if (<recovery-expr>()) {\n                                fixed = -1;\n                                goto cleanup;\n                            }\n                            if (!clusterManagerClearSlotStatus(src, s))\n                                fixed = -1;\n                            if (fixed < 0)\n                                goto cleanup;\n                        }\n                    fixed++;\n                }\n        }\n    }\n  cleanup:\n    if (none)\n        listRelease(none);\n    if (single)\n        listRelease(single);\n    if (multi)\n        listRelease(multi);\n    return fixed;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4872:1#clusterManagerGetConfigSignature",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    sds signature;\n    int node_count = 0, i = 0, name_len = 0;\n    char **node_configs;\n    if (<recovery-expr>())\n        goto cleanup;\n    char *lines, *p, *line;\n    while (<recovery-expr>())\n        {\n            i = 0;\n            *p = '\\x00';\n            line = lines;\n            lines = p + 1;\n            char *nodename;\n            int tot_size = 0;\n            while (<recovery-expr>())\n                {\n                    *p = '\\x00';\n                    char *token = line;\n                    line = p + 1;\n                    if (i == 0) {\n                        nodename = token;\n                        tot_size = (p - token);\n                        name_len = tot_size++;\n                    }\n                    if (++i == 8)\n                        break;\n                }\n            if (i != 8)\n                continue;\n            if (<recovery-expr>())\n                continue;\n            int remaining = strlen(line);\n            if (remaining == 0)\n                continue;\n            char **slots;\n            int c = 0;\n            while (remaining > 0)\n                {\n                    p = strchr(line, ' ');\n                    if (<recovery-expr>())\n                        p = line + remaining;\n                    int size = (p - line);\n                    remaining -= size;\n                    tot_size += size;\n                    char *slotsdef = line;\n                    *p = '\\x00';\n                    if (remaining) {\n                        line = p + 1;\n                        remaining--;\n                    } else\n                        line = p;\n                    if (slotsdef[0] != '[') {\n                        c++;\n                        slots = <recovery-expr>()(slots, (c * sizeof(char *)));\n                        slots[c - 1] = slotsdef;\n                    }\n                }\n            if (c > 0) {\n                if (c > 1)\n                    qsort(slots, c, sizeof(char *), clusterManagerSlotCompare);\n                node_count++;\n                node_configs = <recovery-expr>()(node_configs, (node_count * sizeof(char *)));\n                tot_size += (sizeof(char) * (c - 1));\n                char *cfg = <recovery-expr>()((sizeof(char) * tot_size) + 1);\n                memcpy(cfg, nodename, name_len);\n                char *sp = cfg + name_len;\n                *(sp++) = ':';\n                for (i = 0; i < c; i++) {\n                    if (i > 0)\n                        *(sp++) = ',';\n                    int slen = strlen(slots[i]);\n                    memcpy(sp, slots[i], slen);\n                    sp += slen;\n                }\n                *(sp++) = '\\x00';\n                node_configs[node_count - 1] = cfg;\n            }\n            zfree(slots);\n        }\n    if (node_count > 0) {\n        if (node_count > 1) {\n            qsort(node_configs, node_count, sizeof(char *), clusterManagerSlotCompare);\n        }\n        signature = sdsempty();\n        for (i = 0; i < node_count; i++) {\n            if (i > 0)\n                signature = sdscatprintf(signature, \"%c\", '|');\n            signature = sdscatfmt(signature, \"%s\", node_configs[i]);\n        }\n    }\n  cleanup:\n    ;\n    if (<recovery-expr>()) {\n        for (i = 0; i < node_count; i++)\n            zfree(node_configs[i]);\n        zfree(node_configs);\n    }\n    return signature;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4599:1#clusterManagerNodeLoadInfo",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int success = 1;\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    int getfriends = (opts & 1 << 0);\n    char *lines, *p, *line;\n    while (<recovery-expr>())\n        {\n            *p = '\\x00';\n            line = lines;\n            lines = p + 1;\n            char *name, *addr, *flags, *master_id, *ping_sent, *ping_recv, *config_epoch, *link_status;\n            ((void)link_status);\n            int i = 0;\n            while (<recovery-expr>())\n                {\n                    *p = '\\x00';\n                    char *token = line;\n                    line = p + 1;\n                    switch (i++) {\n                      case 0:\n                        name = token;\n                        break;\n                      case 1:\n                        addr = token;\n                        break;\n                      case 2:\n                        flags = token;\n                        break;\n                      case 3:\n                        master_id = token;\n                        break;\n                      case 4:\n                        ping_sent = token;\n                        break;\n                      case 5:\n                        ping_recv = token;\n                        break;\n                      case 6:\n                        config_epoch = token;\n                        break;\n                      case 7:\n                        link_status = token;\n                        break;\n                    }\n                    if (i == 8)\n                        break;\n                }\n            if (!flags) {\n                success = 0;\n                goto cleanup;\n            }\n            char *ip;\n            int port = 0, bus_port = 0;\n            if (<recovery-expr>()) {\n                success = 0;\n                goto cleanup;\n            }\n            int myself;\n            clusterManagerNode *currentNode;\n            if (myself) {\n                node->bus_port = bus_port;\n                node->flags |= 1 << 0;\n                currentNode = node;\n                clusterManagerNodeResetSlots(node);\n                if (i == 8) {\n                    int remaining = strlen(line);\n                    while (remaining > 0)\n                        {\n                            p = strchr(line, ' ');\n                            if (<recovery-expr>())\n                                p = line + remaining;\n                            remaining -= (p - line);\n                            char *slotsdef = line;\n                            *p = '\\x00';\n                            if (remaining) {\n                                line = p + 1;\n                                remaining--;\n                            } else\n                                line = p;\n                            char *dash;\n                            if (slotsdef[0] == '[') {\n                                slotsdef++;\n                                if ((p = strstr(slotsdef, \"->-\"))) {\n                                    *p = '\\x00';\n                                    p += 3;\n                                    char *closing_bracket = strchr(p, ']');\n                                    if (closing_bracket)\n                                        *closing_bracket = '\\x00';\n                                    sds slot = sdsnew(slotsdef);\n                                    sds dst = sdsnew(p);\n                                    node->migrating_count += 2;\n                                    node->migrating = <recovery-expr>()(node->migrating, (node->migrating_count * sizeof(sds)));\n                                    node->migrating[node->migrating_count - 2] = slot;\n                                    node->migrating[node->migrating_count - 1] = dst;\n                                } else if ((p = strstr(slotsdef, \"-<-\"))) {\n                                    *p = '\\x00';\n                                    p += 3;\n                                    char *closing_bracket = strchr(p, ']');\n                                    if (closing_bracket)\n                                        *closing_bracket = '\\x00';\n                                    sds slot = sdsnew(slotsdef);\n                                    sds src = sdsnew(p);\n                                    node->importing_count += 2;\n                                    node->importing = <recovery-expr>()(node->importing, (node->importing_count * sizeof(sds)));\n                                    node->importing[node->importing_count - 2] = slot;\n                                    node->importing[node->importing_count - 1] = src;\n                                }\n                            } else if (<recovery-expr>()) {\n                                p = dash;\n                                int start, stop;\n                                *p = '\\x00';\n                                start = atoi(slotsdef);\n                                stop = atoi(p + 1);\n                                node->slots_count += (stop - (start - 1));\n                                while (start <= stop)\n                                    <recovery-expr>(node)[start++] = 1;\n                            } else if (p > slotsdef) {\n                                <recovery-expr>(node)[atoi(slotsdef)] = 1;\n                                node->slots_count++;\n                            }\n                        }\n                }\n                node->dirty = 0;\n            } else if (!getfriends) {\n                if (!(node->flags & 1 << 0))\n                    continue;\n                else\n                    break;\n            } else {\n                currentNode = clusterManagerNewNode(sdsnew(ip), port, bus_port);\n                currentNode->flags |= 1 << 2;\n                if (<recovery-expr>())\n                    node->friends = listCreate();\n                listAddNodeTail(node->friends, currentNode);\n            }\n            if (<recovery-expr>()) {\n                if (currentNode->name)\n                    sdsfree(currentNode->name);\n                currentNode->name = sdsnew(name);\n            }\n            if (<recovery-expr>())\n                freeClusterManagerNodeFlags(currentNode->flags_str);\n            currentNode->flags_str = listCreate();\n            int flag_len;\n            while ((flag_len = strlen(flags)) > 0)\n                {\n                    sds flag;\n                    char *fp = strchr(flags, ',');\n                    if (fp) {\n                        *fp = '\\x00';\n                        flag = sdsnew(flags);\n                        flags = fp + 1;\n                    } else {\n                        flag = sdsnew(flags);\n                        flags += flag_len;\n                    }\n                    if (strcmp(flag, \"noaddr\") == 0)\n                        currentNode->flags |= 1 << 3;\n                    else if (strcmp(flag, \"disconnected\") == 0)\n                        currentNode->flags |= 1 << 4;\n                    else if (strcmp(flag, \"fail\") == 0)\n                        currentNode->flags |= 1 << 5;\n                    else if (strcmp(flag, \"slave\") == 0) {\n                        currentNode->flags |= 1 << 1;\n                        if (<recovery-expr>()) {\n                            if (currentNode->replicate)\n                                sdsfree(currentNode->replicate);\n                            currentNode->replicate = sdsnew(master_id);\n                        }\n                    }\n                    listAddNodeTail(currentNode->flags_str, flag);\n                }\n            if (<recovery-expr>())\n                <recovery-expr>(currentNode) = atoll(config_epoch);\n            if (<recovery-expr>())\n                <recovery-expr>(currentNode) = atoll(ping_sent);\n            if (<recovery-expr>())\n                <recovery-expr>(currentNode) = atoll(ping_recv);\n            if (!getfriends && myself)\n                break;\n        }\n  cleanup:\n    ;\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4992:1#clusterManagerGetDisconnectedLinks",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    list *links;\n    if (<recovery-expr>())\n        goto cleanup;\n    links = listCreate();\n    char *lines, *p, *line;\n    while (<recovery-expr>())\n        {\n            int i = 0;\n            *p = '\\x00';\n            line = lines;\n            lines = p + 1;\n            char *nodename, *addr, *flags, *link_status;\n            while (<recovery-expr>())\n                {\n                    *p = '\\x00';\n                    char *token = line;\n                    line = p + 1;\n                    if (i == 0)\n                        nodename = token;\n                    else if (i == 1)\n                        addr = token;\n                    else if (i == 2)\n                        flags = token;\n                    else if (i == 7)\n                        link_status = token;\n                    else if (i == 8)\n                        break;\n                    i++;\n                }\n            if (i == 7)\n                link_status = line;\n            if (<recovery-expr>())\n                continue;\n            if (<recovery-expr>())\n                continue;\n            int disconnected;\n            int handshaking;\n            if (disconnected || handshaking) {\n                clusterManagerLink *link = <recovery-expr>()(sizeof (*link));\n                link->node_name = sdsnew(nodename);\n                link->node_addr = sdsnew(addr);\n                link->connected = 0;\n                link->handshaking = handshaking;\n                listAddNodeTail(links, link);\n            }\n        }\n  cleanup:\n    ;\n    return links;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4508:1#clusterManagerFlushNodeConfig",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    if (!node->dirty)\n        return 0;\n    int is_err = 0, success = 1;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n            }\n            success = 0;\n            goto cleanup;\n        }\n    } else {\n        int added = clusterManagerAddSlots(node, err);\n        if (<recovery-expr>())\n            success = 0;\n    }\n    node->dirty = 0;\n  cleanup:\n    ;\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3999:1#clusterManagerSetSlot",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>()) {\n        if (err)\n            *err = zstrdup(\"CLUSTER SETSLOT failed to run\");\n        return 0;\n    }\n    int success = 1;\n    if (<recovery-expr>()) {\n        success = 0;\n        if (<recovery-expr>()) {\n        } else\n            ;\n        ;\n        goto cleanup;\n    }\n  cleanup:\n    ;\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3905:1#clusterManagerAddSlots",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    void *_reply;\n    int success = 1;\n    int argc = node->slots_count + 2;\n    sds *argv = <recovery-expr>()(argc * sizeof (*argv));\n    argv[0] = \"CLUSTER\";\n    argv[1] = \"ADDSLOTS\";\n    int i, argv_idx = 2;\n    for (i = 0; i < 16384; i++) {\n        if (argv_idx >= argc)\n            break;\n        if (<recovery-expr>(node)[i]) {\n            argv[argv_idx] = sdsfromlonglong((long long)i);\n            argv_idx++;\n        }\n    }\n    if (argv_idx == 2) {\n        success = 0;\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n  cleanup:\n    ;\n    if (<recovery-expr>()) {\n        for (i = 2; i < argc; i++)\n            sdsfree(argv[i]);\n        zfree(argv);\n    }\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3457:1#clusterManagerNodeIsEmpty",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int is_empty = 1;\n    if (<recovery-expr>())\n        return 0;\n    if (<recovery-expr>()) {\n        is_empty = 0;\n        goto result;\n    }\n    if (<recovery-expr>()) {\n        is_empty = 0;\n        goto result;\n    }\n    long known_nodes;\n    is_empty = (known_nodes == 1);\n  result:\n    ;\n    return is_empty;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4122:1#clusterManagerCompareKeysValues",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    static const char *hash_zero = \"0000000000000000000000000000000000000000\";\n    char **argv;\n    argv[0] = \"DEBUG\";\n    argv[1] = \"DIGEST-VALUE\";\n    int success = 0;\n    void *_reply1, *_reply2;\n    if (!success)\n        goto cleanup;\n    if (!success)\n        goto cleanup;\n    if (<recovery-expr>()) {\n        ;\n        success = 0;\n    }\n    if (<recovery-expr>()) {\n        ;\n        success = 0;\n    }\n    if (!success)\n        goto cleanup;\n  cleanup:\n    ;\n    zfree(argv);\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3296:1#clusterManagerExecTransaction",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int success;\n    if (success) {\n        if (<recovery-expr>()) {\n            success = 0;\n            goto cleanup;\n        }\n    }\n  cleanup:\n    ;\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4184:1#clusterManagerMigrateKeysInReply",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    char **argv;\n    int c = (replace ? 8 : 7);\n    if (config.conn_info.auth)\n        c += 2;\n    if (config.conn_info.user)\n        c += 1;\n    char portstr[255];\n    char timeoutstr[255];\n    snprintf(portstr, 10, \"%d\", target->port);\n    snprintf(timeoutstr, 10, \"%d\", timeout);\n    argv[0] = \"MIGRATE\";\n    argv[1] = target->ip;\n    argv[2] = portstr;\n    argv[3] = \"\";\n    argv[4] = \"0\";\n    argv[5] = timeoutstr;\n    if (replace) {\n    }\n    if (config.conn_info.auth) {\n        if (config.conn_info.user) {\n        } else {\n        }\n    }\n    if (dots)\n        dots[<recovery-expr>()->elements] = '\\x00';\n    void *_reply;\n    int success;\n    if (!success)\n        goto cleanup;\n  cleanup:\n    zfree(argv);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4775:1#clusterManagerLoadInfoFromNode",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>()) {\n        freeClusterManagerNode(node);\n        return 0;\n    }\n    char *e;\n    if (!clusterManagerNodeIsCluster(node, &e)) {\n        clusterManagerPrintNotClusterNodeError(node, e);\n        if (e)\n            zfree(e);\n        freeClusterManagerNode(node);\n        return 0;\n    }\n    if (!clusterManagerNodeLoadInfo(node, 1 << 0, &e)) {\n        if (e) {\n            clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (node)->ip, (node)->port, (e));\n            ;\n            zfree(e);\n        }\n        freeClusterManagerNode(node);\n        return 0;\n    }\n    listIter li;\n    listNode *ln;\n    if (<recovery-expr>()) {\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            freeClusterManagerNode((clusterManagerNode *)ln->value);\n        listRelease(cluster_manager.nodes);\n    }\n    cluster_manager.nodes = listCreate();\n    listAddNodeTail(cluster_manager.nodes, node);\n    if (<recovery-expr>()) {\n        listRewind(node->friends, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *friend = ln->value;\n                if (!friend->ip || !friend->port)\n                    goto invalid_friend;\n                if (!<recovery-expr>(friend) && !clusterManagerNodeConnect(friend))\n                    goto invalid_friend;\n                if (clusterManagerNodeLoadInfo(friend, 0, &e)) {\n                    if (friend->flags & (1 << 3 | 1 << 4 | 1 << 5)) {\n                        goto invalid_friend;\n                    }\n                    listAddNodeTail(cluster_manager.nodes, friend);\n                } else {\n                    clusterManagerLog(3, \"[ERR] Unable to load info for node %s:%d\\n\", friend->ip, friend->port);\n                    goto invalid_friend;\n                }\n                continue;\n              invalid_friend:\n                if (!(friend->flags & 1 << 1))\n                    cluster_manager.unreachable_masters++;\n                freeClusterManagerNode(friend);\n            }\n        listRelease(node->friends);\n    }\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (<recovery-expr>()) {\n                clusterManagerNode *master = clusterManagerNodeByName(n->replicate);\n                if (<recovery-expr>()) {\n                    clusterManagerLog(2, \"*** WARNING: %s:%d claims to be slave of unknown node ID %s.\\n\", n->ip, n->port, n->replicate);\n                } else\n                    master->replicas_count++;\n            }\n        }\n    return 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6130:1#clusterManagerCommandCreate",
    "gotos": 6,
    "labels": 2,
    "body": "{\n    int i, j, success = 1;\n    cluster_manager.nodes = listCreate();\n    for (i = 0; i < argc; i++) {\n        char *addr = argv[i];\n        char *ip;\n        int port = 0;\n        if (<recovery-expr>()) {\n            return 0;\n        }\n        clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n        if (!clusterManagerNodeConnect(node)) {\n            freeClusterManagerNode(node);\n            return 0;\n        }\n        char *err;\n        if (!clusterManagerNodeIsCluster(node, &err)) {\n            clusterManagerPrintNotClusterNodeError(node, err);\n            if (err)\n                zfree(err);\n            freeClusterManagerNode(node);\n            return 0;\n        }\n        if (!clusterManagerNodeLoadInfo(node, 0, &err)) {\n            if (err) {\n                clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (node)->ip, (node)->port, (err));\n                ;\n                zfree(err);\n            }\n            freeClusterManagerNode(node);\n            return 0;\n        }\n        if (!clusterManagerNodeIsEmpty(node, &err)) {\n            clusterManagerPrintNotEmptyNodeError(node, err);\n            if (err)\n                zfree(err);\n            freeClusterManagerNode(node);\n            return 0;\n        }\n        listAddNodeTail(cluster_manager.nodes, node);\n    }\n    int node_len = cluster_manager.nodes->len;\n    int replicas = config.cluster_manager_command.replicas;\n    int masters_count = ((node_len) / ((replicas) + 1));\n    if (masters_count < 3) {\n        clusterManagerLog(3, \"*** ERROR: Invalid configuration for cluster creation.\\n*** Redis Cluster requires at least 3 master nodes.\\n*** This is not possible with %d nodes and %d replicas per node.\", node_len, replicas);\n        clusterManagerLog(3, \"\\n*** At least %d nodes are required.\\n\", 3 * (replicas + 1));\n        return 0;\n    }\n    clusterManagerLog(1, \">>> Performing hash slots allocation on %d nodes...\\n\", node_len);\n    int interleaved_len = 0, ip_count = 0;\n    clusterManagerNode **interleaved = <recovery-expr>()(node_len * sizeof (**interleaved));\n    char **ips = <recovery-expr>()(node_len * sizeof(char *));\n    clusterManagerNodeArray *ip_nodes = <recovery-expr>()(node_len * sizeof (*ip_nodes));\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            int found = 0;\n            for (i = 0; i < ip_count; i++) {\n                char *ip = ips[i];\n                if (!strcmp(ip, n->ip)) {\n                    found = 1;\n                    break;\n                }\n            }\n            if (!found) {\n                ips[ip_count++] = n->ip;\n            }\n            clusterManagerNodeArray *node_array = &(ip_nodes[i]);\n            if (<recovery-expr>())\n                clusterManagerNodeArrayInit(node_array, node_len);\n            clusterManagerNodeArrayAdd(node_array, n);\n        }\n    while (interleaved_len < node_len)\n        {\n            for (i = 0; i < ip_count; i++) {\n                clusterManagerNodeArray *node_array = &(ip_nodes[i]);\n                if (node_array->count > 0) {\n                    clusterManagerNode *n;\n                    clusterManagerNodeArrayShift(node_array, &n);\n                    interleaved[interleaved_len++] = n;\n                }\n            }\n        }\n    clusterManagerNode **masters = interleaved;\n    interleaved += masters_count;\n    interleaved_len -= masters_count;\n    float slots_per_node = 16384 / (float)masters_count;\n    long first = 0;\n    float cursor = 0.F;\n    for (i = 0; i < masters_count; i++) {\n        clusterManagerNode *master = masters[i];\n        long last = lround(cursor + slots_per_node - 1);\n        if (last > 16384 || i == (masters_count - 1))\n            last = 16384 - 1;\n        if (last < first)\n            last = first;\n        printf(\"Master[%d] -> Slots %ld - %ld\\n\", i, first, last);\n        master->slots_count = 0;\n        for (j = first; j <= last; j++) {\n            <recovery-expr>(master)[j] = 1;\n            master->slots_count++;\n        }\n        master->dirty = 1;\n        first = last + 1;\n        cursor += slots_per_node;\n    }\n    clusterManagerNode *first_node = interleaved[0];\n    for (i = 0; i < (interleaved_len - 1); i++)\n        interleaved[i] = interleaved[i + 1];\n    interleaved[interleaved_len - 1] = first_node;\n    int assign_unused = 0, available_count = interleaved_len;\n  assign_replicas:\n    for (i = 0; i < masters_count; i++) {\n        clusterManagerNode *master = masters[i];\n        int assigned_replicas = 0;\n        while (assigned_replicas < replicas)\n            {\n                if (available_count == 0)\n                    break;\n                clusterManagerNode *found, *slave;\n                int firstNodeIdx = -1;\n                for (j = 0; j < interleaved_len; j++) {\n                    clusterManagerNode *n = interleaved[j];\n                    if (<recovery-expr>())\n                        continue;\n                    if (strcmp(n->ip, master->ip)) {\n                        found = n;\n                        break;\n                    }\n                    if (firstNodeIdx < 0)\n                        firstNodeIdx = j;\n                }\n                if (found)\n                    slave = found;\n                else if (firstNodeIdx >= 0) {\n                    slave = interleaved[firstNodeIdx];\n                    interleaved_len -= (firstNodeIdx + 1);\n                    interleaved += (firstNodeIdx + 1);\n                }\n                if (<recovery-expr>()) {\n                    assigned_replicas++;\n                    available_count--;\n                    if (slave->replicate)\n                        sdsfree(slave->replicate);\n                    slave->replicate = sdsnew(master->name);\n                    slave->dirty = 1;\n                } else\n                    break;\n                printf(\"Adding replica %s:%d to %s:%d\\n\", slave->ip, slave->port, master->ip, master->port);\n                if (assign_unused)\n                    break;\n            }\n    }\n    if (!assign_unused && available_count > 0) {\n        assign_unused = 1;\n        printf(\"Adding extra replicas...\\n\");\n        goto assign_replicas;\n    }\n    for (i = 0; i < ip_count; i++) {\n        clusterManagerNodeArray *node_array = ip_nodes + i;\n        clusterManagerNodeArrayReset(node_array);\n    }\n    clusterManagerOptimizeAntiAffinity(ip_nodes, ip_count);\n    clusterManagerShowNodes();\n    int ignore_force = 0;\n    if (confirmWithYes(\"Can I set the above configuration?\", ignore_force)) {\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n                char *err;\n                int flushed = clusterManagerFlushNodeConfig(node, &err);\n                if (!flushed && node->dirty && !node->replicate) {\n                    if (<recovery-expr>()) {\n                        clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (node)->ip, (node)->port, (err));\n                        ;\n                        zfree(err);\n                    }\n                    success = 0;\n                    goto cleanup;\n                } else if (<recovery-expr>())\n                    zfree(err);\n            }\n        clusterManagerLog(1, \">>> Nodes configuration updated\\n\");\n        clusterManagerLog(1, \">>> Assign a different config epoch to each node\\n\");\n        int config_epoch = 1;\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n            }\n        clusterManagerLog(1, \">>> Sending CLUSTER MEET messages to join the cluster\\n\");\n        clusterManagerNode *first;\n        char first_ip[46];\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n                if (<recovery-expr>()) {\n                    first = node;\n                    if (<recovery-expr>()) {\n                        success = 0;\n                        goto cleanup;\n                    }\n                    continue;\n                }\n                if (first->bus_port == 0 || (first->bus_port == first->port + 10000)) {\n                } else {\n                }\n                int is_err = 0;\n                if (<recovery-expr>()) {\n                    ;\n                } else {\n                    is_err = 1;\n                }\n                if (is_err) {\n                    success = 0;\n                    goto cleanup;\n                }\n            }\n        sleep(1);\n        clusterManagerWaitForClusterJoin();\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n                if (!node->dirty)\n                    continue;\n                char *err;\n                int flushed = clusterManagerFlushNodeConfig(node, &err);\n                if (!flushed && !node->replicate) {\n                    if (<recovery-expr>()) {\n                        clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (node)->ip, (node)->port, (err));\n                        ;\n                        zfree(err);\n                    }\n                    success = 0;\n                    goto cleanup;\n                } else if (<recovery-expr>()) {\n                    zfree(err);\n                }\n            }\n        listRewind(cluster_manager.nodes, &li);\n        clusterManagerNode *first_node;\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *node = ln->value;\n                if (!first_node)\n                    first_node = node;\n                else\n                    freeClusterManagerNode(node);\n            }\n        listEmpty(cluster_manager.nodes);\n        if (!clusterManagerLoadInfoFromNode(first_node)) {\n            success = 0;\n            goto cleanup;\n        }\n        clusterManagerCheckCluster(0);\n    }\n  cleanup:\n    zfree(masters);\n    zfree(ips);\n    for (i = 0; i < node_len; i++) {\n        clusterManagerNodeArray *node_array = ip_nodes + i;\n        zfree((node_array)->alloc);\n    }\n    zfree(ip_nodes);\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6578:1#clusterManagerCommandDeleteNode",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    ((void)argc);\n    int success = 1;\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    char *node_id = argv[1];\n    clusterManagerLog(1, \">>> Removing node %s from cluster %s:%d\\n\", node_id, ip, port);\n    clusterManagerNode *ref_node = clusterManagerNewNode(ip, port, 0);\n    clusterManagerNode *node;\n    if (!clusterManagerLoadInfoFromNode(ref_node))\n        return 0;\n    node = clusterManagerNodeByName(node_id);\n    if (<recovery-expr>()) {\n        clusterManagerLog(3, \"[ERR] No such node ID %s\\n\", node_id);\n        return 0;\n    }\n    if (node->slots_count != 0) {\n        clusterManagerLog(3, \"[ERR] Node %s:%d is not empty! Reshard data away and try again.\\n\", node->ip, node->port);\n        return 0;\n    }\n    clusterManagerLog(1, \">>> Sending CLUSTER FORGET messages to the cluster...\\n\");\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (n == node)\n                continue;\n            if (n->replicate && !strcasecmp(n->replicate, node_id)) {\n                clusterManagerNode *master = clusterManagerNodeWithLeastReplicas();\n                clusterManagerLog(1, \">>> %s:%d as replica of %s:%d\\n\", n->ip, n->port, master->ip, master->port);\n                if (!success)\n                    return 0;\n            }\n            if (!success)\n                return 0;\n        }\n    clusterManagerLog(1, \">>> Sending CLUSTER RESET SOFT to the deleted node.\\n\");\n    return success;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6645:1#clusterManagerCommandInfo",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    clusterManagerShowClusterInfo();\n    return 1;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6423:1#clusterManagerCommandAddNode",
    "gotos": 12,
    "labels": 2,
    "body": "{\n    int success = 1;\n    char *ref_ip, *ip;\n    int ref_port = 0, port = 0;\n    if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &ref_ip, &ref_port))\n        goto invalid_args;\n    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerLog(1, \">>> Adding node %s:%d to cluster %s:%d\\n\", ip, port, ref_ip, ref_port);\n    clusterManagerNode *refnode = clusterManagerNewNode(ref_ip, ref_port, 0);\n    if (!clusterManagerLoadInfoFromNode(refnode))\n        return 0;\n    if (!clusterManagerCheckCluster(0))\n        return 0;\n    clusterManagerNode *master_node;\n    if (config.cluster_manager_command.flags & 1 << 1) {\n        char *master_id = config.cluster_manager_command.master_id;\n        if (<recovery-expr>()) {\n            master_node = clusterManagerNodeByName(master_id);\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \"[ERR] No such master ID %s\\n\", master_id);\n                return 0;\n            }\n        } else {\n            master_node = clusterManagerNodeWithLeastReplicas();\n            printf(\"Automatically selected master %s:%d\\n\", master_node->ip, master_node->port);\n        }\n    }\n    clusterManagerNode *new_node = clusterManagerNewNode(ip, port, 0);\n    int added = 0;\n    if (!clusterManagerNodeConnect(new_node)) {\n        clusterManagerLog(3, \"[ERR] Sorry, can't connect to node %s:%d\\n\", ip, port);\n        success = 0;\n        goto cleanup;\n    }\n    char *err;\n    if (!(success = clusterManagerNodeIsCluster(new_node, &err))) {\n        clusterManagerPrintNotClusterNodeError(new_node, err);\n        if (err)\n            zfree(err);\n        goto cleanup;\n    }\n    if (!clusterManagerNodeLoadInfo(new_node, 0, &err)) {\n        if (err) {\n            clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (new_node)->ip, (new_node)->port, (err));\n            ;\n            zfree(err);\n        }\n        success = 0;\n        goto cleanup;\n    }\n    if (!(success = clusterManagerNodeIsEmpty(new_node, &err))) {\n        clusterManagerPrintNotEmptyNodeError(new_node, err);\n        if (err)\n            zfree(err);\n        goto cleanup;\n    }\n    clusterManagerNode *first = ((cluster_manager.nodes)->head)->value;\n    listAddNodeTail(cluster_manager.nodes, new_node);\n    added = 1;\n    if (!master_node) {\n        clusterManagerLog(1, \">>> Getting functions from cluster\\n\");\n        if (<recovery-expr>()) {\n            clusterManagerLog(1, \">>> Failed retrieving Functions from the cluster, skip this step as Redis version do not support function command (error = '%s')\\n\", err ? err : \"NULL reply\");\n            if (err)\n                zfree(err);\n        } else {\n            clusterManagerLog(1, \">>> Send FUNCTION LIST to %s:%d to verify there is no functions in it\\n\", ip, port);\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \">>> Failed on CLUSTER LIST (error = '%s')\\r\\n\", err ? err : \"NULL reply\");\n                if (err)\n                    zfree(err);\n                success = 0;\n                goto cleanup;\n            }\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \">>> New node already contains functions and can not be added to the cluster. Use FUNCTION FLUSH and try again.\\r\\n\");\n                success = 0;\n                goto cleanup;\n            }\n            clusterManagerLog(1, \">>> Send FUNCTION RESTORE to %s:%d\\n\", ip, port);\n            if (<recovery-expr>()) {\n                clusterManagerLog(3, \">>> Failed loading functions to the new node (error = '%s')\\r\\n\", err ? err : \"NULL reply\");\n                if (err)\n                    zfree(err);\n                success = 0;\n                goto cleanup;\n            }\n        }\n    }\n    clusterManagerLog(1, \">>> Send CLUSTER MEET to node %s:%d to make it join the cluster.\\n\", ip, port);\n    char first_ip[46];\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    if (first->bus_port == 0 || (first->bus_port == first->port + 10000)) {\n    } else {\n    }\n    if (<recovery-expr>())\n        goto cleanup;\n    if (master_node) {\n        sleep(1);\n        clusterManagerWaitForClusterJoin();\n        clusterManagerLog(1, \">>> Configure node as replica of %s:%d.\\n\", master_node->ip, master_node->port);\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    clusterManagerLog(4, \"[OK] New node added correctly.\\n\");\n  cleanup:\n    if (!added && new_node)\n        freeClusterManagerNode(new_node);\n    return success;\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#6658:1#clusterManagerCommandCheck",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int port = 0;\n    char *ip;\n    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port))\n        goto invalid_args;\n    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);\n    if (!clusterManagerLoadInfoFromNode(node))\n        return 0;\n    clusterManagerShowClusterInfo();\n    return clusterManagerCheckCluster(0);\n  invalid_args:\n    ;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#3579:1#clusterManagerOptimizeAntiAffinity",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    clusterManagerNode **offenders;\n    int score;\n    if (score == 0)\n        goto cleanup;\n    clusterManagerLog(1, \">>> Trying to optimize slaves allocation for anti-affinity\\n\");\n    int node_len = cluster_manager.nodes->len;\n    int maxiter = 500 * node_len;\n    while (maxiter > 0)\n        {\n            int offending_len = 0;\n            if (<recovery-expr>()) {\n                zfree(offenders);\n            }\n            score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count, &offenders, &offending_len);\n            if (score == 0 || offending_len == 0)\n                break;\n            int rand_idx = rand() % offending_len;\n            clusterManagerNode *first = offenders[rand_idx], *second;\n            clusterManagerNode **other_replicas = <recovery-expr>()((node_len - 1) * sizeof (*other_replicas));\n            int other_replicas_count = 0;\n            listIter li;\n            listNode *ln;\n            listRewind(cluster_manager.nodes, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    if (<recovery-expr>())\n                        other_replicas[other_replicas_count++] = n;\n                }\n            if (other_replicas_count == 0) {\n                zfree(other_replicas);\n                break;\n            }\n            rand_idx = rand() % other_replicas_count;\n            second = other_replicas[rand_idx];\n            char *first_master = first->replicate, *second_master = second->replicate;\n            first->replicate = second_master , first->dirty = 1;\n            second->replicate = first_master , second->dirty = 1;\n            int new_score;\n            if (new_score > score) {\n                first->replicate = first_master;\n                second->replicate = second_master;\n            }\n            zfree(other_replicas);\n            maxiter--;\n        }\n    char *msg;\n    int perfect = (score == 0);\n    int log_level = (perfect ? 4 : 2);\n    if (perfect)\n        msg = \"[OK] Perfect anti-affinity obtained!\";\n    else if (score >= 10000)\n        msg = (\"[WARNING] Some slaves are in the same host as their master\");\n    else\n        msg = (\"[WARNING] Some slaves of the same master are in the same host\");\n    clusterManagerLog(log_level, \"%s\\n\", msg);\n  cleanup:\n    zfree(offenders);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#4267:1#clusterManagerMigrateKeysInSlot",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    int success = 1;\n    int do_fix = config.cluster_manager_command.flags & 1 << 0;\n    int do_replace = config.cluster_manager_command.flags & 1 << 6;\n    while (1)\n        {\n            char *dots;\n            if (!success)\n                return 0;\n            if (<recovery-expr>()) {\n                success = 0;\n                if (<recovery-expr>()) {\n                    clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (source)->ip, (source)->port, (*err));\n                    ;\n                }\n                goto next;\n            }\n            if (<recovery-expr>()) {\n                break;\n            }\n            if (<recovery-expr>())\n                goto next;\n            if (<recovery-expr>()) {\n                int is_busy;\n                int not_served = 0;\n                if (!is_busy) {\n                    char *get_owner_err;\n                    clusterManagerNode *served_by = clusterManagerGetSlotOwner(source, slot, &get_owner_err);\n                    if (!served_by) {\n                        if (<recovery-expr>())\n                            not_served = 1;\n                        else {\n                            clusterManagerLog(3, \"Node %s:%d replied with error:\\n%s\\n\", (source)->ip, (source)->port, (get_owner_err));\n                            ;\n                            zfree(get_owner_err);\n                        }\n                    }\n                }\n                if (is_busy || not_served) {\n                    if (do_fix && not_served) {\n                        clusterManagerLog(2, \"*** Slot was not served, setting owner to node %s:%d.\\n\", target->ip, target->port);\n                    }\n                    if (is_busy) {\n                        clusterManagerLog(2, \"\\n*** Target key exists\\n\");\n                        if (!do_replace) {\n                            clusterManagerLog(2, \"*** Checking key values on both nodes...\\n\");\n                            list *diffs = listCreate();\n                            if (!success) {\n                                clusterManagerLog(3, \"*** Value check failed!\\n\");\n                                listRelease(diffs);\n                                goto next;\n                            }\n                            if (((diffs)->len) > 0) {\n                                success = 0;\n                                clusterManagerLog(3, \"*** Found %d key(s) in both source node and target node having different values.\\n    Source node: %s:%d\\n    Target node: %s:%d\\n    Keys(s):\\n\", ((diffs)->len), source->ip, source->port, target->ip, target->port);\n                                listIter dli;\n                                listNode *dln;\n                                listRewind(diffs, &dli);\n                                while (<recovery-expr>())\n                                    {\n                                        char *k = dln->value;\n                                        clusterManagerLog(3, \"    - %s\\n\", k);\n                                    }\n                                clusterManagerLog(3, \"Please fix the above key(s) manually and try again or relaunch the command \\nwith --cluster-replace option to force key overriding.\\n\");\n                                listRelease(diffs);\n                                goto next;\n                            }\n                            listRelease(diffs);\n                        }\n                        clusterManagerLog(2, \"*** Replacing target keys...\\n\");\n                    }\n                } else\n                    success = 0;\n                if (!success) {\n                    if (<recovery-expr>()) {\n                        if (err) {\n                        }\n                        printf(\"\\n\");\n                        ;\n                    }\n                    goto next;\n                }\n            }\n            if (verbose) {\n                printf(\"%s\", dots);\n            }\n          next:\n            ;\n            if (dots)\n                zfree(dots);\n            if (!success)\n                break;\n        }\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-cli.c#5407:1#clusterManagerFixOpenSlot",
    "gotos": 18,
    "labels": 2,
    "body": "{\n    int force_fix = config.cluster_manager_command.flags & 1 << 10;\n    if (cluster_manager.unreachable_masters > 0 && !force_fix) {\n        clusterManagerLog(2, \"*** Fixing open slots with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\\n\", cluster_manager.unreachable_masters);\n        exit(1);\n    }\n    clusterManagerLog(1, \">>> Fixing open slot %d\\n\", slot);\n    int success = 1;\n    list *owners = listCreate();\n    list *migrating = listCreate();\n    list *importing = listCreate();\n    sds migrating_str = sdsempty();\n    sds importing_str = sdsempty();\n    clusterManagerNode *owner;\n    listIter li;\n    listNode *ln;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (n->flags & 1 << 1)\n                continue;\n            if (<recovery-expr>(n)[slot]) {\n                listAddNodeTail(owners, n);\n            } else {\n                if (<recovery-expr>()) {\n                    clusterManagerLog(2, \"*** Found keys about slot %d in non-owner node %s:%d!\\n\", slot, n->ip, n->port);\n                    listAddNodeTail(owners, n);\n                }\n                if (!success)\n                    goto cleanup;\n            }\n        }\n    if (((owners)->len) == 1)\n        owner = ((owners)->head)->value;\n    listRewind(cluster_manager.nodes, &li);\n    while (<recovery-expr>())\n        {\n            clusterManagerNode *n = ln->value;\n            if (n->flags & 1 << 1)\n                continue;\n            int is_migrating = 0, is_importing = 0;\n            if (n->migrating) {\n                for (int i = 0; i < n->migrating_count; i += 2) {\n                    sds migrating_slot = n->migrating[i];\n                    if (atoi(migrating_slot) == slot) {\n                        char *sep = (((migrating)->len) == 0 ? \"\" : \",\");\n                        migrating_str = sdscatfmt(migrating_str, \"%s%s:%u\", sep, n->ip, n->port);\n                        listAddNodeTail(migrating, n);\n                        is_migrating = 1;\n                        break;\n                    }\n                }\n            }\n            if (!is_migrating && n->importing) {\n                for (int i = 0; i < n->importing_count; i += 2) {\n                    sds importing_slot = n->importing[i];\n                    if (atoi(importing_slot) == slot) {\n                        char *sep = (((importing)->len) == 0 ? \"\" : \",\");\n                        importing_str = sdscatfmt(importing_str, \"%s%s:%u\", sep, n->ip, n->port);\n                        listAddNodeTail(importing, n);\n                        is_importing = 1;\n                        break;\n                    }\n                }\n            }\n            if (!is_migrating && !is_importing && n != owner) {\n                if (<recovery-expr>()) {\n                    clusterManagerLog(2, \"*** Found keys about slot %d in node %s:%d!\\n\", slot, n->ip, n->port);\n                    char *sep = (((importing)->len) == 0 ? \"\" : \",\");\n                    importing_str = sdscatfmt(importing_str, \"%s%s:%u\", sep, n->ip, n->port);\n                    listAddNodeTail(importing, n);\n                }\n                if (!success)\n                    goto cleanup;\n            }\n        }\n    if (<recovery-expr>()(migrating_str) > 0)\n        printf(\"Set as migrating in: %s\\n\", migrating_str);\n    if (<recovery-expr>()(importing_str) > 0)\n        printf(\"Set as importing in: %s\\n\", importing_str);\n    if (<recovery-expr>()) {\n        clusterManagerLog(1, \">>> No single clear owner for the slot, selecting an owner by # of keys...\\n\");\n        if (<recovery-expr>()) {\n            clusterManagerLog(3, \"[ERR] Can't select a slot owner. Impossible to fix.\\n\");\n            success = 0;\n            goto cleanup;\n        }\n        clusterManagerLog(2, \"*** Configuring %s:%d as the slot owner\\n\", owner->ip, owner->port);\n        success = clusterManagerClearSlotStatus(owner, slot);\n        if (!success)\n            goto cleanup;\n        success = clusterManagerSetSlotOwner(owner, slot, 0);\n        if (!success)\n            goto cleanup;\n        <recovery-expr>(owner)[slot] = 1;\n        clusterManagerRemoveNodeFromList(migrating, owner);\n        clusterManagerRemoveNodeFromList(importing, owner);\n    }\n    if (((owners)->len) > 1) {\n        listRewind(owners, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n == owner)\n                    continue;\n                success = clusterManagerDelSlot(n, slot, 1);\n                if (!success)\n                    goto cleanup;\n                <recovery-expr>(n)[slot] = 0;\n                if (!success)\n                    goto cleanup;\n                if (!success)\n                    goto cleanup;\n                clusterManagerRemoveNodeFromList(importing, n);\n                listAddNodeTail(importing, n);\n                clusterManagerRemoveNodeFromList(migrating, n);\n            }\n    }\n    int move_opts = 1 << 7;\n    if (((migrating)->len) == 1 && ((importing)->len) == 1) {\n        clusterManagerNode *src = ((migrating)->head)->value;\n        clusterManagerNode *dst = ((importing)->head)->value;\n        clusterManagerLog(1, \">>> Case 1: Moving slot %d from %s:%d to %s:%d\\n\", slot, src->ip, src->port, dst->ip, dst->port);\n        move_opts |= 1 << 2;\n    } else if (((migrating)->len) == 0 && ((importing)->len) > 0) {\n        clusterManagerLog(1, \">>> Case 2: Moving all the %d slot keys to its owner %s:%d\\n\", slot, owner->ip, owner->port);\n        move_opts |= 1 << 1;\n        listRewind(importing, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n == owner)\n                    continue;\n                if (!success)\n                    goto cleanup;\n                clusterManagerLog(1, \">>> Setting %d as STABLE in %s:%d\\n\", slot, n->ip, n->port);\n                success = clusterManagerClearSlotStatus(n, slot);\n                if (!success)\n                    goto cleanup;\n            }\n        listRewind(cluster_manager.nodes, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                if (n == owner)\n                    continue;\n                if (n->flags & 1 << 1)\n                    continue;\n                if (!success)\n                    goto cleanup;\n            }\n    } else if (((migrating)->len) == 1 && ((importing)->len) > 1) {\n        int try_to_fix = 1;\n        clusterManagerNode *src = ((migrating)->head)->value;\n        clusterManagerNode *dst;\n        sds target_id;\n        for (int i = 0; i < src->migrating_count; i += 2) {\n            sds migrating_slot = src->migrating[i];\n            if (atoi(migrating_slot) == slot) {\n                target_id = src->migrating[i + 1];\n                break;\n            }\n        }\n        listIter li;\n        listNode *ln;\n        listRewind(importing, &li);\n        while (<recovery-expr>())\n            {\n                clusterManagerNode *n = ln->value;\n                int count = clusterManagerCountKeysInSlot(n, slot);\n                if (count > 0) {\n                    try_to_fix = 0;\n                    break;\n                }\n                if (strcmp(n->name, target_id) == 0)\n                    dst = n;\n            }\n        if (!try_to_fix)\n            goto unhandled_case;\n        if (<recovery-expr>()) {\n            clusterManagerLog(1, \">>> Case 3: Moving slot %d from %s:%d to %s:%d and closing it on all the other importing nodes.\\n\", slot, src->ip, src->port, dst->ip, dst->port);\n            if (!success)\n                goto cleanup;\n            listRewind(importing, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    if (dst == n)\n                        continue;\n                    success = clusterManagerClearSlotStatus(n, slot);\n                    if (!success)\n                        goto cleanup;\n                }\n        } else {\n            clusterManagerLog(1, \">>> Case 3: Closing slot %d on both migrating and importing nodes.\\n\", slot);\n            success = clusterManagerClearSlotStatus(src, slot);\n            if (!success)\n                goto cleanup;\n            listRewind(importing, &li);\n            while (<recovery-expr>())\n                {\n                    clusterManagerNode *n = ln->value;\n                    success = clusterManagerClearSlotStatus(n, slot);\n                    if (!success)\n                        goto cleanup;\n                }\n        }\n    } else {\n        int try_to_close_slot = (((importing)->len) == 0 && ((migrating)->len) == 1);\n        if (try_to_close_slot) {\n            clusterManagerNode *n = ((migrating)->head)->value;\n            if (!owner || owner != n) {\n                if (<recovery-expr>()) {\n                }\n                if (!success)\n                    goto cleanup;\n            }\n        }\n        if (try_to_close_slot) {\n            clusterManagerNode *n = ((migrating)->head)->value;\n            clusterManagerLog(1, \">>> Case 4: Closing slot %d on %s:%d\\n\", slot, n->ip, n->port);\n            if (!success)\n                goto cleanup;\n        } else {\n          unhandled_case:\n            success = 0;\n            clusterManagerLog(3, \"[ERR] Sorry, redis-cli can't fix this slot yet (work in progress). Slot is set as migrating in %s, as importing in %s, owner is %s:%d\\n\", migrating_str, importing_str, owner->ip, owner->port);\n        }\n    }\n  cleanup:\n    listRelease(owners);\n    listRelease(migrating);\n    listRelease(importing);\n    sdsfree(migrating_str);\n    sdsfree(importing_str);\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/hyperloglog.c#655:1#hllSparseSet",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    struct hllhdr *hdr;\n    long first, span;\n    long is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;\n    if (<recovery-expr>() > 32)\n        goto promote;\n    o->ptr = <recovery-expr>()(o->ptr, 3);\n    first = 0;\n    span = 0;\n    while (<recovery-expr>())\n        {\n            long oplen;\n            oplen = 1;\n            if (<recovery-expr>()) {\n            } else if (<recovery-expr>()) {\n            } else {\n                oplen = 2;\n            }\n            if (index <= first + span - 1)\n                break;\n            first += span;\n        }\n    if (<recovery-expr>())\n        return -1;\n    if (<recovery-expr>()) {\n        is_zero = 1;\n    } else if (<recovery-expr>()) {\n        is_xzero = 1;\n    } else {\n        is_val = 1;\n    }\n    if (is_val) {\n        if (<recovery-expr>())\n            return 0;\n        if (runlen == 1) {\n            do {\n            } while (0);\n            goto updated;\n        }\n    }\n    if (is_zero && runlen == 1) {\n        do {\n        } while (0);\n        goto updated;\n    }\n    int last = first + span - 1;\n    int len;\n    if (is_zero || is_xzero) {\n        if (index != first) {\n            len = index - first;\n            if (len > 64) {\n                do {\n                    int _l = (len) - 1;\n                } while (0);\n            } else {\n                do {\n                } while (0);\n            }\n        }\n        do {\n        } while (0);\n        if (index != last) {\n            len = last - index;\n            if (len > 64) {\n                do {\n                    int _l = (len) - 1;\n                } while (0);\n            } else {\n                do {\n                } while (0);\n            }\n        }\n    } else {\n        int curval;\n        if (index != first) {\n            len = index - first;\n            do {\n            } while (0);\n        }\n        do {\n        } while (0);\n        if (index != last) {\n            len = last - index;\n            do {\n            } while (0);\n        }\n    }\n    int seqlen;\n    int oldlen = is_xzero ? 2 : 1;\n    int deltalen = seqlen - oldlen;\n    if (deltalen > 0 && <recovery-expr>()(o->ptr) + deltalen > <recovery-expr>(server))\n        goto promote;\n    <recovery-expr>()(o->ptr, deltalen);\n  updated:\n    ;\n    int scanlen = 5;\n    while (<recovery-expr>())\n        {\n            if (<recovery-expr>()) {\n                continue;\n            } else if (<recovery-expr>()) {\n                continue;\n            }\n            if (<recovery-expr>()) {\n                int v1;\n                int v2;\n                if (v1 == v2) {\n                    int len;\n                    if (len <= 4) {\n                        do {\n                        } while (0);\n                        <recovery-expr>()(o->ptr, -1);\n                        continue;\n                    }\n                }\n            }\n        }\n    hdr = o->ptr;\n    <recovery-expr>((hdr))[7] |= (1 << 7);\n    return 1;\n  promote:\n    if (hllSparseToDense(o) == -1)\n        return -1;\n    hdr = o->ptr;\n    int dense_retval = <recovery-expr>()(<recovery-expr>(hdr), index, <recovery-expr>());\n    ((dense_retval == 1) ? (void)0 : (_serverAssert(\"dense_retval == 1\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/hyperloglog.c\", 894) , __builtin_unreachable()));\n    return dense_retval;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/hyperloglog.c#1396:1#pfselftestCommand",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    unsigned int j, i;\n    sds bitcounters;\n    struct hllhdr *hdr = (struct hllhdr *)bitcounters, *hdr2;\n    robj *o;\n    for (j = 0; j < 1000; j++) {\n        for (i = 0; i < (1 << 14); i++) {\n            unsigned int r = rand() & ((1 << 6) - 1);\n            do {\n                unsigned long _byte = (i) * 6 / 8;\n                unsigned long _fb = (i) * 6 & 7;\n                unsigned long _fb8 = 8 - _fb;\n                unsigned long _v = (r);\n            } while (0);\n        }\n        for (i = 0; i < (1 << 14); i++) {\n            unsigned int val;\n            do {\n                unsigned long _byte = i * 6 / 8;\n                unsigned long _fb = i * 6 & 7;\n                unsigned long _fb8 = 8 - _fb;\n                unsigned long b0;\n                unsigned long b1;\n                val = ((b0 >> _fb) | (b1 << _fb8)) & ((1 << 6) - 1);\n            } while (0);\n            if (<recovery-expr>()) {\n                goto cleanup;\n            }\n        }\n    }\n    memset(<recovery-expr>(hdr), 0, (sizeof(struct hllhdr) + (((1 << 14) * 6 + 7) / 8)) - sizeof(struct hllhdr));\n    o = createHLLObject();\n    double relerr = 1.04 / sqrt((1 << 14));\n    for (j = 1; j <= 10000000; j++) {\n        if (<recovery-expr>()) {\n            hdr2 = o->ptr;\n            if (<recovery-expr>(hdr2) != 1) {\n                addReplyError(c, \"TESTFAILED sparse encoding not used\");\n                goto cleanup;\n            }\n        }\n        if (<recovery-expr>()) {\n            addReplyError(c, \"TESTFAILED dense/sparse disagree\");\n            goto cleanup;\n        }\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n                goto cleanup;\n            }\n        }\n    }\n    addReply(c, shared.ok);\n  cleanup:\n    sdsfree(bitcounters);\n    if (o)\n        decrRefCount(o);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/hyperloglog.c#1150:1#isHLLObjectOrReply",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    struct hllhdr *hdr;\n    if (checkType(c, o, 0))\n        return -1;\n    if (!(o->encoding == 0 || o->encoding == 8))\n        goto invalid;\n    if (<recovery-expr>()(o) < sizeof (*hdr))\n        goto invalid;\n    hdr = o->ptr;\n    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' || hdr->magic[2] != 'L' || hdr->magic[3] != 'L')\n        goto invalid;\n    if (<recovery-expr>(hdr) > 1)\n        goto invalid;\n    if (<recovery-expr>(hdr) == 0 && <recovery-expr>()(o) != (sizeof(struct hllhdr) + (((1 << 14) * 6 + 7) / 8)))\n        goto invalid;\n    return 0;\n  invalid:\n    addReplyError(c, \"-WRONGTYPE Key is not a valid HyperLogLog string value.\");\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/hyperloglog.c#1505:1#pfdebugCommand",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    char *cmd = c->argv[1]->ptr;\n    struct hllhdr *hdr;\n    robj *o;\n    int j;\n    o = lookupKeyWrite(c->db, c->argv[2]);\n    if (<recovery-expr>()) {\n        addReplyError(c, \"The specified key does not exist\");\n        return;\n    }\n    if (isHLLObjectOrReply(c, o) != 0)\n        return;\n    o = dbUnshareStringValue(c->db, c->argv[2], o);\n    hdr = o->ptr;\n    if (!strcasecmp(cmd, \"getreg\")) {\n        if (c->argc != 3)\n            goto arityerr;\n        if (<recovery-expr>(hdr) == 1) {\n            if (hllSparseToDense(o) == -1) {\n                addReplyError(c, invalid_hll_err);\n                return;\n            }\n            server.dirty++;\n        }\n        hdr = o->ptr;\n        addReplyArrayLen(c, (1 << 14));\n        for (j = 0; j < (1 << 14); j++) {\n            do {\n                unsigned long _byte = j * 6 / 8;\n                unsigned long _fb = j * 6 & 7;\n                unsigned long _fb8 = 8 - _fb;\n                unsigned long b0;\n                unsigned long b1;\n            } while (0);\n        }\n    } else if (!strcasecmp(cmd, \"decode\")) {\n        if (c->argc != 3)\n            goto arityerr;\n        sds decoded = sdsempty();\n        if (<recovery-expr>(hdr) != 1) {\n            sdsfree(decoded);\n            addReplyError(c, \"HLL encoding is not sparse\");\n            return;\n        }\n        while (<recovery-expr>())\n            {\n                int runlen, regval;\n                if (<recovery-expr>()) {\n                    decoded = sdscatprintf(decoded, \"z:%d \", runlen);\n                } else if (<recovery-expr>()) {\n                    decoded = sdscatprintf(decoded, \"Z:%d \", runlen);\n                } else {\n                    decoded = sdscatprintf(decoded, \"v:%d,%d \", regval, runlen);\n                }\n            }\n        decoded = sdstrim(decoded, \" \");\n        addReplyBulkCBuffer(c, decoded, <recovery-expr>()(decoded));\n        sdsfree(decoded);\n    } else if (!strcasecmp(cmd, \"encoding\")) {\n        char *encodingstr[2] = {\"dense\", \"sparse\"};\n        if (c->argc != 3)\n            goto arityerr;\n        addReplyStatus(c, encodingstr[<recovery-expr>(hdr)]);\n    } else if (!strcasecmp(cmd, \"todense\")) {\n        int conv = 0;\n        if (c->argc != 3)\n            goto arityerr;\n        if (<recovery-expr>(hdr) == 1) {\n            if (hllSparseToDense(o) == -1) {\n                addReplyError(c, invalid_hll_err);\n                return;\n            }\n            conv = 1;\n            server.dirty++;\n        }\n        addReply(c, conv ? shared.cone : shared.czero);\n    } else {\n        addReplyErrorFormat(c, \"Unknown PFDEBUG subcommand '%s'\", cmd);\n    }\n    return;\n  arityerr:\n    addReplyErrorFormat(c, \"Wrong number of arguments for the '%s' subcommand\", cmd);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sentinel.c#3759:1#sentinelCommand",
    "gotos": 15,
    "labels": 1,
    "body": "{\n    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr, \"help\")) {\n        const char *help[];\n        addReplyHelp(c, help);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"masters\")) {\n        if (c->argc != 2)\n            goto numargserr;\n        addReplyDictOfRedisInstances(c, sentinel.masters);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"master\")) {\n        sentinelRedisInstance *ri;\n        if (c->argc != 3)\n            goto numargserr;\n        if (<recovery-expr>())\n            return;\n        addReplySentinelRedisInstance(c, ri);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"slaves\") || !strcasecmp(c->argv[1]->ptr, \"replicas\")) {\n        sentinelRedisInstance *ri;\n        if (c->argc != 3)\n            goto numargserr;\n        if (<recovery-expr>())\n            return;\n        addReplyDictOfRedisInstances(c, ri->slaves);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"sentinels\")) {\n        sentinelRedisInstance *ri;\n        if (c->argc != 3)\n            goto numargserr;\n        if (<recovery-expr>())\n            return;\n        addReplyDictOfRedisInstances(c, ri->sentinels);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"myid\") && c->argc == 2) {\n        addReplyBulkCBuffer(c, sentinel.myid, 40);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"is-master-down-by-addr\")) {\n        sentinelRedisInstance *ri;\n        long long req_epoch;\n        char *leader;\n        long port;\n        int isdown = 0;\n        if (c->argc != 6)\n            goto numargserr;\n        if (<recovery-expr>())\n            return;\n        if (!sentinel.tilt && ri && (ri->flags & (1 << 3)) && (ri->flags & (1 << 0)))\n            isdown = 1;\n        if (ri && ri->flags & (1 << 0) && strcasecmp(c->argv[5]->ptr, \"*\")) {\n        }\n        addReplyArrayLen(c, 3);\n        addReply(c, isdown ? shared.cone : shared.czero);\n        addReplyBulkCString(c, leader ? leader : \"*\");\n        if (leader)\n            sdsfree(leader);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"reset\")) {\n        if (c->argc != 3)\n            goto numargserr;\n        addReplyLongLong(c, sentinelResetMastersByPattern(c->argv[2]->ptr, (1 << 16)));\n    } else if (!strcasecmp(c->argv[1]->ptr, \"get-master-addr-by-name\")) {\n        sentinelRedisInstance *ri;\n        if (c->argc != 3)\n            goto numargserr;\n        ri = sentinelGetMasterByName(c->argv[2]->ptr);\n        if (<recovery-expr>()) {\n            addReplyNullArray(c);\n        } else {\n            sentinelAddr *addr = sentinelGetCurrentMasterAddress(ri);\n            addReplyArrayLen(c, 2);\n            addReplyBulkCString(c, announceSentinelAddr(addr));\n            addReplyBulkLongLong(c, addr->port);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"failover\")) {\n        sentinelRedisInstance *ri;\n        if (c->argc != 3)\n            goto numargserr;\n        if (<recovery-expr>())\n            return;\n        if (ri->flags & (1 << 6)) {\n            addReplyError(c, \"-INPROG Failover already in progress\");\n            return;\n        }\n        if (<recovery-expr>()) {\n            addReplyError(c, \"-NOGOODSLAVE No suitable replica to promote\");\n            return;\n        }\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Executing user requested FAILOVER of '%s'\", ri->name);\n        } while (0);\n        sentinelStartFailover(ri);\n        ri->flags |= (1 << 11);\n        addReply(c, shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"pending-scripts\")) {\n        if (c->argc != 2)\n            goto numargserr;\n        sentinelPendingScriptsCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"monitor\")) {\n        sentinelRedisInstance *ri;\n        long quorum, port;\n        char ip[46];\n        if (c->argc != 6)\n            goto numargserr;\n        if (getLongFromObjectOrReply(c, c->argv[5], &quorum, \"Invalid quorum\") != 0)\n            return;\n        if (getLongFromObjectOrReply(c, c->argv[4], &port, \"Invalid port\") != 0)\n            return;\n        if (quorum <= 0) {\n            addReplyError(c, \"Quorum must be 1 or greater.\");\n            return;\n        }\n        if (<recovery-expr>()) {\n            addReplyError(c, \"Invalid IP address or hostname specified\");\n            return;\n        }\n        if (<recovery-expr>()) {\n            addReplyError(c, sentinelCheckCreateInstanceErrors((1 << 0)));\n        } else {\n            sentinelFlushConfigAndReply(c);\n            sentinelEvent(3, \"+monitor\", ri, \"%@ quorum %d\", ri->quorum);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"flushconfig\")) {\n        if (c->argc != 2)\n            goto numargserr;\n        sentinelFlushConfigAndReply(c);\n        return;\n    } else if (!strcasecmp(c->argv[1]->ptr, \"remove\")) {\n        sentinelRedisInstance *ri;\n        if (c->argc != 3)\n            goto numargserr;\n        if (<recovery-expr>())\n            return;\n        sentinelEvent(3, \"-monitor\", ri, \"%@\");\n        dictDelete(sentinel.masters, c->argv[2]->ptr);\n        sentinelFlushConfigAndReply(c);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"ckquorum\")) {\n        sentinelRedisInstance *ri;\n        int usable;\n        if (c->argc != 3)\n            goto numargserr;\n        if (<recovery-expr>())\n            return;\n        int result = sentinelIsQuorumReachable(ri, &usable);\n        if (result == 0) {\n            addReplySds(c, sdscatfmt(sdsempty(), \"+OK %i usable Sentinels. Quorum and failover authorization can be reached\\r\\n\", usable));\n        } else {\n            sds e = sdscatfmt(sdsempty(), \"-NOQUORUM %i usable Sentinels. \", usable);\n            if (result & (1 << 0))\n                e = sdscat(e, \"Not enough available Sentinels to reach the specified quorum for this master\");\n            if (result & (1 << 1)) {\n                if (result & (1 << 0))\n                    e = sdscat(e, \". \");\n                e = sdscat(e, \"Not enough available Sentinels to reach the majority and authorize a failover\");\n            }\n            addReplyErrorSds(c, e);\n        }\n    } else if (!strcasecmp(c->argv[1]->ptr, \"set\")) {\n        sentinelSetCommand(c);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"config\")) {\n        if (c->argc < 3)\n            goto numargserr;\n        if (!strcasecmp(c->argv[2]->ptr, \"set\") && c->argc == 5)\n            sentinelConfigSetCommand(c);\n        else if (!strcasecmp(c->argv[2]->ptr, \"get\") && c->argc == 4)\n            sentinelConfigGetCommand(c);\n        else\n            addReplyError(c, \"Only SENTINEL CONFIG GET <option> / SET <option> <value> are supported.\");\n    } else if (!strcasecmp(c->argv[1]->ptr, \"info-cache\")) {\n        if (c->argc < 2)\n            goto numargserr;\n        mstime_t now = mstime();\n        dictType copy_keeper = instancesDictType;\n        dict *masters_local = sentinel.masters;\n        if (c->argc > 2) {\n            masters_local = dictCreate(&copy_keeper);\n            for (int i = 2; i < c->argc; i++) {\n                sentinelRedisInstance *ri;\n                ri = sentinelGetMasterByName(c->argv[i]->ptr);\n                if (!ri)\n                    continue;\n                dictAdd(masters_local, ri->name, ri);\n            }\n        }\n        addReplyArrayLen(c, ((masters_local)->ht_used[0] + (masters_local)->ht_used[1]) * 2);\n        dictIterator *di;\n        dictEntry *de;\n        di = dictGetIterator(masters_local);\n        while (<recovery-expr>())\n            {\n                sentinelRedisInstance *ri = (<recovery-expr>((de)).val);\n                addReplyBulkCBuffer(c, ri->name, strlen(ri->name));\n                addReplyArrayLen(c, ((ri->slaves)->ht_used[0] + (ri->slaves)->ht_used[1]) + 1);\n                addReplyArrayLen(c, 2);\n                addReplyLongLong(c, ri->info_refresh ? (now - ri->info_refresh) : 0);\n                if (ri->info)\n                    addReplyBulkCBuffer(c, ri->info, <recovery-expr>()(ri->info));\n                else\n                    addReplyNull(c);\n                dictIterator *sdi;\n                dictEntry *sde;\n                sdi = dictGetIterator(ri->slaves);\n                while (<recovery-expr>())\n                    {\n                        sentinelRedisInstance *sri = (<recovery-expr>((sde)).val);\n                        addReplyArrayLen(c, 2);\n                        addReplyLongLong(c, ri->info_refresh ? (now - sri->info_refresh) : 0);\n                        if (sri->info)\n                            addReplyBulkCBuffer(c, sri->info, <recovery-expr>()(sri->info));\n                        else\n                            addReplyNull(c);\n                    }\n                dictReleaseIterator(sdi);\n            }\n        dictReleaseIterator(di);\n        if (masters_local != sentinel.masters)\n            dictRelease(masters_local);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"simulate-failure\")) {\n        int j;\n        sentinel.simfailure_flags = 0;\n        for (j = 2; j < c->argc; j++) {\n            if (!strcasecmp(c->argv[j]->ptr, \"crash-after-election\")) {\n                sentinel.simfailure_flags |= (1 << 0);\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Failure simulation: this Sentinel will crash after being successfully elected as failover leader\");\n                } while (0);\n            } else if (!strcasecmp(c->argv[j]->ptr, \"crash-after-promotion\")) {\n                sentinel.simfailure_flags |= (1 << 1);\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Failure simulation: this Sentinel will crash after promoting the selected replica to master\");\n                } while (0);\n            } else if (!strcasecmp(c->argv[j]->ptr, \"help\")) {\n                addReplyArrayLen(c, 2);\n                addReplyBulkCString(c, \"crash-after-election\");\n                addReplyBulkCString(c, \"crash-after-promotion\");\n                return;\n            } else {\n                addReplyError(c, \"Unknown failure simulation specified\");\n                return;\n            }\n        }\n        addReply(c, shared.ok);\n    } else if (!strcasecmp(c->argv[1]->ptr, \"debug\")) {\n        if (c->argc == 2)\n            addReplySentinelDebugInfo(c);\n        else\n            sentinelSetDebugConfigParameters(c);\n    } else {\n        addReplySubcommandSyntaxError(c);\n    }\n    return;\n  numargserr:\n    addReplyErrorArity(c);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sentinel.c#3491:1#sentinelSetDebugConfigParameters",
    "gotos": 13,
    "labels": 1,
    "body": "{\n    int j;\n    int badarg = 0;\n    char *option;\n    for (j = 2; j < c->argc; j++) {\n        int moreargs = (c->argc - 1) - j;\n        option = c->argv[j]->ptr;\n        long long ll;\n        if (!strcasecmp(option, \"info-period\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_info_period = ll;\n        } else if (!strcasecmp(option, \"ping-period\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_ping_period = ll;\n        } else if (!strcasecmp(option, \"ask-period\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_ask_period = ll;\n        } else if (!strcasecmp(option, \"publish-period\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_publish_period = ll;\n        } else if (!strcasecmp(option, \"default-down-after\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_default_down_after = ll;\n        } else if (!strcasecmp(option, \"tilt-trigger\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_tilt_trigger = ll;\n        } else if (!strcasecmp(option, \"tilt-period\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_tilt_period = ll;\n        } else if (!strcasecmp(option, \"slave-reconf-timeout\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_slave_reconf_timeout = ll;\n        } else if (!strcasecmp(option, \"min-link-reconnect-period\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_min_link_reconnect_period = ll;\n        } else if (!strcasecmp(option, \"default-failover-timeout\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_default_failover_timeout = ll;\n        } else if (!strcasecmp(option, \"election-timeout\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_election_timeout = ll;\n        } else if (!strcasecmp(option, \"script-max-runtime\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_script_max_runtime = ll;\n        } else if (!strcasecmp(option, \"script-retry-delay\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            sentinel_script_retry_delay = ll;\n        } else {\n            addReplyErrorFormat(c, \"Unknown option or number of arguments for SENTINEL DEBUG '%s'\", option);\n            return;\n        }\n    }\n    addReply(c, shared.ok);\n    return;\n  badfmt:\n    addReplyErrorFormat(c, \"Invalid argument '%s' for SENTINEL DEBUG '%s'\", (char *)c->argv[badarg]->ptr, option);\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sentinel.c#3186:1#sentinelConfigSetCommand",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    robj *o = c->argv[3];\n    robj *val = c->argv[4];\n    long long numval;\n    int drop_conns = 0;\n    if (!strcasecmp(o->ptr, \"resolve-hostnames\")) {\n        if ((numval = yesnotoi(val->ptr)) == -1)\n            goto badfmt;\n        sentinel.resolve_hostnames = numval;\n    } else if (!strcasecmp(o->ptr, \"announce-hostnames\")) {\n        if ((numval = yesnotoi(val->ptr)) == -1)\n            goto badfmt;\n        sentinel.announce_hostnames = numval;\n    } else if (!strcasecmp(o->ptr, \"announce-ip\")) {\n        if (sentinel.announce_ip)\n            sdsfree(sentinel.announce_ip);\n        sentinel.announce_ip = sdsnew(val->ptr);\n    } else if (!strcasecmp(o->ptr, \"announce-port\")) {\n        if (getLongLongFromObject(val, &numval) == -1 || numval < 0 || numval > 65535)\n            goto badfmt;\n        sentinel.announce_port = numval;\n    } else if (!strcasecmp(o->ptr, \"sentinel-user\")) {\n        sdsfree(sentinel.sentinel_auth_user);\n        drop_conns = 1;\n    } else if (!strcasecmp(o->ptr, \"sentinel-pass\")) {\n        sdsfree(sentinel.sentinel_auth_pass);\n        drop_conns = 1;\n    } else {\n        addReplyErrorFormat(c, \"Invalid argument '%s' to SENTINEL CONFIG SET\", (char *)o->ptr);\n        return;\n    }\n    sentinelFlushConfigAndReply(c);\n    if (drop_conns)\n        sentinelDropConnections();\n    return;\n  badfmt:\n    addReplyErrorFormat(c, \"Invalid value '%s' to SENTINEL CONFIG SET '%s'\", (char *)val->ptr, (char *)o->ptr);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sentinel.c#2284:1#sentinelFlushConfig",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int fd = -1;\n    int saved_hz = server.hz;\n    int rewrite_status;\n    server.hz = 10;\n    rewrite_status = rewriteConfig(server.configfile, 0);\n    server.hz = saved_hz;\n    if (rewrite_status == -1)\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    if (fsync(fd) == -1)\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"Sentinel new configuration saved on disk\");\n    } while (0);\n    return 0;\n  werr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n    } while (0);\n    if (fd != -1)\n        close(fd);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sentinel.c#1816:1#loadSentinelConfigFromQueue",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    const char *err;\n    listIter li;\n    listNode *ln;\n    int linenum = 0;\n    sds line;\n    unsigned int j;\n    if (<recovery-expr>())\n        return;\n    list *sentinel_configs[3] = {server.sentinel_config->pre_monitor_cfg, server.sentinel_config->monitor_cfg, server.sentinel_config->post_monitor_cfg};\n    for (j = 0; j < sizeof (sentinel_configs) / sizeof (sentinel_configs[0]); j++) {\n        listRewind(sentinel_configs[j], &li);\n        while ((ln = listNext(&li)))\n            {\n                struct sentinelLoadQueueEntry *entry = ln->value;\n                err = sentinelHandleConfiguration(entry->argv, entry->argc);\n                if (err) {\n                    linenum = entry->linenum;\n                    line = entry->line;\n                    goto loaderr;\n                }\n            }\n    }\n    freeSentinelConfig();\n    return;\n  loaderr:\n    ;\n    exit(1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sentinel.c#4236:1#sentinelSetCommand",
    "gotos": 11,
    "labels": 2,
    "body": "{\n    sentinelRedisInstance *ri;\n    int j, changes = 0;\n    int badarg = 0;\n    char *option;\n    int redacted;\n    if (<recovery-expr>())\n        return;\n    for (j = 3; j < c->argc; j++) {\n        int moreargs = (c->argc - 1) - j;\n        option = c->argv[j]->ptr;\n        long long ll;\n        int old_j = j;\n        redacted = 0;\n        if (!strcasecmp(option, \"down-after-milliseconds\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            ri->down_after_period = ll;\n            sentinelPropagateDownAfterPeriod(ri);\n            changes++;\n        } else if (!strcasecmp(option, \"failover-timeout\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            ri->failover_timeout = ll;\n            changes++;\n        } else if (!strcasecmp(option, \"parallel-syncs\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            ri->parallel_syncs = ll;\n            changes++;\n        } else if (!strcasecmp(option, \"notification-script\") && moreargs > 0) {\n            char *value = c->argv[++j]->ptr;\n            if (sentinel.deny_scripts_reconfig) {\n                addReplyError(c, \"Reconfiguration of scripts path is denied for security reasons. Check the deny-scripts-reconfig configuration directive in your Sentinel configuration\");\n                goto seterr;\n            }\n            if (<recovery-expr>()) {\n                addReplyError(c, \"Notification script seems non existing or non executable\");\n                goto seterr;\n            }\n            sdsfree(ri->notification_script);\n            changes++;\n        } else if (!strcasecmp(option, \"client-reconfig-script\") && moreargs > 0) {\n            char *value = c->argv[++j]->ptr;\n            if (sentinel.deny_scripts_reconfig) {\n                addReplyError(c, \"Reconfiguration of scripts path is denied for security reasons. Check the deny-scripts-reconfig configuration directive in your Sentinel configuration\");\n                goto seterr;\n            }\n            if (<recovery-expr>()) {\n                addReplyError(c, \"Client reconfiguration script seems non existing or non executable\");\n                goto seterr;\n            }\n            sdsfree(ri->client_reconfig_script);\n            changes++;\n        } else if (!strcasecmp(option, \"auth-pass\") && moreargs > 0) {\n            char *value = c->argv[++j]->ptr;\n            sdsfree(ri->auth_pass);\n            dropInstanceConnections(ri);\n            changes++;\n            redacted = 1;\n        } else if (!strcasecmp(option, \"auth-user\") && moreargs > 0) {\n            char *value = c->argv[++j]->ptr;\n            sdsfree(ri->auth_user);\n            dropInstanceConnections(ri);\n            changes++;\n        } else if (!strcasecmp(option, \"quorum\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll <= 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            ri->quorum = ll;\n            changes++;\n        } else if (!strcasecmp(option, \"rename-command\") && moreargs > 1) {\n            sds oldname = c->argv[++j]->ptr;\n            sds newname = c->argv[++j]->ptr;\n            if ((<recovery-expr>()(oldname) == 0) || (<recovery-expr>()(newname) == 0)) {\n                badarg = <recovery-expr>()(newname) ? j - 1 : j;\n                goto badfmt;\n            }\n            dictDelete(ri->renamed_commands, oldname);\n            if (!dictSdsKeyCaseCompare(ri->renamed_commands, oldname, newname)) {\n                oldname = sdsdup(oldname);\n                newname = sdsdup(newname);\n                dictAdd(ri->renamed_commands, oldname, newname);\n            }\n            changes++;\n        } else if (!strcasecmp(option, \"master-reboot-down-after-period\") && moreargs > 0) {\n            robj *o = c->argv[++j];\n            if (getLongLongFromObject(o, &ll) == -1 || ll < 0) {\n                badarg = j;\n                goto badfmt;\n            }\n            ri->master_reboot_down_after_period = ll;\n            changes++;\n        } else {\n            addReplyErrorFormat(c, \"Unknown option or number of arguments for SENTINEL SET '%s'\", option);\n            goto seterr;\n        }\n        int numargs = j - old_j + 1;\n        switch (numargs) {\n          case 2:\n            sentinelEvent(3, \"+set\", ri, \"%@ %s %s\", (char *)c->argv[old_j]->ptr, redacted ? \"******\" : (char *)c->argv[old_j + 1]->ptr);\n            break;\n          case 3:\n            sentinelEvent(3, \"+set\", ri, \"%@ %s %s %s\", (char *)c->argv[old_j]->ptr, (char *)c->argv[old_j + 1]->ptr, (char *)c->argv[old_j + 2]->ptr);\n            break;\n          default:\n            sentinelEvent(3, \"+set\", ri, \"%@ %s\", (char *)c->argv[old_j]->ptr);\n            break;\n        }\n    }\n    if (changes)\n        sentinelFlushConfigAndReply(c);\n    return;\n  badfmt:\n    addReplyErrorFormat(c, \"Invalid argument '%s' for SENTINEL SET '%s'\", (char *)c->argv[badarg]->ptr, option);\n  seterr:\n    if (changes)\n        sentinelFlushConfig();\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sentinel.c#2864:1#sentinelProcessHelloMessage",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int numtokens, port, removed, master_port;\n    char **token = <recovery-expr>()(hello, hello_len, \",\", 1, &numtokens);\n    sentinelRedisInstance *si, *master;\n    if (numtokens == 8) {\n        master = sentinelGetMasterByName(token[4]);\n        if (!master)\n            goto cleanup;\n        port = atoi(token[1]);\n        master_port = atoi(token[6]);\n        si = getSentinelRedisInstanceByAddrAndRunID(master->sentinels, token[0], port, token[2]);\n        if (!si) {\n            removed = removeMatchingSentinelFromMaster(master, token[2]);\n            if (removed) {\n                sentinelEvent(2, \"+sentinel-address-switch\", master, \"%@ ip %s port %d for %s\", token[0], port, token[2]);\n            } else {\n                sentinelRedisInstance *other;\n                if (other) {\n                    sentinelEvent(2, \"+sentinel-invalid-addr\", other, \"%@\");\n                    dictIterator *di;\n                    dictEntry *de;\n                    sds runid_obsolete = sdsnew(other->runid);\n                    di = dictGetIterator(sentinel.masters);\n                    while (<recovery-expr>())\n                        {\n                            sentinelRedisInstance *master = (<recovery-expr>((de)).val);\n                            removeMatchingSentinelFromMaster(master, runid_obsolete);\n                        }\n                    dictReleaseIterator(di);\n                    sdsfree(runid_obsolete);\n                }\n            }\n            si = createSentinelRedisInstance(token[2], (1 << 2), token[0], port, master->quorum, master);\n            if (si) {\n                if (!removed)\n                    sentinelEvent(2, \"+sentinel\", si, \"%@\");\n                si->runid = sdsnew(token[2]);\n                sentinelTryConnectionSharing(si);\n                if (removed)\n                    sentinelUpdateSentinelAddressInAllMasters(si);\n                sentinelFlushConfig();\n            }\n        }\n        if (<recovery-expr>()) {\n            sentinelFlushConfig();\n            sentinelEvent(3, \"+new-epoch\", master, \"%llu\", (unsigned long long)<recovery-expr>(sentinel));\n        }\n        if (<recovery-expr>()) {\n            if (master_port != master->addr->port || !sentinelAddrEqualsHostname(master->addr, token[5])) {\n                sentinelAddr *old_addr;\n                sentinelEvent(3, \"+config-update-from\", si, \"%@\");\n                sentinelEvent(3, \"+switch-master\", master, \"%s %s %d %s %d\", master->name, announceSentinelAddr(master->addr), master->addr->port, token[5], master_port);\n                old_addr = dupSentinelAddr(master->addr);\n                sentinelResetMasterAndChangeAddress(master, token[5], master_port);\n                sentinelCallClientReconfScript(master, (1 << 18), \"start\", old_addr, master->addr);\n                releaseSentinelAddr(old_addr);\n            }\n        }\n        if (si)\n            si->last_hello_time = mstime();\n    }\n  cleanup:\n    sdsfreesplitres(token, numtokens);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/bitops.c#877:1#bitposCommand",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    robj *o;\n    long long start, end;\n    long bit, strlen;\n    unsigned char *p;\n    char llbuf[21];\n    int isbit = 0, end_given = 0;\n    unsigned char first_byte_neg_mask = 0, last_byte_neg_mask = 0;\n    if (<recovery-expr>())\n        return;\n    if (bit != 0 && bit != 1) {\n        addReplyError(c, \"The bit argument must be 1 or 0.\");\n        return;\n    }\n    if (<recovery-expr>()) {\n        addReplyLongLong(c, bit ? -1 : 0);\n        return;\n    }\n    if (checkType(c, o, 0))\n        return;\n    p = getObjectReadOnlyString(o, &strlen, llbuf);\n    if (c->argc == 4 || c->argc == 5 || c->argc == 6) {\n        long long totlen = strlen;\n        if (<recovery-expr>())\n            return;\n        if (c->argc == 6) {\n            if (!strcasecmp(c->argv[5]->ptr, \"bit\"))\n                isbit = 1;\n            else if (!strcasecmp(c->argv[5]->ptr, \"byte\"))\n                isbit = 0;\n            else {\n                addReplyErrorObject(c, shared.syntaxerr);\n                return;\n            }\n        }\n        if (c->argc >= 5) {\n            if (<recovery-expr>())\n                return;\n            end_given = 1;\n        } else {\n            if (isbit)\n                end = (totlen << 3) + 7;\n            else\n                end = totlen - 1;\n        }\n        if (isbit)\n            totlen <<= 3;\n        if (start < 0)\n            start = totlen + start;\n        if (end < 0)\n            end = totlen + end;\n        if (start < 0)\n            start = 0;\n        if (end < 0)\n            end = 0;\n        if (end >= totlen)\n            end = totlen - 1;\n        if (isbit && start <= end) {\n            first_byte_neg_mask = ~((1 << (8 - (start & 7))) - 1) & 255;\n            last_byte_neg_mask = (1 << (7 - (end & 7))) - 1;\n            start >>= 3;\n            end >>= 3;\n        }\n    } else if (c->argc == 3) {\n        start = 0;\n        end = strlen - 1;\n    } else {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n    if (start > end) {\n        addReplyLongLong(c, -1);\n    } else {\n        long bytes = end - start + 1;\n        long long pos;\n        unsigned char tmpchar;\n        if (first_byte_neg_mask) {\n            if (bit)\n                tmpchar = p[start] & ~first_byte_neg_mask;\n            else\n                tmpchar = p[start] | first_byte_neg_mask;\n            if (last_byte_neg_mask && bytes == 1) {\n                if (bit)\n                    tmpchar = tmpchar & ~last_byte_neg_mask;\n                else\n                    tmpchar = tmpchar | last_byte_neg_mask;\n            }\n            pos = redisBitpos(&tmpchar, 1, bit);\n            if (bytes == 1 || (pos != -1 && pos != 8))\n                goto result;\n            start++;\n            bytes--;\n        }\n        long curbytes = bytes - (last_byte_neg_mask ? 1 : 0);\n        if (curbytes > 0) {\n            pos = redisBitpos(p + start, curbytes, bit);\n            if (bytes == curbytes || (pos != -1 && pos != (long long)curbytes << 3))\n                goto result;\n            start += curbytes;\n            bytes -= curbytes;\n        }\n        if (bit)\n            tmpchar = p[end] & ~last_byte_neg_mask;\n        else\n            tmpchar = p[end] | last_byte_neg_mask;\n        pos = redisBitpos(&tmpchar, 1, bit);\n      result:\n        if (end_given && bit == 0 && pos == (long long)bytes << 3) {\n            addReplyLongLong(c, -1);\n            return;\n        }\n        if (pos != -1)\n            pos += (long long)start << 3;\n        addReplyLongLong(c, pos);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/bitops.c#325:1#checkSignedBitfieldOverflow",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            if (owtype == 0) {\n                goto handle_wrap;\n            } else if (owtype == 1) {\n            }\n        }\n        return 1;\n    } else if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            if (owtype == 0) {\n                goto handle_wrap;\n            } else if (owtype == 1) {\n            }\n        }\n        return -1;\n    }\n    return 0;\n  handle_wrap:\n    {\n        if (<recovery-expr>() < 64) {\n            if (<recovery-expr>()) {\n            } else {\n            }\n        }\n    }\n    return 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/bitops.c#288:1#checkUnsignedBitfieldOverflow",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            if (owtype == 0) {\n                goto handle_wrap;\n            } else if (owtype == 1) {\n            }\n        }\n        return 1;\n    } else if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            if (owtype == 0) {\n                goto handle_wrap;\n            } else if (owtype == 1) {\n                *<recovery-expr>() = 0;\n            }\n        }\n        return -1;\n    }\n    return 0;\n  handle_wrap:\n    {\n    }\n    return 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c#1837:1#zremrangeGenericCommand",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    robj *key = c->argv[1];\n    robj *zobj;\n    int keyremoved = 0;\n    unsigned long deleted = 0;\n    zrangespec range;\n    zlexrangespec lexrange;\n    long start, end, llen;\n    char *notify_type;\n    if (rangetype == ZRANGE_RANK) {\n        notify_type = \"zremrangebyrank\";\n        if (<recovery-expr>())\n            return;\n    } else if (rangetype == ZRANGE_SCORE) {\n        notify_type = \"zremrangebyscore\";\n        if (zslParseRange(c->argv[2], c->argv[3], &range) != 0) {\n            addReplyError(c, \"min or max is not a float\");\n            return;\n        }\n    } else if (rangetype == ZRANGE_LEX) {\n        notify_type = \"zremrangebylex\";\n        if (zslParseLexRange(c->argv[2], c->argv[3], &lexrange) != 0) {\n            addReplyError(c, \"min or max not valid string range item\");\n            return;\n        }\n    } else {\n        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c\", 1866, \"unknown rangetype %d\", (int)rangetype) , __builtin_unreachable();\n    }\n    if (<recovery-expr>())\n        goto cleanup;\n    if (rangetype == ZRANGE_RANK) {\n        llen = zsetLength(zobj);\n        if (start < 0)\n            start = llen + start;\n        if (end < 0)\n            end = llen + end;\n        if (start < 0)\n            start = 0;\n        if (start > end || start >= llen) {\n            addReply(c, shared.czero);\n            goto cleanup;\n        }\n        if (end >= llen)\n            end = llen - 1;\n    }\n    if (zobj->encoding == 11) {\n        switch (rangetype) {\n          case ZRANGE_AUTO:\n          case ZRANGE_RANK:\n            zobj->ptr = zzlDeleteRangeByRank(zobj->ptr, start + 1, end + 1, &deleted);\n            break;\n          case ZRANGE_SCORE:\n            zobj->ptr = zzlDeleteRangeByScore(zobj->ptr, &range, &deleted);\n            break;\n          case ZRANGE_LEX:\n            zobj->ptr = zzlDeleteRangeByLex(zobj->ptr, &lexrange, &deleted);\n            break;\n        }\n        if (zzlLength(zobj->ptr) == 0) {\n            dbDelete(c->db, key);\n            keyremoved = 1;\n        }\n    } else if (zobj->encoding == 7) {\n        zset *zs = zobj->ptr;\n        switch (rangetype) {\n          case ZRANGE_AUTO:\n          case ZRANGE_RANK:\n            deleted = zslDeleteRangeByRank(zs->zsl, start + 1, end + 1, zs->dict);\n            break;\n          case ZRANGE_SCORE:\n            deleted = zslDeleteRangeByScore(zs->zsl, &range, zs->dict);\n            break;\n          case ZRANGE_LEX:\n            deleted = zslDeleteRangeByLex(zs->zsl, &lexrange, zs->dict);\n            break;\n        }\n        if (htNeedsResize(zs->dict))\n            dictResize(zs->dict);\n        if (((zs->dict)->ht_used[0] + (zs->dict)->ht_used[1]) == 0) {\n            dbDelete(c->db, key);\n            keyremoved = 1;\n        }\n    } else {\n        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c\", 1927, \"Unknown sorted set encoding\") , __builtin_unreachable();\n    }\n    if (deleted) {\n        signalModifiedKey(c, c->db, key);\n        notifyKeyspaceEvent((1 << 7), notify_type, key, c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent((1 << 2), \"del\", key, c->db->id);\n    }\n    server.dirty += deleted;\n    addReplyLongLong(c, deleted);\n  cleanup:\n    if (rangetype == ZRANGE_LEX)\n        zslFreeLexRange(&lexrange);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c#1666:1#zaddGenericCommand",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    static char *nanerr = \"resulting score is not a number (NaN)\";\n    robj *key = c->argv[1];\n    robj *zobj;\n    sds ele;\n    double score = 0, *scores;\n    int j, elements, ch = 0;\n    int scoreidx = 0;\n    int added = 0;\n    int updated = 0;\n    int processed = 0;\n    scoreidx = 2;\n    while (scoreidx < c->argc)\n        {\n            char *opt = c->argv[scoreidx]->ptr;\n            if (!strcasecmp(opt, \"nx\"))\n                flags |= (1 << 1);\n            else if (!strcasecmp(opt, \"xx\"))\n                flags |= (1 << 2);\n            else if (!strcasecmp(opt, \"ch\"))\n                ch = 1;\n            else if (!strcasecmp(opt, \"incr\"))\n                flags |= (1 << 0);\n            else if (!strcasecmp(opt, \"gt\"))\n                flags |= (1 << 3);\n            else if (!strcasecmp(opt, \"lt\"))\n                flags |= (1 << 4);\n            else\n                break;\n            scoreidx++;\n        }\n    int incr = (flags & (1 << 0)) != 0;\n    int nx = (flags & (1 << 1)) != 0;\n    int xx = (flags & (1 << 2)) != 0;\n    int gt = (flags & (1 << 3)) != 0;\n    int lt = (flags & (1 << 4)) != 0;\n    elements = c->argc - scoreidx;\n    if (elements % 2 || !elements) {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n    elements /= 2;\n    if (nx && xx) {\n        addReplyError(c, \"XX and NX options at the same time are not compatible\");\n        return;\n    }\n    if ((gt && nx) || (lt && nx) || (gt && lt)) {\n        addReplyError(c, \"GT, LT, and/or NX options at the same time are not compatible\");\n        return;\n    }\n    if (incr && elements > 1) {\n        addReplyError(c, \"INCR option supports a single increment-element pair\");\n        return;\n    }\n    scores = <recovery-expr>()(sizeof(double) * elements);\n    for (j = 0; j < elements; j++) {\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    zobj = lookupKeyWrite(c->db, key);\n    if (checkType(c, zobj, 3))\n        goto cleanup;\n    if (<recovery-expr>()) {\n        if (xx)\n            goto reply_to_client;\n        if (<recovery-expr>(server) == 0 || <recovery-expr>(server) < <recovery-expr>()(c->argv[scoreidx + 1]->ptr)) {\n            zobj = createZsetObject();\n        } else {\n            zobj = createZsetListpackObject();\n        }\n        dbAdd(c->db, key, zobj);\n    }\n    for (j = 0; j < elements; j++) {\n        double newscore;\n        score = scores[j];\n        int retflags = 0;\n        ele = c->argv[scoreidx + 1 + j * 2]->ptr;\n        int retval = zsetAdd(zobj, score, ele, flags, &retflags, &newscore);\n        if (retval == 0) {\n            addReplyError(c, nanerr);\n            goto cleanup;\n        }\n        if (retflags & (1 << 2))\n            added++;\n        if (retflags & (1 << 3))\n            updated++;\n        if (!(retflags & (1 << 0)))\n            processed++;\n        score = newscore;\n    }\n    server.dirty += (added + updated);\n  reply_to_client:\n    if (incr) {\n        if (processed)\n            addReplyDouble(c, score);\n        else\n            addReplyNull(c);\n    } else {\n        addReplyLongLong(c, ch ? added + updated : added);\n    }\n  cleanup:\n    zfree(scores);\n    if (added || updated) {\n        signalModifiedKey(c, c->db, key);\n        notifyKeyspaceEvent((1 << 7), incr ? \"zincr\" : \"zadd\", key, c->db->id);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_zset.c#3571:1#zrangeGenericCommand",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    client *c = handler->client;\n    robj *key = c->argv[argc_start];\n    robj *zobj;\n    zrangespec range;\n    zlexrangespec lexrange;\n    int minidx = argc_start + 1;\n    int maxidx = argc_start + 2;\n    long opt_start = 0;\n    long opt_end = 0;\n    int opt_withscores = 0;\n    long opt_offset = 0;\n    long opt_limit = -1;\n    for (int j = argc_start + 3; j < c->argc; j++) {\n        int leftargs = c->argc - j - 1;\n        if (!store && !strcasecmp(c->argv[j]->ptr, \"withscores\")) {\n            opt_withscores = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr, \"limit\") && leftargs >= 2) {\n            if (<recovery-expr>()) {\n                return;\n            }\n            j += 2;\n        } else if (direction == ZRANGE_DIRECTION_AUTO && !strcasecmp(c->argv[j]->ptr, \"rev\")) {\n            direction = ZRANGE_DIRECTION_REVERSE;\n        } else if (rangetype == ZRANGE_AUTO && !strcasecmp(c->argv[j]->ptr, \"bylex\")) {\n            rangetype = ZRANGE_LEX;\n        } else if (rangetype == ZRANGE_AUTO && !strcasecmp(c->argv[j]->ptr, \"byscore\")) {\n            rangetype = ZRANGE_SCORE;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n    if (direction == ZRANGE_DIRECTION_AUTO)\n        direction = ZRANGE_DIRECTION_FORWARD;\n    if (rangetype == ZRANGE_AUTO)\n        rangetype = ZRANGE_RANK;\n    if (opt_limit != -1 && rangetype == ZRANGE_RANK) {\n        addReplyError(c, \"syntax error, LIMIT is only supported in combination with either BYSCORE or BYLEX\");\n        return;\n    }\n    if (opt_withscores && rangetype == ZRANGE_LEX) {\n        addReplyError(c, \"syntax error, WITHSCORES not supported in combination with BYLEX\");\n        return;\n    }\n    if (direction == ZRANGE_DIRECTION_REVERSE && ((ZRANGE_SCORE == rangetype) || (ZRANGE_LEX == rangetype))) {\n        int tmp = maxidx;\n        maxidx = minidx;\n        minidx = tmp;\n    }\n    switch (rangetype) {\n      case ZRANGE_AUTO:\n      case ZRANGE_RANK:\n        if (<recovery-expr>()) {\n            return;\n        }\n        break;\n      case ZRANGE_SCORE:\n        if (zslParseRange(c->argv[minidx], c->argv[maxidx], &range) != 0) {\n            addReplyError(c, \"min or max is not a float\");\n            return;\n        }\n        break;\n      case ZRANGE_LEX:\n        if (zslParseLexRange(c->argv[minidx], c->argv[maxidx], &lexrange) != 0) {\n            addReplyError(c, \"min or max not valid string range item\");\n            return;\n        }\n        break;\n    }\n    if (opt_withscores || store) {\n        zrangeResultHandlerScoreEmissionEnable(handler);\n    }\n    zobj = lookupKeyRead(c->db, key);\n    if (<recovery-expr>()) {\n        if (store) {\n            handler->beginResultEmission(handler, -1);\n            handler->finalizeResultEmission(handler, 0);\n        } else {\n            addReply(c, shared.emptyarray);\n        }\n        goto cleanup;\n    }\n    if (checkType(c, zobj, 3))\n        goto cleanup;\n    switch (rangetype) {\n      case ZRANGE_AUTO:\n      case ZRANGE_RANK:\n        genericZrangebyrankCommand(handler, zobj, opt_start, opt_end, opt_withscores || store, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n      case ZRANGE_SCORE:\n        genericZrangebyscoreCommand(handler, &range, zobj, opt_offset, opt_limit, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n      case ZRANGE_LEX:\n        genericZrangebylexCommand(handler, &lexrange, zobj, opt_withscores || store, opt_offset, opt_limit, direction == ZRANGE_DIRECTION_REVERSE);\n        break;\n    }\n  cleanup:\n    if (rangetype == ZRANGE_LEX) {\n        zslFreeLexRange(&lexrange);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/lua/src/lstrlib.c#365:1#match",
    "gotos": 7,
    "labels": 2,
    "body": "{\n  init:\n    switch (*p) {\n      case '(':\n        {\n            if (*(p + 1) == ')')\n                return start_capture(ms, s, p + 2, (-2));\n            else\n                return start_capture(ms, s, p + 1, (-1));\n        }\n      case ')':\n        {\n            return end_capture(ms, s, p + 1);\n        }\n      case '%':\n        {\n            switch (*(p + 1)) {\n              case 'b':\n                {\n                    s = matchbalance(ms, s, p + 2);\n                    p += 4;\n                    goto init;\n                }\n              case 'f':\n                {\n                    const char *ep;\n                    char previous;\n                    p += 2;\n                    if (*p != '[')\n                        luaL_error(ms->L, \"missing '[' after '%%f' in pattern\");\n                    ep = classend(ms, p);\n                    previous = (s == ms->src_init) ? '\\x00' : *(s - 1);\n                    p = ep;\n                    goto init;\n                }\n              default:\n                {\n                    if (isdigit(((unsigned char)(*(p + 1))))) {\n                        s = match_capture(ms, s, ((unsigned char)(*(p + 1))));\n                        p += 2;\n                        goto init;\n                    }\n                    goto dflt;\n                }\n            }\n        }\n      case '\\x00':\n        {\n            return s;\n        }\n      case '$':\n        {\n            if (*(p + 1) == '\\x00')\n                ;\n            else\n                goto dflt;\n        }\n      default:\n      dflt:\n        {\n            const char *ep = classend(ms, p);\n            int m = s < ms->src_end && singlematch(((unsigned char)(*s)), p, ep);\n            switch (*ep) {\n              case '?':\n                {\n                    const char *res;\n                    if (<recovery-expr>())\n                        return res;\n                    p = ep + 1;\n                    goto init;\n                }\n              case '*':\n                {\n                    return max_expand(ms, s, p, ep);\n                }\n              case '+':\n                {\n                }\n              case '-':\n                {\n                    return min_expand(ms, s, p, ep);\n                }\n              default:\n                {\n                    s++;\n                    p = ep;\n                    goto init;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/linenoise/linenoise.c#234:1#enableRawMode",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    struct termios raw;\n    if (<recovery-expr>())\n        goto fatal;\n    if (!atexit_registered) {\n        atexit(linenoiseAtExit);\n        atexit_registered = 1;\n    }\n    if (tcgetattr(fd, &orig_termios) == -1)\n        goto fatal;\n    <recovery-expr>() = orig_termios;\n    if (<recovery-expr>())\n        goto fatal;\n    rawmode = 1;\n    return 0;\n  fatal:\n    ;\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/linenoise/linenoise.c#302:1#getColumns",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    struct winsize ws;\n    if (<recovery-expr>()) {\n        int start, cols;\n        start = getCursorPosition(ifd, ofd);\n        if (start == -1)\n            goto failed;\n        if (write(ofd, \"\\033[999C\", 6) != 6)\n            goto failed;\n        cols = getCursorPosition(ifd, ofd);\n        if (cols == -1)\n            goto failed;\n        if (cols > start) {\n            char seq[32];\n            snprintf(seq, 32, \"\\033[%dD\", cols - start);\n            if (write(ofd, seq, strlen(seq)) == -1) {\n            }\n        }\n        return cols;\n    } else {\n        return <recovery-expr>().ws_col;\n    }\n  failed:\n    return 80;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sds.c#1267:1#sdstemplate",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    sds res = sdsempty();\n    const char *p = template;\n    while (*p)\n        {\n            const char *sv = strchr(p, '{');\n            if (!sv) {\n                res = sdscat(res, p);\n                break;\n            } else if (sv > p) {\n                res = <recovery-expr>()(res, p, sv - p);\n            }\n            sv++;\n            if (!*sv)\n                goto error;\n            if (*sv == '{') {\n                p = sv + 1;\n                res = sdscat(res, \"{\");\n                continue;\n            }\n            const char *ev = strchr(sv, '}');\n            if (!ev)\n                goto error;\n            sds varname = <recovery-expr>()(sv, ev - sv);\n            sds value = cb_func(varname, cb_arg);\n            sdsfree(varname);\n            if (!value)\n                goto error;\n            res = sdscat(res, value);\n            sdsfree(value);\n            p = ev + 1;\n        }\n    return res;\n  error:\n    sdsfree(res);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sds.c#937:1#sdssplitlen",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int elements = 0, slots = 5;\n    long start = 0, j;\n    sds *tokens;\n    if (seplen < 1 || <recovery-expr>() <= 0) {\n        *count = 0;\n    }\n    tokens = <recovery-expr>()(sizeof(sds) * slots);\n    for (j = 0; j < (<recovery-expr>() - (seplen - 1)); j++) {\n        if (slots < elements + 2) {\n            sds *newtokens;\n            slots *= 2;\n            newtokens = <recovery-expr>()(tokens, sizeof(sds) * slots);\n            if (<recovery-expr>())\n                goto cleanup;\n            tokens = newtokens;\n        }\n        if ((seplen == 1 && *(s + j) == sep[0]) || (memcmp(s + j, sep, seplen) == 0)) {\n            tokens[elements] = <recovery-expr>()(s + start, j - start);\n            if (<recovery-expr>())\n                goto cleanup;\n            elements++;\n            start = j + seplen;\n            j = j + seplen - 1;\n        }\n    }\n    tokens[elements] = <recovery-expr>()(s + start, <recovery-expr>() - start);\n    if (<recovery-expr>())\n        goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n  cleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++)\n            sdsfree(tokens[i]);\n        zfree(tokens);\n        *count = 0;\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sds.c#1094:1#sdssplitargs",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    const char *p = line;\n    char *current;\n    char **vector;\n    *argc = 0;\n    while (1)\n        {\n            while (*p && isspace(*p))\n                p++;\n            if (*p) {\n                int inq = 0;\n                int insq = 0;\n                int done = 0;\n                if (<recovery-expr>())\n                    current = sdsempty();\n                while (!done)\n                    {\n                        if (inq) {\n                            if (*p == '\\\\' && *(p + 1) == 'x' && is_hex_digit(*(p + 2)) && is_hex_digit(*(p + 3))) {\n                                unsigned char byte;\n                                byte = (hex_digit_to_int(*(p + 2)) * 16) + hex_digit_to_int(*(p + 3));\n                                current = <recovery-expr>()(current, (char *)&byte, 1);\n                                p += 3;\n                            } else if (*p == '\\\\' && *(p + 1)) {\n                                char c;\n                                p++;\n                                switch (*p) {\n                                  case 'n':\n                                    c = '\\n';\n                                    break;\n                                  case 'r':\n                                    c = '\\r';\n                                    break;\n                                  case 't':\n                                    c = '\\t';\n                                    break;\n                                  case 'b':\n                                    c = '\\b';\n                                    break;\n                                  case 'a':\n                                    c = '\\a';\n                                    break;\n                                  default:\n                                    c = *p;\n                                    break;\n                                }\n                                current = <recovery-expr>()(current, &c, 1);\n                            } else if (*p == '\"') {\n                                if (*(p + 1) && !isspace(*(p + 1)))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = <recovery-expr>()(current, p, 1);\n                            }\n                        } else if (insq) {\n                            if (*p == '\\\\' && *(p + 1) == '\\'') {\n                                p++;\n                                current = <recovery-expr>()(current, \"'\", 1);\n                            } else if (*p == '\\'') {\n                                if (*(p + 1) && !isspace(*(p + 1)))\n                                    goto err;\n                                done = 1;\n                            } else if (!*p) {\n                                goto err;\n                            } else {\n                                current = <recovery-expr>()(current, p, 1);\n                            }\n                        } else {\n                            switch (*p) {\n                              case ' ':\n                              case '\\n':\n                              case '\\r':\n                              case '\\t':\n                              case '\\x00':\n                                done = 1;\n                                break;\n                              case '\"':\n                                inq = 1;\n                                break;\n                              case '\\'':\n                                insq = 1;\n                                break;\n                              default:\n                                current = <recovery-expr>()(current, p, 1);\n                                break;\n                            }\n                        }\n                        if (*p)\n                            p++;\n                    }\n                vector = <recovery-expr>()(vector, ((*argc) + 1) * sizeof(char *));\n                vector[*argc] = current;\n                (*argc)++;\n            } else {\n                if (<recovery-expr>())\n                    vector = <recovery-expr>()(sizeof(void *));\n                return vector;\n            }\n        }\n  err:\n    while ((*argc)--)\n        sdsfree(vector[*argc]);\n    zfree(vector);\n    if (current)\n        sdsfree(current);\n    *argc = 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-check-rdb.c#192:1#redis_check_rdb",
    "gotos": 24,
    "labels": 2,
    "body": "{\n    int selected_dbid = -1;\n    int type, rdbver;\n    char buf[1024];\n    long long expiretime, now = mstime();\n    static rio rdb;\n    struct stat sb;\n    int closefile;\n    if (<recovery-expr>())\n        return 1;\n    if (fstat(fileno(<recovery-expr>()), &<recovery-expr>()) == -1)\n        <recovery-expr>().st_size = 0;\n    startLoadingFile(<recovery-expr>().st_size, rdbfilename, 0);\n    <recovery-expr>()(&rdb, <recovery-expr>());\n    rdbstate.rio = &rdb;\n    rdb.update_cksum = rdbLoadProgressCallback;\n    if (<recovery-expr>()(&rdb, buf, 9) == 0)\n        goto eoferr;\n    buf[9] = '\\x00';\n    if (memcmp(buf, \"REDIS\", 5) != 0) {\n        rdbCheckError(\"Wrong signature trying to load DB from file\");\n        goto err;\n    }\n    rdbver = atoi(buf + 5);\n    if (rdbver < 1 || rdbver > 10) {\n        rdbCheckError(\"Can't handle RDB format version %d\", rdbver);\n        goto err;\n    }\n    expiretime = -1;\n    while (1)\n        {\n            robj *key, *val;\n            rdbstate.doing = 1;\n            if ((type = rdbLoadType(&rdb)) == -1)\n                goto eoferr;\n            if (type == 253) {\n                rdbstate.doing = 2;\n                expiretime = <recovery-expr>()(&rdb);\n                expiretime *= 1000;\n                if (rioGetReadError(&rdb))\n                    goto eoferr;\n                continue;\n            } else if (type == 252) {\n                rdbstate.doing = 2;\n                expiretime = rdbLoadMillisecondTime(&rdb, rdbver);\n                if (rioGetReadError(&rdb))\n                    goto eoferr;\n                continue;\n            } else if (type == 249) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 248) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 255) {\n                break;\n            } else if (type == 254) {\n                rdbstate.doing = 6;\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 251) {\n                rdbstate.doing = 6;\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 250) {\n                robj *auxkey, *auxval;\n                rdbstate.doing = 7;\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>()) {\n                    decrRefCount(auxkey);\n                    goto eoferr;\n                }\n                rdbCheckInfo(\"AUX FIELD %s = '%s'\", (char *)auxkey->ptr, (char *)auxval->ptr);\n                decrRefCount(auxkey);\n                decrRefCount(auxval);\n                continue;\n            } else if (type == 247) {\n                rdbstate.doing = 8;\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>()) {\n                    rdbCheckError(\"bad when_opcode\");\n                    goto err;\n                }\n                char name[10];\n                rdbCheckInfo(\"MODULE AUX for: %s\", name);\n                robj *o = rdbLoadCheckModuleValue(&rdb, name);\n                decrRefCount(o);\n                continue;\n            } else if (type == 246) {\n                rdbCheckError(\"Pre-release function format not supported %d\", rdbver);\n                goto err;\n            } else if (type == 245) {\n                sds err;\n                rdbstate.doing = 9;\n                if (<recovery-expr>()) {\n                    rdbCheckError(\"Failed loading library, %s\", err);\n                    sdsfree(err);\n                    goto err;\n                }\n                continue;\n            } else {\n                if (!(((type) >= 0 && (type) <= 7) || ((type) >= 9 && (type) <= 19))) {\n                    rdbCheckError(\"Invalid object type: %d\", type);\n                    goto err;\n                }\n                rdbstate.key_type = type;\n            }\n            rdbstate.doing = 3;\n            if (<recovery-expr>())\n                goto eoferr;\n            rdbstate.key = key;\n            rdbstate.keys++;\n            rdbstate.doing = 4;\n            if (<recovery-expr>())\n                goto eoferr;\n            if (expiretime != -1 && expiretime < now)\n                rdbstate.already_expired++;\n            if (expiretime != -1)\n                rdbstate.expires++;\n            decrRefCount(key);\n            decrRefCount(val);\n            rdbstate.key_type = -1;\n            expiretime = -1;\n        }\n    if (rdbver >= 5 && server.rdb_checksum) {\n        rdbstate.doing = 5;\n        if (<recovery-expr>())\n            goto eoferr;\n        ((void)(0));\n        if (<recovery-expr>()) {\n            rdbCheckInfo(\"RDB file was saved with checksum disabled: no check performed.\");\n        } else if (<recovery-expr>()) {\n            rdbCheckError(\"RDB CRC error\");\n            goto err;\n        } else {\n            rdbCheckInfo(\"Checksum OK\");\n        }\n    }\n    if (closefile)\n        fclose(<recovery-expr>());\n    stopLoading(1);\n    return 0;\n  eoferr:\n    if (rdbstate.error_set) {\n        rdbCheckError(rdbstate.error);\n    } else {\n        rdbCheckError(\"Unexpected EOF reading RDB file\");\n    }\n  err:\n    if (closefile)\n        fclose(<recovery-expr>());\n    stopLoading(0);\n    return 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/config.c#2905:1#setConfigLatencyTrackingInfoPercentilesOutputOption",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    ((void)config);\n    zfree(server.latency_tracking_info_percentiles);\n    server.latency_tracking_info_percentiles_len = argc;\n    if (argc == 1 && <recovery-expr>()(argv[0]) == 0)\n        server.latency_tracking_info_percentiles_len = 0;\n    else\n        server.latency_tracking_info_percentiles = <recovery-expr>()(sizeof(double) * argc);\n    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {\n        double percentile;\n        if (!<recovery-expr>()(argv[j], <recovery-expr>()(argv[j]), &percentile)) {\n            *err = \"Invalid latency-tracking-info-percentiles parameters\";\n            goto configerr;\n        }\n        if (percentile > 100. || percentile < 0.) {\n            *err = \"latency-tracking-info-percentiles parameters should sit between [0.0,100.0]\";\n            goto configerr;\n        }\n        server.latency_tracking_info_percentiles[j] = percentile;\n    }\n    return 1;\n  configerr:\n    zfree(server.latency_tracking_info_percentiles);\n    server.latency_tracking_info_percentiles_len = 0;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/config.c#790:1#configSetCommand",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    const char *errstr;\n    const char *invalid_arg_name;\n    const char *err_arg_name;\n    standardConfig **set_configs;\n    list *module_configs_apply;\n    const char **config_names;\n    sds *new_values;\n    sds *old_values;\n    apply_fn *apply_fns;\n    int config_count, i, j;\n    int invalid_args = 0, deny_loading_error = 0;\n    int *config_map_fns;\n    if (c->argc & 1) {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n    config_count = (c->argc - 2) / 2;\n    module_configs_apply = listCreate();\n    set_configs = <recovery-expr>()(sizeof(standardConfig *) * config_count);\n    config_names = <recovery-expr>()(sizeof(char *) * config_count);\n    new_values = <recovery-expr>()(sizeof(sds *) * config_count);\n    old_values = <recovery-expr>()(sizeof(sds *) * config_count);\n    apply_fns = <recovery-expr>()(sizeof(apply_fn) * config_count);\n    config_map_fns = <recovery-expr>()(sizeof(int) * config_count);\n    for (i = 0; i < config_count; i++) {\n        standardConfig *config = lookupConfig(c->argv[2 + i * 2]->ptr);\n        if (!config) {\n            if (!invalid_args) {\n                invalid_arg_name = c->argv[2 + i * 2]->ptr;\n                invalid_args = 1;\n            }\n            continue;\n        }\n        if (config->flags & (1ULL << 1)) {\n            redactClientCommandArgument(c, 2 + i * 2 + 1);\n        }\n        if (invalid_args)\n            continue;\n        if (config->flags & (1ULL << 0) || (config->flags & (1ULL << 5) && !allowProtectedAction(server.enable_protected_configs, c))) {\n            errstr = (config->flags & (1ULL << 0)) ? \"can't set immutable config\" : \"can't set protected config\";\n            err_arg_name = c->argv[2 + i * 2]->ptr;\n            invalid_args = 1;\n            continue;\n        }\n        if (<recovery-expr>(server) && config->flags & (1ULL << 6)) {\n            deny_loading_error = 1;\n            invalid_args = 1;\n            continue;\n        }\n        for (j = 0; j < i; j++) {\n            if (set_configs[j] == config) {\n                errstr = \"duplicate parameter\";\n                err_arg_name = c->argv[2 + i * 2]->ptr;\n                invalid_args = 1;\n                break;\n            }\n        }\n        set_configs[i] = config;\n        config_names[i] = config->name;\n        new_values[i] = c->argv[2 + i * 2 + 1]->ptr;\n    }\n    if (invalid_args)\n        goto err;\n    for (i = 0; i < config_count; i++)\n        old_values[i] = set_configs[i]->interface.get(set_configs[i]);\n    for (i = 0; i < config_count; i++) {\n        int res = performInterfaceSet(set_configs[i], new_values[i], &errstr);\n        if (!res) {\n            err_arg_name = set_configs[i]->name;\n            goto err;\n        } else if (res == 1) {\n            if (set_configs[i]->flags & (1ULL << 8)) {\n                addModuleConfigApply(module_configs_apply, set_configs[i]->privdata);\n            } else if (set_configs[i]->interface.apply) {\n                int exists = 0;\n                if (!exists) {\n                    apply_fns[j] = set_configs[i]->interface.apply;\n                    config_map_fns[j] = i;\n                }\n            }\n        }\n    }\n    if (!moduleConfigApplyConfig(module_configs_apply, &errstr, &err_arg_name)) {\n        serverLogRaw(3, \"Failed applying new module configuration. Restoring previous settings.\");\n        restoreBackupConfig(set_configs, old_values, config_count, apply_fns, module_configs_apply);\n        goto err;\n    }\n    RedisModuleConfigChangeV1 cc = <recovery-expr>({.num_changes = config_count, .config_names = config_names});\n    <recovery-expr>()(16, 0, &cc);\n    addReply(c, shared.ok);\n    goto end;\n  err:\n    if (deny_loading_error) {\n        addReplyErrorObject(c, shared.loadingerr);\n    } else if (invalid_arg_name) {\n        addReplyErrorFormat(c, \"Unknown option or number of arguments for CONFIG SET - '%s'\", invalid_arg_name);\n    } else if (errstr) {\n        addReplyErrorFormat(c, \"CONFIG SET failed (possibly related to argument '%s') - %s\", err_arg_name, errstr);\n    } else {\n        addReplyErrorFormat(c, \"CONFIG SET failed (possibly related to argument '%s')\", err_arg_name);\n    }\n  end:\n    zfree(set_configs);\n    zfree(config_names);\n    zfree(new_values);\n    for (i = 0; i < config_count; i++)\n        sdsfree(old_values[i]);\n    zfree(old_values);\n    zfree(apply_fns);\n    zfree(config_map_fns);\n    listRelease(module_configs_apply);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/config.c#444:1#loadServerConfigFromString",
    "gotos": 12,
    "labels": 1,
    "body": "{\n    deprecatedConfig deprecated_configs[];\n    char buf[1024];\n    const char *err;\n    int linenum = 0, totlines, i;\n    sds *lines;\n    reading_config_file = 1;\n    lines = <recovery-expr>()(config, strlen(config), \"\\n\", 1, &totlines);\n    for (i = 0; i < totlines; i++) {\n        sds *argv;\n        int argc;\n        linenum = i + 1;\n        lines[i] = sdstrim(lines[i], \" \\t\\r\\n\");\n        if (lines[i][0] == '#' || lines[i][0] == '\\x00')\n            continue;\n        argv = sdssplitargs(lines[i], &argc);\n        if (<recovery-expr>()) {\n            err = \"Unbalanced quotes in configuration line\";\n            goto loaderr;\n        }\n        if (argc == 0) {\n            sdsfreesplitres(argv, argc);\n            continue;\n        }\n        sdstolower(argv[0]);\n        standardConfig *config = lookupConfig(argv[0]);\n        if (config) {\n            if (!(config->flags & (1ULL << 3)) && argc != 2) {\n                err = \"wrong number of arguments\";\n                goto loaderr;\n            }\n            if ((config->flags & (1ULL << 3)) && argc == 2 && <recovery-expr>()(argv[1])) {\n                sds *new_argv;\n                int new_argc;\n                new_argv = sdssplitargs(argv[1], &new_argc);\n                if (!config->interface.set(config, new_argv, new_argc, &err)) {\n                    goto loaderr;\n                }\n                sdsfreesplitres(new_argv, new_argc);\n            } else {\n                if (!config->interface.set(config, &argv[1], argc - 1, &err)) {\n                    goto loaderr;\n                }\n            }\n            sdsfreesplitres(argv, argc);\n            continue;\n        } else {\n            int match = 0;\n            if (match) {\n                sdsfreesplitres(argv, argc);\n                continue;\n            }\n        }\n        if (!strcasecmp(argv[0], \"include\") && argc == 2) {\n        } else if (!strcasecmp(argv[0], \"rename-command\") && argc == 3) {\n            struct redisCommand *cmd = lookupCommandBySds(argv[1]);\n            int retval;\n            if (!cmd) {\n                err = \"No such command in rename-command\";\n                goto loaderr;\n            }\n            retval = dictDelete(server.commands, argv[1]);\n            ((retval == 0) ? (void)0 : (_serverAssert(\"retval == DICT_OK\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/config.c\", 545) , __builtin_unreachable()));\n            if (<recovery-expr>()(argv[2]) != 0) {\n                sds copy = sdsdup(argv[2]);\n                retval = dictAdd(server.commands, copy, cmd);\n                if (retval != 0) {\n                    sdsfree(copy);\n                    err = \"Target command name already exists\";\n                    goto loaderr;\n                }\n            }\n        } else if (!strcasecmp(argv[0], \"user\") && argc >= 2) {\n            int argc_err;\n            if (ACLAppendUserForLoading(argv, argc, &argc_err) == -1) {\n                const char *errmsg = ACLSetUserStringError();\n                snprintf(buf, sizeof (buf), \"Error in user declaration '%s': %s\", argv[argc_err], errmsg);\n                err = buf;\n                goto loaderr;\n            }\n        } else if (!strcasecmp(argv[0], \"loadmodule\") && argc >= 2) {\n            queueLoadModule(argv[1], &argv[2], argc - 2);\n        } else if (strchr(argv[0], '.')) {\n            if (argc < 2) {\n                err = \"Module config specified without value\";\n                goto loaderr;\n            }\n            sds name = sdsdup(argv[0]);\n            sds val = sdsdup(argv[1]);\n            for (int i = 2; i < argc; i++)\n                val = sdscatfmt(val, \" %S\", argv[i]);\n            if (!dictReplace(server.module_configs_queue, name, val))\n                sdsfree(name);\n        } else if (!strcasecmp(argv[0], \"sentinel\")) {\n            if (argc != 1) {\n                if (!server.sentinel_mode) {\n                    err = \"sentinel directive while not in sentinel mode\";\n                    goto loaderr;\n                }\n                queueSentinelConfig(argv + 1, argc - 1, linenum, lines[i]);\n            }\n        } else {\n            err = \"Bad directive or wrong number of arguments\";\n            goto loaderr;\n        }\n        sdsfreesplitres(argv, argc);\n    }\n    if (server.logfile[0] != '\\x00') {\n        if (<recovery-expr>()) {\n            goto loaderr;\n        }\n    }\n    if (server.cluster_enabled && server.masterhost) {\n        err = \"replicaof directive not allowed in cluster mode\";\n        goto loaderr;\n    }\n    if (server.config_hz < 1)\n        server.config_hz = 1;\n    if (server.config_hz > 500)\n        server.config_hz = 500;\n    sdsfreesplitres(lines, totlines);\n    reading_config_file = 0;\n    return;\n  loaderr:\n    ;\n    if (i < totlines) {\n    }\n    exit(1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/config.c#1663:1#rewriteConfigOverwriteFile",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int fd = -1;\n    int retval = -1;\n    char tmp_conffile;\n    const char *tmp_suffix = \".XXXXXX\";\n    int offset(int *);\n    int old_errno;\n    int tmp_path_len = snprintf(<recovery-expr>(), sizeof (<recovery-expr>()), \"%s%s\", configfile, tmp_suffix);\n    if (tmp_path_len <= 0 || (unsigned int)tmp_path_len >= sizeof (<recovery-expr>())) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Config file full path is too long\");\n        } while (0);\n        return retval;\n    }\n    fd = mkstemp(<recovery-expr>());\n    if (fd == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        return retval;\n    }\n    while (<recovery-expr>() < <recovery-expr>()(content))\n        {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    continue;\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                goto cleanup;\n            }\n        }\n    if (fsync(fd))\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n    else if (fchmod(fd, 420 & ~<recovery-expr>(server)) == -1)\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n    else if (rename(<recovery-expr>(), configfile) == -1)\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n    else if (fsyncFileDir(configfile) == -1)\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n    else {\n        retval = 0;\n        do {\n            if (((0) & 255) < server.verbosity)\n                break;\n            _serverLog(0, \"Rewritten config file (%s) successfully\", configfile);\n        } while (0);\n    }\n  cleanup:\n    ;\n    close(fd);\n    if (retval)\n        unlink(<recovery-expr>());\n    return retval;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/acl.c#1956:1#ACLStringSetUser",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    sds error;\n    int merged_argc = 0, invalid_idx = 0;\n    sds *acl_args = ACLMergeSelectorArguments(argv, argc, &merged_argc, &invalid_idx);\n    if (!acl_args) {\n        return sdscatfmt(sdsempty(), \"Unmatched parenthesis in acl selector starting at '%s'.\", (char *)argv[invalid_idx]);\n    }\n    user *tempu = ACLCreateUnlinkedUser();\n    if (u) {\n        ACLCopyUser(tempu, u);\n    }\n    for (int j = 0; j < merged_argc; j++) {\n        if (<recovery-expr>()) {\n            const char *errmsg = ACLSetUserStringError();\n            error = sdscatfmt(sdsempty(), \"Error in ACL SETUSER modifier '%s': %s\", (char *)acl_args[j], errmsg);\n            goto cleanup;\n        }\n    }\n    if (u) {\n        ACLKillPubsubClientsIfNeeded(tempu, u);\n    }\n    if (!u) {\n        u = ACLCreateUser(username, <recovery-expr>()(username));\n    }\n    ACLCopyUser(u, tempu);\n  cleanup:\n    ACLFreeUser(tempu);\n    for (int i = 0; i < merged_argc; i++) {\n        sdsfree(acl_args[i]);\n    }\n    zfree(acl_args);\n    return error;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/acl.c#911:1#aclCreateSelectorFromOpSet",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    aclSelector *s = ACLCreateSelector(0);\n    int argc = 0;\n    sds trimmed = <recovery-expr>()(opset + 1, opsetlen - 2);\n    sds *argv = sdssplitargs(trimmed, &argc);\n    for (int i = 0; i < argc; i++) {\n        if (ACLSetSelector(s, argv[i], <recovery-expr>()(argv[i])) == -1) {\n            ACLFreeSelector(s);\n            goto cleanup;\n        }\n    }\n  cleanup:\n    sdsfreesplitres(argv, argc);\n    sdsfree(trimmed);\n    return s;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/acl.c#2311:1#ACLSaveToFile",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    sds acl = sdsempty();\n    int fd = -1;\n    sds tmpfilename;\n    int retval = -1;\n    raxIterator ri;\n    raxStart(&ri, Users);\n    while (raxNext(&ri))\n        {\n            user *u = ri.data;\n            sds user = sdsnew(\"user \");\n            user = sdscatsds(user, u->name);\n            user = <recovery-expr>()(user, \" \", 1);\n            robj *descr = ACLDescribeUser(u);\n            user = sdscatsds(user, descr->ptr);\n            decrRefCount(descr);\n            acl = sdscatsds(acl, user);\n            acl = <recovery-expr>()(acl, \"\\n\", 1);\n            sdsfree(user);\n        }\n    raxStop(&ri);\n    tmpfilename = sdsnew(filename);\n    tmpfilename = sdscatfmt(tmpfilename, \".tmp-%i-%I\", (int)getpid(), commandTimeSnapshot());\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    int offset(int *);\n    while (<recovery-expr>() < <recovery-expr>()(acl))\n        {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    continue;\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                goto cleanup;\n            }\n        }\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    close(fd);\n    fd = -1;\n    if (rename(tmpfilename, filename) == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    if (fsyncFileDir(filename) == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    sdsfree(tmpfilename);\n    retval = 0;\n  cleanup:\n    if (fd != -1)\n        close(fd);\n    if (tmpfilename)\n        unlink(tmpfilename);\n    sdsfree(tmpfilename);\n    sdsfree(acl);\n    return retval;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/hiredis.c#970:1#redisBufferWrite",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (c->err)\n        return -1;\n    if (<recovery-expr>()(c->obuf) > 0) {\n        if (<recovery-expr>()) {\n            return -1;\n        } else if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n                hi_sdsfree(c->obuf);\n                c->obuf = hi_sdsempty();\n                if (<recovery-expr>())\n                    goto oom;\n            } else {\n                if (<recovery-expr>())\n                    goto oom;\n            }\n        }\n    }\n    if (<recovery-expr>())\n        *done = (<recovery-expr>()(c->obuf) == 0);\n    return 0;\n  oom:\n    __redisSetError(c, 5, \"Out of memory\");\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/hiredis.c#312:1#redisvFormatCommand",
    "gotos": 19,
    "labels": 5,
    "body": "{\n    const char *c = format;\n    char *cmd;\n    int pos;\n    hisds curarg, newarg;\n    int touched = 0;\n    char **curargv, **newargv;\n    int argc = 0;\n    int totlen = 0;\n    int error_type = 0;\n    int j;\n    if (<recovery-expr>())\n        return -1;\n    curarg = hi_sdsempty();\n    if (<recovery-expr>())\n        return -1;\n    while (*c != '\\x00')\n        {\n            if (*c != '%' || c[1] == '\\x00') {\n                if (*c == ' ') {\n                    if (touched) {\n                        newargv = <recovery-expr>()(curargv, sizeof(char *) * (argc + 1));\n                        if (<recovery-expr>())\n                            goto memory_err;\n                        curargv = newargv;\n                        curargv[argc++] = curarg;\n                        totlen += <recovery-expr>()(<recovery-expr>()(curarg));\n                        curarg = hi_sdsempty();\n                        if (<recovery-expr>())\n                            goto memory_err;\n                        touched = 0;\n                    }\n                } else {\n                    newarg = <recovery-expr>()(curarg, c, 1);\n                    if (<recovery-expr>())\n                        goto memory_err;\n                    curarg = newarg;\n                    touched = 1;\n                }\n            } else {\n                char *arg;\n                newarg = curarg;\n                switch (c[1]) {\n                  case 's':\n                    ;\n                    break;\n                  case 'b':\n                    ;\n                    break;\n                  case '%':\n                    newarg = hi_sdscat(curarg, \"%\");\n                    break;\n                  default:\n                    {\n                        static const char intfmts[] = \"diouxX\";\n                        static const char flags[] = \"#0-+ \";\n                        char _format[16];\n                        const char *_p = c + 1;\n                        while (<recovery-expr>())\n                            _p++;\n                        while (*_p != '\\x00' && isdigit(*_p))\n                            _p++;\n                        if (*_p == '.') {\n                            _p++;\n                            while (*_p != '\\x00' && isdigit(*_p))\n                                _p++;\n                        }\n                        if (<recovery-expr>()) {\n                            goto fmt_valid;\n                        }\n                        if (<recovery-expr>()) {\n                            goto fmt_valid;\n                        }\n                        if (_p[0] == 'h' && _p[1] == 'h') {\n                            _p += 2;\n                            if (<recovery-expr>()) {\n                                goto fmt_valid;\n                            }\n                            goto fmt_invalid;\n                        }\n                        if (_p[0] == 'h') {\n                            _p += 1;\n                            if (<recovery-expr>()) {\n                                goto fmt_valid;\n                            }\n                            goto fmt_invalid;\n                        }\n                        if (_p[0] == 'l' && _p[1] == 'l') {\n                            _p += 2;\n                            if (<recovery-expr>()) {\n                                goto fmt_valid;\n                            }\n                            goto fmt_invalid;\n                        }\n                        if (_p[0] == 'l') {\n                            _p += 1;\n                            if (<recovery-expr>()) {\n                                goto fmt_valid;\n                            }\n                            goto fmt_invalid;\n                        }\n                      fmt_invalid:\n                        ;\n                        goto format_err;\n                      fmt_valid:\n                        ;\n                        if (<recovery-expr>()) {\n                            c = _p - 1;\n                        }\n                        break;\n                    }\n                }\n                if (<recovery-expr>())\n                    goto memory_err;\n                curarg = newarg;\n                touched = 1;\n                c++;\n            }\n            c++;\n        }\n    if (touched) {\n        newargv = <recovery-expr>()(curargv, sizeof(char *) * (argc + 1));\n        if (<recovery-expr>())\n            goto memory_err;\n        curargv = newargv;\n        curargv[argc++] = curarg;\n        totlen += <recovery-expr>()(<recovery-expr>()(curarg));\n    } else {\n        hi_sdsfree(curarg);\n    }\n    totlen += 1 + <recovery-expr>()(argc) + 2;\n    cmd = <recovery-expr>()(totlen + 1);\n    if (<recovery-expr>())\n        goto memory_err;\n    pos = sprintf(cmd, \"*%d\\r\\n\", argc);\n    for (j = 0; j < argc; j++) {\n        pos += sprintf(cmd + pos, \"$%zu\\r\\n\", <recovery-expr>()(curargv[j]));\n        memcpy(cmd + pos, curargv[j], <recovery-expr>()(curargv[j]));\n        pos += <recovery-expr>()(curargv[j]);\n        hi_sdsfree(curargv[j]);\n        cmd[pos++] = '\\r';\n        cmd[pos++] = '\\n';\n    }\n    assert(pos == totlen);\n    cmd[pos] = '\\x00';\n    hi_free(curargv);\n    *target = cmd;\n    return totlen;\n  format_err:\n    error_type = -2;\n    goto cleanup;\n  memory_err:\n    error_type = -1;\n    goto cleanup;\n  cleanup:\n    if (curargv) {\n        while (argc--)\n            hi_sdsfree(curargv[argc]);\n        hi_free(curargv);\n    }\n    hi_sdsfree(curarg);\n    hi_free(cmd);\n    return error_type;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/hiredis.c#124:1#createStringObject",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    redisReply *r, *parent;\n    char *buf;\n    r = createReplyObject(task->type);\n    assert(task->type == 6 || task->type == 5 || task->type == 1 || task->type == 14 || task->type == 13);\n    if (task->type == 14) {\n        buf = <recovery-expr>()(<recovery-expr>() - 4 + 1);\n        if (<recovery-expr>())\n            goto oom;\n        memcpy(r->vtype, str, 3);\n        r->vtype[3] = '\\x00';\n        memcpy(buf, str + 4, <recovery-expr>() - 4);\n        buf[<recovery-expr>() - 4] = '\\x00';\n        <recovery-expr>(r) = <recovery-expr>() - 4;\n    } else {\n        buf = <recovery-expr>()(<recovery-expr>() + 1);\n        if (<recovery-expr>())\n            goto oom;\n        memcpy(buf, str, <recovery-expr>());\n        buf[<recovery-expr>()] = '\\x00';\n        <recovery-expr>(r) = <recovery-expr>();\n    }\n    r->str = buf;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == 2 || parent->type == 9 || parent->type == 10 || parent->type == 12);\n        parent->element[task->idx] = r;\n    }\n    return r;\n  oom:\n    freeReplyObject(r);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/eval.c#957:1#ldbReplParseCommand",
    "gotos": 9,
    "labels": 2,
    "body": "{\n    static char *protocol_error = \"protocol error\";\n    sds *argv;\n    int argc = 0;\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n    p = strchr(p, '*');\n    if (!p)\n        goto protoerr;\n    char *plen = p + 1;\n    p = strstr(p, \"\\r\\n\");\n    if (!p)\n        goto keep_reading;\n    *p = '\\x00';\n    p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024)\n        goto protoerr;\n    argv = <recovery-expr>()(sizeof(sds) * (*argcp));\n    argc = 0;\n    while (argc < *argcp)\n        {\n            if (*p == '\\x00')\n                goto keep_reading;\n            if (*p != '$')\n                goto protoerr;\n            plen = p + 1;\n            p = strstr(p, \"\\r\\n\");\n            if (!p)\n                goto keep_reading;\n            *p = '\\x00';\n            p += 2;\n            int slen = atoi(plen);\n            if (slen <= 0 || slen > 1024)\n                goto protoerr;\n            if (<recovery-expr>())\n                goto keep_reading;\n            argv[argc++] = <recovery-expr>()(p, slen);\n            p += slen;\n            if (p[0] != '\\r' || p[1] != '\\n')\n                goto protoerr;\n            p += 2;\n        }\n    sdsfree(copy);\n    return argv;\n  protoerr:\n    *err = protocol_error;\n  keep_reading:\n    sdsfreesplitres(argv, argc);\n    sdsfree(copy);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_string.c#727:1#lcsCommand",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    long long minmatchlen = 0;\n    sds a, b;\n    int getlen = 0, getidx = 0, withmatchlen = 0;\n    robj *obja, *objb;\n    obja = lookupKeyRead(c->db, c->argv[1]);\n    objb = lookupKeyRead(c->db, c->argv[2]);\n    if ((obja && obja->type != 0) || (objb && objb->type != 0)) {\n        addReplyError(c, \"The specified keys must contain string values\");\n        goto cleanup;\n    }\n    obja = obja ? getDecodedObject(obja) : createStringObject(\"\", 0);\n    objb = objb ? getDecodedObject(objb) : createStringObject(\"\", 0);\n    a = obja->ptr;\n    b = objb->ptr;\n    if (getlen && getidx) {\n        addReplyError(c, \"If you want both the length and indexes, please just use IDX.\");\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        addReplyError(c, \"String too long for LCS\");\n        goto cleanup;\n    }\n    unsigned long long lcssize;\n    unsigned long long lcsalloc;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            addReplyError(c, \"Insufficient memory, transient memory for LCS exceeds proto-max-bulk-len\");\n            goto cleanup;\n        }\n    }\n    if (<recovery-expr>()) {\n        addReplyError(c, \"Insufficient memory, failed allocating transient memory for LCS\");\n        goto cleanup;\n    }\n    sds result;\n    void *arraylenptr;\n    int computelcs = getidx || !getlen;\n    if (getidx) {\n        addReplyMapLen(c, 2);\n        addReplyBulkCString(c, \"matches\");\n        arraylenptr = addReplyDeferredLen(c);\n    }\n    while (<recovery-expr>())\n        {\n            int emit_range = 0;\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                } else {\n                    if (<recovery-expr>()) {\n                    } else {\n                        emit_range = 1;\n                    }\n                }\n                if (<recovery-expr>())\n                    emit_range = 1;\n            } else {\n                if (<recovery-expr>())\n                    emit_range = 1;\n            }\n            if (emit_range) {\n                if (<recovery-expr>()) {\n                    if (arraylenptr) {\n                        addReplyArrayLen(c, 2 + withmatchlen);\n                        addReplyArrayLen(c, 2);\n                        addReplyArrayLen(c, 2);\n                    }\n                }\n            }\n        }\n    if (arraylenptr) {\n        addReplyBulkCString(c, \"len\");\n    } else if (getlen) {\n    } else {\n        addReplyBulkSds(c, result);\n    }\n    sdsfree(result);\n  cleanup:\n    if (obja)\n        decrRefCount(obja);\n    if (objb)\n        decrRefCount(objb);\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/lua/src/lvm.c#379:1#luaV_execute",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    LClosure *cl;\n    StkId base;\n    TValue *k;\n    const Instruction *pc;\n  reentry:\n    ((void)0);\n    pc = L->savedpc;\n    cl = &(&(L->ci->func)->value.gc->cl)->l;\n    base = L->base;\n    k = cl->p->k;\n    for (;;) {\n        const Instruction i = *pc++;\n        StkId ra;\n        if ((L->hookmask & ((1 << 2) | (1 << 3))) && (--L->hookcount == 0 || L->hookmask & (1 << 2))) {\n            traceexec(L, pc);\n            if (L->status == 1) {\n                L->savedpc = pc - 1;\n                return;\n            }\n            base = L->base;\n        }\n        ra = (base + (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0)))));\n        ((void)0);\n        ((void)0);\n        ((void)0);\n        switch ((((OpCode)(((i) >> 0) & ((~((~(Instruction)0) << 6)) << 0))))) {\n          case OP_MOVE:\n            {\n                {\n                    const TValue *o2 = ((base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))));\n                    TValue *o1 = (ra);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                continue;\n            }\n          case OP_LOADK:\n            {\n                {\n                    const TValue *o2 = ((k + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0))))));\n                    TValue *o1 = (ra);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                continue;\n            }\n          case OP_LOADBOOL:\n            {\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.b = ((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    i_o->tt = 1;\n                }\n                ;\n                if ((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))))\n                    pc++;\n                continue;\n            }\n          case OP_LOADNIL:\n            {\n                TValue *rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                do {\n                    ((rb--)->tt = 0);\n                } while (rb >= ra);\n                continue;\n            }\n          case OP_GETUPVAL:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                {\n                    const TValue *o2 = (cl->upvals[b]->v);\n                    TValue *o1 = (ra);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                continue;\n            }\n          case OP_GETGLOBAL:\n            {\n                TValue g;\n                TValue *rb = (k + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0)))));\n                {\n                    TValue *i_o = (&g);\n                    i_o->value.gc = ((GCObject *)((cl->env)));\n                    i_o->tt = 5;\n                    ((void)0);\n                }\n                ;\n                ((void)0);\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_gettable(L, &g, rb, ra);\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_GETTABLE:\n            {\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_gettable(L, (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))), ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))), ra);\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_SETGLOBAL:\n            {\n                TValue g;\n                {\n                    TValue *i_o = (&g);\n                    i_o->value.gc = ((GCObject *)((cl->env)));\n                    i_o->tt = 5;\n                    ((void)0);\n                }\n                ;\n                ((void)0);\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_settable(L, &g, (k + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0))))), ra);\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_SETUPVAL:\n            {\n                UpVal *uv = cl->upvals[(((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))];\n                {\n                    const TValue *o2 = (ra);\n                    TValue *o1 = (uv->v);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                {\n                    if (((((ra)->tt) >= 4) && (((((ra)->value.gc))->gch.marked) & ((((1 << (0)) | (1 << (1))))))) && ((((((GCObject *)((uv)))))->gch.marked) & ((1 << (2)))))\n                        luaC_barrierf(L, (((GCObject *)((uv)))), ((ra)->value.gc));\n                }\n                ;\n                continue;\n            }\n          case OP_SETTABLE:\n            {\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_settable(L, ra, ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))), ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))));\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_NEWTABLE:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int c = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.gc = ((GCObject *)((luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)))));\n                    i_o->tt = 5;\n                    ((void)0);\n                }\n                ;\n                {\n                    L->savedpc = pc;\n                    {\n                        {\n                            ((void)0);\n                            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)\n                                luaC_step(L);\n                        }\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_SELF:\n            {\n                StkId rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                {\n                    const TValue *o2 = (rb);\n                    TValue *o1 = (ra + 1);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_gettable(L, rb, ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))), ra);\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_ADD:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) + (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_ADD);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_SUB:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) - (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_SUB);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_MUL:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) * (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_MUL);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_DIV:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) / (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_DIV);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_MOD:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((nb) - floor((nb) / (nc)) * (nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_MOD);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_POW:\n            {\n                {\n                    TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    if ((((rb)->tt) == 3) && (((rc)->tt) == 3)) {\n                        lua_Number nb = ((rb)->value.n), nc = ((rc)->value.n);\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = ((pow(nb, nc)));\n                            i_o->tt = 3;\n                        }\n                        ;\n                    } else {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rc, TM_POW);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_UNM:\n            {\n                TValue *rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                if ((((rb)->tt) == 3)) {\n                    lua_Number nb = ((rb)->value.n);\n                    {\n                        TValue *i_o = (ra);\n                        i_o->value.n = ((-(nb)));\n                        i_o->tt = 3;\n                    }\n                    ;\n                } else {\n                    {\n                        L->savedpc = pc;\n                        {\n                            Arith(L, ra, rb, rb, TM_UNM);\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                }\n                continue;\n            }\n          case OP_NOT:\n            {\n                int res = (((((base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))))->tt) == 0) || (((((base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))))->tt) == 1) && (((base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))))->value.b) == 0));\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.b = (res);\n                    i_o->tt = 1;\n                }\n                ;\n                continue;\n            }\n          case OP_LEN:\n            {\n                const TValue *rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                switch (((rb)->tt)) {\n                  case 5:\n                    {\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((lua_Number)((luaH_getn((&(rb)->value.gc->h))))));\n                            i_o->tt = 3;\n                        }\n                        ;\n                        break;\n                    }\n                  case 4:\n                    {\n                        {\n                            TValue *i_o = (ra);\n                            i_o->value.n = (((lua_Number)(((&(&<recovery-expr>((rb)->value.gc))->tsv)->len))));\n                            i_o->tt = 3;\n                        }\n                        ;\n                        break;\n                    }\n                  default:\n                    {\n                        {\n                            L->savedpc = pc;\n                            {\n                                if (!call_binTM(L, rb, (&luaO_nilobject_), ra, TM_LEN))\n                                    luaG_typeerror(L, rb, \"get length of\");\n                                ;\n                            }\n                            ;\n                            base = L->base;\n                        }\n                    }\n                }\n                continue;\n            }\n          case OP_CONCAT:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int c = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));\n                {\n                    L->savedpc = pc;\n                    {\n                        luaV_concat(L, c - b + 1, c);\n                        {\n                            ((void)0);\n                            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)\n                                luaC_step(L);\n                        }\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                {\n                    const TValue *o2 = (base + b);\n                    TValue *o1 = ((base + (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))));\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                continue;\n            }\n          case OP_JMP:\n            {\n                {\n                    {\n                        ((void)0);\n                        ((void)0);\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_EQ:\n            {\n                TValue *rb = ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                TValue *rc = ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                {\n                    L->savedpc = pc;\n                    {\n                        if ((((rb)->tt) == ((rc)->tt) && luaV_equalval(L, rb, rc)) == (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) {\n                            {\n                                ((void)0);\n                                ((void)0);\n                            }\n                            ;\n                        }\n                        ;\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                pc++;\n                continue;\n            }\n          case OP_LT:\n            {\n                {\n                    L->savedpc = pc;\n                    {\n                        if (luaV_lessthan(L, ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))), ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))))) == (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) {\n                            {\n                                ((void)0);\n                                ((void)0);\n                            }\n                            ;\n                        }\n                        ;\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                pc++;\n                continue;\n            }\n          case OP_LE:\n            {\n                {\n                    L->savedpc = pc;\n                    {\n                        if (lessequal(L, ((((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))), ((((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & (1 << (9 - 1))) ? k + ((int)((((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) & ~(1 << (9 - 1))) : base + (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))))) == (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) {\n                            {\n                                ((void)0);\n                                ((void)0);\n                            }\n                            ;\n                        }\n                        ;\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                pc++;\n                continue;\n            }\n          case OP_TEST:\n            {\n                if (((((ra)->tt) == 0) || ((((ra)->tt) == 1) && ((ra)->value.b) == 0)) != (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) {\n                    {\n                        ((void)0);\n                        ((void)0);\n                    }\n                    ;\n                }\n                ;\n                pc++;\n                continue;\n            }\n          case OP_TESTSET:\n            {\n                TValue *rb = (base + (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                if (((((rb)->tt) == 0) || ((((rb)->tt) == 1) && ((rb)->value.b) == 0)) != (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))))) {\n                    {\n                        const TValue *o2 = (rb);\n                        TValue *o1 = (ra);\n                        o1->value = o2->value;\n                        o1->tt = o2->tt;\n                        ((void)0);\n                    }\n                    ;\n                    {\n                        {\n                            ((void)0);\n                            ((void)0);\n                        }\n                        ;\n                    }\n                    ;\n                }\n                pc++;\n                continue;\n            }\n          case OP_CALL:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int nresults = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))) - 1;\n                if (b != 0)\n                    L->top = ra + b;\n                L->savedpc = pc;\n                switch (luaD_precall(L, ra, nresults)) {\n                  case 0:\n                    {\n                        nexeccalls++;\n                        goto reentry;\n                    }\n                  case 1:\n                    {\n                        if (nresults >= 0)\n                            L->top = L->ci->top;\n                        base = L->base;\n                        continue;\n                    }\n                  default:\n                    {\n                        return;\n                    }\n                }\n            }\n          case OP_TAILCALL:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                if (b != 0)\n                    L->top = ra + b;\n                L->savedpc = pc;\n                ((void)0);\n                switch (luaD_precall(L, ra, (-1))) {\n                  case 0:\n                    {\n                        CallInfo *ci = L->ci - 1;\n                        int aux;\n                        StkId func = ci->func;\n                        StkId pfunc = (ci + 1)->func;\n                        if (L->openupval)\n                            luaF_close(L, ci->base);\n                        L->base = ci->base = ci->func + ((ci + 1)->base - pfunc);\n                        for (aux = 0; pfunc + aux < L->top; aux++) {\n                            const TValue *o2 = (pfunc + aux);\n                            TValue *o1 = (func + aux);\n                            o1->value = o2->value;\n                            o1->tt = o2->tt;\n                            ((void)0);\n                        }\n                        ;\n                        ci->top = L->top = func + aux;\n                        ((void)0);\n                        ci->savedpc = L->savedpc;\n                        ci->tailcalls++;\n                        L->ci--;\n                        goto reentry;\n                    }\n                  case 1:\n                    {\n                        base = L->base;\n                        continue;\n                    }\n                  default:\n                    {\n                        return;\n                    }\n                }\n            }\n          case OP_RETURN:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                if (b != 0)\n                    L->top = ra + b - 1;\n                if (L->openupval)\n                    luaF_close(L, base);\n                L->savedpc = pc;\n                b = luaD_poscall(L, ra);\n                if (--nexeccalls == 0)\n                    return;\n                else {\n                    if (b)\n                        L->top = L->ci->top;\n                    ((void)0);\n                    ((void)0);\n                    goto reentry;\n                }\n            }\n          case OP_FORLOOP:\n            {\n                lua_Number step = ((ra + 2)->value.n);\n                lua_Number idx = ((((ra)->value.n)) + (step));\n                lua_Number limit = ((ra + 1)->value.n);\n                if (((0) < (step)) ? ((idx) <= (limit)) : ((limit) <= (idx))) {\n                    {\n                        {\n                            ((void)0);\n                            ((void)0);\n                        }\n                        ;\n                    }\n                    ;\n                    {\n                        TValue *i_o = (ra);\n                        i_o->value.n = (idx);\n                        i_o->tt = 3;\n                    }\n                    ;\n                    {\n                        TValue *i_o = (ra + 3);\n                        i_o->value.n = (idx);\n                        i_o->tt = 3;\n                    }\n                    ;\n                }\n                continue;\n            }\n          case OP_FORPREP:\n            {\n                const TValue *init = ra;\n                const TValue *plimit = ra + 1;\n                const TValue *pstep = ra + 2;\n                L->savedpc = pc;\n                if (<recovery-expr>())\n                    luaG_runerror(L, \"'for' initial value must be a number\");\n                else if (<recovery-expr>())\n                    luaG_runerror(L, \"'for' limit must be a number\");\n                else if (<recovery-expr>())\n                    luaG_runerror(L, \"'for' step must be a number\");\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.n = (((((ra)->value.n)) - (((pstep)->value.n))));\n                    i_o->tt = 3;\n                }\n                ;\n                {\n                    {\n                        ((void)0);\n                        ((void)0);\n                    }\n                    ;\n                }\n                ;\n                continue;\n            }\n          case OP_TFORLOOP:\n            {\n                StkId cb = ra + 3;\n                {\n                    const TValue *o2 = (ra + 2);\n                    TValue *o1 = (cb + 2);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                {\n                    const TValue *o2 = (ra + 1);\n                    TValue *o1 = (cb + 1);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                {\n                    const TValue *o2 = (ra);\n                    TValue *o1 = (cb);\n                    o1->value = o2->value;\n                    o1->tt = o2->tt;\n                    ((void)0);\n                }\n                ;\n                L->top = cb + 3;\n                {\n                    L->savedpc = pc;\n                    {\n                        luaD_call(L, cb, (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                L->top = L->ci->top;\n                cb = (base + (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0))))) + 3;\n                if (!(((cb)->tt) == 0)) {\n                    {\n                        const TValue *o2 = (cb);\n                        TValue *o1 = (cb - 1);\n                        o1->value = o2->value;\n                        o1->tt = o2->tt;\n                        ((void)0);\n                    }\n                    ;\n                    {\n                        {\n                            ((void)0);\n                            ((void)0);\n                        }\n                        ;\n                    }\n                    ;\n                }\n                pc++;\n                continue;\n            }\n          case OP_SETLIST:\n            {\n                int n = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int c = (((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << 9)) << 0))));\n                int last;\n                Table *h;\n                if (n == 0) {\n                    n = ((int)((L->top - ra))) - 1;\n                    L->top = L->ci->top;\n                }\n                if (c == 0)\n                    c = ((int)((*pc++)));\n                {\n                    if (!((((ra)->tt) == 5)))\n                        break;\n                }\n                ;\n                h = (&(ra)->value.gc->h);\n                last = ((c - 1) * 50) + n;\n                if (last > h->sizearray)\n                    luaH_resizearray(L, h, last);\n                for (; n > 0; n--) {\n                    TValue *val = ra + n;\n                    {\n                        const TValue *o2 = (val);\n                        TValue *o1 = (luaH_setnum(L, h, last--));\n                        o1->value = o2->value;\n                        o1->tt = o2->tt;\n                        ((void)0);\n                    }\n                    ;\n                    {\n                        if (((((val)->tt) >= 4) && (((((val)->value.gc))->gch.marked) & ((((1 << (0)) | (1 << (1))))))) && ((((((GCObject *)((h)))))->gch.marked) & ((1 << (2)))))\n                            luaC_barrierback(L, h);\n                    }\n                    ;\n                }\n                continue;\n            }\n          case OP_CLOSE:\n            {\n                luaF_close(L, ra);\n                continue;\n            }\n          case OP_CLOSURE:\n            {\n                Proto *p;\n                Closure *ncl;\n                int nup, j;\n                p = cl->p->p[(((int)(((i) >> ((0 + 6) + 8)) & ((~((~(Instruction)0) << (9 + 9))) << 0))))];\n                nup = p->nups;\n                ncl = luaF_newLclosure(L, nup, cl->env);\n                ncl->l.p = p;\n                for (j = 0; j < nup; j++ , pc++) {\n                    if ((((OpCode)(((*pc) >> 0) & ((~((~(Instruction)0) << 6)) << 0)))) == OP_GETUPVAL)\n                        ncl->l.upvals[j] = cl->upvals[(((int)(((*pc) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0))))];\n                    else {\n                        ((void)0);\n                        ncl->l.upvals[j] = luaF_findupval(L, base + (((int)(((*pc) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))));\n                    }\n                }\n                {\n                    TValue *i_o = (ra);\n                    i_o->value.gc = ((GCObject *)((ncl)));\n                    i_o->tt = 6;\n                    ((void)0);\n                }\n                ;\n                {\n                    L->savedpc = pc;\n                    {\n                        {\n                            ((void)0);\n                            if ((L->l_G)->totalbytes >= (L->l_G)->GCthreshold)\n                                luaC_step(L);\n                        }\n                        ;\n                    }\n                    ;\n                    base = L->base;\n                }\n                ;\n                continue;\n            }\n          case OP_VARARG:\n            {\n                int b = (((int)(((i) >> (((0 + 6) + 8) + 9)) & ((~((~(Instruction)0) << 9)) << 0)))) - 1;\n                int j;\n                CallInfo *ci = L->ci;\n                int n = ((int)((ci->base - ci->func))) - cl->p->numparams - 1;\n                if (b == (-1)) {\n                    {\n                        L->savedpc = pc;\n                        {\n                            if ((char *)L->stack_last - (char *)L->top <= (n) * (int)sizeof(TValue))\n                                luaD_growstack(L, n);\n                            else\n                                ((void)0);\n                            ;\n                        }\n                        ;\n                        base = L->base;\n                    }\n                    ;\n                    ra = (base + (((int)(((i) >> (0 + 6)) & ((~((~(Instruction)0) << 8)) << 0)))));\n                    b = n;\n                    L->top = ra + n;\n                }\n                for (j = 0; j < b; j++) {\n                    if (j < n) {\n                        {\n                            const TValue *o2 = (ci->base - n + j);\n                            TValue *o1 = (ra + j);\n                            o1->value = o2->value;\n                            o1->tt = o2->tt;\n                            ((void)0);\n                        }\n                        ;\n                    } else {\n                        ((ra + j)->tt = 0);\n                    }\n                }\n                continue;\n            }\n        }\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/server.c#4134:1#finishShutdown",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int save = server.shutdown_flags & 1;\n    int nosave = server.shutdown_flags & 2;\n    int force = server.shutdown_flags & 8;\n    listIter replicas_iter;\n    listNode *replicas_list_node;\n    int num_replicas = 0, num_lagging_replicas = 0;\n    listRewind(server.slaves, &replicas_iter);\n    while (<recovery-expr>())\n        {\n            client *replica = ((replicas_list_node)->value);\n            num_replicas++;\n            if (replica->repl_ack_off != server.master_repl_offset) {\n                num_lagging_replicas++;\n                long lag;\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Lagging replica %s reported offset %lld behind master, lag=%ld, state=%s.\", replicationGetSlaveName(replica), server.master_repl_offset - replica->repl_ack_off, lag, replstateToString(replica->replstate));\n                } while (0);\n            }\n        }\n    if (num_replicas > 0) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"%d of %d replicas are in sync when shutting down.\", num_replicas - num_lagging_replicas, num_replicas);\n        } while (0);\n    }\n    ldbKillForkedSessions();\n    if (server.child_type == 1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"There is a child saving an .rdb. Killing it!\");\n        } while (0);\n        killRDBChild();\n        <recovery-expr>()(<recovery-expr>(server), 0);\n    }\n    if (server.child_type == 4) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"There is a module fork child. Killing it!\");\n        } while (0);\n        TerminateModuleForkChild(<recovery-expr>(server), 0);\n    }\n    if (server.child_type == 2) {\n        if (server.aof_state == 2) {\n            if (force) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Writing initial AOF. Exit anyway.\");\n                } while (0);\n            } else {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Writing initial AOF, can't exit.\");\n                } while (0);\n                goto error;\n            }\n        }\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"There is a child rewriting the AOF. Killing it!\");\n        } while (0);\n        killAppendOnlyChild();\n    }\n    if (server.aof_state != 0) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Calling fsync() on the AOF file.\");\n        } while (0);\n        flushAppendOnlyFile(1);\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n        }\n    }\n    if ((server.saveparamslen > 0 && !nosave) || save) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Saving the final RDB snapshot before exiting.\");\n        } while (0);\n        if (server.supervised_mode == 2)\n            redisCommunicateSystemd(\"STATUS=Saving the final RDB snapshot\\n\");\n        rdbSaveInfo rsi, *rsiptr;\n        rsiptr = rdbPopulateSaveInfo(&rsi);\n        if (rdbSave(0, server.rdb_filename, rsiptr) != 0) {\n            if (force) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Error trying to save the DB. Exit anyway.\");\n                } while (0);\n            } else {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Error trying to save the DB, can't exit.\");\n                } while (0);\n                if (server.supervised_mode == 2)\n                    redisCommunicateSystemd(\"STATUS=Error trying to save the DB, can't exit.\\n\");\n                goto error;\n            }\n        }\n    }\n    if (server.aof_manifest)\n        aofManifestFree(server.aof_manifest);\n    if (server.daemonize || server.pidfile) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Removing the pid file.\");\n        } while (0);\n        unlink(server.pidfile);\n    }\n    flushSlavesOutputBuffers();\n    closeListeningSockets(1);\n    if (server.cluster_enabled && server.cluster_config_file_lock_fd != -1) {\n    }\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"%s is now ready to exit, bye bye...\", server.sentinel_mode ? \"Sentinel\" : \"Redis\");\n    } while (0);\n    return 0;\n  error:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Errors trying to shut down the server. Check the logs for more information.\");\n    } while (0);\n    cancelShutdown();\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/server.c#164:1#serverLogFromHandler",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    int fd;\n    int log_to_stdout = server.logfile[0] == '\\x00';\n    char buf[64];\n    if ((level & 255) < server.verbosity || (log_to_stdout && server.daemonize))\n        return;\n    if (fd == -1)\n        return;\n    <recovery-expr>()(buf, sizeof (buf), getpid());\n    if (write(fd, buf, strlen(buf)) == -1)\n        goto err;\n    if (write(fd, \":signal-handler (\", 17) == -1)\n        goto err;\n    if (write(fd, buf, strlen(buf)) == -1)\n        goto err;\n    if (write(fd, \") \", 2) == -1)\n        goto err;\n    if (write(fd, msg, strlen(msg)) == -1)\n        goto err;\n    if (write(fd, \"\\n\", 1) == -1)\n        goto err;\n  err:\n    if (!log_to_stdout)\n        close(fd);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hdr_histogram/hdr_histogram.c#1173:1#hdr_percentiles_print",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    char line_format[25];\n    const char *head_format;\n    int rc = 0;\n    struct hdr_iter iter;\n    struct hdr_iter_percentiles *percentiles;\n    <recovery-expr>()(line_format, 25, <recovery-expr>(h), format);\n    head_format = format_head_string(format);\n    <recovery-expr>()(&iter, h, <recovery-expr>());\n    if (fprintf(<recovery-expr>(), head_format, \"Value\", \"Percentile\", \"TotalCount\", \"1/(1-Percentile)\") < 0) {\n        goto cleanup;\n    }\n    percentiles = &<recovery-expr>(iter).percentiles;\n    while (<recovery-expr>()(&iter))\n        {\n            double value = <recovery-expr>(iter) / value_scale;\n            double percentile = percentiles->percentile / 100.;\n            double inverted_percentile = (1. / (1. - percentile));\n            if (<recovery-expr>()) {\n                goto cleanup;\n            }\n        }\n    if (CLASSIC == format) {\n        double mean = hdr_mean(h) / value_scale;\n        double stddev = hdr_stddev(h) / value_scale;\n        double max = <recovery-expr>()(h) / value_scale;\n        if (fprintf(<recovery-expr>(), CLASSIC_FOOTER, mean, stddev, max, <recovery-expr>(h), <recovery-expr>(h), <recovery-expr>(h)) < 0) {\n            goto cleanup;\n        }\n    }\n  cleanup:\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/multi.c#357:1#touchWatchedKey",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    list *clients;\n    listIter li;\n    listNode *ln;\n    if (((db->watched_keys)->ht_used[0] + (db->watched_keys)->ht_used[1]) == 0)\n        return;\n    clients = dictFetchValue(db->watched_keys, key);\n    if (!clients)\n        return;\n    listRewind(clients, &li);\n    while ((ln = listNext(&li)))\n        {\n            watchedKey *wk = ((ln)->value);\n            client *c = wk->client;\n            if (wk->expired) {\n                if (<recovery-expr>()) {\n                    wk->expired = 0;\n                    goto skip_client;\n                }\n                break;\n            }\n            <recovery-expr>(c) |= (1 << 5);\n            unwatchAllKeys(c);\n          skip_client:\n            continue;\n        }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/evict.c#538:1#performEvictions",
    "gotos": 3,
    "labels": 2,
    "body": "{\n    if (!isSafeToPerformEvictions())\n        return 0;\n    int keys_freed = 0;\n    int mem_reported(int *), mem_tofree(int *);\n    long long mem_freed;\n    mstime_t latency, eviction_latency;\n    long long delta;\n    int slaves = ((server.slaves)->len);\n    int result = 2;\n    if (<recovery-expr>()) {\n        result = 0;\n        goto update_metrics;\n    }\n    if (server.maxmemory_policy == (7 << 8)) {\n        result = 2;\n        goto update_metrics;\n    }\n    unsigned long eviction_time_limit_us = evictionTimeLimitUs();\n    mem_freed = 0;\n    if (server.latency_monitor_threshold) {\n        latency = mstime();\n    } else {\n        latency = 0;\n    }\n    ;\n    monotime evictionTimer;\n    elapsedStart(&evictionTimer);\n    int prev_core_propagates = server.core_propagates;\n    ((server.also_propagate.numops == 0) ? (void)0 : (_serverAssert(\"server.also_propagate.numops == 0\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/evict.c\", 573) , __builtin_unreachable()));\n    server.core_propagates = 1;\n    server.in_nested_call++;\n    while (mem_freed < (long long)mem_tofree)\n        {\n            int j, k, i;\n            static unsigned int next_db = 0;\n            sds bestkey;\n            int bestdbid;\n            redisDb *db;\n            dict *dict;\n            dictEntry *de;\n            if (server.maxmemory_policy & ((1 << 0) | (1 << 1)) || server.maxmemory_policy == (2 << 8)) {\n                struct evictionPoolEntry *pool = EvictionPoolLRU;\n                while (<recovery-expr>())\n                    {\n                        unsigned long total_keys = 0, keys;\n                        for (i = 0; i < server.dbnum; i++) {\n                            db = server.db + i;\n                            dict = (server.maxmemory_policy & (1 << 2)) ? db->dict : db->expires;\n                            if ((keys = ((dict)->ht_used[0] + (dict)->ht_used[1])) != 0) {\n                                evictionPoolPopulate(i, dict, db->dict, pool);\n                                total_keys += keys;\n                            }\n                        }\n                        if (!total_keys)\n                            break;\n                        for (k = 16 - 1; k >= 0; k--) {\n                            if (<recovery-expr>())\n                                continue;\n                            bestdbid = pool[k].dbid;\n                            if (server.maxmemory_policy & (1 << 2)) {\n                                de = dictFind(server.db[bestdbid].dict, pool[k].key);\n                            } else {\n                                de = dictFind(server.db[bestdbid].expires, pool[k].key);\n                            }\n                            if (pool[k].key != pool[k].cached)\n                                sdsfree(pool[k].key);\n                            pool[k].idle = 0;\n                            if (de) {\n                                bestkey = ((de)->key);\n                                break;\n                            } else {\n                            }\n                        }\n                    }\n            } else if (server.maxmemory_policy == ((6 << 8) | (1 << 2)) || server.maxmemory_policy == (3 << 8)) {\n                for (i = 0; i < server.dbnum; i++) {\n                    j = (++next_db) % server.dbnum;\n                    db = server.db + j;\n                    dict = (server.maxmemory_policy == ((6 << 8) | (1 << 2))) ? db->dict : db->expires;\n                    if (((dict)->ht_used[0] + (dict)->ht_used[1]) != 0) {\n                        de = dictGetRandomKey(dict);\n                        bestkey = ((de)->key);\n                        bestdbid = j;\n                        break;\n                    }\n                }\n            }\n            if (bestkey) {\n                db = server.db + bestdbid;\n                robj *keyobj = createStringObject(bestkey, <recovery-expr>()(bestkey));\n                delta = (long long)<recovery-expr>()();\n                if (server.latency_monitor_threshold) {\n                    eviction_latency = mstime();\n                } else {\n                    eviction_latency = 0;\n                }\n                ;\n                if (server.lazyfree_lazy_eviction)\n                    dbAsyncDelete(db, keyobj);\n                else\n                    dbSyncDelete(db, keyobj);\n                if (server.latency_monitor_threshold) {\n                    eviction_latency = mstime() - eviction_latency;\n                }\n                ;\n                if (server.latency_monitor_threshold && (eviction_latency) >= server.latency_monitor_threshold)\n                    latencyAddSample((\"eviction-del\"), (eviction_latency));\n                ;\n                delta -= (long long)<recovery-expr>()();\n                mem_freed += delta;\n                server.stat_evictedkeys++;\n                notifyKeyspaceEvent((1 << 9), \"evicted\", keyobj, db->id);\n                propagateDeletion(db, keyobj, server.lazyfree_lazy_eviction);\n                propagatePendingCommands();\n                decrRefCount(keyobj);\n                keys_freed++;\n                if (keys_freed % 16 == 0) {\n                    if (slaves)\n                        flushSlavesOutputBuffers();\n                    if (server.lazyfree_lazy_eviction) {\n                        if (<recovery-expr>()) {\n                            break;\n                        }\n                    }\n                    if (<recovery-expr>()(evictionTimer) > eviction_time_limit_us) {\n                        startEvictionTimeProc();\n                        break;\n                    }\n                }\n            } else {\n                goto cant_free;\n            }\n        }\n    result = (isEvictionProcRunning) ? 1 : 0;\n  cant_free:\n    if (result == 2) {\n        mstime_t lazyfree_latency;\n        if (server.latency_monitor_threshold) {\n            lazyfree_latency = mstime();\n        } else {\n            lazyfree_latency = 0;\n        }\n        ;\n        while (bioPendingJobsOfType(2) && <recovery-expr>()(evictionTimer) < eviction_time_limit_us)\n            {\n                if (<recovery-expr>()) {\n                    result = 0;\n                    break;\n                }\n                usleep(eviction_time_limit_us < 1000 ? eviction_time_limit_us : 1000);\n            }\n        if (server.latency_monitor_threshold) {\n            lazyfree_latency = mstime() - lazyfree_latency;\n        }\n        ;\n        if (server.latency_monitor_threshold && (lazyfree_latency) >= server.latency_monitor_threshold)\n            latencyAddSample((\"eviction-lazyfree\"), (lazyfree_latency));\n        ;\n    }\n    ((server.core_propagates) ? (void)0 : (_serverAssert(\"server.core_propagates\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/evict.c\", 753) , __builtin_unreachable()));\n    server.core_propagates = prev_core_propagates;\n    server.in_nested_call--;\n    if (server.latency_monitor_threshold) {\n        latency = mstime() - latency;\n    }\n    ;\n    if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n        latencyAddSample((\"eviction-cycle\"), (latency));\n    ;\n  update_metrics:\n    if (result == 1 || result == 2) {\n        if (server.stat_last_eviction_exceeded_time == 0)\n            elapsedStart(&server.stat_last_eviction_exceeded_time);\n    } else if (result == 0) {\n        if (server.stat_last_eviction_exceeded_time != 0) {\n            server.stat_total_eviction_exceeded_time += <recovery-expr>()(server.stat_last_eviction_exceeded_time);\n            server.stat_last_eviction_exceeded_time = 0;\n        }\n    }\n    return result;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/anet.c#582:1#anetFdToString",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    struct sockaddr_storage sa;\n    if (remote) {\n        if (<recovery-expr>())\n            goto error;\n    } else {\n        if (<recovery-expr>())\n            goto error;\n    }\n    if (<recovery-expr>()) {\n        struct sockaddr_in *s = (struct sockaddr_in *)&<recovery-expr>();\n        if (ip) {\n            if (<recovery-expr>())\n                goto error;\n        }\n        if (port)\n            *port = ntohs(<recovery-expr>(s));\n    } else if (<recovery-expr>()) {\n        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&<recovery-expr>();\n        if (ip) {\n            if (<recovery-expr>())\n                goto error;\n        }\n        if (port)\n            *port = ntohs(<recovery-expr>(s));\n    } else if (<recovery-expr>()) {\n        if (ip) {\n            int res = snprintf(ip, <recovery-expr>(), \"/unixsocket\");\n            if (res < 0 || (unsigned int)res >= <recovery-expr>())\n                goto error;\n        }\n        if (port)\n            *port = 0;\n    } else {\n        goto error;\n    }\n    return 0;\n  error:\n    if (ip) {\n        if (<recovery-expr>() >= 2) {\n            ip[0] = '?';\n            ip[1] = '\\x00';\n        } else if (<recovery-expr>() == 1) {\n            ip[0] = '\\x00';\n        }\n    }\n    if (port)\n        *port = 0;\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/anet.c#633:1#anetPipe",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int pipe_flags = 0;\n    if (pipe_flags == 0 && pipe(fds))\n        return -1;\n    if (<recovery-expr>())\n        if (<recovery-expr>())\n            goto error;\n    if (<recovery-expr>())\n        if (<recovery-expr>())\n            goto error;\n    if (read_flags)\n        if (<recovery-expr>())\n            goto error;\n    if (write_flags)\n        if (<recovery-expr>())\n            goto error;\n    return 0;\n  error:\n    close(fds[0]);\n    close(fds[1]);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/anet.c#444:1#_anetTcpServer",
    "gotos": 1,
    "labels": 2,
    "body": "{\n    int s = -1, rv;\n    char _port[6];\n    struct addrinfo hints, *servinfo, *p;\n    snprintf(_port, 6, \"%d\", port);\n    memset(&<recovery-expr>(), 0, sizeof (<recovery-expr>()));\n    <recovery-expr>().ai_family = af;\n    if ((rv = getaddrinfo(bindaddr, _port, &<recovery-expr>(), &servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return -1;\n    }\n    if (<recovery-expr>()) {\n        goto error;\n    }\n  error:\n    if (s != -1)\n        close(s);\n    s = -1;\n  end:\n    freeaddrinfo(servinfo);\n    return s;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rax.c#509:1#raxGenericInsert",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int j = 0;\n    raxNode *h, **parentlink;\n    ;\n    if (<recovery-expr>()) {\n        ;\n        if (!<recovery-expr>(h) || (<recovery-expr>(h) && overwrite)) {\n            h = raxReallocForData(h, data);\n            if (h)\n                memcpy(parentlink, &h, sizeof (h));\n        }\n        if (<recovery-expr>()) {\n            return 0;\n        }\n        if (<recovery-expr>(h)) {\n            if (old)\n                *old = raxGetData(h);\n            if (overwrite)\n                raxSetData(h, data);\n            return 0;\n        }\n        raxSetData(h, data);\n        <recovery-expr>(rax)++;\n        return 1;\n    }\n    if (<recovery-expr>()) {\n        ;\n        ;\n        ;\n        ;\n        raxNode **childfield = ((raxNode **)(((char *)(h)) + (sizeof(raxNode) + <recovery-expr>((h)) + ((sizeof(void *) - (((<recovery-expr>((h))) + 4) % sizeof(void *))) & (sizeof(void *) - 1)) + (<recovery-expr>((h)) ? sizeof(raxNode *) : sizeof(raxNode *) * <recovery-expr>((h))) + ((<recovery-expr>((h)) && !<recovery-expr>((h))) * sizeof(void *))) - sizeof(raxNode *) - ((<recovery-expr>((h)) && !<recovery-expr>((h))) ? sizeof(void *) : 0)));\n        raxNode *next;\n        memcpy(&next, childfield, sizeof (next));\n        ;\n        ;\n        if (<recovery-expr>(h)) {\n            ;\n        }\n        int split_node_is_key;\n        raxNode *splitnode = <recovery-expr>()(1, split_node_is_key);\n        raxNode *trimmed;\n        raxNode *postfix;\n        if (<recovery-expr>()) {\n        }\n        if (<recovery-expr>()) {\n        }\n        if (<recovery-expr>()) {\n            zfree(splitnode);\n            zfree(trimmed);\n            zfree(postfix);\n            return 0;\n        }\n        splitnode->data[0] = h->data[j];\n        if (j == 0) {\n            if (<recovery-expr>(h)) {\n                void *ndata = raxGetData(h);\n                raxSetData(splitnode, ndata);\n            }\n            memcpy(parentlink, &splitnode, sizeof (splitnode));\n        } else {\n            <recovery-expr>(trimmed) = j;\n            memcpy(trimmed->data, h->data, j);\n            <recovery-expr>(trimmed) = j > 1 ? 1 : 0;\n            <recovery-expr>(trimmed) = <recovery-expr>(h);\n            <recovery-expr>(trimmed) = <recovery-expr>(h);\n            if (<recovery-expr>(h) && !<recovery-expr>(h)) {\n                void *ndata = raxGetData(h);\n                raxSetData(trimmed, ndata);\n            }\n            raxNode **cp = ((raxNode **)(((char *)(trimmed)) + (sizeof(raxNode) + <recovery-expr>((trimmed)) + ((sizeof(void *) - (((<recovery-expr>((trimmed))) + 4) % sizeof(void *))) & (sizeof(void *) - 1)) + (<recovery-expr>((trimmed)) ? sizeof(raxNode *) : sizeof(raxNode *) * <recovery-expr>((trimmed))) + ((<recovery-expr>((trimmed)) && !<recovery-expr>((trimmed))) * sizeof(void *))) - sizeof(raxNode *) - ((<recovery-expr>((trimmed)) && !<recovery-expr>((trimmed))) ? sizeof(void *) : 0)));\n            memcpy(cp, &splitnode, sizeof (splitnode));\n            memcpy(parentlink, &trimmed, sizeof (trimmed));\n            parentlink = cp;\n            <recovery-expr>(rax)++;\n        }\n        if (<recovery-expr>()) {\n            <recovery-expr>(postfix) = 0;\n            <recovery-expr>(postfix) = 0;\n            raxNode **cp = ((raxNode **)(((char *)(postfix)) + (sizeof(raxNode) + <recovery-expr>((postfix)) + ((sizeof(void *) - (((<recovery-expr>((postfix))) + 4) % sizeof(void *))) & (sizeof(void *) - 1)) + (<recovery-expr>((postfix)) ? sizeof(raxNode *) : sizeof(raxNode *) * <recovery-expr>((postfix))) + ((<recovery-expr>((postfix)) && !<recovery-expr>((postfix))) * sizeof(void *))) - sizeof(raxNode *) - ((<recovery-expr>((postfix)) && !<recovery-expr>((postfix))) ? sizeof(void *) : 0)));\n            memcpy(cp, &next, sizeof (next));\n            <recovery-expr>(rax)++;\n        } else {\n            postfix = next;\n        }\n        raxNode **splitchild = ((raxNode **)(((char *)(splitnode)) + (sizeof(raxNode) + <recovery-expr>((splitnode)) + ((sizeof(void *) - (((<recovery-expr>((splitnode))) + 4) % sizeof(void *))) & (sizeof(void *) - 1)) + (<recovery-expr>((splitnode)) ? sizeof(raxNode *) : sizeof(raxNode *) * <recovery-expr>((splitnode))) + ((<recovery-expr>((splitnode)) && !<recovery-expr>((splitnode))) * sizeof(void *))) - sizeof(raxNode *) - ((<recovery-expr>((splitnode)) && !<recovery-expr>((splitnode))) ? sizeof(void *) : 0)));\n        memcpy(splitchild, &postfix, sizeof (postfix));\n        zfree(h);\n        h = splitnode;\n    } else if (<recovery-expr>()) {\n        ;\n        raxNode *postfix;\n        raxNode *trimmed;\n        if (<recovery-expr>()) {\n            zfree(postfix);\n            zfree(trimmed);\n            return 0;\n        }\n        raxNode **childfield = ((raxNode **)(((char *)(h)) + (sizeof(raxNode) + <recovery-expr>((h)) + ((sizeof(void *) - (((<recovery-expr>((h))) + 4) % sizeof(void *))) & (sizeof(void *) - 1)) + (<recovery-expr>((h)) ? sizeof(raxNode *) : sizeof(raxNode *) * <recovery-expr>((h))) + ((<recovery-expr>((h)) && !<recovery-expr>((h))) * sizeof(void *))) - sizeof(raxNode *) - ((<recovery-expr>((h)) && !<recovery-expr>((h))) ? sizeof(void *) : 0)));\n        raxNode *next;\n        memcpy(&next, childfield, sizeof (next));\n        <recovery-expr>(postfix) = 1;\n        <recovery-expr>(postfix) = 0;\n        raxSetData(postfix, data);\n        raxNode **cp = ((raxNode **)(((char *)(postfix)) + (sizeof(raxNode) + <recovery-expr>((postfix)) + ((sizeof(void *) - (((<recovery-expr>((postfix))) + 4) % sizeof(void *))) & (sizeof(void *) - 1)) + (<recovery-expr>((postfix)) ? sizeof(raxNode *) : sizeof(raxNode *) * <recovery-expr>((postfix))) + ((<recovery-expr>((postfix)) && !<recovery-expr>((postfix))) * sizeof(void *))) - sizeof(raxNode *) - ((<recovery-expr>((postfix)) && !<recovery-expr>((postfix))) ? sizeof(void *) : 0)));\n        memcpy(cp, &next, sizeof (next));\n        <recovery-expr>(rax)++;\n        <recovery-expr>(trimmed) = j;\n        <recovery-expr>(trimmed) = j > 1;\n        <recovery-expr>(trimmed) = 0;\n        <recovery-expr>(trimmed) = 0;\n        memcpy(trimmed->data, h->data, j);\n        memcpy(parentlink, &trimmed, sizeof (trimmed));\n        if (<recovery-expr>(h)) {\n            void *aux = raxGetData(h);\n            raxSetData(trimmed, aux);\n        }\n        cp = ((raxNode **)(((char *)(trimmed)) + (sizeof(raxNode) + <recovery-expr>((trimmed)) + ((sizeof(void *) - (((<recovery-expr>((trimmed))) + 4) % sizeof(void *))) & (sizeof(void *) - 1)) + (<recovery-expr>((trimmed)) ? sizeof(raxNode *) : sizeof(raxNode *) * <recovery-expr>((trimmed))) + ((<recovery-expr>((trimmed)) && !<recovery-expr>((trimmed))) * sizeof(void *))) - sizeof(raxNode *) - ((<recovery-expr>((trimmed)) && !<recovery-expr>((trimmed))) ? sizeof(void *) : 0)));\n        memcpy(cp, &postfix, sizeof (postfix));\n        <recovery-expr>(rax)++;\n        zfree(h);\n        return 1;\n    }\n    while (<recovery-expr>())\n        {\n            raxNode *child;\n            if (<recovery-expr>()) {\n                ;\n                raxNode *newh;\n                if (<recovery-expr>())\n                    goto oom;\n                h = newh;\n                memcpy(parentlink, &h, sizeof (h));\n                parentlink = ((raxNode **)(((char *)(h)) + (sizeof(raxNode) + <recovery-expr>((h)) + ((sizeof(void *) - (((<recovery-expr>((h))) + 4) % sizeof(void *))) & (sizeof(void *) - 1)) + (<recovery-expr>((h)) ? sizeof(raxNode *) : sizeof(raxNode *) * <recovery-expr>((h))) + ((<recovery-expr>((h)) && !<recovery-expr>((h))) * sizeof(void *))) - sizeof(raxNode *) - ((<recovery-expr>((h)) && !<recovery-expr>((h))) ? sizeof(void *) : 0)));\n            } else {\n                ;\n                raxNode **new_parentlink;\n                raxNode *newh;\n                if (<recovery-expr>())\n                    goto oom;\n                h = newh;\n                memcpy(parentlink, &h, sizeof (h));\n                parentlink = new_parentlink;\n            }\n            <recovery-expr>(rax)++;\n            h = child;\n        }\n    raxNode *newh = raxReallocForData(h, data);\n    if (<recovery-expr>())\n        goto oom;\n    h = newh;\n    if (!<recovery-expr>(h))\n        <recovery-expr>(rax)++;\n    raxSetData(h, data);\n    memcpy(parentlink, &h, sizeof (h));\n    return 1;\n  oom:\n    if (<recovery-expr>(h) == 0) {\n        <recovery-expr>(h) = 1;\n        <recovery-expr>(h) = 1;\n        <recovery-expr>(rax)++;\n    }\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-check-aof.c#508:1#redis_check_aof_main",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    char *filepath;\n    char temp_filepath;\n    char *dirpath;\n    int fix = 0;\n    if (argc < 2) {\n        goto invalid_args;\n    } else if (argc == 2) {\n        filepath = argv[1];\n    } else if (argc == 3) {\n        if (!strcmp(argv[1], \"--fix\")) {\n            filepath = argv[2];\n            fix = 1;\n        } else {\n            goto invalid_args;\n        }\n    } else if (argc == 4) {\n        if (!strcmp(argv[1], \"--truncate-to-timestamp\")) {\n            char *endptr;\n            <recovery-expr>() = strtol(argv[2], &endptr, 10);\n            if (<recovery-expr>()) {\n                printf(\"Invalid timestamp, aborting...\\n\");\n                exit(1);\n            }\n            filepath = argv[3];\n        } else {\n            goto invalid_args;\n        }\n    } else {\n        goto invalid_args;\n    }\n    memcpy(<recovery-expr>(), filepath, strlen(filepath) + 1);\n    dirpath = dirname(<recovery-expr>());\n    input_file_type type = getInputFileType(filepath);\n    switch (type) {\n      case AOF_MULTI_PART:\n        checkMultiPartAof(dirpath, filepath, fix);\n        break;\n      case AOF_RESP:\n        checkOldStyleAof(filepath, fix, 0);\n        break;\n      case AOF_RDB_PREAMBLE:\n        checkOldStyleAof(filepath, fix, 1);\n        break;\n    }\n    exit(0);\n  invalid_args:\n    printf(\"Usage: %s [--fix|--truncate-to-timestamp $timestamp] <file.manifest|file.aof>\\n\", argv[0]);\n    exit(1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/functions.c#715:1#functionRestoreCommand",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    if (c->argc > 4) {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n    restorePolicy restore_replicy = restorePolicy_Append;\n    sds data = c->argv[2]->ptr;\n    int data_len(int *);\n    rio payload;\n    sds err;\n    if (c->argc == 4) {\n        const char *restore_policy_str = c->argv[3]->ptr;\n        if (!strcasecmp(restore_policy_str, \"append\")) {\n            restore_replicy = restorePolicy_Append;\n        } else if (!strcasecmp(restore_policy_str, \"replace\")) {\n            restore_replicy = restorePolicy_Replace;\n        } else if (!strcasecmp(restore_policy_str, \"flush\")) {\n            restore_replicy = restorePolicy_Flush;\n        } else {\n            addReplyError(c, \"Wrong restore policy given, value should be either FLUSH, APPEND or REPLACE.\");\n            return;\n        }\n    }\n    if (<recovery-expr>()) {\n        addReplyError(c, \"DUMP payload version or checksum are wrong\");\n        return;\n    }\n    functionsLibCtx *functions_lib_ctx = functionsLibCtxCreate();\n    rioInitWithBuffer(&payload, data);\n    while (<recovery-expr>() - <recovery-expr>(payload).buffer.pos > 10)\n        {\n            int type;\n            if ((type = rdbLoadType(&payload)) == -1) {\n                err = sdsnew(\"can not read data type\");\n                goto load_error;\n            }\n            if (type == 246) {\n                err = sdsnew(\"Pre-GA function format not supported\");\n                goto load_error;\n            }\n            if (type != 245) {\n                err = sdsnew(\"given type is not a function\");\n                goto load_error;\n            }\n            if (<recovery-expr>()) {\n                if (!err) {\n                    err = sdsnew(\"failed loading the given functions payload\");\n                }\n                goto load_error;\n            }\n        }\n    if (restore_replicy == restorePolicy_Flush) {\n        functionsLibCtxSwapWithCurrent(functions_lib_ctx);\n    } else {\n        if (libraryJoin(curr_functions_lib_ctx, functions_lib_ctx, restore_replicy == restorePolicy_Replace, &err) != 0) {\n            goto load_error;\n        }\n    }\n    server.dirty++;\n  load_error:\n    if (err) {\n        addReplyErrorSds(c, err);\n    } else {\n        addReply(c, shared.ok);\n    }\n    if (functions_lib_ctx) {\n        functionsLibCtxFree(functions_lib_ctx);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/functions.c#331:1#libraryJoin",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int ret = -1;\n    dictIterator *iter;\n    list *old_libraries_list;\n    dictEntry *entry;\n    iter = dictGetIterator(functions_lib_ctx_src->libraries);\n    while ((entry = dictNext(iter)))\n        {\n            functionLibInfo *li = (<recovery-expr>((entry)).val);\n            functionLibInfo *old_li = dictFetchValue(functions_lib_ctx_dst->libraries, li->name);\n            if (old_li) {\n                if (!replace) {\n                    *err = sdscatfmt(sdsempty(), \"Library %s already exists\", li->name);\n                    goto done;\n                } else {\n                    if (!old_libraries_list) {\n                        old_libraries_list = listCreate();\n                        ((old_libraries_list)->free = ((void (*)(void *))engineLibraryFree));\n                    }\n                    libraryUnlink(functions_lib_ctx_dst, old_li);\n                    listAddNodeTail(old_libraries_list, old_li);\n                }\n            }\n        }\n    dictReleaseIterator(iter);\n    iter = dictGetIterator(functions_lib_ctx_src->functions);\n    while ((entry = dictNext(iter)))\n        {\n            functionInfo *fi = (<recovery-expr>((entry)).val);\n            if (dictFetchValue(functions_lib_ctx_dst->functions, fi->name)) {\n                *err = sdscatfmt(sdsempty(), \"Function %s already exists\", fi->name);\n                goto done;\n            }\n        }\n    dictReleaseIterator(iter);\n    iter = dictGetIterator(functions_lib_ctx_src->libraries);\n    while ((entry = dictNext(iter)))\n        {\n            functionLibInfo *li = (<recovery-expr>((entry)).val);\n            libraryLink(functions_lib_ctx_dst, li);\n            do {\n            } while (0);\n        }\n    dictReleaseIterator(iter);\n    functionsLibCtxClear(functions_lib_ctx_src);\n    if (old_libraries_list) {\n        listRelease(old_libraries_list);\n    }\n    ret = 0;\n  done:\n    if (iter)\n        dictReleaseIterator(iter);\n    if (old_libraries_list) {\n        while (((old_libraries_list)->len) > 0)\n            {\n                listNode *head = ((old_libraries_list)->head);\n                functionLibInfo *li = ((head)->value);\n                libraryLink(functions_lib_ctx_dst, li);\n                listDelNode(old_libraries_list, head);\n            }\n        listRelease(old_libraries_list);\n    }\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/functions.c#957:1#functionsCreateWithLibraryCtx",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    dictIterator *iter;\n    dictEntry *entry;\n    functionLibInfo *new_li;\n    functionLibInfo *old_li;\n    functionsLibMataData md = {0};\n    if (functionExtractLibMetaData(code, &md, err) != 0) {\n    }\n    if (functionsVerifyName(md.name)) {\n        *err = sdsnew(\"Library names can only contain letters, numbers, or underscores(_) and must be at least one character long\");\n        goto error;\n    }\n    engineInfo *ei = dictFetchValue(engines, md.engine);\n    if (!ei) {\n        *err = sdscatfmt(sdsempty(), \"Engine '%S' not found\", md.engine);\n        goto error;\n    }\n    engine *engine = ei->engine;\n    old_li = dictFetchValue(lib_ctx->libraries, md.name);\n    if (old_li && !replace) {\n        *err = sdscatfmt(sdsempty(), \"Library '%S' already exists\", md.name);\n        goto error;\n    }\n    if (old_li) {\n        libraryUnlink(lib_ctx, old_li);\n    }\n    new_li = engineLibraryCreate(md.name, ei, code);\n    if (engine->create(engine->engine_ctx, new_li, md.code, err) != 0) {\n        goto error;\n    }\n    if (((new_li->functions)->ht_used[0] + (new_li->functions)->ht_used[1]) == 0) {\n        *err = sdsnew(\"No functions registered\");\n        goto error;\n    }\n    iter = dictGetIterator(new_li->functions);\n    while ((entry = dictNext(iter)))\n        {\n            functionInfo *fi = (<recovery-expr>((entry)).val);\n            if (dictFetchValue(lib_ctx->functions, fi->name)) {\n                *err = sdscatfmt(sdsempty(), \"Function %s already exists\", fi->name);\n                goto error;\n            }\n        }\n    dictReleaseIterator(iter);\n    libraryLink(lib_ctx, new_li);\n    if (old_li) {\n        engineLibraryFree(old_li);\n    }\n    sds loaded_lib_name = md.name;\n    functionFreeLibMetaData(&md);\n    return loaded_lib_name;\n  error:\n    if (iter)\n        dictReleaseIterator(iter);\n    if (new_li)\n        engineLibraryFree(new_li);\n    if (old_li)\n        libraryLink(lib_ctx, old_li);\n    functionFreeLibMetaData(&md);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/functions.c#886:1#functionExtractLibMetaData",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    sds name;\n    sds desc;\n    sds engine;\n    sds code;\n    if (strncmp(payload, \"#!\", 2) != 0) {\n        *err = sdsnew(\"Missing library metadata\");\n        return -1;\n    }\n    char *shebang_end = strchr(payload, '\\n');\n    if (<recovery-expr>()) {\n        *err = sdsnew(\"Invalid library metadata\");\n        return -1;\n    }\n    int shebang_len(int *);\n    sds shebang = <recovery-expr>()(payload, <recovery-expr>());\n    int numparts;\n    sds *parts = sdssplitargs(shebang, &numparts);\n    sdsfree(shebang);\n    if (!parts || numparts == 0) {\n        *err = sdsnew(\"Invalid library metadata\");\n        sdsfreesplitres(parts, numparts);\n        return -1;\n    }\n    engine = sdsdup(parts[0]);\n    <recovery-expr>()(engine, 2, -1);\n    for (int i = 1; i < numparts; ++i) {\n        sds part = parts[i];\n        if (strncasecmp(part, \"name=\", 5) == 0) {\n            if (name) {\n                *err = sdscatfmt(sdsempty(), \"Invalid metadata value, name argument was given multiple times\");\n                goto error;\n            }\n            name = sdsdup(part);\n            <recovery-expr>()(name, 5, -1);\n            continue;\n        }\n        *err = sdscatfmt(sdsempty(), \"Invalid metadata value given: %s\", part);\n        goto error;\n    }\n    if (!name) {\n        *err = sdsnew(\"Library name was not given\");\n        goto error;\n    }\n    sdsfreesplitres(parts, numparts);\n    md->name = name;\n    md->code = <recovery-expr>()(shebang_end, <recovery-expr>()(payload) - <recovery-expr>());\n    md->engine = engine;\n    return 0;\n  error:\n    if (name)\n        sdsfree(name);\n    if (desc)\n        sdsfree(desc);\n    if (engine)\n        sdsfree(engine);\n    if (code)\n        sdsfree(code);\n    sdsfreesplitres(parts, numparts);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/script_lua.c#840:1#luaRedisGenericCommand",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int j;\n    scriptRunCtx *rctx = <recovery-expr>()(<recovery-expr>(), \"__RUN_CTX__\");\n    ((rctx) ? (void)0 : (_serverAssert(\"rctx\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/script_lua.c\", 843) , __builtin_unreachable()));\n    sds err;\n    client *c = rctx->c;\n    sds reply;\n    int argc;\n    robj **argv = <recovery-expr>()(<recovery-expr>(), &argc);\n    if (<recovery-expr>()) {\n        return raise_error ? <recovery-expr>()(<recovery-expr>()) : 1;\n    }\n    static int inuse = 0;\n    if (inuse) {\n        char *recursion_warning = \"luaRedisGenericCommand() recursive call detected. Are you doing funny stuff with Lua debug hooks?\";\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"%s\", recursion_warning);\n        } while (0);\n        <recovery-expr>()(<recovery-expr>(), recursion_warning);\n        return 1;\n    }\n    inuse++;\n    if (ldbIsEnabled()) {\n        sds cmdlog = sdsnew(\"<redis>\");\n        for (j = 0; j < c->argc; j++) {\n            if (j == 10) {\n                cmdlog = sdscatprintf(cmdlog, \" ... (%d more)\", c->argc - j - 1);\n                break;\n            } else {\n                cmdlog = <recovery-expr>()(cmdlog, \" \", 1);\n                cmdlog = sdscatsds(cmdlog, c->argv[j]->ptr);\n            }\n        }\n        ldbLog(cmdlog);\n    }\n    scriptCall(rctx, argv, argc, &err);\n    if (err) {\n        <recovery-expr>()(<recovery-expr>(), err);\n        sdsfree(err);\n        lua_pushstring(<recovery-expr>(), \"ignore_error_stats_update\");\n        lua_pushboolean(<recovery-expr>(), 1);\n        lua_settable(<recovery-expr>(), -3);\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        c->buf[c->bufpos] = '\\x00';\n        reply = c->buf;\n        c->bufpos = 0;\n    } else {\n        reply = <recovery-expr>()(c->buf, c->bufpos);\n        c->bufpos = 0;\n        while (((c->reply)->len))\n            {\n                clientReplyBlock *o = ((((c->reply)->head))->value);\n                reply = <recovery-expr>()(reply, o->buf, <recovery-expr>(o));\n                listDelNode(c->reply, ((c->reply)->head));\n            }\n    }\n    if (raise_error && reply[0] != '-')\n        raise_error = 0;\n    <recovery-expr>()(<recovery-expr>(), reply);\n    if (ldbIsEnabled())\n        ldbLogRedisReply(reply);\n    if (reply != c->buf)\n        sdsfree(reply);\n    c->reply_bytes = 0;\n  cleanup:\n    freeClientArgv(c);\n    inuse--;\n    if (raise_error) {\n        return <recovery-expr>()(<recovery-expr>());\n    }\n    return 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/replication.c#723:1#masterTryPartialResynchronization",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    long long psync_len;\n    char *master_replid = c->argv[1]->ptr;\n    char buf[128];\n    int buflen;\n    if (strcasecmp(master_replid, server.replid) && (strcasecmp(master_replid, server.replid2) || psync_offset > server.second_replid_offset)) {\n        if (master_replid[0] != '?') {\n            if (strcasecmp(master_replid, server.replid) && strcasecmp(master_replid, server.replid2)) {\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"Partial resynchronization not accepted: Replication ID mismatch (Replica asked for '%s', my replication IDs are '%s' and '%s')\", master_replid, server.replid, server.replid2);\n                } while (0);\n            } else {\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"Partial resynchronization not accepted: Requested offset for second ID was %lld, but I can reply up to %lld\", psync_offset, server.second_replid_offset);\n                } while (0);\n            }\n        } else {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Full resync requested by replica %s\", replicationGetSlaveName(c));\n            } while (0);\n        }\n        goto need_full_resync;\n    }\n    if (!server.repl_backlog || psync_offset < server.repl_backlog->offset || psync_offset > (server.repl_backlog->offset + server.repl_backlog->histlen)) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Unable to partial resync with replica %s for lack of backlog (Replica request was: %lld).\", replicationGetSlaveName(c), psync_offset);\n        } while (0);\n        if (psync_offset > server.master_repl_offset) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Warning: replica %s tried to PSYNC with an offset that is greater than the master replication offset.\", replicationGetSlaveName(c));\n            } while (0);\n        }\n        goto need_full_resync;\n    }\n    <recovery-expr>(c) |= (1 << 0);\n    c->replstate = 9;\n    c->repl_ack_time = <recovery-expr>(server);\n    c->repl_start_cmd_stream_on_ack = 0;\n    listAddNodeTail(server.slaves, c);\n    if (c->slave_capa & (1 << 1)) {\n        buflen = snprintf(buf, sizeof (buf), \"+CONTINUE %s\\r\\n\", server.replid);\n    } else {\n        buflen = snprintf(buf, sizeof (buf), \"+CONTINUE\\r\\n\");\n    }\n    if (<recovery-expr>()(c->conn, buf, buflen) != buflen) {\n        freeClientAsync(c);\n        return 0;\n    }\n    psync_len = addReplyReplicationBacklog(c, psync_offset);\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.\", replicationGetSlaveName(c), psync_len, psync_offset);\n    } while (0);\n    refreshGoodSlavesCount();\n    return 0;\n  need_full_resync:\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/replication.c#2568:1#syncWithMaster",
    "gotos": 20,
    "labels": 3,
    "body": "{\n    char tmpfile[256], *err;\n    int dfd = -1, maxtries = 5;\n    int psync_result;\n    if (server.repl_state == REPL_STATE_NONE) {\n        connClose(conn);\n        return;\n    }\n    if (connGetState(conn) != CONN_STATE_CONNECTED) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Error condition on socket for SYNC: %s\", connGetLastError(conn));\n        } while (0);\n        goto error;\n    }\n    if (server.repl_state == REPL_STATE_CONNECTING) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Non blocking connect for SYNC fired the event.\");\n        } while (0);\n        connSetReadHandler(conn, syncWithMaster);\n        server.repl_state = REPL_STATE_RECEIVE_PING_REPLY;\n        if (err)\n            goto write_error;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_PING_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] != '+' && strncmp(err, \"-NOAUTH\", 7) != 0 && strncmp(err, \"-NOPERM\", 7) != 0 && strncmp(err, \"-ERR operation not permitted\", 28) != 0) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Error reply to PING from master: '%s'\", err);\n            } while (0);\n            sdsfree(err);\n            goto error;\n        } else {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Master replied to PING, replication can continue...\");\n            } while (0);\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_SEND_HANDSHAKE;\n    }\n    if (server.repl_state == REPL_STATE_SEND_HANDSHAKE) {\n        if (server.masterauth) {\n            char *args[3];\n            int lens;\n            int argc = 1;\n            if (server.masteruser) {\n                args[argc] = server.masteruser;\n                <recovery-expr>()[argc] = strlen(server.masteruser);\n                argc++;\n            }\n            args[argc] = server.masterauth;\n            <recovery-expr>()[argc] = <recovery-expr>()(server.masterauth);\n            argc++;\n            err = sendCommandArgv(conn, argc, args, <recovery-expr>());\n            if (err)\n                goto write_error;\n        }\n        {\n            int port;\n            if (server.slave_announce_port)\n                port = server.slave_announce_port;\n            else if (server.tls_replication && server.tls_port)\n                port = server.tls_port;\n            else\n                port = server.port;\n            sds portstr = sdsfromlonglong(port);\n            sdsfree(portstr);\n            if (err)\n                goto write_error;\n        }\n        if (server.slave_announce_ip) {\n            if (err)\n                goto write_error;\n        }\n        if (err)\n            goto write_error;\n        server.repl_state = REPL_STATE_RECEIVE_AUTH_REPLY;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_AUTH_REPLY && !server.masterauth)\n        server.repl_state = REPL_STATE_RECEIVE_PORT_REPLY;\n    if (server.repl_state == REPL_STATE_RECEIVE_AUTH_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] == '-') {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Unable to AUTH to MASTER: %s\", err);\n            } while (0);\n            sdsfree(err);\n            goto error;\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_RECEIVE_PORT_REPLY;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_PORT_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] == '-') {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"(Non critical) Master does not understand REPLCONF listening-port: %s\", err);\n            } while (0);\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_RECEIVE_IP_REPLY;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_IP_REPLY && !server.slave_announce_ip)\n        server.repl_state = REPL_STATE_RECEIVE_CAPA_REPLY;\n    if (server.repl_state == REPL_STATE_RECEIVE_IP_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] == '-') {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"(Non critical) Master does not understand REPLCONF ip-address: %s\", err);\n            } while (0);\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_RECEIVE_CAPA_REPLY;\n        return;\n    }\n    if (server.repl_state == REPL_STATE_RECEIVE_CAPA_REPLY) {\n        err = receiveSynchronousResponse(conn);\n        if (<recovery-expr>())\n            goto no_response_error;\n        if (err[0] == '-') {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"(Non critical) Master does not understand REPLCONF capa: %s\", err);\n            } while (0);\n        }\n        sdsfree(err);\n        server.repl_state = REPL_STATE_SEND_PSYNC;\n    }\n    if (server.repl_state == REPL_STATE_SEND_PSYNC) {\n        if (slaveTryPartialResynchronization(conn, 0) == 0) {\n            err = sdsnew(\"Write error sending the PSYNC command.\");\n            abortFailover(\"Write error to failover target\");\n            goto write_error;\n        }\n        server.repl_state = REPL_STATE_RECEIVE_PSYNC_REPLY;\n        return;\n    }\n    if (server.repl_state != REPL_STATE_RECEIVE_PSYNC_REPLY) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"syncWithMaster(): state machine error, state should be RECEIVE_PSYNC but is %d\", server.repl_state);\n        } while (0);\n        goto error;\n    }\n    psync_result = slaveTryPartialResynchronization(conn, 1);\n    if (psync_result == 1)\n        return;\n    if (server.failover_state == FAILOVER_IN_PROGRESS) {\n        if (psync_result == 2 || psync_result == 3) {\n            clearFailoverState();\n        } else {\n            abortFailover(\"Failover target rejected psync request\");\n            return;\n        }\n    }\n    if (psync_result == 5)\n        goto error;\n    if (psync_result == 2) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"MASTER <-> REPLICA sync: Master accepted a Partial Resynchronization.\");\n        } while (0);\n        if (server.supervised_mode == 2) {\n            redisCommunicateSystemd(\"STATUS=MASTER <-> REPLICA sync: Partial Resynchronization accepted. Ready to accept connections in read-write mode.\\n\");\n        }\n        return;\n    }\n    if (psync_result == 4) {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Retrying with SYNC...\");\n        } while (0);\n        if (<recovery-expr>()(conn, \"SYNC\\r\\n\", 6, server.repl_syncio_timeout * 1000) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto error;\n        }\n    }\n    if (!useDisklessLoad()) {\n        while (maxtries--)\n            {\n                snprintf(tmpfile, 256, \"temp-%d.%ld.rdb\", (int)<recovery-expr>(server), (long)getpid());\n                if (dfd != -1)\n                    break;\n                sleep(1);\n            }\n        if (dfd == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto error;\n        }\n        server.repl_transfer_tmpfile = zstrdup(tmpfile);\n        server.repl_transfer_fd = dfd;\n    }\n    if (connSetReadHandler(conn, readSyncBulkPayload) == -1) {\n        char conninfo[32];\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto error;\n    }\n    server.repl_state = REPL_STATE_TRANSFER;\n    <recovery-expr>(server) = -1;\n    <recovery-expr>(server) = 0;\n    <recovery-expr>(server) = 0;\n    <recovery-expr>(server) = <recovery-expr>(server);\n    return;\n  no_response_error:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Master did not respond to command during SYNC handshake\");\n    } while (0);\n  error:\n    if (dfd != -1)\n        close(dfd);\n    connClose(conn);\n    if (server.repl_transfer_fd != -1)\n        close(server.repl_transfer_fd);\n    if (server.repl_transfer_tmpfile)\n        zfree(server.repl_transfer_tmpfile);\n    server.repl_transfer_fd = -1;\n    server.repl_state = REPL_STATE_CONNECT;\n    return;\n  write_error:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Sending command to master in replication handshake: %s\", err);\n    } while (0);\n    sdsfree(err);\n    goto error;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/replication.c#1817:1#readSyncBulkPayload",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    char buf[16384];\n    int use_diskless_load = useDisklessLoad();\n    redisDb *diskless_load_tempDb;\n    functionsLibCtx *temp_functions_lib_ctx;\n    int empty_db_flags = server.repl_slave_lazy_flush ? (1 << 0) : 0;\n    static char eofmark[40];\n    static char lastbytes[40];\n    static int usemark = 0;\n    if (<recovery-expr>(server) == -1) {\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto error;\n        } else {\n        }\n        if (buf[0] == '-') {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"MASTER aborted replication with an error: %s\", buf + 1);\n            } while (0);\n            goto error;\n        } else if (buf[0] == '\\x00') {\n            <recovery-expr>(server) = <recovery-expr>(server);\n            return;\n        } else if (buf[0] != '$') {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?\", buf);\n            } while (0);\n            goto error;\n        }\n        if (strncmp(buf + 1, \"EOF:\", 4) == 0 && strlen(buf + 5) >= 40) {\n            usemark = 1;\n            memcpy(eofmark, buf + 5, 40);\n            memset(lastbytes, 0, 40);\n            <recovery-expr>(server) = 0;\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"MASTER <-> REPLICA sync: receiving streamed RDB from master with EOF %s\", use_diskless_load ? \"to parser\" : \"to disk\");\n            } while (0);\n        } else {\n            usemark = 0;\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"MASTER <-> REPLICA sync: receiving %lld bytes from master %s\", (long long)<recovery-expr>(server), use_diskless_load ? \"to parser\" : \"to disk\");\n            } while (0);\n        }\n        return;\n    }\n    if (!use_diskless_load) {\n        if (usemark) {\n        } else {\n        }\n        if (<recovery-expr>()) {\n            if (connGetState(conn) == CONN_STATE_CONNECTED) {\n                return;\n            }\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            cancelReplicationHandshake(1);\n            return;\n        }\n        int eof_reached = 0;\n        if (usemark) {\n            if (<recovery-expr>()) {\n            } else {\n                int rem;\n            }\n            if (memcmp(lastbytes, eofmark, 40) == 0)\n                eof_reached = 1;\n        }\n        <recovery-expr>(server) = <recovery-expr>(server);\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto error;\n        }\n        if (usemark && eof_reached) {\n            if (ftruncate(server.repl_transfer_fd, <recovery-expr>(server) - 40) == -1) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                goto error;\n            }\n        }\n        if (<recovery-expr>(server) >= <recovery-expr>(server) + (1024 * 1024 * 8)) {\n        }\n        if (!usemark) {\n            if (<recovery-expr>(server) == <recovery-expr>(server))\n                eof_reached = 1;\n        }\n        if (!eof_reached)\n            return;\n    }\n    if (server.aof_state != 0)\n        stopAppendOnly();\n    if (server.child_type == 1) {\n        if (!use_diskless_load) {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Replica is about to load the RDB file received from the master, but there is a pending RDB child running. Killing process %ld and removing its temp file to avoid any race\", (long)<recovery-expr>(server));\n            } while (0);\n        }\n        killRDBChild();\n    }\n    if (use_diskless_load && server.repl_diskless_load == 2) {\n        diskless_load_tempDb = disklessLoadInitTempDb();\n        temp_functions_lib_ctx = functionsLibCtxCreate();\n    } else {\n        replicationAttachToNewMaster();\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"MASTER <-> REPLICA sync: Flushing old data\");\n        } while (0);\n        emptyData(-1, empty_db_flags, replicationEmptyDbCallback);\n    }\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"MASTER <-> REPLICA sync: Loading DB in memory\");\n    } while (0);\n    rdbSaveInfo rsi = {-1, 0, \"0000000000000000000000000000000000000000\", -1};\n    if (use_diskless_load) {\n        rio rdb;\n        redisDb *dbarray;\n        functionsLibCtx *functions_lib_ctx;\n        int asyncLoading = 0;\n        if (server.repl_diskless_load == 2) {\n            if (memcmp(server.replid, server.master_replid, 40) == 0) {\n                asyncLoading = 1;\n            }\n            dbarray = diskless_load_tempDb;\n            functions_lib_ctx = temp_functions_lib_ctx;\n        } else {\n            dbarray = server.db;\n            functions_lib_ctx = functionsLibCtxGetCurrent();\n            functionsLibCtxClear(functions_lib_ctx);\n        }\n        <recovery-expr>()(&rdb, conn, <recovery-expr>(server));\n        connBlock(conn);\n        connRecvTimeout(conn, server.repl_timeout * 1000);\n        startLoading(<recovery-expr>(server), (1 << 1), asyncLoading);\n        int loadingFailed = 0;\n        rdbLoadingCtx loadingCtx = {.dbarray = dbarray, .functions_lib_ctx = functions_lib_ctx};\n        if (rdbLoadRioWithLoadingCtx(&rdb, (1 << 1), &rsi, &loadingCtx) != 0) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Failed trying to load the MASTER synchronization DB from socket, check server logs.\");\n            } while (0);\n            loadingFailed = 1;\n        } else if (usemark) {\n            if (!<recovery-expr>()(&rdb, buf, 40) || memcmp(buf, eofmark, 40) != 0) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Replication stream EOF marker is broken\");\n                } while (0);\n                loadingFailed = 1;\n            }\n        }\n        if (loadingFailed) {\n            stopLoading(0);\n            cancelReplicationHandshake(1);\n            if (server.repl_diskless_load == 2) {\n                disklessLoadDiscardTempDb(diskless_load_tempDb);\n                functionsLibCtxFree(temp_functions_lib_ctx);\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"MASTER <-> REPLICA sync: Discarding temporary DB in background\");\n                } while (0);\n            } else {\n                emptyData(-1, empty_db_flags, replicationEmptyDbCallback);\n            }\n            return;\n        }\n        if (server.repl_diskless_load == 2) {\n            replicationAttachToNewMaster();\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"MASTER <-> REPLICA sync: Swapping active DB with loaded DB\");\n            } while (0);\n            swapMainDbWithTempDb(diskless_load_tempDb);\n            functionsLibCtxSwapWithCurrent(temp_functions_lib_ctx);\n            disklessLoadDiscardTempDb(diskless_load_tempDb);\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"MASTER <-> REPLICA sync: Discarding old DB in background\");\n            } while (0);\n        }\n        server.dirty++;\n        stopLoading(1);\n        connNonBlock(conn);\n        connRecvTimeout(conn, 0);\n    } else {\n        if (fsync(server.repl_transfer_fd) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            cancelReplicationHandshake(1);\n            return;\n        }\n        int old_rdb_fd;\n        if (rename(server.repl_transfer_tmpfile, server.rdb_filename) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            cancelReplicationHandshake(1);\n            if (old_rdb_fd != -1)\n                close(old_rdb_fd);\n            return;\n        }\n        if (old_rdb_fd != -1)\n            bioCreateCloseJob(old_rdb_fd, 0);\n        if (fsyncFileDir(server.rdb_filename) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            cancelReplicationHandshake(1);\n            return;\n        }\n        if (rdbLoad(server.rdb_filename, &rsi, (1 << 1)) != 0) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Failed trying to load the MASTER synchronization DB from disk, check server logs.\");\n            } while (0);\n            cancelReplicationHandshake(1);\n            if (server.rdb_del_sync_files && allPersistenceDisabled()) {\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"Removing the RDB file obtained from the master. This replica has persistence disabled\");\n                } while (0);\n                bg_unlink(server.rdb_filename);\n            }\n            return;\n        }\n        if (server.rdb_del_sync_files && allPersistenceDisabled()) {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Removing the RDB file obtained from the master. This replica has persistence disabled\");\n            } while (0);\n            bg_unlink(server.rdb_filename);\n        }\n        zfree(server.repl_transfer_tmpfile);\n        close(server.repl_transfer_fd);\n        server.repl_transfer_fd = -1;\n    }\n    replicationCreateMasterClient(server.repl_transfer_s, rsi.repl_stream_db);\n    server.repl_state = REPL_STATE_CONNECTED;\n    <recovery-expr>(server) = 0;\n    memcpy(server.replid, server.master->replid, sizeof (server.replid));\n    server.master_repl_offset = server.master->reploff;\n    clearReplicationId2();\n    if (<recovery-expr>())\n        createReplicationBacklog();\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"MASTER <-> REPLICA sync: Finished with success\");\n    } while (0);\n    if (server.supervised_mode == 2) {\n        redisCommunicateSystemd(\"STATUS=MASTER <-> REPLICA sync: Finished with success. Ready to accept connections in read-write mode.\\n\");\n    }\n    if (usemark)\n        replicationSendAck();\n    if (server.aof_enabled)\n        restartAOFAfterSYNC();\n    return;\n  error:\n    cancelReplicationHandshake(1);\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/networking.c#2563:1#readQueryFromClient",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    client *c = connGetPrivateData(conn);\n    int nread, big_arg = 0;\n    int qblen(int *), readlen(int *);\n    if (postponeClientRead(c))\n        return;\n    <recovery-expr>(readlen, (1024 * 16));\n    if (c->reqtype == 2 && c->multibulklen && c->bulklen != -1 && c->bulklen >= (1024 * 32)) {\n        big_arg = 1;\n        if (<recovery-expr>(c) & (1 << 1) && readlen < (1024 * 16))\n            <recovery-expr>(readlen, (1024 * 16));\n    }\n    qblen = <recovery-expr>()(c->querybuf);\n    if (!(<recovery-expr>(c) & (1 << 1)) && (big_arg || <recovery-expr>()(c->querybuf) < (1024 * 16))) {\n        c->querybuf = <recovery-expr>()(c->querybuf, readlen);\n    } else {\n        c->querybuf = <recovery-expr>()(c->querybuf, readlen);\n        readlen = <recovery-expr>()(c->querybuf);\n    }\n    nread = <recovery-expr>()(c->conn, <recovery-expr>(c->querybuf, qblen), readlen);\n    if (nread == -1) {\n        if (connGetState(conn) == CONN_STATE_CONNECTED) {\n            return;\n        } else {\n            do {\n                if (((1) & 255) < server.verbosity)\n                    break;\n                _serverLog(1, \"Reading from client: %s\", connGetLastError(c->conn));\n            } while (0);\n            freeClientAsync(c);\n            goto done;\n        }\n    } else if (nread == 0) {\n        if (server.verbosity <= 1) {\n            sds info = catClientInfoString(sdsempty(), c);\n            do {\n                if (((1) & 255) < server.verbosity)\n                    break;\n                _serverLog(1, \"Client closed connection %s\", info);\n            } while (0);\n            sdsfree(info);\n        }\n        freeClientAsync(c);\n        goto done;\n    }\n    <recovery-expr>()(c->querybuf, nread);\n    qblen = <recovery-expr>()(c->querybuf);\n    if (<recovery-expr>(c) < qblen)\n        <recovery-expr>(c) = qblen;\n    <recovery-expr>(c) = <recovery-expr>(server);\n    if (<recovery-expr>(c) & (1 << 1)) {\n        c->read_reploff += nread;\n    } else {\n    }\n    if (!(<recovery-expr>(c) & (1 << 1)) && <recovery-expr>()(c->querybuf) > <recovery-expr>(server)) {\n        sds ci = catClientInfoString(sdsempty(), c), bytes = sdsempty();\n        bytes = <recovery-expr>()(bytes, c->querybuf, 64);\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)\", ci, bytes);\n        } while (0);\n        sdsfree(ci);\n        sdsfree(bytes);\n        freeClientAsync(c);\n        goto done;\n    }\n  done:\n    beforeNextClient(c);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/script.c#516:1#scriptCall",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    client *c = run_ctx->c;\n    c->argv = argv;\n    c->argc = argc;\n    c->user = run_ctx->original_client->user;\n    moduleCallCommandFilters(c);\n    argv = c->argv;\n    argc = c->argc;\n    struct redisCommand *cmd = lookupCommand(argv, argc);\n    c->cmd = c->lastcmd = c->realcmd = cmd;\n    if (scriptVerifyCommandArity(cmd, argc, err) != 0) {\n        goto error;\n    }\n    if (!server.script_disable_deny_script && (<recovery-expr>(cmd) & (1ULL << 6))) {\n        *err = sdsnew(\"This Redis command is not allowed from script\");\n        goto error;\n    }\n    if (scriptVerifyAllowStale(c, err) != 0) {\n        goto error;\n    }\n    if (scriptVerifyACL(c, err) != 0) {\n        goto error;\n    }\n    if (scriptVerifyWriteCommandAllow(run_ctx, err) != 0) {\n        goto error;\n    }\n    if (scriptVerifyOOM(run_ctx, err) != 0) {\n        goto error;\n    }\n    if (<recovery-expr>(cmd) & (1ULL << 0)) {\n        run_ctx->flags |= (1ULL << 0);\n    }\n    if (scriptVerifyClusterState(run_ctx, c, run_ctx->original_client, err) != 0) {\n        goto error;\n    }\n    int call_flags = (1 << 0) | (1 << 1);\n    if (run_ctx->repl_flags & 1) {\n        call_flags |= (1 << 2);\n    }\n    if (run_ctx->repl_flags & 2) {\n        call_flags |= (1 << 3);\n    }\n    call(c, call_flags);\n    (((<recovery-expr>(c) & (1 << 4)) == 0) ? (void)0 : (_serverAssert(\"(c->flags & CLIENT_BLOCKED) == 0\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/script.c\", 574) , __builtin_unreachable()));\n    return;\n  error:\n    afterErrorReply(c, *err, <recovery-expr>()(*err), 0);\n    incrCommandStatsOnError(cmd, (1 << 0));\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/db.c#1746:1#getKeysUsingKeySpecs",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    int j, i, k = 0, last, first, step;\n    keyReference *keys;\n    for (j = 0; j < cmd->key_specs_num; j++) {\n        keySpec *spec = cmd->key_specs + j;\n        ((spec->begin_search_type != KSPEC_BS_INVALID) ? (void)0 : (_serverAssert(\"spec->begin_search_type != KSPEC_BS_INVALID\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/db.c\", 1752) , __builtin_unreachable()));\n        if ((<recovery-expr>(spec) & (1ULL << 8)) && !(search_flags & (1 << 0))) {\n            continue;\n        }\n        first = 0;\n        if (spec->begin_search_type == KSPEC_BS_INDEX) {\n            first = spec->bs.index.pos;\n        } else if (spec->begin_search_type == KSPEC_BS_KEYWORD) {\n            int start_index = spec->bs.keyword.startfrom > 0 ? spec->bs.keyword.startfrom : argc + spec->bs.keyword.startfrom;\n            int end_index = spec->bs.keyword.startfrom > 0 ? argc - 1 : 1;\n            for (i = start_index; i != end_index; i = start_index <= end_index ? i + 1 : i - 1) {\n                if (i >= argc || i < 1)\n                    break;\n                if (!strcasecmp((char *)argv[i]->ptr, spec->bs.keyword.keyword)) {\n                    first = i + 1;\n                    break;\n                }\n            }\n            if (!first) {\n                continue;\n            }\n        } else {\n            goto invalid_spec;\n        }\n        if (spec->find_keys_type == KSPEC_FK_RANGE) {\n            step = spec->fk.range.keystep;\n            if (spec->fk.range.lastkey >= 0) {\n                last = first + spec->fk.range.lastkey;\n            } else {\n                if (!spec->fk.range.limit) {\n                    last = argc + spec->fk.range.lastkey;\n                } else {\n                    ((spec->fk.range.lastkey == -1) ? (void)0 : (_serverAssert(\"spec->fk.range.lastkey == -1\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/db.c\", 1789) , __builtin_unreachable()));\n                    last = first + ((argc - first) / spec->fk.range.limit + spec->fk.range.lastkey);\n                }\n            }\n        } else if (spec->find_keys_type == KSPEC_FK_KEYNUM) {\n            step = spec->fk.keynum.keystep;\n            long long numkeys;\n            if (spec->fk.keynum.keynumidx >= argc)\n                goto invalid_spec;\n            sds keynum_str = argv[first + spec->fk.keynum.keynumidx]->ptr;\n            if (!<recovery-expr>()(keynum_str, <recovery-expr>()(keynum_str), &numkeys) || numkeys < 0) {\n                goto invalid_spec;\n            }\n            first += spec->fk.keynum.firstkey;\n            last = first + (int)numkeys - 1;\n        } else {\n            goto invalid_spec;\n        }\n        int count = ((last - first) + 1);\n        keys = getKeysPrepareResult(result, count);\n        if (last >= argc || last < first || first >= argc) {\n            goto invalid_spec;\n        }\n        for (i = first; i <= last; i += step) {\n            if (i >= argc || i < first) {\n                if (<recovery-expr>(cmd) & (1ULL << 3) || cmd->arity < 0) {\n                    continue;\n                } else {\n                    _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/db.c\", 1831, \"Redis built-in command declared keys positions not matching the arity requirements.\") , __builtin_unreachable();\n                }\n            }\n            keys[k].pos = i;\n            keys[k++].flags = <recovery-expr>(spec);\n        }\n        if (<recovery-expr>(spec) & (1ULL << 9)) {\n            goto invalid_spec;\n        }\n        continue;\n      invalid_spec:\n        if (search_flags & (1 << 1)) {\n            continue;\n        } else {\n            result->numkeys = 0;\n            return -1;\n        }\n    }\n    result->numkeys = k;\n    return k;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/db.c#824:1#scanGenericCommand",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int i, j;\n    list *keys = listCreate();\n    listNode *node, *nextnode;\n    long count = 10;\n    sds pat;\n    sds typename;\n    int patlen = 0, use_pattern = 0;\n    dict *ht;\n    while (i < c->argc)\n        {\n            j = c->argc - i;\n            if (!strcasecmp(c->argv[i]->ptr, \"count\") && j >= 2) {\n                if (<recovery-expr>()) {\n                    goto cleanup;\n                }\n                if (count < 1) {\n                    addReplyErrorObject(c, shared.syntaxerr);\n                    goto cleanup;\n                }\n                i += 2;\n            } else if (!strcasecmp(c->argv[i]->ptr, \"match\") && j >= 2) {\n                pat = c->argv[i + 1]->ptr;\n                patlen = <recovery-expr>()(pat);\n                use_pattern = !(patlen == 1 && pat[0] == '*');\n                i += 2;\n            } else if (<recovery-expr>()) {\n                typename = c->argv[i + 1]->ptr;\n                i += 2;\n            } else {\n                addReplyErrorObject(c, shared.syntaxerr);\n                goto cleanup;\n            }\n        }\n    if (<recovery-expr>()) {\n        ht = c->db->dict;\n    } else if (o->type == 2 && o->encoding == 2) {\n        ht = o->ptr;\n    } else if (o->type == 4 && o->encoding == 2) {\n        ht = o->ptr;\n        count *= 2;\n    } else if (o->type == 3 && o->encoding == 7) {\n        zset *zs = o->ptr;\n        ht = zs->dict;\n        count *= 2;\n    }\n    if (ht) {\n        void *privdata[2];\n        long maxiterations = count * 10;\n        privdata[0] = keys;\n        privdata[1] = o;\n        do {\n        } while (cursor && maxiterations-- && ((keys)->len) < (unsigned long)count);\n    } else if (o->type == 2) {\n        int pos = 0;\n        cursor = 0;\n    } else if (o->type == 4 || o->type == 3) {\n        unsigned char *p = lpFirst(o->ptr);\n        unsigned char *vstr;\n        unsigned char intbuf[21];\n        while (p)\n            {\n                p = lpNext(o->ptr, p);\n            }\n        cursor = 0;\n    } else {\n        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/db.c\", 938, \"Not handled encoding in SCAN.\") , __builtin_unreachable();\n    }\n    node = ((keys)->head);\n    while (node)\n        {\n            robj *kobj = ((node)->value);\n            nextnode = ((node)->next);\n            int filter = 0;\n            if (use_pattern) {\n                if ((kobj->encoding == 0 || kobj->encoding == 8)) {\n                    if (!stringmatchlen(pat, patlen, kobj->ptr, <recovery-expr>()(kobj->ptr), 0))\n                        filter = 1;\n                } else {\n                    char buf[21];\n                    int len;\n                    ((kobj->encoding == 1) ? (void)0 : (_serverAssert(\"kobj->encoding == OBJ_ENCODING_INT\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/db.c\", 957) , __builtin_unreachable()));\n                    len = <recovery-expr>()(buf, sizeof (buf), (long)kobj->ptr);\n                    if (!stringmatchlen(pat, patlen, buf, len, 0))\n                        filter = 1;\n                }\n            }\n            if (<recovery-expr>()) {\n                robj *typecheck = lookupKeyReadWithFlags(c->db, kobj, (1 << 0));\n                char *type = getObjectTypeName(typecheck);\n                if (strcasecmp((char *)typename, type))\n                    filter = 1;\n            }\n            if (<recovery-expr>())\n                filter = 1;\n            if (filter) {\n                decrRefCount(kobj);\n                listDelNode(keys, node);\n            }\n            if (o && (o->type == 3 || o->type == 4)) {\n                node = nextnode;\n                ((node) ? (void)0 : (_serverAssert(\"node\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/db.c\", 984) , __builtin_unreachable()));\n                nextnode = ((node)->next);\n                if (filter) {\n                    kobj = ((node)->value);\n                    decrRefCount(kobj);\n                    listDelNode(keys, node);\n                }\n            }\n            node = nextnode;\n        }\n    addReplyArrayLen(c, 2);\n    addReplyBulkLongLong(c, cursor);\n    addReplyArrayLen(c, ((keys)->len));\n    while (<recovery-expr>())\n        {\n            robj *kobj = ((node)->value);\n            addReplyBulk(c, kobj);\n            decrRefCount(kobj);\n            listDelNode(keys, node);\n        }\n  cleanup:\n    ((keys)->free = (decrRefCountVoid));\n    listRelease(keys);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/async.c#756:1#__redisAsyncCommand",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    redisContext *c = &(<recovery-expr>(ac));\n    redisCallback cb;\n    struct dict *cbdict;\n    dictEntry *de;\n    redisCallback *existcb;\n    int pvariant, hasnext;\n    const char *cstr, *astr;\n    const char *p;\n    hisds sname;\n    int ret;\n    if (c->flags & (4 | 8))\n        return -1;\n    cb.fn = fn;\n    cb.privdata = privdata;\n    cb.pending_subs = 1;\n    hasnext = (p[0] == '$');\n    pvariant = (tolower(cstr[0]) == 'p') ? 1 : 0;\n    cstr += pvariant;\n    if (hasnext && strncasecmp(cstr, \"subscribe\\r\\n\", 11) == 0) {\n        c->flags |= 32;\n        while (<recovery-expr>())\n            {\n                if (<recovery-expr>())\n                    goto oom;\n                if (pvariant)\n                    cbdict = ac->sub.patterns;\n                else\n                    cbdict = ac->sub.channels;\n                de = dictFind(cbdict, sname);\n                if (<recovery-expr>()) {\n                    existcb = ((de)->val);\n                    cb.pending_subs = existcb->pending_subs + 1;\n                }\n                ret = dictReplace(cbdict, sname, &cb);\n                if (ret == 0)\n                    hi_sdsfree(sname);\n            }\n    } else if (strncasecmp(cstr, \"unsubscribe\\r\\n\", 13) == 0) {\n        if (!(c->flags & 32))\n            return -1;\n    } else if (strncasecmp(cstr, \"monitor\\r\\n\", 9) == 0) {\n        c->flags |= 64;\n        if (__redisPushCallback(&ac->replies, &cb) != 0)\n            goto oom;\n    } else {\n        if (c->flags & 32) {\n            if (__redisPushCallback(&ac->sub.replies, &cb) != 0)\n                goto oom;\n        } else {\n            if (__redisPushCallback(&ac->replies, &cb) != 0)\n                goto oom;\n        }\n    }\n    <recovery-expr>()(c, cmd, <recovery-expr>());\n    do {\n        refreshTimeout(ac);\n        if ((ac)->ev.addWrite)\n            (ac)->ev.addWrite((ac)->ev.data);\n    } while (0);\n    return 0;\n  oom:\n    __redisSetError(&(<recovery-expr>(ac)), 5, \"Out of memory\");\n    __redisAsyncCopyError(ac);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/async.c#106:1#redisAsyncInitialize",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    redisAsyncContext *ac;\n    dict *channels, *patterns;\n    if (<recovery-expr>())\n        goto oom;\n    if (<recovery-expr>())\n        goto oom;\n    ac = <recovery-expr>()(c, sizeof(redisAsyncContext));\n    if (<recovery-expr>())\n        goto oom;\n    c = &(<recovery-expr>(ac));\n    c->flags &= ~2;\n    ac->err = 0;\n    ac->sub.channels = channels;\n    ac->sub.patterns = patterns;\n    return ac;\n  oom:\n    if (channels)\n        dictRelease(channels);\n    if (patterns)\n        dictRelease(patterns);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/async.c#411:1#__redisGetSubscribeCallback",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    redisContext *c = &(<recovery-expr>(ac));\n    dict *callbacks;\n    redisCallback *cb;\n    dictEntry *de;\n    int pvariant;\n    char *stype;\n    hisds sname;\n    if ((reply->type == 2 && !(c->flags & 256) && <recovery-expr>(reply) >= 3) || reply->type == 12) {\n        assert(reply->element[0]->type == 1);\n        stype = reply->element[0]->str;\n        pvariant = (tolower(stype[0]) == 'p') ? 1 : 0;\n        if (pvariant)\n            callbacks = ac->sub.patterns;\n        else\n            callbacks = ac->sub.channels;\n        assert(reply->element[1]->type == 1);\n        sname = <recovery-expr>()(reply->element[1]->str, <recovery-expr>(reply->element[1]));\n        if (<recovery-expr>())\n            goto oom;\n        de = dictFind(callbacks, sname);\n        if (<recovery-expr>()) {\n            cb = ((de)->val);\n            if (strcasecmp(stype + pvariant, \"subscribe\") == 0) {\n                cb->pending_subs -= 1;\n            }\n            memcpy(dstcb, cb, sizeof (*dstcb));\n            if (strcasecmp(stype + pvariant, \"unsubscribe\") == 0) {\n                if (cb->pending_subs == 0)\n                    dictDelete(callbacks, sname);\n                assert(reply->element[2]->type == 3);\n                if (reply->element[2]->integer == 0 && ((ac->sub.channels)->used) == 0 && ((ac->sub.patterns)->used) == 0) {\n                    c->flags &= ~32;\n                    redisCallback cb;\n                    while (__redisShiftCallback(&ac->sub.replies, &cb) == 0)\n                        {\n                            __redisPushCallback(&ac->replies, &cb);\n                        }\n                }\n            }\n        }\n        hi_sdsfree(sname);\n    } else {\n        __redisShiftCallback(&ac->sub.replies, dstcb);\n    }\n    return 0;\n  oom:\n    __redisSetError(&(<recovery-expr>(ac)), 5, \"Out of memory\");\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/lua/src/llex.c#223:1#read_long_string",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int cont = 0;\n    (void)(cont);\n    (save(ls, ls->current) , (ls->current = ((<recovery-expr>((ls->z))--) > 0 ? ((int)(((unsigned char)((*(ls->z)->p++))))) : luaZ_fill(ls->z))));\n    if ((ls->current == '\\n' || ls->current == '\\r'))\n        inclinenumber(ls);\n    for (;;) {\n        switch (ls->current) {\n          case (-1):\n            luaX_lexerror(ls, (seminfo) ? \"unfinished long string\" : \"unfinished long comment\", TK_EOS);\n            break;\n          case '[':\n            {\n                if (skip_sep(ls) == sep) {\n                    (save(ls, ls->current) , (ls->current = ((<recovery-expr>((ls->z))--) > 0 ? ((int)(((unsigned char)((*(ls->z)->p++))))) : luaZ_fill(ls->z))));\n                    cont++;\n                    if (sep == 0)\n                        luaX_lexerror(ls, \"nesting of [[...]] is deprecated\", '[');\n                }\n                break;\n            }\n          case ']':\n            {\n                if (skip_sep(ls) == sep) {\n                    (save(ls, ls->current) , (ls->current = ((<recovery-expr>((ls->z))--) > 0 ? ((int)(((unsigned char)((*(ls->z)->p++))))) : luaZ_fill(ls->z))));\n                    goto endloop;\n                }\n                break;\n            }\n          case '\\n':\n          case '\\r':\n            {\n                save(ls, '\\n');\n                inclinenumber(ls);\n                if (!seminfo)\n                    (<recovery-expr>((ls->buff)) = 0);\n                break;\n            }\n          default:\n            {\n                if (seminfo)\n                    (save(ls, ls->current) , (ls->current = ((<recovery-expr>((ls->z))--) > 0 ? ((int)(((unsigned char)((*(ls->z)->p++))))) : luaZ_fill(ls->z))));\n                else\n                    (ls->current = ((<recovery-expr>((ls->z))--) > 0 ? ((int)(((unsigned char)((*(ls->z)->p++))))) : luaZ_fill(ls->z)));\n            }\n        }\n    }\n  endloop:\n    if (seminfo)\n        seminfo->ts = <recovery-expr>()(ls, ((ls->buff)->buffer) + (2 + sep), (<recovery-expr>((ls->buff))) - 2 * (2 + sep));\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-benchmark.c#1414:1#parseOptions",
    "gotos": 18,
    "labels": 2,
    "body": "{\n    int i;\n    int lastarg;\n    int exit_status = 1;\n    for (i = 1; i < argc; i++) {\n        lastarg = (i == (argc - 1));\n        if (!strcmp(argv[i], \"-c\")) {\n            if (lastarg)\n                goto invalid;\n            config.numclients = atoi(argv[++i]);\n        } else if (!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--version\")) {\n            sds version = benchmarkVersion();\n            printf(\"redis-benchmark %s\\n\", version);\n            sdsfree(version);\n            exit(0);\n        } else if (!strcmp(argv[i], \"-n\")) {\n            if (lastarg)\n                goto invalid;\n            config.requests = atoi(argv[++i]);\n        } else if (!strcmp(argv[i], \"-k\")) {\n            if (lastarg)\n                goto invalid;\n            config.keepalive = atoi(argv[++i]);\n        } else if (!strcmp(argv[i], \"-h\")) {\n            if (lastarg)\n                goto invalid;\n            sdsfree(config.conn_info.hostip);\n            config.conn_info.hostip = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i], \"-p\")) {\n            if (lastarg)\n                goto invalid;\n            config.conn_info.hostport = atoi(argv[++i]);\n            if (config.conn_info.hostport < 0 || config.conn_info.hostport > 65535) {\n                exit(1);\n            }\n        } else if (!strcmp(argv[i], \"-s\")) {\n            if (lastarg)\n                goto invalid;\n            config.hostsocket = strdup(argv[++i]);\n        } else if (!strcmp(argv[i], \"-x\")) {\n            config.stdinarg = 1;\n        } else if (!strcmp(argv[i], \"-a\")) {\n            if (lastarg)\n                goto invalid;\n            config.conn_info.auth = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i], \"--user\")) {\n            if (lastarg)\n                goto invalid;\n            config.conn_info.user = sdsnew(argv[++i]);\n        } else if (!strcmp(argv[i], \"-u\") && !lastarg) {\n            parseRedisUri(argv[++i], \"redis-benchmark\", &config.conn_info, &config.tls);\n            if (config.conn_info.hostport < 0 || config.conn_info.hostport > 65535) {\n                exit(1);\n            }\n            config.input_dbnumstr = sdsfromlonglong(config.conn_info.input_dbnum);\n        } else if (!strcmp(argv[i], \"-3\")) {\n            config.resp3 = 1;\n        } else if (!strcmp(argv[i], \"-d\")) {\n            if (lastarg)\n                goto invalid;\n            config.datasize = atoi(argv[++i]);\n            if (config.datasize < 1)\n                config.datasize = 1;\n            if (config.datasize > 1024 * 1024 * 1024)\n                config.datasize = 1024 * 1024 * 1024;\n        } else if (!strcmp(argv[i], \"-P\")) {\n            if (lastarg)\n                goto invalid;\n            config.pipeline = atoi(argv[++i]);\n            if (config.pipeline <= 0)\n                config.pipeline = 1;\n        } else if (!strcmp(argv[i], \"-r\")) {\n            if (lastarg)\n                goto invalid;\n            const char *next = argv[++i], *p = next;\n            if (*p == '-') {\n                p++;\n                if (*p < '0' || *p > '9')\n                    goto invalid;\n            }\n            config.randomkeys = 1;\n            config.randomkeys_keyspacelen = atoi(next);\n            if (config.randomkeys_keyspacelen < 0)\n                config.randomkeys_keyspacelen = 0;\n        } else if (!strcmp(argv[i], \"-q\")) {\n            config.quiet = 1;\n        } else if (!strcmp(argv[i], \"--csv\")) {\n            config.csv = 1;\n        } else if (!strcmp(argv[i], \"-l\")) {\n            config.loop = 1;\n        } else if (!strcmp(argv[i], \"-I\")) {\n            config.idlemode = 1;\n        } else if (!strcmp(argv[i], \"-e\")) {\n        } else if (!strcmp(argv[i], \"-t\")) {\n            if (lastarg)\n                goto invalid;\n            config.tests = sdsnew(\",\");\n            config.tests = sdscat(config.tests, (char *)argv[++i]);\n            config.tests = sdscat(config.tests, \",\");\n            sdstolower(config.tests);\n        } else if (!strcmp(argv[i], \"--dbnum\")) {\n            if (lastarg)\n                goto invalid;\n            config.conn_info.input_dbnum = atoi(argv[++i]);\n            config.input_dbnumstr = sdsfromlonglong(config.conn_info.input_dbnum);\n        } else if (!strcmp(argv[i], \"--precision\")) {\n            if (lastarg)\n                goto invalid;\n            config.precision = atoi(argv[++i]);\n            if (config.precision < 0)\n                config.precision = 3;\n            if (config.precision > 4)\n                config.precision = 4;\n        } else if (!strcmp(argv[i], \"--threads\")) {\n            if (lastarg)\n                goto invalid;\n            config.num_threads = atoi(argv[++i]);\n            if (config.num_threads > 500) {\n                config.num_threads = 500;\n            } else if (config.num_threads < 0)\n                config.num_threads = 0;\n        } else if (!strcmp(argv[i], \"--cluster\")) {\n            config.cluster_mode = 1;\n        } else if (!strcmp(argv[i], \"--enable-tracking\")) {\n            config.enable_tracking = 1;\n        } else if (!strcmp(argv[i], \"--help\")) {\n            exit_status = 0;\n            goto usage;\n        } else {\n            if (argv[i][0] == '-')\n                goto invalid;\n            return i;\n        }\n    }\n    return i;\n  invalid:\n    printf(\"Invalid option \\\"%s\\\" or option argument missing\\n\\n\", argv[i]);\n  usage:\n    printf(\"%s%s\", \"Usage: redis-benchmark [OPTIONS] [COMMAND ARGS...]\\n\\nOptions:\\n -h <hostname>      Server hostname (default 127.0.0.1)\\n -p <port>          Server port (default 6379)\\n -s <socket>        Server socket (overrides host and port)\\n -a <password>      Password for Redis Auth\\n --user <username>  Used to send ACL style 'AUTH username pass'. Needs -a.\\n -u <uri>           Server URI.\\n -c <clients>       Number of parallel connections (default 50)\\n -n <requests>      Total number of requests (default 100000)\\n -d <size>          Data size of SET/GET value in bytes (default 3)\\n --dbnum <db>       SELECT the specified db number (default 0)\\n -3                 Start session in RESP3 protocol mode.\\n --threads <num>    Enable multi-thread mode.\\n --cluster          Enable cluster mode.\\n                    If the command is supplied on the command line in cluster\\n                    mode, the key must contain \\\"{tag}\\\". Otherwise, the\\n                    command will not be sent to the right cluster node.\\n --enable-tracking  Send CLIENT TRACKING on before starting benchmark.\\n -k <boolean>       1=keep alive 0=reconnect (default 1)\\n -r <keyspacelen>   Use random keys for SET/GET/INCR, random values for SADD,\\n                    random members and scores for ZADD.\\n                    Using this option the benchmark will expand the string\\n                    __rand_int__ inside an argument with a 12 digits number in\\n                    the specified range from 0 to keyspacelen-1. The\\n                    substitution changes every time a command is executed.\\n                    Default tests use this to hit random keys in the specified\\n                    range.\\n                    Note: If -r is omitted, all commands in a benchmark will\\n                    use the same key.\\n -P <numreq>        Pipeline <numreq> requests. Default 1 (no pipeline).\\n -q                 Quiet. Just show query/sec values\\n --precision        Number of decimal places to display in latency output (default 0)\\n --csv              Output in CSV format\\n -l                 Loop. Run the tests forever\\n -t <tests>         Only run the comma separated list of tests. The test\\n                    names are the same as the ones produced as output.\\n                    The -t option is ignored if a specific command is supplied\\n                    on the command line.\\n -I                 Idle mode. Just open N idle connections and wait.\\n -x                 Read last argument from STDIN.\\n --help             Output this help and exit.\\n --version          Output version and exit.\\n\\n\", \"Examples:\\n\\n Run the benchmark with the default configuration against 127.0.0.1:6379:\\n   $ redis-benchmark\\n\\n Use 20 parallel clients, for a total of 100k requests, against 192.168.1.1:\\n   $ redis-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20\\n\\n Fill 127.0.0.1:6379 with about 1 million keys only using the SET test:\\n   $ redis-benchmark -t set -n 1000000 -r 100000000\\n\\n Benchmark 127.0.0.1:6379 for a few commands producing CSV output:\\n   $ redis-benchmark -t ping,set,get -n 100000 --csv\\n\\n Benchmark a specific command line:\\n   $ redis-benchmark -r 10000 -n 10000 eval 'return redis.call(\\\"ping\\\")' 0\\n\\n Fill a list with 10000 random elements:\\n   $ redis-benchmark -r 10000 -n 10000 lpush mylist __rand_int__\\n\\n On user specified command lines __rand_int__ is replaced with a random integer\\n with a range of values selected by the -r option.\\n\");\n    exit(exit_status);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-benchmark.c#1290:1#fetchClusterSlotsConfiguration",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    ((void)c);\n    int success = 1, is_fetching_slots = 0, last_update = 0;\n    do {\n    } while (0);\n    if (c->slots_last_update < last_update) {\n        c->slots_last_update = last_update;\n        return -1;\n    }\n    do {\n    } while (0);\n    if (is_fetching_slots)\n        return -1;\n    const char *errmsg = \"Failed to update cluster slots configuration\";\n    static dictType dtype;\n    dict *masters = dictCreate(&dtype);\n    if (<recovery-expr>()) {\n        success = 0;\n        goto cleanup;\n    }\n    updateClusterSlotsConfiguration();\n  cleanup:\n    ;\n    dictRelease(masters);\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-benchmark.c#1122:1#fetchClusterConfiguration",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    int success = 1;\n    if (<recovery-expr>()) {\n        exit(1);\n    }\n    clusterNode *firstNode = createClusterNode((char *)config.conn_info.hostip, config.conn_info.hostport);\n    if (!firstNode) {\n        success = 0;\n        goto cleanup;\n    }\n    if (!success)\n        goto cleanup;\n    if (!success) {\n        if (<recovery-expr>()) {\n        } else {\n        }\n        goto cleanup;\n    }\n    char *lines, *p, *line;\n    while (<recovery-expr>())\n        {\n            *p = '\\x00';\n            line = lines;\n            lines = p + 1;\n            char *name, *addr, *flags, *master_id;\n            int i = 0;\n            while (<recovery-expr>())\n                {\n                    *p = '\\x00';\n                    char *token = line;\n                    line = p + 1;\n                    switch (i++) {\n                      case 0:\n                        name = token;\n                        break;\n                      case 1:\n                        addr = token;\n                        break;\n                      case 2:\n                        flags = token;\n                        break;\n                      case 3:\n                        master_id = token;\n                        break;\n                    }\n                    if (i == 8)\n                        break;\n                }\n            if (!flags) {\n                success = 0;\n                goto cleanup;\n            }\n            int myself;\n            int is_replica;\n            if (is_replica)\n                continue;\n            if (<recovery-expr>()) {\n                success = 0;\n                goto cleanup;\n            }\n            clusterNode *node;\n            char *ip;\n            int port = 0;\n            char *paddr = strrchr(addr, ':');\n            if (<recovery-expr>()) {\n                *paddr = '\\x00';\n                ip = addr;\n                addr = paddr + 1;\n                if (<recovery-expr>())\n                    *paddr = '\\x00';\n                port = atoi(addr);\n            }\n            if (myself) {\n                node = firstNode;\n                if (<recovery-expr>()) {\n                    node->ip = sdsnew(ip);\n                    node->port = port;\n                }\n            } else {\n                node = createClusterNode(sdsnew(ip), port);\n            }\n            if (<recovery-expr>()) {\n                success = 0;\n                goto cleanup;\n            }\n            if (<recovery-expr>())\n                node->name = sdsnew(name);\n            if (i == 8) {\n                int remaining = strlen(line);\n                while (remaining > 0)\n                    {\n                        p = strchr(line, ' ');\n                        if (<recovery-expr>())\n                            p = line + remaining;\n                        remaining -= (p - line);\n                        char *slotsdef = line;\n                        *p = '\\x00';\n                        if (remaining) {\n                            line = p + 1;\n                            remaining--;\n                        } else\n                            line = p;\n                        char *dash;\n                        if (slotsdef[0] == '[') {\n                            slotsdef++;\n                            if ((p = strstr(slotsdef, \"->-\"))) {\n                                *p = '\\x00';\n                                p += 3;\n                                char *closing_bracket = strchr(p, ']');\n                                if (closing_bracket)\n                                    *closing_bracket = '\\x00';\n                                sds slot = sdsnew(slotsdef);\n                                sds dst = sdsnew(p);\n                                node->migrating_count += 2;\n                                node->migrating = <recovery-expr>()(node->migrating, (node->migrating_count * sizeof(sds)));\n                                node->migrating[node->migrating_count - 2] = slot;\n                                node->migrating[node->migrating_count - 1] = dst;\n                            } else if ((p = strstr(slotsdef, \"-<-\"))) {\n                                *p = '\\x00';\n                                p += 3;\n                                char *closing_bracket = strchr(p, ']');\n                                if (closing_bracket)\n                                    *closing_bracket = '\\x00';\n                                sds slot = sdsnew(slotsdef);\n                                sds src = sdsnew(p);\n                                node->importing_count += 2;\n                                node->importing = <recovery-expr>()(node->importing, (node->importing_count * sizeof(sds)));\n                                node->importing[node->importing_count - 2] = slot;\n                                node->importing[node->importing_count - 1] = src;\n                            }\n                        } else if (<recovery-expr>()) {\n                            p = dash;\n                            int start, stop;\n                            *p = '\\x00';\n                            start = atoi(slotsdef);\n                            stop = atoi(p + 1);\n                            while (start <= stop)\n                                {\n                                    int slot = start++;\n                                    node->slots[node->slots_count++] = slot;\n                                }\n                        } else if (p > slotsdef) {\n                            int slot = atoi(slotsdef);\n                            node->slots[node->slots_count++] = slot;\n                        }\n                    }\n            }\n            if (node->slots_count == 0) {\n                continue;\n            }\n            if (!addClusterNode(node)) {\n                success = 0;\n                goto cleanup;\n            }\n        }\n  cleanup:\n    ;\n    if (!success) {\n        if (config.cluster_nodes)\n            freeClusterNodes();\n    }\n    return success;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-benchmark.c#313:1#getRedisConfig",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    redisConfig *cfg = <recovery-expr>()(sizeof (*cfg));\n    if (<recovery-expr>()) {\n        freeRedisConfig(cfg);\n        exit(1);\n    }\n    int i = 0;\n    void *r;\n    for (; i < 2; i++) {\n        int res;\n        if (<recovery-expr>())\n            goto fail;\n        if (<recovery-expr>()) {\n            goto fail;\n        }\n        if (<recovery-expr>())\n            goto fail;\n        char *value;\n        if (!value)\n            value = \"\";\n        switch (i) {\n          case 0:\n            cfg->save = sdsnew(value);\n            break;\n          case 1:\n            cfg->appendonly = sdsnew(value);\n            break;\n        }\n    }\n    return cfg;\n  fail:\n    ;\n    int abort_test = 0;\n    if (<recovery-expr>())\n        abort_test = 1;\n    freeRedisConfig(cfg);\n    if (abort_test)\n        exit(1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/redis-benchmark.c#256:1#getRedisContext",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>()) {\n        char *err;\n        goto cleanup;\n    }\n    if (config.tls == 1) {\n        const char *err;\n        if (<recovery-expr>()) {\n            goto cleanup;\n        }\n    }\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            exit(1);\n        }\n    }\n  cleanup:\n    ;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/pqsort.c#98:1#_pqsort",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    char *pa, *pb, *pc, *pd, *pl, *pm, *pn;\n    int swaptype, cmp_result;\n  loop:\n    ;\n    ;\n    if (<recovery-expr>() < 7) {\n        for (pm = (char *)a + <recovery-expr>(); pm < (char *)a + <recovery-expr>() * <recovery-expr>(); pm += <recovery-expr>())\n            for (pl = pm; pl > (char *)a && cmp(pl - <recovery-expr>(), pl) > 0; pl -= <recovery-expr>())\n                if (swaptype == 0) {\n                    long t = *(long *)(void *)(pl);\n                    *(long *)(void *)(pl) = *(long *)(void *)(pl - <recovery-expr>());\n                    *(long *)(void *)(pl - <recovery-expr>()) = t;\n                } else\n                    swapfunc(pl, pl - <recovery-expr>(), <recovery-expr>(), swaptype);\n        return;\n    }\n    pm = (char *)a + (<recovery-expr>() / 2) * <recovery-expr>();\n    if (<recovery-expr>() > 7) {\n        pl = (char *)a;\n        pn = (char *)a + (<recovery-expr>() - 1) * <recovery-expr>();\n        if (<recovery-expr>() > 40) {\n        }\n        pm = med3(pl, pm, pn, cmp);\n    }\n    if (swaptype == 0) {\n        long t = *(long *)(void *)(a);\n        *(long *)(void *)(a) = *(long *)(void *)(pm);\n        *(long *)(void *)(pm) = t;\n    } else\n        swapfunc(a, pm, <recovery-expr>(), swaptype);\n    pa = pb = (char *)a + <recovery-expr>();\n    pc = pd = (char *)a + (<recovery-expr>() - 1) * <recovery-expr>();\n    for (;;) {\n        while (pb <= pc && (cmp_result = cmp(pb, a)) <= 0)\n            {\n                if (cmp_result == 0) {\n                    if (swaptype == 0) {\n                        long t = *(long *)(void *)(pa);\n                        *(long *)(void *)(pa) = *(long *)(void *)(pb);\n                        *(long *)(void *)(pb) = t;\n                    } else\n                        swapfunc(pa, pb, <recovery-expr>(), swaptype);\n                    pa += <recovery-expr>();\n                }\n                pb += <recovery-expr>();\n            }\n        while (pb <= pc && (cmp_result = cmp(pc, a)) >= 0)\n            {\n                if (cmp_result == 0) {\n                    if (swaptype == 0) {\n                        long t = *(long *)(void *)(pc);\n                        *(long *)(void *)(pc) = *(long *)(void *)(pd);\n                        *(long *)(void *)(pd) = t;\n                    } else\n                        swapfunc(pc, pd, <recovery-expr>(), swaptype);\n                    pd -= <recovery-expr>();\n                }\n                pc -= <recovery-expr>();\n            }\n        if (pb > pc)\n            break;\n        if (swaptype == 0) {\n            long t = *(long *)(void *)(pb);\n            *(long *)(void *)(pb) = *(long *)(void *)(pc);\n            *(long *)(void *)(pc) = t;\n        } else\n            swapfunc(pb, pc, <recovery-expr>(), swaptype);\n        pb += <recovery-expr>();\n        pc -= <recovery-expr>();\n    }\n    pn = (char *)a + <recovery-expr>() * <recovery-expr>();\n    if (<recovery-expr>()) {\n        void *_l = a, *_r;\n    }\n    if (<recovery-expr>()) {\n        void *_l, *_r;\n        _l = a;\n        if (!((lrange < _l && rrange < _l) || (lrange > _r && rrange > _r)))\n            goto loop;\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#2353:1#rewriteAppendOnlyFile",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    rio aof;\n    char tmpfile[256];\n    snprintf(tmpfile, 256, \"temp-rewriteaof-%d.aof\", (int)getpid());\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        return -1;\n    }\n    if (server.aof_rewrite_incremental_fsync)\n        <recovery-expr>()(&aof, (1024 * 1024 * 4));\n    startSaving((1 << 0));\n    if (server.aof_use_rdb_preamble) {\n        int error;\n        if (<recovery-expr>()) {\n            goto werr;\n        }\n    } else {\n        if (rewriteAppendOnlyFileRio(&aof) == -1)\n            goto werr;\n    }\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>()) {\n        goto werr;\n    }\n    if (rename(tmpfile, filename) == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        unlink(tmpfile);\n        stopSaving(0);\n        return -1;\n    }\n    stopSaving(1);\n    return 0;\n  werr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n    } while (0);\n    unlink(tmpfile);\n    stopSaving(0);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#2224:1#rewriteFunctions",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    dict *functions = functionsLibGet();\n    dictIterator *iter = dictGetIterator(functions);\n    dictEntry *entry;\n    while ((entry = dictNext(iter)))\n        {\n            functionLibInfo *li = (<recovery-expr>((entry)).val);\n            if (<recovery-expr>()(aof, \"*3\\r\\n\", 4) == 0)\n                goto werr;\n            char function_load[] = \"$8\\r\\nFUNCTION\\r\\n$4\\r\\nLOAD\\r\\n\";\n            if (<recovery-expr>()(aof, function_load, sizeof (function_load) - 1) == 0)\n                goto werr;\n            if (<recovery-expr>()(aof, li->code, <recovery-expr>()(li->code)) == 0)\n                goto werr;\n        }\n    dictReleaseIterator(iter);\n    return 1;\n  werr:\n    dictReleaseIterator(iter);\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#1381:1#loadSingleAppendOnlyFile",
    "gotos": 18,
    "labels": 5,
    "body": "{\n    struct client *fakeClient;\n    struct stat64 sb;\n    int old_aof_state = server.aof_state;\n    long loops = 0;\n    int ret = 0;\n    sds aof_filepath = makePath(server.aof_dirname, filename);\n    if (<recovery-expr>()) {\n        int en;\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Fatal error: can't open the append log file %s for reading: %s\", filename, strerror(en));\n            } while (0);\n            sdsfree(aof_filepath);\n            return 3;\n        } else {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            sdsfree(aof_filepath);\n            return 1;\n        }\n    }\n    if (<recovery-expr>()) {\n        sdsfree(aof_filepath);\n        return 2;\n    }\n    server.aof_state = 0;\n    client *old_client = server.current_client;\n    fakeClient = server.current_client = createAOFClient();\n    char sig[5];\n    if (<recovery-expr>()) {\n        if (<recovery-expr>())\n            goto readerr;\n    } else {\n        rio rdb;\n        int old_style = !strcmp(filename, server.aof_filename);\n        if (old_style)\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Reading RDB preamble from AOF file...\");\n            } while (0);\n        else\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Reading RDB base file on AOF loading...\");\n            } while (0);\n        if (<recovery-expr>())\n            goto readerr;\n        if (<recovery-expr>()) {\n            if (old_style)\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Error reading the RDB preamble of the AOF file %s, AOF loading aborted\", filename);\n                } while (0);\n            else\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Error reading the RDB base file %s, AOF loading aborted\", filename);\n                } while (0);\n            ret = 4;\n            goto cleanup;\n        } else {\n            if (old_style)\n                do {\n                    if (((2) & 255) < server.verbosity)\n                        break;\n                    _serverLog(2, \"Reading the remaining AOF tail...\");\n                } while (0);\n        }\n    }\n    while (1)\n        {\n            int argc, j;\n            unsigned long len;\n            robj **argv;\n            char buf[1024];\n            sds argsds;\n            struct redisCommand *cmd;\n            if (!(loops++ % 1024)) {\n                processEventsWhileBlocked();\n                processModuleLoadingProgressEvent(1);\n            }\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    break;\n                } else {\n                    goto readerr;\n                }\n            }\n            if (buf[0] == '#')\n                continue;\n            if (buf[0] != '*')\n                goto fmterr;\n            if (buf[1] == '\\x00')\n                goto readerr;\n            argc = atoi(buf + 1);\n            if (argc < 1)\n                goto fmterr;\n            if (<recovery-expr>())\n                goto fmterr;\n            argv = <recovery-expr>()(sizeof(robj *) * argc);\n            fakeClient->argc = argc;\n            fakeClient->argv = argv;\n            fakeClient->argv_len = argc;\n            for (j = 0; j < argc; j++) {\n                char *readres;\n                if (<recovery-expr>()) {\n                    fakeClient->argc = j;\n                    freeClientArgv(fakeClient);\n                    if (<recovery-expr>())\n                        goto readerr;\n                    else\n                        goto fmterr;\n                }\n                argsds = <recovery-expr>()(SDS_NOINIT, len);\n                if (<recovery-expr>()) {\n                    sdsfree(argsds);\n                    fakeClient->argc = j;\n                    freeClientArgv(fakeClient);\n                    goto readerr;\n                }\n                argv[j] = createObject(0, argsds);\n                if (<recovery-expr>()) {\n                    fakeClient->argc = j + 1;\n                    freeClientArgv(fakeClient);\n                    goto readerr;\n                }\n            }\n            cmd = lookupCommand(argv, argc);\n            if (!cmd) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Unknown command '%s' reading the append only file %s\", (char *)argv[0]->ptr, filename);\n                } while (0);\n                freeClientArgv(fakeClient);\n                ret = 4;\n                goto cleanup;\n            }\n            fakeClient->cmd = fakeClient->lastcmd = cmd;\n            if (<recovery-expr>(fakeClient) & (1 << 3) && fakeClient->cmd->proc != execCommand) {\n                <recovery-expr>()(fakeClient, <recovery-expr>(cmd));\n            } else {\n                cmd->proc(fakeClient);\n            }\n            ((fakeClient->bufpos == 0 && ((fakeClient->reply)->len) == 0) ? (void)0 : (_serverAssert(\"fakeClient->bufpos == 0 && listLength(fakeClient->reply) == 0\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c\", 1549) , __builtin_unreachable()));\n            (((<recovery-expr>(fakeClient) & (1 << 4)) == 0) ? (void)0 : (_serverAssert(\"(fakeClient->flags & CLIENT_BLOCKED) == 0\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c\", 1552) , __builtin_unreachable()));\n            freeClientArgv(fakeClient);\n            if (server.key_load_delay)\n                debugDelay(server.key_load_delay);\n        }\n    if (<recovery-expr>(fakeClient) & (1 << 3)) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Revert incomplete MULTI/EXEC transaction in AOF file %s\", filename);\n        } while (0);\n        goto uxeof;\n    }\n  loaded_ok:\n    ;\n    server.aof_state = old_aof_state;\n    goto cleanup;\n  readerr:\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        ret = 4;\n        goto cleanup;\n    }\n  uxeof:\n    if (server.aof_load_truncated) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"!!! Warning: short read while loading the AOF file %s!!!\", filename);\n        } while (0);\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"Last valid command offset is invalid\");\n                } while (0);\n            } else {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n            }\n        } else {\n            if (<recovery-expr>()) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n            } else {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"AOF %s loaded anyway because aof-load-truncated is enabled\", filename);\n                } while (0);\n                ret = 5;\n                goto loaded_ok;\n            }\n        }\n    }\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Unexpected end of file reading the append only file %s. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix <filename.manifest>. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server.\", filename);\n    } while (0);\n    ret = 4;\n    goto cleanup;\n  fmterr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Bad file format reading the append only file %s: make a backup of your AOF file, then use ./redis-check-aof --fix <filename.manifest>\", filename);\n    } while (0);\n    ret = 4;\n  cleanup:\n    if (fakeClient)\n        freeClient(fakeClient);\n    server.current_client = old_client;\n    sdsfree(aof_filepath);\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#789:1#openNewIncrAofForAppend",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int newfd = -1;\n    aofManifest *temp_am;\n    sds new_aof_name;\n    if (server.aof_state == 0)\n        return 0;\n    if (server.aof_state == 2) {\n        new_aof_name = getTempIncrAofName();\n    } else {\n        temp_am = aofManifestDup(server.aof_manifest);\n        new_aof_name = sdsdup(getNewIncrAofName(temp_am));\n    }\n    sds new_aof_filepath = makePath(server.aof_dirname, new_aof_name);\n    sdsfree(new_aof_filepath);\n    if (newfd == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    if (temp_am) {\n        if (persistAofManifest(temp_am) == -1) {\n            goto cleanup;\n        }\n    }\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"Creating AOF incr file %s on background rewrite\", new_aof_name);\n    } while (0);\n    sdsfree(new_aof_name);\n    if (server.aof_fd != -1) {\n        aof_background_fsync_and_close(server.aof_fd);\n        <recovery-expr>(server) = <recovery-expr>(server);\n        <recovery-expr>(server) = <recovery-expr>(server);\n    }\n    server.aof_fd = newfd;\n    <recovery-expr>(server) = 0;\n    if (temp_am)\n        aofManifestFreeAndUpdate(temp_am);\n    return 0;\n  cleanup:\n    if (new_aof_name)\n        sdsfree(new_aof_name);\n    if (newfd != -1)\n        close(newfd);\n    if (temp_am)\n        aofManifestFree(temp_am);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#525:1#writeAofManifestFile",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    int ret = 0;\n    int len;\n    sds am_name = getAofManifestFileName();\n    sds am_filepath = makePath(server.aof_dirname, am_name);\n    sds tmp_am_name = getTempAofManifestFileName();\n    sds tmp_am_filepath = makePath(server.aof_dirname, tmp_am_name);\n    int fd;\n    if (fd == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        ret = -1;\n        goto cleanup;\n    }\n    len = <recovery-expr>()(buf);\n    while (len)\n        {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    continue;\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                ret = -1;\n                goto cleanup;\n            }\n        }\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        ret = -1;\n        goto cleanup;\n    }\n    if (rename(tmp_am_filepath, am_filepath) != 0) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        ret = -1;\n        goto cleanup;\n    }\n    if (fsyncFileDir(am_filepath) == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        ret = -1;\n        goto cleanup;\n    }\n  cleanup:\n    if (fd != -1)\n        close(fd);\n    sdsfree(am_name);\n    sdsfree(am_filepath);\n    sdsfree(tmp_am_name);\n    sdsfree(tmp_am_filepath);\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#2568:1#backgroundRewriteDoneHandler",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    if (!bysignal && exitcode == 0) {\n        char tmpfile[256];\n        long long now = ustime();\n        sds new_base_filepath;\n        sds new_incr_filepath;\n        aofManifest *temp_am;\n        mstime_t latency;\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Background AOF rewrite terminated with success\");\n        } while (0);\n        snprintf(tmpfile, 256, \"temp-rewriteaof-bg-%d.aof\", (int)<recovery-expr>(server));\n        temp_am = aofManifestDup(server.aof_manifest);\n        sds new_base_filename = getNewBaseFileNameAndMarkPreAsHistory(temp_am);\n        new_base_filepath = makePath(server.aof_dirname, new_base_filename);\n        if (server.latency_monitor_threshold) {\n            latency = mstime();\n        } else {\n            latency = 0;\n        }\n        ;\n        if (rename(tmpfile, new_base_filepath) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            aofManifestFree(temp_am);\n            sdsfree(new_base_filepath);\n            server.aof_lastbgrewrite_status = -1;\n            server.stat_aofrw_consecutive_failures++;\n            goto cleanup;\n        }\n        if (server.latency_monitor_threshold) {\n            latency = mstime() - latency;\n        }\n        ;\n        if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n            latencyAddSample((\"aof-rename\"), (latency));\n        ;\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Successfully renamed the temporary AOF base file %s into %s\", tmpfile, new_base_filename);\n        } while (0);\n        if (server.aof_state == 2) {\n            sds temp_incr_aof_name = getTempIncrAofName();\n            sds temp_incr_filepath = makePath(server.aof_dirname, temp_incr_aof_name);\n            sds new_incr_filename = getNewIncrAofName(temp_am);\n            new_incr_filepath = makePath(server.aof_dirname, new_incr_filename);\n            if (server.latency_monitor_threshold) {\n                latency = mstime();\n            } else {\n                latency = 0;\n            }\n            ;\n            if (rename(temp_incr_filepath, new_incr_filepath) == -1) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                bg_unlink(new_base_filepath);\n                sdsfree(new_base_filepath);\n                aofManifestFree(temp_am);\n                sdsfree(temp_incr_filepath);\n                sdsfree(new_incr_filepath);\n                sdsfree(temp_incr_aof_name);\n                server.aof_lastbgrewrite_status = -1;\n                server.stat_aofrw_consecutive_failures++;\n                goto cleanup;\n            }\n            if (server.latency_monitor_threshold) {\n                latency = mstime() - latency;\n            }\n            ;\n            if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n                latencyAddSample((\"aof-rename\"), (latency));\n            ;\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Successfully renamed the temporary AOF incr file %s into %s\", temp_incr_aof_name, new_incr_filename);\n            } while (0);\n            sdsfree(temp_incr_filepath);\n            sdsfree(temp_incr_aof_name);\n        }\n        markRewrittenIncrAofAsHistory(temp_am);\n        if (persistAofManifest(temp_am) == -1) {\n            bg_unlink(new_base_filepath);\n            aofManifestFree(temp_am);\n            sdsfree(new_base_filepath);\n            if (new_incr_filepath) {\n                bg_unlink(new_incr_filepath);\n                sdsfree(new_incr_filepath);\n            }\n            server.aof_lastbgrewrite_status = -1;\n            server.stat_aofrw_consecutive_failures++;\n            goto cleanup;\n        }\n        sdsfree(new_base_filepath);\n        if (new_incr_filepath)\n            sdsfree(new_incr_filepath);\n        aofManifestFreeAndUpdate(temp_am);\n        if (server.aof_fd != -1) {\n            server.aof_selected_db = -1;\n            <recovery-expr>(server) = <recovery-expr>(server);\n            <recovery-expr>(server) = <recovery-expr>(server);\n            <recovery-expr>(server) = <recovery-expr>(server);\n        }\n        aofDelHistoryFiles();\n        server.aof_lastbgrewrite_status = 0;\n        server.stat_aofrw_consecutive_failures = 0;\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Background AOF rewrite finished successfully\");\n        } while (0);\n        if (server.aof_state == 2)\n            server.aof_state = 1;\n        do {\n            if (((1) & 255) < server.verbosity)\n                break;\n            _serverLog(1, \"Background AOF rewrite signal handler took %lldus\", ustime() - now);\n        } while (0);\n    } else if (!bysignal && exitcode != 0) {\n        server.aof_lastbgrewrite_status = -1;\n        server.stat_aofrw_consecutive_failures++;\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Background AOF rewrite terminated with error\");\n        } while (0);\n    } else {\n        if (<recovery-expr>()) {\n            server.aof_lastbgrewrite_status = -1;\n            server.stat_aofrw_consecutive_failures++;\n        }\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Background AOF rewrite terminated by signal %d\", bysignal);\n        } while (0);\n    }\n  cleanup:\n    <recovery-expr>()(<recovery-expr>(server));\n    if (server.aof_state == 2) {\n        sdsfree(server.aof_buf);\n        server.aof_buf = sdsempty();\n        aofDelTempIncrAofFile();\n    }\n    <recovery-expr>(server) = -1;\n    if (server.aof_state == 2)\n        server.aof_rewrite_scheduled = 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#256:1#aofLoadManifestFromFile",
    "gotos": 10,
    "labels": 1,
    "body": "{\n    const char *err;\n    long long maxseq = 0;\n    aofManifest *am = aofManifestCreate();\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        exit(1);\n    }\n    char buf[1025];\n    sds *argv;\n    int argc;\n    aofInfo *ai;\n    sds line;\n    int linenum = 0;\n    while (1)\n        {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>()) {\n                    if (linenum == 0) {\n                        err = \"Found an empty AOF manifest\";\n                        goto loaderr;\n                    } else {\n                        break;\n                    }\n                } else {\n                    err = \"Read AOF manifest failed\";\n                    goto loaderr;\n                }\n            }\n            linenum++;\n            if (buf[0] == '#')\n                continue;\n            if (<recovery-expr>()) {\n                err = \"The AOF manifest file contains too long line\";\n                goto loaderr;\n            }\n            line = sdstrim(sdsnew(buf), \" \\t\\r\\n\");\n            if (!<recovery-expr>()(line)) {\n                err = \"Invalid AOF manifest file format\";\n                goto loaderr;\n            }\n            argv = sdssplitargs(line, &argc);\n            if (<recovery-expr>()) {\n                err = \"Invalid AOF manifest file format\";\n                goto loaderr;\n            }\n            ai = aofInfoCreate();\n            for (int i = 0; i < argc; i += 2) {\n                if (!strcasecmp(argv[i], \"file\")) {\n                    ai->file_name = sdsnew(argv[i + 1]);\n                    if (!pathIsBaseName(ai->file_name)) {\n                        err = \"File can't be a path, just a filename\";\n                        goto loaderr;\n                    }\n                } else if (!strcasecmp(argv[i], \"seq\")) {\n                    ai->file_seq = atoll(argv[i + 1]);\n                } else if (!strcasecmp(argv[i], \"type\")) {\n                    ai->file_type = (argv[i + 1])[0];\n                }\n            }\n            if (!ai->file_name || !ai->file_seq || !ai->file_type) {\n                err = \"Invalid AOF manifest file format\";\n                goto loaderr;\n            }\n            sdsfreesplitres(argv, argc);\n            if (ai->file_type == AOF_FILE_TYPE_BASE) {\n                if (am->base_aof_info) {\n                    err = \"Found duplicate base file information\";\n                    goto loaderr;\n                }\n                am->base_aof_info = ai;\n                am->curr_base_file_seq = ai->file_seq;\n            } else if (ai->file_type == AOF_FILE_TYPE_HIST) {\n                listAddNodeTail(am->history_aof_list, ai);\n            } else if (ai->file_type == AOF_FILE_TYPE_INCR) {\n                if (ai->file_seq <= maxseq) {\n                    err = \"Found a non-monotonic sequence number\";\n                    goto loaderr;\n                }\n                listAddNodeTail(am->incr_aof_list, ai);\n                am->curr_incr_file_seq = ai->file_seq;\n                maxseq = ai->file_seq;\n            } else {\n                err = \"Unknown AOF file type\";\n                goto loaderr;\n            }\n            sdsfree(line);\n        }\n    return am;\n  loaderr:\n    if (argv)\n        sdsfreesplitres(argv, argc);\n    if (ai)\n        aofInfoFree(ai);\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"\\n*** FATAL AOF MANIFEST FILE ERROR ***\\n\");\n    } while (0);\n    if (line) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Reading the manifest file, at line %d\\n\", linenum);\n        } while (0);\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \">>> '%s'\\n\", line);\n        } while (0);\n    }\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"%s\\n\", err);\n    } while (0);\n    exit(1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#2243:1#rewriteAppendOnlyFileRio",
    "gotos": 16,
    "labels": 1,
    "body": "{\n    dictIterator *di;\n    dictEntry *de;\n    int j;\n    long key_count = 0;\n    long long updated_time = 0;\n    if (server.aof_timestamp_enabled) {\n        sds ts = genAofTimestampAnnotationIfNeeded(1);\n        if (<recovery-expr>()(aof, ts, <recovery-expr>()(ts)) == 0) {\n            sdsfree(ts);\n            goto werr;\n        }\n        sdsfree(ts);\n    }\n    if (rewriteFunctions(aof) == 0)\n        goto werr;\n    for (j = 0; j < server.dbnum; j++) {\n        char selectcmd[] = \"*2\\r\\n$6\\r\\nSELECT\\r\\n\";\n        redisDb *db = server.db + j;\n        dict *d = db->dict;\n        if (((d)->ht_used[0] + (d)->ht_used[1]) == 0)\n            continue;\n        di = dictGetSafeIterator(d);\n        if (<recovery-expr>()(aof, selectcmd, sizeof (selectcmd) - 1) == 0)\n            goto werr;\n        if (<recovery-expr>()(aof, j) == 0)\n            goto werr;\n        while (<recovery-expr>())\n            {\n                sds keystr;\n                robj key, *o;\n                long long expiretime;\n                int aof_bytes_before_key(int *);\n                keystr = ((de)->key);\n                o = (<recovery-expr>((de)).val);\n                do {\n                    key.type = 0;\n                    key.encoding = 0;\n                    key.ptr = keystr;\n                } while (0);\n                expiretime = getExpire(db, &key);\n                if (o->type == 0) {\n                    char cmd[] = \"*3\\r\\n$3\\r\\nSET\\r\\n\";\n                    if (<recovery-expr>()(aof, cmd, sizeof (cmd) - 1) == 0)\n                        goto werr;\n                    if (rioWriteBulkObject(aof, &key) == 0)\n                        goto werr;\n                    if (rioWriteBulkObject(aof, o) == 0)\n                        goto werr;\n                } else if (o->type == 1) {\n                    if (rewriteListObject(aof, &key, o) == 0)\n                        goto werr;\n                } else if (o->type == 2) {\n                    if (rewriteSetObject(aof, &key, o) == 0)\n                        goto werr;\n                } else if (o->type == 3) {\n                    if (rewriteSortedSetObject(aof, &key, o) == 0)\n                        goto werr;\n                } else if (o->type == 4) {\n                    if (rewriteHashObject(aof, &key, o) == 0)\n                        goto werr;\n                } else if (o->type == 6) {\n                    if (rewriteStreamObject(aof, &key, o) == 0)\n                        goto werr;\n                } else if (o->type == 5) {\n                    if (rewriteModuleObject(aof, &key, o, j) == 0)\n                        goto werr;\n                } else {\n                    _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c\", 2304, \"Unknown object type\") , __builtin_unreachable();\n                }\n                int dump_size(int *);\n                if (server.in_fork_child)\n                    dismissObject(o, <recovery-expr>());\n                if (expiretime != -1) {\n                    char cmd[] = \"*3\\r\\n$9\\r\\nPEXPIREAT\\r\\n\";\n                    if (<recovery-expr>()(aof, cmd, sizeof (cmd) - 1) == 0)\n                        goto werr;\n                    if (rioWriteBulkObject(aof, &key) == 0)\n                        goto werr;\n                    if (<recovery-expr>()(aof, expiretime) == 0)\n                        goto werr;\n                }\n                if ((key_count++ & 1023) == 0) {\n                    long long now = mstime();\n                    if (now - updated_time >= 1000) {\n                        sendChildInfo(CHILD_INFO_TYPE_CURRENT_INFO, key_count, \"AOF rewrite\");\n                        updated_time = now;\n                    }\n                }\n                if (server.rdb_key_save_delay)\n                    debugDelay(server.rdb_key_save_delay);\n            }\n        dictReleaseIterator(di);\n    }\n    return 0;\n  werr:\n    if (di)\n        dictReleaseIterator(di);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#1632:1#loadAppendOnlyFiles",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int status, ret = 0;\n    long long start;\n    sds aof_name;\n    int total_num, aof_num = 0, last_file;\n    if (fileExist(server.aof_filename)) {\n        if (<recovery-expr>()) {\n            aofUpgradePrepare(am);\n        }\n    }\n    if (<recovery-expr>()) {\n        return 1;\n    }\n    total_num = getBaseAndIncrAppendOnlyFilesNum(am);\n    ((total_num > 0) ? (void)0 : (_serverAssert(\"total_num > 0\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c\", 1664) , __builtin_unreachable()));\n    if (status != 0) {\n        if (status == 1)\n            status = 4;\n        return status;\n    } else if (<recovery-expr>()) {\n        return 2;\n    }\n    if (am->base_aof_info) {\n        ((am->base_aof_info->file_type == AOF_FILE_TYPE_BASE) ? (void)0 : (_serverAssert(\"am->base_aof_info->file_type == AOF_FILE_TYPE_BASE\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c\", 1682) , __builtin_unreachable()));\n        aof_name = (char *)am->base_aof_info->file_name;\n        updateLoadingFileName(aof_name);\n        last_file = ++aof_num == total_num;\n        start = ustime();\n        ret = loadSingleAppendOnlyFile(aof_name);\n        if (ret == 0 || (ret == 5 && last_file)) {\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"DB loaded from base file %s: %.3f seconds\", aof_name, (float)(ustime() - start) / 1000000);\n            } while (0);\n        }\n        if (ret == 5 && !last_file) {\n            ret = 4;\n        }\n        if (ret == 3 || ret == 4) {\n            goto cleanup;\n        }\n    }\n    if (((am->incr_aof_list)->len)) {\n        listNode *ln;\n        listIter li;\n        listRewind(am->incr_aof_list, &li);\n        while (<recovery-expr>())\n            {\n                aofInfo *ai = (aofInfo *)ln->value;\n                ((ai->file_type == AOF_FILE_TYPE_INCR) ? (void)0 : (_serverAssert(\"ai->file_type == AOF_FILE_TYPE_INCR\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c\", 1712) , __builtin_unreachable()));\n                aof_name = (char *)ai->file_name;\n                updateLoadingFileName(aof_name);\n                last_file = ++aof_num == total_num;\n                start = ustime();\n                ret = loadSingleAppendOnlyFile(aof_name);\n                if (ret == 0 || (ret == 5 && last_file)) {\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                        _serverLog(2, \"DB loaded from incr file %s: %.3f seconds\", aof_name, (float)(ustime() - start) / 1000000);\n                    } while (0);\n                }\n                if (ret == 2)\n                    ret = 0;\n                if (ret == 5 && !last_file) {\n                    ret = 4;\n                }\n                if (ret == 3 || ret == 4) {\n                    goto cleanup;\n                }\n            }\n    }\n    <recovery-expr>(server) = <recovery-expr>(server);\n  cleanup:\n    stopLoading(ret == 0 || ret == 5);\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/aof.c#1060:1#flushAppendOnlyFile",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int sync_in_progress = 0;\n    mstime_t latency;\n    if (<recovery-expr>()(server.aof_buf) == 0) {\n        if (server.aof_fsync == 2 && <recovery-expr>(server) != <recovery-expr>(server) && <recovery-expr>(server) > <recovery-expr>(server) && !(sync_in_progress = aofFsyncInProgress())) {\n            goto try_fsync;\n        } else {\n            return;\n        }\n    }\n    if (server.aof_fsync == 2)\n        sync_in_progress = aofFsyncInProgress();\n    if (server.aof_fsync == 2 && !force) {\n        if (sync_in_progress) {\n            if (<recovery-expr>(server) == 0) {\n                <recovery-expr>(server) = <recovery-expr>(server);\n                return;\n            } else if (<recovery-expr>(server) - <recovery-expr>(server) < 2) {\n                return;\n            }\n            server.aof_delayed_fsync++;\n            do {\n                if (((2) & 255) < server.verbosity)\n                    break;\n                _serverLog(2, \"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.\");\n            } while (0);\n        }\n    }\n    if (server.aof_flush_sleep && <recovery-expr>()(server.aof_buf)) {\n        usleep(server.aof_flush_sleep);\n    }\n    if (server.latency_monitor_threshold) {\n        latency = mstime();\n    } else {\n        latency = 0;\n    }\n    ;\n    if (server.latency_monitor_threshold) {\n        latency = mstime() - latency;\n    }\n    ;\n    if (sync_in_progress) {\n        if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n            latencyAddSample((\"aof-write-pending-fsync\"), (latency));\n        ;\n    } else if (hasActiveChildProcess()) {\n        if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n            latencyAddSample((\"aof-write-active-child\"), (latency));\n        ;\n    } else {\n        if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n            latencyAddSample((\"aof-write-alone\"), (latency));\n        ;\n    }\n    if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n        latencyAddSample((\"aof-write\"), (latency));\n    ;\n    <recovery-expr>(server) = 0;\n    if (<recovery-expr>()) {\n        static int last_write_error_log;\n        int can_log = 0;\n        if ((<recovery-expr>(server) - <recovery-expr>()) > 30) {\n            can_log = 1;\n            <recovery-expr>() = <recovery-expr>(server);\n        }\n        if (<recovery-expr>()) {\n            if (can_log) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n            }\n        } else {\n            if (can_log) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n            }\n            if (ftruncate(server.aof_fd, <recovery-expr>(server)) == -1) {\n                if (can_log) {\n                    do {\n                        if (((3) & 255) < server.verbosity)\n                            break;\n                    } while (0);\n                }\n            } else {\n            }\n        }\n        if (server.aof_fsync == 1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting...\");\n            } while (0);\n            exit(1);\n        } else {\n            server.aof_last_write_status = -1;\n            if (<recovery-expr>()) {\n            }\n            return;\n        }\n    } else {\n        if (server.aof_last_write_status == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"AOF write error looks solved, Redis can write again.\");\n            } while (0);\n            server.aof_last_write_status = 0;\n        }\n    }\n    if ((<recovery-expr>()(server.aof_buf) + <recovery-expr>()(server.aof_buf)) < 4000) {\n        sdsclear(server.aof_buf);\n    } else {\n        sdsfree(server.aof_buf);\n        server.aof_buf = sdsempty();\n    }\n  try_fsync:\n    if (server.aof_no_fsync_on_rewrite && hasActiveChildProcess())\n        return;\n    if (server.aof_fsync == 1) {\n        if (server.latency_monitor_threshold) {\n            latency = mstime();\n        } else {\n            latency = 0;\n        }\n        ;\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            exit(1);\n        }\n        if (server.latency_monitor_threshold) {\n            latency = mstime() - latency;\n        }\n        ;\n        if (server.latency_monitor_threshold && (latency) >= server.latency_monitor_threshold)\n            latencyAddSample((\"aof-fsync-always\"), (latency));\n        ;\n        <recovery-expr>(server) = <recovery-expr>(server);\n        <recovery-expr>(server) = <recovery-expr>(server);\n    } else if ((server.aof_fsync == 2 && <recovery-expr>(server) > <recovery-expr>(server))) {\n        if (!sync_in_progress) {\n            aof_background_fsync(server.aof_fd);\n            <recovery-expr>(server) = <recovery-expr>(server);\n        }\n        <recovery-expr>(server) = <recovery-expr>(server);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/function_lua.c#271:1#luaRegisterFunctionReadNamedArgs",
    "gotos": 10,
    "labels": 1,
    "body": "{\n    char *err;\n    sds name;\n    sds desc;\n    luaFunctionCtx *lua_f_ctx;\n    if (!lua_istable(<recovery-expr>(), 1)) {\n        err = \"calling redis.register_function with a single argument is only applicable to Lua table (representing named arguments).\";\n        goto error;\n    }\n    lua_pushnil(<recovery-expr>());\n    while (lua_next(<recovery-expr>(), -2))\n        {\n            if (!lua_isstring(<recovery-expr>(), -2)) {\n                err = \"named argument key given to redis.register_function is not a string\";\n                goto error;\n            }\n            const char *key = lua_tostring(<recovery-expr>(), -2);\n            if (!strcasecmp(key, \"function_name\")) {\n                if (!(name = <recovery-expr>()(<recovery-expr>(), -1))) {\n                    err = \"function_name argument given to redis.register_function must be a string\";\n                    goto error;\n                }\n            } else if (!strcasecmp(key, \"description\")) {\n                if (!(desc = <recovery-expr>()(<recovery-expr>(), -1))) {\n                    err = \"description argument given to redis.register_function must be a string\";\n                    goto error;\n                }\n            } else if (!strcasecmp(key, \"callback\")) {\n                if (!lua_isfunction(<recovery-expr>(), -1)) {\n                    err = \"callback argument given to redis.register_function must be a function\";\n                    goto error;\n                }\n                int lua_function_ref;\n                lua_f_ctx = <recovery-expr>()(sizeof (*lua_f_ctx));\n                lua_f_ctx->lua_function_ref = lua_function_ref;\n                continue;\n            } else if (!strcasecmp(key, \"flags\")) {\n                if (!lua_istable(<recovery-expr>(), -1)) {\n                    err = \"flags argument to redis.register_function must be a table representing function flags\";\n                    goto error;\n                }\n                if (<recovery-expr>()) {\n                    err = \"unknown flag given\";\n                    goto error;\n                }\n            } else {\n                err = \"unknown argument given to redis.register_function\";\n                goto error;\n            }\n            lua_pop(<recovery-expr>(), 1);\n        }\n    if (!name) {\n        err = \"redis.register_function must get a function name argument\";\n        goto error;\n    }\n    if (!lua_f_ctx) {\n        err = \"redis.register_function must get a callback argument\";\n        goto error;\n    }\n    return 0;\n  error:\n    if (name)\n        sdsfree(name);\n    if (desc)\n        sdsfree(desc);\n    if (lua_f_ctx) {\n        lua_unref(<recovery-expr>(), lua_f_ctx->lua_function_ref);\n        zfree(lua_f_ctx);\n    }\n    <recovery-expr>()(<recovery-expr>(), err);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/function_lua.c#230:1#luaRegisterFunctionReadFlags",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int j = 1;\n    int ret = -1;\n    int f_flags = 0;\n    while (1)\n        {\n            lua_pushnumber(<recovery-expr>(), j++);\n            lua_gettable(<recovery-expr>(), -2);\n            int t = lua_type(<recovery-expr>(), -1);\n            if (<recovery-expr>()) {\n                lua_pop(<recovery-expr>(), 1);\n                break;\n            }\n            if (!lua_isstring(<recovery-expr>(), -1)) {\n                lua_pop(<recovery-expr>(), 1);\n                goto done;\n            }\n            const char *flag_str = lua_tostring(<recovery-expr>(), -1);\n            int found = 0;\n            for (scriptFlag *flag = scripts_flags_def; flag->str; ++flag) {\n                if (!strcasecmp(flag->str, flag_str)) {\n                    f_flags |= <recovery-expr>(flag);\n                    found = 1;\n                    break;\n                }\n            }\n            lua_pop(<recovery-expr>(), 1);\n            if (!found) {\n                goto done;\n            }\n        }\n    *<recovery-expr>() = f_flags;\n    ret = 0;\n  done:\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/function_lua.c#103:1#luaEngineCreate",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int ret = -1;\n    luaEngineCtx *lua_engine_ctx = engine_ctx;\n    if (<recovery-expr>()) {\n        goto done;\n    }\n    loadCtx load_ctx = {.li = li, .start_time = getMonotonicUs()};\n    if (<recovery-expr>()) {\n        errorInfo err_info = {0};\n        *err = sdscatprintf(sdsempty(), \"Error registering functions: %s\", err_info.msg);\n        luaErrorInformationDiscard(&err_info);\n        goto done;\n    }\n    ret = 0;\n  done:\n    ;\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/function_lua.c#353:1#luaRegisterFunctionReadPositionalArgs",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    char *err;\n    sds name;\n    sds desc;\n    luaFunctionCtx *lua_f_ctx;\n    if (!(name = <recovery-expr>()(<recovery-expr>(), 1))) {\n        err = \"first argument to redis.register_function must be a string\";\n        goto error;\n    }\n    if (!lua_isfunction(<recovery-expr>(), 2)) {\n        err = \"second argument to redis.register_function must be a function\";\n        goto error;\n    }\n    int lua_function_ref;\n    lua_f_ctx = <recovery-expr>()(sizeof (*lua_f_ctx));\n    lua_f_ctx->lua_function_ref = lua_function_ref;\n    return 0;\n  error:\n    if (name)\n        sdsfree(name);\n    if (desc)\n        sdsfree(desc);\n    <recovery-expr>()(<recovery-expr>(), err);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/sort.c#61:1#lookupKeyByPattern",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    char *p, *f, *k;\n    sds spat, ssub;\n    robj *keyobj, *fieldobj, *o;\n    int prefixlen, sublen, postfixlen, fieldlen;\n    spat = pattern->ptr;\n    if (spat[0] == '#' && spat[1] == '\\x00') {\n        incrRefCount(subst);\n        return subst;\n    }\n    subst = getDecodedObject(subst);\n    ssub = subst->ptr;\n    p = strchr(spat, '*');\n    if (!p) {\n        decrRefCount(subst);\n    }\n    if (<recovery-expr>()) {\n        fieldlen = <recovery-expr>()(spat) - (f - spat) - 2;\n        fieldobj = createStringObject(f + 2, fieldlen);\n    } else {\n        fieldlen = 0;\n    }\n    prefixlen = p - spat;\n    sublen = <recovery-expr>()(ssub);\n    postfixlen = <recovery-expr>()(spat) - (prefixlen + 1) - (fieldlen ? fieldlen + 2 : 0);\n    k = keyobj->ptr;\n    memcpy(k, spat, prefixlen);\n    memcpy(k + prefixlen, ssub, sublen);\n    memcpy(k + prefixlen + sublen, p + 1, postfixlen);\n    decrRefCount(subst);\n    o = lookupKeyRead(db, keyobj);\n    if (<recovery-expr>())\n        goto noobj;\n    if (fieldobj) {\n        if (o->type != 4)\n            goto noobj;\n        o = hashTypeGetValueObject(o, fieldobj->ptr);\n    } else {\n        if (o->type != 0)\n            goto noobj;\n        incrRefCount(o);\n    }\n    decrRefCount(keyobj);\n    if (fieldobj)\n        decrRefCount(fieldobj);\n    return o;\n  noobj:\n    decrRefCount(keyobj);\n    if (fieldlen)\n        decrRefCount(fieldobj);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/util.c#363:1#ull2string",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    static const char digits[201] = \"00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899\";\n    if (<recovery-expr>())\n        goto err;\n    ;\n    while (value >= 100)\n        {\n            const int i = (value % 100) * 2;\n            value /= 100;\n        }\n    if (value < 10) {\n    } else {\n        int i;\n    }\n  err:\n    if (<recovery-expr>() > 0)\n        dst[0] = '\\x00';\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/util.c#321:1#ll2string",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    unsigned long long value;\n    int negative = 0;\n    if (svalue < 0) {\n        if (<recovery-expr>()) {\n            value = -svalue;\n        } else {\n        }\n        if (<recovery-expr>() < 2)\n            goto err;\n        negative = 1;\n        dst[0] = '-';\n        dst++;\n        <recovery-expr>()--;\n    } else {\n        value = svalue;\n    }\n    int length = <recovery-expr>()(dst, <recovery-expr>(), value);\n    if (length == 0)\n        return 0;\n    return length + negative;\n  err:\n    if (<recovery-expr>() > 0)\n        dst[0] = '\\x00';\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/util.c#653:1#ld2string",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    if (isinf(value)) {\n        if (<recovery-expr>() < 5)\n            goto err;\n        if (value > 0) {\n            memcpy(buf, \"inf\", 3);\n        } else {\n            memcpy(buf, \"-inf\", 4);\n        }\n    } else {\n        switch (mode) {\n          case LD_STR_AUTO:\n            ;\n            if (<recovery-expr>())\n                goto err;\n            ;\n            break;\n          case LD_STR_HEX:\n            ;\n            if (<recovery-expr>())\n                goto err;\n            break;\n          case LD_STR_HUMAN:\n            ;\n            if (<recovery-expr>())\n                goto err;\n            if (<recovery-expr>()) {\n                char *p;\n                while (*p == '0')\n                    {\n                        p--;\n                    }\n            }\n            if (<recovery-expr>()) {\n                buf[0] = '0';\n            }\n            break;\n          default:\n            goto err;\n        }\n    }\n  err:\n    if (<recovery-expr>() > 0)\n        buf[0] = '\\x00';\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/read.c#703:1#redisReaderFeed",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    hisds newbuf;\n    if (r->err)\n        return -1;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>(r) == 0 && <recovery-expr>(r) != 0 && <recovery-expr>()(r->buf) > <recovery-expr>(r)) {\n            hi_sdsfree(r->buf);\n            r->buf = hi_sdsempty();\n            if (r->buf == 0)\n                goto oom;\n            <recovery-expr>(r) = 0;\n        }\n        newbuf = <recovery-expr>()(r->buf, buf, <recovery-expr>());\n        if (<recovery-expr>())\n            goto oom;\n        r->buf = newbuf;\n        <recovery-expr>(r) = <recovery-expr>()(r->buf);\n    }\n    return 0;\n  oom:\n    __redisReaderSetErrorOOM(r);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/read.c#651:1#redisReaderCreateWithFunctions",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    redisReader *r;\n    r = <recovery-expr>()(1, sizeof(redisReader));\n    r->buf = hi_sdsempty();\n    if (<recovery-expr>())\n        goto oom;\n    r->task = <recovery-expr>()(9, sizeof (*r->task));\n    if (<recovery-expr>())\n        goto oom;\n    for (; r->tasks < 9; r->tasks++) {\n        r->task[r->tasks] = <recovery-expr>()(1, sizeof (**r->task));\n        if (<recovery-expr>())\n            goto oom;\n    }\n    r->fn = fn;\n    <recovery-expr>(r) = (1024 * 16);\n    r->maxelements = ((1LL << 32) - 1);\n    r->ridx = -1;\n    return r;\n  oom:\n    redisReaderFree(r);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/read.c#466:1#redisReaderGrow",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    redisReadTask **aux;\n    int newlen;\n    newlen = r->tasks + 9;\n    aux = <recovery-expr>()(r->task, sizeof (*r->task) * newlen);\n    if (<recovery-expr>())\n        goto oom;\n    r->task = aux;\n    for (; r->tasks < newlen; r->tasks++) {\n        r->task[r->tasks] = <recovery-expr>()(1, sizeof (**r->task));\n        if (<recovery-expr>())\n            goto oom;\n    }\n    return 0;\n  oom:\n    __redisReaderSetErrorOOM(r);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/blocked.c#412:1#serveClientsBlockedOnStreamKey",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (!server.blocked_clients_by_type[4])\n        return;\n    dictEntry *de = dictFind(rl->db->blocking_keys, rl->key);\n    stream *s;\n    if (de) {\n        list *clients = (<recovery-expr>((de)).val);\n        listNode *ln;\n        listIter li;\n        listRewind(clients, &li);\n        while ((ln = listNext(&li)))\n            {\n                client *receiver = ((ln)->value);\n                if (receiver->btype != 4)\n                    continue;\n                bkinfo *bki = dictFetchValue(<recovery-expr>(receiver).keys, rl->key);\n                streamID *gt = &<recovery-expr>(bki);\n                if (!<recovery-expr>(receiver).xread_group && (!o || o->type != 6)) {\n                    continue;\n                }\n                long long prev_error_replies = server.stat_total_error_replies;\n                client *old_client = server.current_client;\n                server.current_client = receiver;\n                monotime replyTimer;\n                elapsedStart(&replyTimer);\n                streamCG *group;\n                if (<recovery-expr>(receiver).xread_group) {\n                    if (!o || o->type != 6) {\n                        addReplyError(receiver, \"-UNBLOCKED the stream key no longer exists\");\n                        goto unblock_receiver;\n                    }\n                    group = streamLookupCG(s, <recovery-expr>(receiver).xread_group->ptr);\n                    if (!group) {\n                        addReplyError(receiver, \"-NOGROUP the consumer group this client was blocked on no longer exists\");\n                        goto unblock_receiver;\n                    } else {\n                        *gt = <recovery-expr>(group);\n                    }\n                }\n                if (streamCompareID(&<recovery-expr>(s), gt) > 0) {\n                    streamID start = *gt;\n                    streamIncrID(&start);\n                    streamConsumer *consumer;\n                    int noack = 0;\n                    if (group) {\n                        noack = <recovery-expr>(receiver).xread_group_noack;\n                        sds name = <recovery-expr>(receiver).xread_consumer->ptr;\n                        consumer = streamLookupConsumer(group, name, 0);\n                        if (<recovery-expr>()) {\n                            consumer = streamCreateConsumer(group, name, rl->key, rl->db->id, 0);\n                            if (noack) {\n                                streamPropagateConsumerCreation(receiver, rl->key, <recovery-expr>(receiver).xread_group, consumer->name);\n                            }\n                        }\n                    }\n                    if (receiver->resp == 2) {\n                        addReplyArrayLen(receiver, 1);\n                        addReplyArrayLen(receiver, 2);\n                    } else {\n                        addReplyMapLen(receiver, 1);\n                    }\n                    addReplyBulk(receiver, rl->key);\n                    streamPropInfo pi = {rl->key, <recovery-expr>(receiver).xread_group};\n                  unblock_receiver:\n                    updateStatsOnUnblock(receiver, 0, <recovery-expr>()(replyTimer), server.stat_total_error_replies != prev_error_replies);\n                    unblockClient(receiver);\n                    afterCommand(receiver);\n                    server.current_client = old_client;\n                }\n            }\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#2873:1#rdbLoadRioWithLoadingCtx",
    "gotos": 19,
    "labels": 1,
    "body": "{\n    int type, rdbver;\n    redisDb *db = rdb_loading_ctx->dbarray + 0;\n    char buf[1024];\n    int error;\n    long long empty_keys_skipped = 0;\n    rdb->update_cksum = rdbLoadProgressCallback;\n    <recovery-expr>(rdb) = <recovery-expr>(server);\n    if (<recovery-expr>()(rdb, buf, 9) == 0)\n        goto eoferr;\n    buf[9] = '\\x00';\n    if (memcmp(buf, \"REDIS\", 5) != 0) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Wrong signature trying to load DB from file\");\n        } while (0);\n        return -1;\n    }\n    rdbver = atoi(buf + 5);\n    if (rdbver < 1 || rdbver > 10) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Can't handle RDB format version %d\", rdbver);\n        } while (0);\n        return -1;\n    }\n    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();\n    long long lru_clock = LRU_CLOCK();\n    while (1)\n        {\n            sds key;\n            robj *val;\n            if ((type = rdbLoadType(rdb)) == -1)\n                goto eoferr;\n            if (type == 253) {\n                expiretime = <recovery-expr>()(rdb);\n                expiretime *= 1000;\n                if (rioGetReadError(rdb))\n                    goto eoferr;\n                continue;\n            } else if (type == 252) {\n                expiretime = rdbLoadMillisecondTime(rdb, rdbver);\n                if (rioGetReadError(rdb))\n                    goto eoferr;\n                continue;\n            } else if (type == 249) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 248) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 255) {\n                break;\n            } else if (type == 254) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>()) {\n                    do {\n                        if (((3) & 255) < server.verbosity)\n                            break;\n                        _serverLog(3, \"FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\\n\", server.dbnum);\n                    } while (0);\n                    exit(1);\n                }\n                continue;\n            } else if (type == 251) {\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>())\n                    goto eoferr;\n                continue;\n            } else if (type == 250) {\n                robj *auxkey, *auxval;\n                if (<recovery-expr>())\n                    goto eoferr;\n                if (<recovery-expr>()) {\n                    decrRefCount(auxkey);\n                    goto eoferr;\n                }\n                if (((char *)auxkey->ptr)[0] == '%') {\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                        _serverLog(2, \"RDB '%s': %s\", (char *)auxkey->ptr, (char *)auxval->ptr);\n                    } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"repl-stream-db\")) {\n                    if (rsi)\n                        rsi->repl_stream_db = atoi(auxval->ptr);\n                } else if (!strcasecmp(auxkey->ptr, \"repl-id\")) {\n                    if (rsi && <recovery-expr>()(auxval->ptr) == 40) {\n                        memcpy(rsi->repl_id, auxval->ptr, 40 + 1);\n                        rsi->repl_id_is_set = 1;\n                    }\n                } else if (!strcasecmp(auxkey->ptr, \"repl-offset\")) {\n                } else if (!strcasecmp(auxkey->ptr, \"lua\")) {\n                } else if (!strcasecmp(auxkey->ptr, \"redis-ver\")) {\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                        _serverLog(2, \"Loading RDB produced by version %s\", (char *)auxval->ptr);\n                    } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"ctime\")) {\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                    } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"used-mem\")) {\n                    long long usedmem;\n                    do {\n                        if (((2) & 255) < server.verbosity)\n                            break;\n                        _serverLog(2, \"RDB memory usage when created %.2f Mb\", (double)usedmem / (1024 * 1024));\n                    } while (0);\n                    <recovery-expr>(server) = usedmem;\n                } else if (!strcasecmp(auxkey->ptr, \"aof-preamble\")) {\n                    long long haspreamble;\n                    if (haspreamble)\n                        do {\n                            if (((2) & 255) < server.verbosity)\n                                break;\n                            _serverLog(2, \"RDB has an AOF tail\");\n                        } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"aof-base\")) {\n                    long long isbase;\n                    if (isbase)\n                        do {\n                            if (((2) & 255) < server.verbosity)\n                                break;\n                            _serverLog(2, \"RDB is base AOF\");\n                        } while (0);\n                } else if (!strcasecmp(auxkey->ptr, \"redis-bits\")) {\n                } else {\n                    do {\n                        if (((0) & 255) < server.verbosity)\n                            break;\n                        _serverLog(0, \"Unrecognized RDB AUX field: '%s'\", (char *)auxkey->ptr);\n                    } while (0);\n                }\n                decrRefCount(auxkey);\n                decrRefCount(auxval);\n                continue;\n            } else if (type == 247) {\n                int when_opcode;\n                int when;\n                if (rioGetReadError(rdb))\n                    goto eoferr;\n                if (when_opcode != 2) {\n                    rdbReportError(0, 3030, \"bad when_opcode\");\n                    goto eoferr;\n                }\n                moduleType *mt;\n                char name[10];\n                if (<recovery-expr>()) {\n                    do {\n                        if (((3) & 255) < server.verbosity)\n                            break;\n                        _serverLog(3, \"The RDB file contains AUX module data I can't load: no matching module '%s'\", name);\n                    } while (0);\n                    exit(1);\n                } else if (<recovery-expr>()) {\n                    if (!mt->aux_load) {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"The RDB file contains module AUX data, but the module '%s' doesn't seem to support it.\", name);\n                        } while (0);\n                        exit(1);\n                    }\n                    RedisModuleIO io;\n                    do {\n                        io.rio = rdb;\n                        io.type = mt;\n                        <recovery-expr>(io) = 0;\n                        io.error = 0;\n                        io.dbid = -1;\n                    } while (0);\n                    int rc;\n                    if (io.ctx) {\n                        moduleFreeContext(io.ctx);\n                        zfree(io.ctx);\n                    }\n                    if (rc != 0 || io.error) {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", name);\n                        } while (0);\n                        goto eoferr;\n                    }\n                    if (<recovery-expr>()) {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker\", name);\n                        } while (0);\n                        goto eoferr;\n                    }\n                    continue;\n                } else {\n                    robj *aux = rdbLoadCheckModuleValue(rdb, name);\n                    decrRefCount(aux);\n                    continue;\n                }\n            } else if (type == 246) {\n                rdbReportError(1, 3075, \"Pre-release function format not supported.\");\n                exit(1);\n            } else if (type == 245) {\n                sds err;\n                if (rdbFunctionLoad(rdb, rdbver, rdb_loading_ctx->functions_lib_ctx, rdbflags, &err) != 0) {\n                    do {\n                        if (((3) & 255) < server.verbosity)\n                            break;\n                        _serverLog(3, \"Failed loading library, %s\", err);\n                    } while (0);\n                    sdsfree(err);\n                    goto eoferr;\n                }\n                continue;\n            }\n            if (<recovery-expr>())\n                goto eoferr;\n            val = rdbLoadObject(type, rdb, key, db->id, &error);\n            if (<recovery-expr>()) {\n                if (error == 1) {\n                    if (empty_keys_skipped++ < 10)\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"rdbLoadObject skipping empty key: %s\", key);\n                        } while (0);\n                    sdsfree(key);\n                } else {\n                    sdsfree(key);\n                    goto eoferr;\n                }\n            } else if (iAmMaster() && !(rdbflags & (1 << 0)) && expiretime != -1 && expiretime < now) {\n                if (rdbflags & (1 << 3)) {\n                    robj keyobj;\n                    do {\n                        keyobj.type = 0;\n                        keyobj.encoding = 0;\n                        keyobj.ptr = key;\n                    } while (0);\n                    robj *argv[2];\n                    argv[0] = server.lazyfree_lazy_expire ? shared.unlink : shared.del;\n                    argv[1] = &keyobj;\n                }\n                sdsfree(key);\n                decrRefCount(val);\n                server.rdb_last_load_keys_expired++;\n            } else {\n                robj keyobj;\n                do {\n                    keyobj.type = 0;\n                    keyobj.encoding = 0;\n                    keyobj.ptr = key;\n                } while (0);\n                int added = dbAddRDBLoad(db, key, val);\n                server.rdb_last_load_keys_loaded++;\n                if (!added) {\n                    if (rdbflags & (1 << 2)) {\n                        dbSyncDelete(db, &keyobj);\n                        dbAddRDBLoad(db, key, val);\n                    } else {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"RDB has duplicated key '%s' in DB %d\", key, db->id);\n                        } while (0);\n                        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c\", 3150, \"Duplicated key found in RDB file\") , __builtin_unreachable();\n                    }\n                }\n                if (expiretime != -1) {\n                }\n                objectSetLRUOrLFU(val, lfu_freq, lru_idle, lru_clock, 1000);\n                moduleNotifyKeyspaceEvent((1 << 12), \"loaded\", &keyobj, db->id);\n            }\n            if (server.key_load_delay)\n                debugDelay(server.key_load_delay);\n            expiretime = -1;\n            lfu_freq = -1;\n            lru_idle = -1;\n        }\n    if (rdbver >= 5) {\n        if (<recovery-expr>())\n            goto eoferr;\n        if (server.rdb_checksum && !server.skip_checksum_validation) {\n            ((void)(0));\n            if (<recovery-expr>()) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                    _serverLog(3, \"RDB file was saved with checksum disabled: no check performed.\");\n                } while (0);\n            } else if (<recovery-expr>()) {\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                rdbReportError(1, 3191, \"RDB CRC error\");\n                return -1;\n            }\n        }\n    }\n    if (empty_keys_skipped) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Done loading RDB, keys loaded: %lld, keys expired: %lld, empty keys skipped: %lld.\", server.rdb_last_load_keys_loaded, server.rdb_last_load_keys_expired, empty_keys_skipped);\n        } while (0);\n    } else {\n        do {\n            if (((2) & 255) < server.verbosity)\n                break;\n            _serverLog(2, \"Done loading RDB, keys loaded: %lld, keys expired: %lld.\", server.rdb_last_load_keys_loaded, server.rdb_last_load_keys_expired);\n        } while (0);\n    }\n    return 0;\n  eoferr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Short read or OOM loading DB. Unrecoverable error, aborting now.\");\n    } while (0);\n    rdbReportError(0, 3215, \"Unexpected EOF reading RDB file\");\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#2822:1#rdbFunctionLoad",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    ((void)ver);\n    sds error;\n    sds final_payload;\n    int res = -1;\n    if (<recovery-expr>()) {\n        error = sdsnew(\"Failed loading library payload\");\n        goto done;\n    }\n    if (lib_ctx) {\n        sds library_name;\n        if (!(library_name = functionsCreateWithLibraryCtx(final_payload, rdbflags & (1 << 2), &error, lib_ctx))) {\n            if (!error) {\n                error = sdsnew(\"Failed creating the library\");\n            }\n            goto done;\n        }\n        sdsfree(library_name);\n    }\n    res = 0;\n  done:\n    if (final_payload)\n        sdsfree(final_payload);\n    if (error) {\n        if (err) {\n            *err = error;\n        } else {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n                _serverLog(3, \"Failed creating function, %s\", error);\n            } while (0);\n            sdsfree(error);\n        }\n    }\n    return res;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1750:1#rdbLoadObject",
    "gotos": 11,
    "labels": 1,
    "body": "{\n    robj *o, *ele, *dec;\n    unsigned int i;\n    if (error)\n        *error = 2;\n    int deep_integrity_validation = server.sanitize_dump_payload == 1;\n    if (server.sanitize_dump_payload == 2) {\n        int skip = <recovery-expr>(server) || (server.current_client && (<recovery-expr>(server.current_client) & (1 << 1)));\n        if (!skip && server.current_client && server.current_client->user)\n            skip = !!(<recovery-expr>(server.current_client->user) & (1 << 4));\n        deep_integrity_validation = !skip;\n    }\n    if (rdbtype == 0) {\n        o = tryObjectEncoding(o);\n    } else if (rdbtype == 1) {\n        if (<recovery-expr>())\n            goto emptykey;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_listpack_size, server.list_compress_depth);\n        while (<recovery-expr>())\n            {\n                if (<recovery-expr>()) {\n                    decrRefCount(o);\n                }\n                dec = getDecodedObject(ele);\n                int len(int *);\n                <recovery-expr>()(o->ptr, dec->ptr, <recovery-expr>());\n                decrRefCount(dec);\n                decrRefCount(ele);\n            }\n    } else if (rdbtype == 2) {\n        if (<recovery-expr>())\n            goto emptykey;\n        int max_entries(int *);\n        if (<recovery-expr>() >= 1 << 30)\n            <recovery-expr>() = 1 << 30;\n        if (<recovery-expr>()) {\n            o = createSetObject();\n            if (<recovery-expr>()) {\n                decrRefCount(o);\n            }\n        } else {\n            o = createIntsetObject();\n        }\n    } else if (rdbtype == 5 || rdbtype == 3) {\n        int maxelelen(int *), totelelen(int *);\n        zset *zs;\n        if (<recovery-expr>())\n            goto emptykey;\n        o = createZsetObject();\n        zs = o->ptr;\n        if (<recovery-expr>()) {\n            decrRefCount(o);\n        }\n        while (<recovery-expr>())\n            {\n                sds sdsele;\n                double score;\n                zskiplistNode *znode;\n                if (<recovery-expr>()) {\n                    decrRefCount(o);\n                }\n                if (rdbtype == 5) {\n                    if (rdbLoadBinaryDoubleValue(rdb, &score) == -1) {\n                        decrRefCount(o);\n                        sdsfree(sdsele);\n                    }\n                } else {\n                    if (rdbLoadDoubleValue(rdb, &score) == -1) {\n                        decrRefCount(o);\n                        sdsfree(sdsele);\n                    }\n                }\n                if (isnan(score)) {\n                    rdbReportError(1, 1904, \"Zset with NAN score detected\");\n                    decrRefCount(o);\n                    sdsfree(sdsele);\n                }\n                if (<recovery-expr>()(sdsele) > <recovery-expr>())\n                    <recovery-expr>() = <recovery-expr>()(sdsele);\n                <recovery-expr>() += <recovery-expr>()(sdsele);\n                znode = zslInsert(zs->zsl, score, sdsele);\n                if (dictAdd(zs->dict, sdsele, &znode->score) != 0) {\n                    rdbReportError(1, 1916, \"Duplicate zset fields detected\");\n                    decrRefCount(o);\n                }\n            }\n        if (<recovery-expr>()) {\n            zsetConvert(o, 11);\n        }\n    } else if (rdbtype == 4) {\n        int ret;\n        sds field, value;\n        dict *dupSearchDict;\n        if (<recovery-expr>())\n            goto emptykey;\n        o = createHashObject();\n        if (<recovery-expr>())\n            hashTypeConvert(o, 2);\n        else if (deep_integrity_validation) {\n            dupSearchDict = dictCreate(&hashDictType);\n        }\n        while (<recovery-expr>())\n            {\n                if (<recovery-expr>()) {\n                    decrRefCount(o);\n                    if (dupSearchDict)\n                        dictRelease(dupSearchDict);\n                }\n                if (<recovery-expr>()) {\n                    sdsfree(field);\n                    decrRefCount(o);\n                    if (dupSearchDict)\n                        dictRelease(dupSearchDict);\n                }\n                if (dupSearchDict) {\n                    sds field_dup = sdsdup(field);\n                    if (<recovery-expr>()) {\n                        rdbReportError(1, 1973, \"Hash with dup elements\");\n                        dictRelease(dupSearchDict);\n                        decrRefCount(o);\n                        sdsfree(field_dup);\n                        sdsfree(field);\n                        sdsfree(value);\n                    }\n                }\n                if (<recovery-expr>()(field) > <recovery-expr>(server) || <recovery-expr>()(value) > <recovery-expr>(server) || !lpSafeToAdd(o->ptr, <recovery-expr>()(field) + <recovery-expr>()(value))) {\n                    hashTypeConvert(o, 2);\n                    ret = dictAdd((dict *)o->ptr, field, value);\n                    if (ret == 1) {\n                        rdbReportError(1, 1991, \"Duplicate hash fields detected\");\n                        if (dupSearchDict)\n                            dictRelease(dupSearchDict);\n                        sdsfree(value);\n                        sdsfree(field);\n                        decrRefCount(o);\n                    }\n                    break;\n                }\n                o->ptr = <recovery-expr>()(o->ptr, (unsigned char *)field, <recovery-expr>()(field));\n                o->ptr = <recovery-expr>()(o->ptr, (unsigned char *)value, <recovery-expr>()(value));\n                sdsfree(field);\n                sdsfree(value);\n            }\n        if (dupSearchDict) {\n            dictRelease(dupSearchDict);\n        }\n        if (<recovery-expr>()) {\n            if (<recovery-expr>()) {\n                decrRefCount(o);\n            }\n        }\n        while (<recovery-expr>())\n            {\n                if (<recovery-expr>()) {\n                    decrRefCount(o);\n                }\n                if (<recovery-expr>()) {\n                    sdsfree(field);\n                    decrRefCount(o);\n                }\n                ret = dictAdd((dict *)o->ptr, field, value);\n                if (ret == 1) {\n                    rdbReportError(1, 2041, \"Duplicate hash fields detected\");\n                    sdsfree(value);\n                    sdsfree(field);\n                    decrRefCount(o);\n                }\n            }\n    } else if (rdbtype == 14 || rdbtype == 18) {\n        if (<recovery-expr>())\n            goto emptykey;\n        o = createQuicklistObject();\n        quicklistSetOptions(o->ptr, server.list_max_listpack_size, server.list_compress_depth);\n        while (<recovery-expr>())\n            {\n                unsigned char *lp;\n                int encoded_len(int *);\n                if (rdbtype == 18) {\n                    if (<recovery-expr>()) {\n                        decrRefCount(o);\n                    }\n                    if (<recovery-expr>()) {\n                        rdbReportError(1, 2070, \"Quicklist integrity check failed.\");\n                        decrRefCount(o);\n                    }\n                }\n                unsigned char *data = rdbGenericLoadStringObject(rdb, (1 << 1), &encoded_len);\n                if (<recovery-expr>()) {\n                    zfree(data);\n                    decrRefCount(o);\n                }\n                if (<recovery-expr>()) {\n                    <recovery-expr>()(o->ptr, data, encoded_len);\n                    continue;\n                }\n                if (rdbtype == 18) {\n                    lp = data;\n                    if (deep_integrity_validation)\n                        server.stat_dump_payload_sanitizations++;\n                    if (<recovery-expr>()) {\n                        rdbReportError(1, 2093, \"Listpack integrity check failed.\");\n                        decrRefCount(o);\n                        zfree(lp);\n                    }\n                } else {\n                    lp = lpNew(encoded_len);\n                    if (!<recovery-expr>()(data, encoded_len, 1, _ziplistEntryConvertAndValidate, &lp)) {\n                        rdbReportError(1, 2103, \"Ziplist integrity check failed.\");\n                        decrRefCount(o);\n                        zfree(data);\n                        zfree(lp);\n                    }\n                    zfree(data);\n                    lp = lpShrinkToFit(lp);\n                }\n                if (lpLength(lp) == 0) {\n                    zfree(lp);\n                    continue;\n                } else {\n                    quicklistAppendListpack(o->ptr, lp);\n                }\n            }\n        if (quicklistCount(o->ptr) == 0) {\n            decrRefCount(o);\n            goto emptykey;\n        }\n    } else if (rdbtype == 9 || rdbtype == 10 || rdbtype == 11 || rdbtype == 12 || rdbtype == 17 || rdbtype == 13 || rdbtype == 16) {\n        int encoded_len(int *);\n        unsigned char *encoded = rdbGenericLoadStringObject(rdb, (1 << 1), &encoded_len);\n        o = createObject(0, encoded);\n        switch (rdbtype) {\n          case 9:\n            if (!<recovery-expr>()(encoded, encoded_len, 1)) {\n                rdbReportError(1, 2152, \"Zipmap integrity check failed.\");\n                zfree(encoded);\n                decrRefCount(o);\n            }\n            {\n                unsigned char *lp = lpNew(0);\n                unsigned char *zi = zipmapRewind(o->ptr);\n                unsigned char *fstr, *vstr;\n                unsigned int flen, vlen;\n                unsigned int maxlen = 0;\n                dict *dupSearchDict = dictCreate(&hashDictType);\n                while (<recovery-expr>())\n                    {\n                        if (flen > maxlen)\n                            maxlen = flen;\n                        if (vlen > maxlen)\n                            maxlen = vlen;\n                        sds field = <recovery-expr>()(fstr, flen);\n                        if (<recovery-expr>()) {\n                            rdbReportError(1, 2176, \"Hash zipmap with dup elements, or big length (%u)\", flen);\n                            dictRelease(dupSearchDict);\n                            sdsfree(field);\n                            zfree(encoded);\n                            decrRefCount(o);\n                        }\n                        lp = <recovery-expr>()(lp, fstr, flen);\n                        lp = <recovery-expr>()(lp, vstr, vlen);\n                    }\n                dictRelease(dupSearchDict);\n                zfree(o->ptr);\n                o->ptr = lp;\n                o->type = 4;\n                o->encoding = 11;\n                if (hashTypeLength(o) > <recovery-expr>(server) || maxlen > <recovery-expr>(server)) {\n                    hashTypeConvert(o, 2);\n                }\n            }\n            break;\n          case 10:\n            {\n                quicklist *ql = quicklistNew(server.list_max_listpack_size, server.list_compress_depth);\n                if (!<recovery-expr>()(encoded, encoded_len, 1, _listZiplistEntryConvertAndValidate, ql)) {\n                    rdbReportError(1, 2210, \"List ziplist integrity check failed.\");\n                    zfree(encoded);\n                    decrRefCount(o);\n                    quicklistRelease(ql);\n                }\n                if (ql->len == 0) {\n                    zfree(encoded);\n                    decrRefCount(o);\n                    quicklistRelease(ql);\n                    goto emptykey;\n                }\n                zfree(encoded);\n                o->type = 1;\n                o->ptr = ql;\n                o->encoding = 9;\n                break;\n            }\n          case 11:\n            if (deep_integrity_validation)\n                server.stat_dump_payload_sanitizations++;\n            if (!<recovery-expr>()(encoded, encoded_len, deep_integrity_validation)) {\n                rdbReportError(1, 2235, \"Intset integrity check failed.\");\n                zfree(encoded);\n                decrRefCount(o);\n            }\n            o->type = 2;\n            o->encoding = 6;\n            if (<recovery-expr>()(o->ptr) > <recovery-expr>(server))\n                setTypeConvert(o, 2);\n            break;\n          case 12:\n            {\n                unsigned char *lp = lpNew(encoded_len);\n                if (!ziplistPairsConvertAndValidateIntegrity(encoded, encoded_len, &lp)) {\n                    rdbReportError(1, 2250, \"Zset ziplist integrity check failed.\");\n                    zfree(lp);\n                    zfree(encoded);\n                    decrRefCount(o);\n                }\n                zfree(o->ptr);\n                o->type = 3;\n                o->ptr = lp;\n                o->encoding = 11;\n                if (zsetLength(o) == 0) {\n                    decrRefCount(o);\n                    goto emptykey;\n                }\n                if (zsetLength(o) > <recovery-expr>(server))\n                    zsetConvert(o, 7);\n                else\n                    o->ptr = lpShrinkToFit(o->ptr);\n                break;\n            }\n          case 17:\n            if (deep_integrity_validation)\n                server.stat_dump_payload_sanitizations++;\n            if (!lpPairsValidateIntegrityAndDups(encoded, encoded_len, deep_integrity_validation)) {\n                rdbReportError(1, 2276, \"Zset listpack integrity check failed.\");\n                zfree(encoded);\n                decrRefCount(o);\n            }\n            o->type = 3;\n            o->encoding = 11;\n            if (zsetLength(o) == 0) {\n                decrRefCount(o);\n                goto emptykey;\n            }\n            if (zsetLength(o) > <recovery-expr>(server))\n                zsetConvert(o, 7);\n            break;\n          case 13:\n            {\n                unsigned char *lp = lpNew(encoded_len);\n                if (!ziplistPairsConvertAndValidateIntegrity(encoded, encoded_len, &lp)) {\n                    rdbReportError(1, 2296, \"Hash ziplist integrity check failed.\");\n                    zfree(lp);\n                    zfree(encoded);\n                    decrRefCount(o);\n                }\n                zfree(o->ptr);\n                o->ptr = lp;\n                o->type = 4;\n                o->encoding = 11;\n                if (hashTypeLength(o) == 0) {\n                    decrRefCount(o);\n                    goto emptykey;\n                }\n                if (hashTypeLength(o) > <recovery-expr>(server))\n                    hashTypeConvert(o, 2);\n                else\n                    o->ptr = lpShrinkToFit(o->ptr);\n                break;\n            }\n          case 16:\n            if (deep_integrity_validation)\n                server.stat_dump_payload_sanitizations++;\n            if (!lpPairsValidateIntegrityAndDups(encoded, encoded_len, deep_integrity_validation)) {\n                rdbReportError(1, 2322, \"Hash listpack integrity check failed.\");\n                zfree(encoded);\n                decrRefCount(o);\n            }\n            o->type = 4;\n            o->encoding = 11;\n            if (hashTypeLength(o) == 0) {\n                decrRefCount(o);\n                goto emptykey;\n            }\n            if (hashTypeLength(o) > <recovery-expr>(server))\n                hashTypeConvert(o, 2);\n            break;\n          default:\n            rdbReportError(1, 2340, \"Unknown RDB encoding type %d\", rdbtype);\n            break;\n        }\n    } else if (rdbtype == 15 || rdbtype == 19) {\n        o = createStreamObject();\n        stream *s = o->ptr;\n        if (<recovery-expr>()) {\n            rdbReportError(0, 2348, \"Stream listpacks len loading failed.\");\n            decrRefCount(o);\n        }\n        while (<recovery-expr>())\n            {\n                sds nodekey;\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2359, \"Stream master ID loading failed: invalid encoding or I/O error.\");\n                    decrRefCount(o);\n                }\n                if (<recovery-expr>()(nodekey) != sizeof(streamID)) {\n                    rdbReportError(1, 2365, \"Stream node key entry is not the size of a stream ID\");\n                    sdsfree(nodekey);\n                    decrRefCount(o);\n                }\n                int lp_size(int *);\n                unsigned char *lp = rdbGenericLoadStringObject(rdb, (1 << 1), &lp_size);\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2376, \"Stream listpacks loading failed.\");\n                    sdsfree(nodekey);\n                    decrRefCount(o);\n                }\n                if (deep_integrity_validation)\n                    server.stat_dump_payload_sanitizations++;\n                if (!streamValidateListpackIntegrity(lp, lp_size, deep_integrity_validation)) {\n                    rdbReportError(1, 2383, \"Stream listpack integrity check failed.\");\n                    sdsfree(nodekey);\n                    decrRefCount(o);\n                    zfree(lp);\n                }\n                unsigned char *first = lpFirst(lp);\n                if (<recovery-expr>()) {\n                    rdbReportError(1, 2395, \"Empty listpack inside stream\");\n                    sdsfree(nodekey);\n                    decrRefCount(o);\n                    zfree(lp);\n                }\n                int retval;\n                sdsfree(nodekey);\n                if (!retval) {\n                    rdbReportError(1, 2407, \"Listpack re-added with existing key\");\n                    decrRefCount(o);\n                    zfree(lp);\n                }\n            }\n        if (rdbtype == 19) {\n        } else {\n            <recovery-expr>(s).ms = 0;\n            <recovery-expr>(s).seq = 0;\n            <recovery-expr>(s) = <recovery-expr>(s);\n            streamGetEdgeID(s, 1, 1, &<recovery-expr>(s));\n        }\n        if (rioGetReadError(rdb)) {\n            rdbReportError(0, 2445, \"Stream object metadata loading failed.\");\n            decrRefCount(o);\n        }\n        if (<recovery-expr>(s) && !<recovery-expr>()(s->rax)) {\n            rdbReportError(1, 2451, \"Stream length inconsistent with rax entries\");\n            decrRefCount(o);\n        }\n        if (<recovery-expr>()) {\n            rdbReportError(0, 2459, \"Stream cgroup count loading failed.\");\n            decrRefCount(o);\n        }\n        while (<recovery-expr>())\n            {\n                streamID cg_id;\n                sds cgname;\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2471, \"Error reading the consumer group name from Stream\");\n                    decrRefCount(o);\n                }\n                if (rioGetReadError(rdb)) {\n                    rdbReportError(0, 2479, \"Stream cgroup ID loading failed.\");\n                    sdsfree(cgname);\n                    decrRefCount(o);\n                }\n                if (rdbtype == 19) {\n                    if (rioGetReadError(rdb)) {\n                        rdbReportError(0, 2490, \"Stream cgroup offset loading failed.\");\n                        sdsfree(cgname);\n                        decrRefCount(o);\n                    }\n                } else {\n                }\n                streamCG *cgroup;\n                if (<recovery-expr>()) {\n                    rdbReportError(1, 2502, \"Duplicated consumer group name %s\", cgname);\n                    decrRefCount(o);\n                    sdsfree(cgname);\n                }\n                sdsfree(cgname);\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2516, \"Stream PEL size loading failed.\");\n                    decrRefCount(o);\n                }\n                while (<recovery-expr>())\n                    {\n                        unsigned char rawid[1];\n                        if (<recovery-expr>()(rdb, rawid, sizeof (rawid)) == 0) {\n                            rdbReportError(0, 2523, \"Stream PEL ID loading failed.\");\n                            decrRefCount(o);\n                        }\n                        streamNACK *nack;\n                        nack->delivery_time = rdbLoadMillisecondTime(rdb, 10);\n                        if (rioGetReadError(rdb)) {\n                            rdbReportError(0, 2531, \"Stream PEL NACK loading failed.\");\n                            decrRefCount(o);\n                            streamFreeNACK(nack);\n                        }\n                        if (<recovery-expr>()) {\n                            rdbReportError(1, 2538, \"Duplicated global PEL entry loading stream consumer group\");\n                            decrRefCount(o);\n                            streamFreeNACK(nack);\n                        }\n                    }\n                if (<recovery-expr>()) {\n                    rdbReportError(0, 2549, \"Stream consumers num loading failed.\");\n                    decrRefCount(o);\n                }\n                while (<recovery-expr>())\n                    {\n                        sds cname;\n                        if (<recovery-expr>()) {\n                            rdbReportError(0, 2557, \"Error reading the consumer name from Stream group.\");\n                            decrRefCount(o);\n                        }\n                        streamConsumer *consumer;\n                        sdsfree(cname);\n                        if (!consumer) {\n                            rdbReportError(1, 2565, \"Duplicate stream consumer detected.\");\n                            decrRefCount(o);\n                        }\n                        consumer->seen_time = rdbLoadMillisecondTime(rdb, 10);\n                        if (rioGetReadError(rdb)) {\n                            rdbReportError(0, 2571, \"Stream short read reading seen time.\");\n                            decrRefCount(o);\n                        }\n                        if (<recovery-expr>()) {\n                            rdbReportError(0, 2581, \"Stream consumer PEL num loading failed.\");\n                            decrRefCount(o);\n                        }\n                        while (<recovery-expr>())\n                            {\n                                unsigned char rawid[1];\n                                if (<recovery-expr>()(rdb, rawid, sizeof (rawid)) == 0) {\n                                    rdbReportError(0, 2589, \"Stream short read reading PEL streamID.\");\n                                    decrRefCount(o);\n                                }\n                                streamNACK *nack = <recovery-expr>()(cgroup->pel, rawid, sizeof (rawid));\n                                if (nack == raxNotFound) {\n                                    rdbReportError(1, 2596, \"Consumer entry not found in group global PEL\");\n                                    decrRefCount(o);\n                                }\n                                nack->consumer = consumer;\n                                if (<recovery-expr>()) {\n                                    rdbReportError(1, 2608, \"Duplicated consumer PEL entry  loading a stream consumer group\");\n                                    decrRefCount(o);\n                                    streamFreeNACK(nack);\n                                }\n                            }\n                    }\n                if (deep_integrity_validation) {\n                    raxIterator ri_cg_pel;\n                    raxStart(&ri_cg_pel, cgroup->pel);\n                    while (raxNext(&ri_cg_pel))\n                        {\n                            streamNACK *nack = ri_cg_pel.data;\n                            if (!nack->consumer) {\n                                raxStop(&ri_cg_pel);\n                                rdbReportError(1, 2625, \"Stream CG PEL entry without consumer\");\n                                decrRefCount(o);\n                            }\n                        }\n                    raxStop(&ri_cg_pel);\n                }\n            }\n    } else if (rdbtype == 6) {\n        rdbReportError(1, 2634, \"Pre-release module format not supported\");\n    } else if (rdbtype == 7) {\n        if (rioGetReadError(rdb)) {\n            rdbReportError(0, 2639, \"Short read module id\");\n        }\n        moduleType *mt;\n        if (rdbCheckMode) {\n            char name[10];\n            return rdbLoadCheckModuleValue(rdb, name);\n        }\n        if (<recovery-expr>()) {\n            char name[10];\n            rdbReportError(1, 2653, \"The RDB file contains module data I can't load: no matching module type '%s'\", name);\n        }\n        RedisModuleIO io;\n        robj keyobj;\n        do {\n            keyobj.type = 0;\n            keyobj.encoding = 0;\n            keyobj.ptr = key;\n        } while (0);\n        do {\n            io.rio = rdb;\n            io.type = mt;\n            <recovery-expr>(io) = 0;\n            io.error = 0;\n            io.key = &keyobj;\n            io.dbid = dbid;\n        } while (0);\n        void *ptr;\n        if (io.ctx) {\n            moduleFreeContext(io.ctx);\n            zfree(io.ctx);\n        }\n        if (<recovery-expr>()) {\n            if (ptr) {\n                o = createModuleObject(mt, ptr);\n                decrRefCount(o);\n            }\n        }\n        if (<recovery-expr>()) {\n            rdbReportError(1, 2679, \"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker\", moduleTypeModuleName(mt));\n            if (ptr) {\n                o = createModuleObject(mt, ptr);\n                decrRefCount(o);\n            }\n        }\n        if (<recovery-expr>()) {\n            rdbReportError(1, 2690, \"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.\", moduleTypeModuleName(mt));\n        }\n        o = createModuleObject(mt, ptr);\n    } else {\n        rdbReportError(0, 2695, \"Unknown RDB encoding type %d\", rdbtype);\n    }\n    if (error)\n        *error = 0;\n    return o;\n  emptykey:\n    if (error)\n        *error = 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1346:1#rdbSaveRio",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    char magic[10];\n    long key_counter = 0;\n    int j;\n    if (server.rdb_checksum)\n        rdb->update_cksum = <recovery-expr>();\n    snprintf(magic, sizeof (magic), \"REDIS%04d\", 10);\n    if (<recovery-expr>()(rdb, magic, 9) == -1)\n        goto werr;\n    if (rdbSaveInfoAuxFields(rdb, rdbflags, rsi) == -1)\n        goto werr;\n    if (!(req & (1 << 0)) && <recovery-expr>()(rdb, (1 << 0)) == -1)\n        goto werr;\n    if (!(req & (1 << 1)) && <recovery-expr>()(rdb) == -1)\n        goto werr;\n    if (!(req & (1 << 0))) {\n        for (j = 0; j < server.dbnum; j++) {\n            if (<recovery-expr>()(rdb, j, rdbflags, &key_counter) == -1)\n                goto werr;\n        }\n    }\n    if (!(req & (1 << 0)) && <recovery-expr>()(rdb, (1 << 1)) == -1)\n        goto werr;\n    if (rdbSaveType(rdb, 255) == -1)\n        goto werr;\n    ((void)(0));\n    if (<recovery-expr>())\n        goto werr;\n    return 0;\n  werr:\n    ;\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1249:1#rdbSaveFunctions",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    dict *functions = functionsLibGet();\n    dictIterator *iter = dictGetIterator(functions);\n    dictEntry *entry;\n    while ((entry = dictNext(iter)))\n        {\n            if (<recovery-expr>())\n                goto werr;\n            functionLibInfo *li = (<recovery-expr>((entry)).val);\n            if (<recovery-expr>())\n                goto werr;\n        }\n    dictReleaseIterator(iter);\n  werr:\n    dictReleaseIterator(iter);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#384:1#rdbLoadLzfStringObject",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int plain = flags & (1 << 1);\n    int sds = flags & (1 << 2);\n    unsigned char *c;\n    char *val;\n    if (<recovery-expr>()) {\n        do {\n            if (<recovery-expr>())\n                break;\n        } while (0);\n        goto err;\n    }\n    if (plain) {\n    } else {\n    }\n    if (!val) {\n        do {\n            if (<recovery-expr>())\n                break;\n        } while (0);\n        goto err;\n    }\n    if (<recovery-expr>())\n        goto err;\n    if (<recovery-expr>()) {\n        rdbReportError(1, 414, \"Invalid LZF compressed string\");\n        goto err;\n    }\n    zfree(c);\n    if (plain || sds) {\n        return val;\n    } else {\n        return createObject(0, val);\n    }\n  err:\n    zfree(c);\n    if (plain)\n        zfree(val);\n    else\n        sdsfree(val);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#338:1#rdbSaveLzfBlob",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    unsigned char byte;\n    byte = (3 << 6) | 3;\n    if (<recovery-expr>())\n        goto writeerr;\n    if (<recovery-expr>())\n        goto writeerr;\n    if (<recovery-expr>())\n        goto writeerr;\n    if (<recovery-expr>())\n        goto writeerr;\n  writeerr:\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1416:1#rdbSave",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    char tmpfile[256];\n    char cwd;\n    rio rdb;\n    int error = 0;\n    char *err_op;\n    snprintf(tmpfile, 256, \"temp-%d.rdb\", (int)getpid());\n    if (<recovery-expr>()) {\n        char *str_err;\n        char *cwdp;\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Failed opening the temp RDB file %s (in server root dir %s) for saving: %s\", tmpfile, cwdp ? cwdp : \"unknown\", str_err);\n        } while (0);\n        return -1;\n    }\n    startSaving(0);\n    if (server.rdb_save_incremental_fsync)\n        <recovery-expr>()(&rdb, (1024 * 1024 * 4));\n    if (rdbSaveRio(req, &rdb, &error, 0, rsi) == -1) {\n        err_op = \"rdbSaveRio\";\n        goto werr;\n    }\n    if (<recovery-expr>()) {\n        err_op = \"fflush\";\n        goto werr;\n    }\n    if (<recovery-expr>()) {\n        err_op = \"fsync\";\n        goto werr;\n    }\n    if (<recovery-expr>()) {\n        err_op = \"fclose\";\n        goto werr;\n    }\n    if (rename(tmpfile, filename) == -1) {\n        char *str_err;\n        char *cwdp;\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n            _serverLog(3, \"Error moving temp DB file %s on the final destination %s (in server root dir %s): %s\", tmpfile, filename, cwdp ? cwdp : \"unknown\", str_err);\n        } while (0);\n        unlink(tmpfile);\n        stopSaving(0);\n        return -1;\n    }\n    if (fsyncFileDir(filename) == -1) {\n        err_op = \"fsyncFileDir\";\n        goto werr;\n    }\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"DB saved on disk\");\n    } while (0);\n    server.dirty = 0;\n    server.lastbgsave_status = 0;\n    stopSaving(1);\n    return 0;\n  werr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n    } while (0);\n    unlink(tmpfile);\n    stopSaving(0);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1186:1#rdbSaveSingleModuleAux",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    RedisModuleIO io;\n    int retval = 0;\n    do {\n        io.rio = rdb;\n        io.type = mt;\n        <recovery-expr>(io) = 0;\n        io.error = 0;\n        io.dbid = -1;\n    } while (0);\n    rio aux_save_headers_rio;\n    rioInitWithBuffer(&aux_save_headers_rio, sdsempty());\n    if (rdbSaveType(&aux_save_headers_rio, 247) == -1)\n        goto error;\n    if (<recovery-expr>()(&aux_save_headers_rio, <recovery-expr>(mt)) == -1)\n        goto error;\n    if (<recovery-expr>()(&aux_save_headers_rio, 2) == -1)\n        goto error;\n    if (<recovery-expr>()(&aux_save_headers_rio, when) == -1)\n        goto error;\n    if (mt->aux_save2) {\n        io.pre_flush_buffer = <recovery-expr>(aux_save_headers_rio).buffer.ptr;\n        mt->aux_save2(&io, when);\n        if (io.pre_flush_buffer) {\n            sdsfree(io.pre_flush_buffer);\n            return 0;\n        }\n    } else {\n        retval = <recovery-expr>()(rdb, <recovery-expr>(aux_save_headers_rio).buffer.ptr, <recovery-expr>()(<recovery-expr>(aux_save_headers_rio).buffer.ptr));\n        if (retval == -1)\n            goto error;\n        <recovery-expr>(io) += retval;\n        sdsfree(<recovery-expr>(aux_save_headers_rio).buffer.ptr);\n        mt->aux_save(&io, when);\n    }\n    retval = <recovery-expr>()(rdb, 0);\n    ((!io.pre_flush_buffer) ? (void)0 : (_serverAssert(\"!io.pre_flush_buffer\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c\", 1231) , __builtin_unreachable()));\n    if (retval == -1)\n        io.error = 1;\n    else\n        <recovery-expr>(io) += retval;\n    if (io.ctx) {\n        moduleFreeContext(io.ctx);\n        zfree(io.ctx);\n    }\n    if (io.error)\n        return -1;\n    return <recovery-expr>(io);\n  error:\n    sdsfree(<recovery-expr>(aux_save_headers_rio).buffer.ptr);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1394:1#rdbSaveRioWithEOFMark",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    char eofmark[40];\n    startSaving((1 << 1));\n    getRandomHexChars(eofmark, 40);\n    if (error)\n        *error = 0;\n    if (<recovery-expr>()(rdb, \"$EOF:\", 5) == 0)\n        goto werr;\n    if (<recovery-expr>()(rdb, eofmark, 40) == 0)\n        goto werr;\n    if (<recovery-expr>()(rdb, \"\\r\\n\", 2) == 0)\n        goto werr;\n    if (rdbSaveRio(req, rdb, error, 0, rsi) == -1)\n        goto werr;\n    if (<recovery-expr>()(rdb, eofmark, 40) == 0)\n        goto werr;\n    stopSaving(1);\n    return 0;\n  werr:\n    ;\n    stopSaving(0);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/rdb.c#1270:1#rdbSaveDb",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    dictIterator *di;\n    dictEntry *de;\n    static long long info_updated_time = 0;\n    char *pname = (rdbflags & (1 << 0)) ? \"AOF rewrite\" : \"RDB\";\n    redisDb *db = server.db + dbid;\n    dict *d = db->dict;\n    if (((d)->ht_used[0] + (d)->ht_used[1]) == 0)\n        return 0;\n    di = dictGetSafeIterator(d);\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    if (<recovery-expr>())\n        goto werr;\n    while (<recovery-expr>())\n        {\n            sds keystr = ((de)->key);\n            robj key, *o = (<recovery-expr>((de)).val);\n            long long expire;\n            int rdb_bytes_before_key(int *);\n            do {\n                key.type = 0;\n                key.encoding = 0;\n                key.ptr = keystr;\n            } while (0);\n            expire = getExpire(db, &key);\n            if (<recovery-expr>())\n                goto werr;\n            int dump_size(int *);\n            if (server.in_fork_child)\n                dismissObject(o, <recovery-expr>());\n            if (((*key_counter)++ & 1023) == 0) {\n                long long now = mstime();\n                if (now - info_updated_time >= 1000) {\n                    sendChildInfo(CHILD_INFO_TYPE_CURRENT_INFO, *key_counter, pname);\n                    info_updated_time = now;\n                }\n            }\n        }\n    dictReleaseIterator(di);\n  werr:\n    dictReleaseIterator(di);\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#3122:1#xclaimCommand",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    streamCG *group;\n    robj *o = lookupKeyRead(c->db, c->argv[1]);\n    long long minidle;\n    long long retrycount = -1;\n    mstime_t deliverytime = -1;\n    int force = 0;\n    int justid = 0;\n    if (o) {\n        if (checkType(c, o, 6))\n            return;\n        group = streamLookupCG(o->ptr, c->argv[2]->ptr);\n    }\n    if (<recovery-expr>()) {\n        addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer group '%s'\", (char *)c->argv[1]->ptr, (char *)c->argv[2]->ptr);\n        return;\n    }\n    if (getLongLongFromObjectOrReply(c, c->argv[4], &minidle, \"Invalid min-idle-time argument for XCLAIM\") != 0)\n        return;\n    if (minidle < 0)\n        minidle = 0;\n    int j;\n    streamID static_ids[8];\n    streamID *ids = static_ids;\n    int id_count = c->argc - 5;\n    if (id_count > 8)\n        ids = <recovery-expr>()(sizeof(streamID) * id_count);\n    for (j = 5; j < c->argc; j++) {\n        if (<recovery-expr>())\n            break;\n    }\n    int last_id_arg = j - 1;\n    mstime_t now = commandTimeSnapshot();\n    streamID last_id = <recovery-expr>({0, 0});\n    int propagate_last_id = 0;\n    for (; j < c->argc; j++) {\n        int moreargs = (c->argc - 1) - j;\n        char *opt = c->argv[j]->ptr;\n        if (!strcasecmp(opt, \"FORCE\")) {\n            force = 1;\n        } else if (!strcasecmp(opt, \"JUSTID\")) {\n            justid = 1;\n        } else if (!strcasecmp(opt, \"IDLE\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c, c->argv[j], &deliverytime, \"Invalid IDLE option argument for XCLAIM\") != 0)\n                goto cleanup;\n            deliverytime = now - deliverytime;\n        } else if (!strcasecmp(opt, \"TIME\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c, c->argv[j], &deliverytime, \"Invalid TIME option argument for XCLAIM\") != 0)\n                goto cleanup;\n        } else if (!strcasecmp(opt, \"RETRYCOUNT\") && moreargs) {\n            j++;\n            if (getLongLongFromObjectOrReply(c, c->argv[j], &retrycount, \"Invalid RETRYCOUNT option argument for XCLAIM\") != 0)\n                goto cleanup;\n        } else if (!strcasecmp(opt, \"LASTID\") && moreargs) {\n            j++;\n            if (<recovery-expr>())\n                goto cleanup;\n        } else {\n            addReplyErrorFormat(c, \"Unrecognized XCLAIM option '%s'\", opt);\n            goto cleanup;\n        }\n    }\n    if (streamCompareID(&last_id, &<recovery-expr>(group)) > 0) {\n        <recovery-expr>(group) = last_id;\n        propagate_last_id = 1;\n    }\n    if (deliverytime != -1) {\n        if (deliverytime < 0 || deliverytime > now)\n            deliverytime = now;\n    } else {\n        deliverytime = now;\n    }\n    streamConsumer *consumer;\n    void *arraylenptr = addReplyDeferredLen(c);\n    int arraylen(int *);\n    sds name = c->argv[3]->ptr;\n    for (int j = 5; j <= last_id_arg; j++) {\n        streamID id = ids[j - 5];\n        unsigned char buf[1];\n        streamEncodeID(buf, &id);\n        streamNACK *nack = <recovery-expr>()(group->pel, buf, sizeof (buf));\n        if (!streamEntryExists(o->ptr, &id)) {\n            if (nack != raxNotFound) {\n                streamPropagateXCLAIM(c, c->argv[1], group, c->argv[2], c->argv[j], nack);\n                propagate_last_id = 0;\n                server.dirty++;\n                streamFreeNACK(nack);\n            }\n            continue;\n        }\n        if (force && nack == raxNotFound) {\n        }\n        if (nack != raxNotFound) {\n            if (nack->consumer && minidle) {\n                mstime_t this_idle = now - nack->delivery_time;\n                if (this_idle < minidle)\n                    continue;\n            }\n            if (<recovery-expr>()) {\n                consumer = streamCreateConsumer(group, name, c->argv[1], c->db->id, 0);\n            }\n            if (nack->consumer != consumer) {\n            }\n            nack->delivery_time = deliverytime;\n            if (retrycount >= 0) {\n                <recovery-expr>(nack) = retrycount;\n            } else if (!justid) {\n                <recovery-expr>(nack)++;\n            }\n            if (nack->consumer != consumer) {\n                nack->consumer = consumer;\n            }\n            if (justid) {\n                addReplyStreamID(c, &id);\n            } else {\n            }\n            <recovery-expr>()++;\n            streamPropagateXCLAIM(c, c->argv[1], group, c->argv[2], c->argv[j], nack);\n            propagate_last_id = 0;\n            server.dirty++;\n        }\n    }\n    if (propagate_last_id) {\n        streamPropagateGroupID(c, c->argv[1], group, c->argv[2]);\n        server.dirty++;\n    }\n    setDeferredArrayLen(c, arraylenptr, <recovery-expr>());\n    preventCommandPropagation(c);\n  cleanup:\n    if (ids != static_ids)\n        zfree(ids);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#2823:1#xackCommand",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    streamCG *group;\n    robj *o = lookupKeyRead(c->db, c->argv[1]);\n    if (o) {\n        if (checkType(c, o, 6))\n            return;\n        group = streamLookupCG(o->ptr, c->argv[2]->ptr);\n    }\n    if (<recovery-expr>()) {\n        addReply(c, shared.czero);\n        return;\n    }\n    streamID static_ids[8];\n    streamID *ids = static_ids;\n    int id_count = c->argc - 3;\n    if (id_count > 8)\n        ids = <recovery-expr>()(sizeof(streamID) * id_count);\n    for (int j = 3; j < c->argc; j++) {\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    int acknowledged = 0;\n    for (int j = 3; j < c->argc; j++) {\n        unsigned char buf[1];\n        streamEncodeID(buf, &ids[j - 3]);\n        streamNACK *nack = <recovery-expr>()(group->pel, buf, sizeof (buf));\n        if (nack != raxNotFound) {\n            streamFreeNACK(nack);\n            acknowledged++;\n            server.dirty++;\n        }\n    }\n    addReplyLongLong(c, acknowledged);\n  cleanup:\n    if (ids != static_ids)\n        zfree(ids);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#2167:1#xreadCommand",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    long long timeout = -1;\n    long long count = 0;\n    int streams_count = 0;\n    int streams_arg = 0;\n    int noack = 0;\n    streamID static_ids[8];\n    streamID *ids = static_ids;\n    streamCG **groups;\n    int xreadgroup = <recovery-expr>()(c->argv[0]->ptr) == 10;\n    robj *groupname;\n    robj *consumername;\n    for (int i = 1; i < c->argc; i++) {\n        int moreargs = c->argc - i - 1;\n        char *o = c->argv[i]->ptr;\n        if (!strcasecmp(o, \"BLOCK\") && moreargs) {\n            if (<recovery-expr>(c) & (1 << 8)) {\n                addReplyErrorFormat(c, \"%s command is not allowed with BLOCK option from scripts\", (char *)c->argv[0]->ptr);\n                return;\n            }\n            i++;\n            if (getTimeoutFromObjectOrReply(c, c->argv[i], &timeout, 1) != 0)\n                return;\n        } else if (!strcasecmp(o, \"COUNT\") && moreargs) {\n            i++;\n            if (<recovery-expr>())\n                return;\n            if (count < 0)\n                count = 0;\n        } else if (!strcasecmp(o, \"STREAMS\") && moreargs) {\n            streams_arg = i + 1;\n            streams_count = (c->argc - streams_arg);\n            if ((streams_count % 2) != 0) {\n                addReplyError(c, \"Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified.\");\n                return;\n            }\n            streams_count /= 2;\n            break;\n        } else if (!strcasecmp(o, \"GROUP\") && moreargs >= 2) {\n            if (!xreadgroup) {\n                addReplyError(c, \"The GROUP option is only supported by XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            groupname = c->argv[i + 1];\n            consumername = c->argv[i + 2];\n            i += 2;\n        } else if (!strcasecmp(o, \"NOACK\")) {\n            if (!xreadgroup) {\n                addReplyError(c, \"The NOACK option is only supported by XREADGROUP. You called XREAD instead.\");\n                return;\n            }\n            noack = 1;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n    if (streams_arg == 0) {\n        addReplyErrorObject(c, shared.syntaxerr);\n        return;\n    }\n    if (<recovery-expr>()) {\n        addReplyError(c, \"Missing GROUP option for XREADGROUP\");\n        return;\n    }\n    if (streams_count > 8)\n        ids = <recovery-expr>()(sizeof(streamID) * streams_count);\n    if (groupname)\n        groups = <recovery-expr>()(sizeof(streamCG *) * streams_count);\n    for (int i = streams_arg + streams_count; i < c->argc; i++) {\n        int id_idx = i - streams_arg - streams_count;\n        robj *key = c->argv[i - streams_count];\n        robj *o = lookupKeyRead(c->db, key);\n        if (checkType(c, o, 6))\n            goto cleanup;\n        streamCG *group;\n        if (groupname) {\n            if (<recovery-expr>()) {\n                addReplyErrorFormat(c, \"-NOGROUP No such key '%s' or consumer group '%s' in XREADGROUP with GROUP option\", (char *)key->ptr, (char *)groupname->ptr);\n                goto cleanup;\n            }\n            groups[id_idx] = group;\n        }\n        if (strcmp(c->argv[i]->ptr, \"$\") == 0) {\n            if (xreadgroup) {\n                addReplyError(c, \"The $ ID is meaningless in the context of XREADGROUP: you want to read the history of this consumer by specifying a proper ID, or use the > ID to get new messages. The $ ID would just return an empty result set.\");\n                goto cleanup;\n            }\n            if (o) {\n                stream *s = o->ptr;\n                ids[id_idx] = <recovery-expr>(s);\n            } else {\n                <recovery-expr>(ids[id_idx]) = 0;\n                <recovery-expr>(ids[id_idx]) = 0;\n            }\n            continue;\n        } else if (strcmp(c->argv[i]->ptr, \">\") == 0) {\n            if (!xreadgroup) {\n                addReplyError(c, \"The > ID can be specified only when calling XREADGROUP using the GROUP <group> <consumer> option.\");\n                goto cleanup;\n            }\n            continue;\n        }\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    int arraylen(int *);\n    void *arraylen_ptr;\n    for (int i = 0; i < streams_count; i++) {\n        robj *o = lookupKeyRead(c->db, c->argv[streams_arg + i]);\n        if (<recovery-expr>())\n            continue;\n        stream *s = o->ptr;\n        streamID *gt = ids + i;\n        int serve_synchronously = 0;\n        int serve_history = 0;\n        if (groups) {\n            if (<recovery-expr>()) {\n                serve_synchronously = 1;\n                serve_history = 1;\n            } else if (<recovery-expr>(s)) {\n                streamID maxid, *last = &<recovery-expr>(groups[i]);\n                streamLastValidID(s, &maxid);\n                if (streamCompareID(&maxid, last) > 0) {\n                    serve_synchronously = 1;\n                    *gt = *last;\n                }\n            }\n        } else if (<recovery-expr>(s)) {\n            streamID maxid;\n            streamLastValidID(s, &maxid);\n            if (streamCompareID(&maxid, gt) > 0) {\n                serve_synchronously = 1;\n            }\n        }\n        if (serve_synchronously) {\n            <recovery-expr>()++;\n            if (<recovery-expr>() == 1)\n                arraylen_ptr = addReplyDeferredLen(c);\n            streamID start = *gt;\n            streamIncrID(&start);\n            if (c->resp == 2)\n                addReplyArrayLen(c, 2);\n            addReplyBulk(c, c->argv[streams_arg + i]);\n            streamConsumer *consumer;\n            streamPropInfo spi = {c->argv[i + streams_arg], groupname};\n            if (groups) {\n                consumer = streamLookupConsumer(groups[i], consumername->ptr, 0);\n                if (<recovery-expr>()) {\n                    consumer = streamCreateConsumer(groups[i], consumername->ptr, c->argv[streams_arg + i], c->db->id, 0);\n                    if (noack)\n                        streamPropagateConsumerCreation(c, spi.keyname, spi.groupname, consumer->name);\n                }\n            }\n            int flags = 0;\n            if (noack)\n                flags |= (1 << 0);\n            if (serve_history)\n                flags |= (1 << 2);\n            if (groups)\n                server.dirty++;\n        }\n    }\n    if (<recovery-expr>()) {\n        if (c->resp == 2)\n            setDeferredArrayLen(c, arraylen_ptr, <recovery-expr>());\n        else\n            setDeferredMapLen(c, arraylen_ptr, <recovery-expr>());\n        goto cleanup;\n    }\n    if (timeout != -1) {\n        if (<recovery-expr>(c) & (1ULL << 41)) {\n            addReplyNullArray(c);\n            goto cleanup;\n        }\n        <recovery-expr>(c).xread_count = count ? count : 1000;\n        if (groupname) {\n            incrRefCount(groupname);\n            incrRefCount(consumername);\n            <recovery-expr>(c).xread_group = groupname;\n            <recovery-expr>(c).xread_consumer = consumername;\n            <recovery-expr>(c).xread_group_noack = noack;\n        } else {\n        }\n        goto cleanup;\n    }\n    addReplyNullArray(c);\n  cleanup:\n    preventCommandPropagation(c);\n    if (ids != static_ids)\n        zfree(ids);\n    zfree(groups);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#1879:1#streamGenericParseIDOrReply",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    char buf[128];\n    if (<recovery-expr>()(o->ptr) > sizeof (buf) - 1)\n        goto invalid;\n    memcpy(buf, o->ptr, <recovery-expr>()(o->ptr) + 1);\n    if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\\x00')\n        goto invalid;\n    if (<recovery-expr>()) {\n        *seq_given = 1;\n    }\n    if (buf[0] == '-' && buf[1] == '\\x00') {\n        <recovery-expr>(id) = 0;\n        <recovery-expr>(id) = 0;\n        return 0;\n    } else if (buf[0] == '+' && buf[1] == '\\x00') {\n        return 0;\n    }\n    unsigned long long ms, seq;\n    char *dot = strchr(buf, '-');\n    if (dot)\n        *dot = '\\x00';\n    if (string2ull(buf, &ms) == 0)\n        goto invalid;\n    if (dot) {\n        int seqlen(int *);\n        if (<recovery-expr>()) {\n            seq = 0;\n            *seq_given = 0;\n        } else if (string2ull(dot + 1, &seq) == 0) {\n            goto invalid;\n        }\n    } else {\n        seq = <recovery-expr>();\n    }\n    <recovery-expr>(id) = ms;\n    <recovery-expr>(id) = seq;\n    return 0;\n  invalid:\n    if (c)\n        addReplyError(c, \"Invalid stream ID specified as stream command argument\");\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/t_stream.c#3518:1#xdelCommand",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    robj *o;\n    if (<recovery-expr>())\n        return;\n    stream *s = o->ptr;\n    streamID static_ids[8];\n    streamID *ids = static_ids;\n    int id_count = c->argc - 2;\n    if (id_count > 8)\n        ids = <recovery-expr>()(sizeof(streamID) * id_count);\n    for (int j = 2; j < c->argc; j++) {\n        if (<recovery-expr>())\n            goto cleanup;\n    }\n    int deleted = 0;\n    int first_entry = 0;\n    for (int j = 2; j < c->argc; j++) {\n        streamID *id = &ids[j - 2];\n        if (streamDeleteItem(s, id)) {\n            if (streamCompareID(id, &<recovery-expr>(s)) == 0) {\n                first_entry = 1;\n            }\n            if (streamCompareID(id, &<recovery-expr>(s)) > 0) {\n                <recovery-expr>(s) = *id;\n            }\n            deleted++;\n        }\n        ;\n    }\n    if (deleted) {\n        if (<recovery-expr>(s) == 0) {\n            <recovery-expr>(s).ms = 0;\n            <recovery-expr>(s).seq = 0;\n        } else if (first_entry) {\n            streamGetEdgeID(s, 1, 1, &<recovery-expr>(s));\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c, c->db, c->argv[1]);\n        notifyKeyspaceEvent((1 << 10), \"xdel\", c->argv[1], c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c, deleted);\n  cleanup:\n    if (ids != static_ids)\n        zfree(ids);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/setproctitle.c#275:1#setproctitle",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    char buf[256];\n    char *nul;\n    int len, error;\n    if (!SPT.base)\n        return;\n    if (fmt) {\n    } else {\n        len = snprintf(buf, sizeof buf, \"%s\", SPT.arg0);\n    }\n    if (len <= 0) {\n        goto error;\n    }\n    if (!SPT.reset) {\n        memset(SPT.base, 0, SPT.end - SPT.base);\n        SPT.reset = 1;\n    } else {\n        memset(SPT.base, 0, <recovery-expr>()(sizeof buf, SPT.end - SPT.base));\n    }\n    len = <recovery-expr>()(len, <recovery-expr>()(sizeof buf, SPT.end - SPT.base) - 1);\n    memcpy(SPT.base, buf, len);\n    nul = &SPT.base[len];\n    if (nul < SPT.nul) {\n        *SPT.nul = '.';\n    } else if (nul == SPT.nul && &nul[1] < SPT.end) {\n        *SPT.nul = ' ';\n        *++nul = '\\x00';\n    }\n    return;\n  error:\n    SPT.error = error;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/setproctitle.c#191:1#spt_init",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    char **envp = environ;\n    char *base, *end, *nul, *tmp;\n    int i, error, envc;\n    if (!(base = argv[0]))\n        return;\n    nul = &base[strlen(base)];\n    end = nul + 1;\n    for (i = 0; i < argc || (i >= argc && argv[i]); i++) {\n        if (!argv[i] || argv[i] < end)\n            continue;\n        if (end >= argv[i] && end <= argv[i] + strlen(argv[i]))\n            end = argv[i] + strlen(argv[i]) + 1;\n    }\n    for (i = 0; envp[i]; i++) {\n        if (envp[i] < end)\n            continue;\n        if (end >= envp[i] && end <= envp[i] + strlen(envp[i]))\n            end = envp[i] + strlen(envp[i]) + 1;\n    }\n    envc = i;\n    if (!(SPT.arg0 = strdup(argv[0])))\n        goto syerr;\n    if (!(tmp = strdup(getprogname())))\n        goto syerr;\n    setprogname(tmp);\n    if ((error = spt_copyenv(envc, envp)))\n        goto error;\n    if ((error = spt_copyargs(argc, argv)))\n        goto error;\n    SPT.nul = nul;\n    SPT.base = base;\n    SPT.end = end;\n    return;\n  syerr:\n    ;\n  error:\n    SPT.error = error;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/net.c#363:1#_redisContextConnectTcp",
    "gotos": 4,
    "labels": 3,
    "body": "{\n    redisFD s;\n    int rv, n;\n    char _port[6];\n    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;\n    int blocking = (c->flags & 1);\n    int reuseaddr = (c->flags & 128);\n    int reuses = 0;\n    long timeout_msec = -1;\n    c->connection_type = REDIS_CONN_TCP;\n    c->tcp.port = port;\n    if (c->tcp.host != addr) {\n        hi_free(c->tcp.host);\n        c->tcp.host = hi_strdup(addr);\n        if (<recovery-expr>())\n            goto oom;\n    }\n    if (timeout) {\n        if (redisContextUpdateConnectTimeout(c, timeout) == -1)\n            goto oom;\n    } else {\n        hi_free(c->connect_timeout);\n    }\n    if (redisContextTimeoutMsec(c, &timeout_msec) != 0) {\n        __redisSetError(c, 1, \"Invalid timeout specified\");\n        goto error;\n    }\n    if (<recovery-expr>()) {\n        hi_free(c->tcp.source_addr);\n    } else if (c->tcp.source_addr != source_addr) {\n        hi_free(c->tcp.source_addr);\n        c->tcp.source_addr = hi_strdup(source_addr);\n    }\n    snprintf(_port, 6, \"%d\", port);\n    memset(&<recovery-expr>(), 0, sizeof (<recovery-expr>()));\n    if ((rv = getaddrinfo(c->tcp.host, _port, &<recovery-expr>(), &servinfo)) != 0) {\n        if ((rv = getaddrinfo(addr, _port, &<recovery-expr>(), &servinfo)) != 0) {\n            __redisSetError(c, 2, gai_strerror(rv));\n            return -1;\n        }\n    }\n    if (<recovery-expr>()) {\n        char buf[128];\n        __redisSetError(c, 2, buf);\n        goto error;\n    }\n  oom:\n    __redisSetError(c, 5, \"Out of memory\");\n  error:\n    rv = -1;\n  end:\n    if (servinfo) {\n        freeaddrinfo(servinfo);\n    }\n    return rv;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/deps/hiredis/net.c#547:1#redisContextConnectUnix",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int blocking = (c->flags & 1);\n    struct sockaddr_un *sa;\n    long timeout_msec = -1;\n    if (<recovery-expr>())\n        return -1;\n    if (redisSetBlocking(c, 0) != 0)\n        return -1;\n    c->connection_type = REDIS_CONN_UNIX;\n    if (c->unix_sock.path != path) {\n        hi_free(c->unix_sock.path);\n        c->unix_sock.path = hi_strdup(path);\n        if (<recovery-expr>())\n            goto oom;\n    }\n    if (timeout) {\n        if (redisContextUpdateConnectTimeout(c, timeout) == -1)\n            goto oom;\n    } else {\n        hi_free(c->connect_timeout);\n    }\n    if (redisContextTimeoutMsec(c, &timeout_msec) != 0)\n        return -1;\n    if (c->saddr)\n        hi_free(c->saddr);\n    if (<recovery-expr>())\n        goto oom;\n    strncpy(<recovery-expr>(sa), path, sizeof (<recovery-expr>(sa)) - 1);\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n        } else {\n            if (redisContextWaitReady(c, timeout_msec) != 0)\n                return -1;\n        }\n    }\n    if (blocking && redisSetBlocking(c, 1) != 0)\n        return -1;\n    c->flags |= 2;\n    return 0;\n  oom:\n    __redisSetError(c, 5, \"Out of memory\");\n    return -1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#5857:1#RM_Call",
    "gotos": 13,
    "labels": 1,
    "body": "{\n    client *c;\n    robj **argv;\n    int argc = 0, flags = 0;\n    RedisModuleCallReply *reply;\n    int replicate = 0;\n    int error_as_call_replies = 0;\n    replicate = flags & (1 << 0);\n    error_as_call_replies = flags & (1 << 8);\n    user *user;\n    if (flags & (1 << 5)) {\n        user = ctx->user ? ctx->user->user : ctx->client->user;\n        if (!user) {\n            if (error_as_call_replies) {\n                sds msg = sdsnew(\"cannot run as user, no user directly attached to context or context's client\");\n                reply = callReplyCreateError(msg, ctx);\n            }\n            return reply;\n        }\n    }\n    c = moduleAllocTempClient(user);\n    <recovery-expr>(c) |= (1ULL << 41);\n    c->db = ctx->client->db;\n    c->argv = argv;\n    c->argc = c->argv_len = argc;\n    c->resp = 2;\n    if (flags & (1 << 3)) {\n        c->resp = 3;\n    } else if (flags & (1 << 4)) {\n        c->resp = ctx->client->resp;\n    }\n    if (ctx->module)\n        ctx->module->in_call++;\n    if (<recovery-expr>()) {\n        goto cleanup;\n    }\n    moduleCallCommandFilters(c);\n    c->cmd = c->lastcmd = c->realcmd = lookupCommand(c->argv, c->argc);\n    sds err;\n    if (<recovery-expr>()) {\n        if (error_as_call_replies)\n            reply = callReplyCreateError(err, ctx);\n        goto cleanup;\n    }\n    if (<recovery-expr>()) {\n        if (error_as_call_replies)\n            reply = callReplyCreateError(err, ctx);\n        goto cleanup;\n    }\n    if (flags & (1 << 6)) {\n        if (<recovery-expr>()) {\n            if (error_as_call_replies) {\n                sds msg = sdscatfmt(sdsempty(), \"command '%S' is not allowed on script mode\", c->cmd->fullname);\n                reply = callReplyCreateError(msg, ctx);\n            }\n            goto cleanup;\n        }\n    }\n    if (flags & (1 << 9) && server.maxmemory) {\n        if (<recovery-expr>()) {\n            int oom_state;\n            if (ctx->flags & (1 << 4)) {\n            } else {\n                oom_state = server.pre_command_oom_state;\n            }\n            if (oom_state) {\n                if (error_as_call_replies) {\n                    sds msg = sdsdup(shared.oomerr->ptr);\n                    reply = callReplyCreateError(msg, ctx);\n                }\n                goto cleanup;\n            }\n        }\n    } else {\n        <recovery-expr>(c) |= (1ULL << 44);\n    }\n    if (flags & (1 << 7)) {\n        if (<recovery-expr>()) {\n            if (error_as_call_replies) {\n                sds msg = sdscatfmt(sdsempty(), \"Write command '%S' was called while write is not allowed.\", c->cmd->fullname);\n                reply = callReplyCreateError(msg, ctx);\n            }\n            goto cleanup;\n        }\n    }\n    if (flags & (1 << 6)) {\n        if (<recovery-expr>()) {\n            if (!checkGoodReplicasStatus()) {\n                if (error_as_call_replies) {\n                    sds msg = sdsdup(shared.noreplicaserr->ptr);\n                    reply = callReplyCreateError(msg, ctx);\n                }\n                goto cleanup;\n            }\n            int deny_write_type = writeCommandsDeniedByDiskError();\n            int obey_client = (server.current_client && mustObeyClient(server.current_client));\n            if (deny_write_type != 0 && !obey_client) {\n                if (error_as_call_replies) {\n                    sds msg = writeCommandsGetDiskErrorMessage(deny_write_type);\n                    reply = callReplyCreateError(msg, ctx);\n                }\n                goto cleanup;\n            }\n            if (server.masterhost && server.repl_slave_ro && !obey_client) {\n                if (error_as_call_replies) {\n                    sds msg = sdsdup(shared.roslaveerr->ptr);\n                    reply = callReplyCreateError(msg, ctx);\n                }\n                goto cleanup;\n            }\n        }\n        if (<recovery-expr>()) {\n            if (error_as_call_replies) {\n                sds msg = sdsdup(shared.masterdownerr->ptr);\n                reply = callReplyCreateError(msg, ctx);\n            }\n            goto cleanup;\n        }\n    }\n    if (flags & (1 << 5)) {\n        int acl_errpos;\n        int acl_retval;\n        acl_retval = ACLCheckAllUserCommandPerm(user, c->cmd, c->argv, c->argc, &acl_errpos);\n        if (acl_retval != 0) {\n            sds object = (acl_retval == 1) ? sdsdup(c->cmd->fullname) : sdsdup(c->argv[acl_errpos]->ptr);\n            addACLLogEntry(ctx->client, acl_retval, 3, -1, ctx->client->user->name, object);\n            if (error_as_call_replies) {\n                sds acl_msg = getAclErrorMessage(acl_retval, ctx->client->user, c->cmd, c->argv[acl_errpos]->ptr, 0);\n                sds msg = sdscatfmt(sdsempty(), \"-NOPERM %S\\r\\n\", acl_msg);\n                sdsfree(acl_msg);\n                reply = callReplyCreateError(msg, ctx);\n            }\n            goto cleanup;\n        }\n    }\n    if (server.cluster_enabled && !mustObeyClient(ctx->client)) {\n        int error_code;\n        <recovery-expr>(c) &= ~((1 << 17) | (1 << 9));\n        <recovery-expr>(c) |= <recovery-expr>(ctx->client) & ((1 << 17) | (1 << 9));\n        if (<recovery-expr>()) {\n            sds msg;\n            if (error_code == 7) {\n                if (error_as_call_replies) {\n                    msg = sdscatfmt(sdsempty(), \"Can not execute a write command '%S' while the cluster is down and readonly\", c->cmd->fullname);\n                }\n            } else if (error_code == 5) {\n                if (error_as_call_replies) {\n                    msg = sdscatfmt(sdsempty(), \"Can not execute a command '%S' while the cluster is down\", c->cmd->fullname);\n                }\n            } else {\n                if (error_as_call_replies) {\n                    msg = sdsnew(\"Attempted to access a non local key in a cluster node\");\n                }\n            }\n            if (msg) {\n                reply = callReplyCreateError(msg, ctx);\n            }\n            goto cleanup;\n        }\n    }\n    if (flags & (1 << 10)) {\n        goto cleanup;\n    }\n    int prev_replication_allowed = server.replication_allowed;\n    server.replication_allowed = replicate && server.replication_allowed;\n    int call_flags = (1 << 0) | (1 << 1) | (1 << 4);\n    if (replicate) {\n        if (!(flags & (1 << 1)))\n            call_flags |= (1 << 2);\n        if (!(flags & (1 << 2)))\n            call_flags |= (1 << 3);\n    }\n    call(c, call_flags);\n    server.replication_allowed = prev_replication_allowed;\n    (((<recovery-expr>(c) & (1 << 4)) == 0) ? (void)0 : (_serverAssert(\"(c->flags & CLIENT_BLOCKED) == 0\", \"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c\", 6123) , __builtin_unreachable()));\n    sds proto = <recovery-expr>()(c->buf, c->bufpos);\n    c->bufpos = 0;\n    while (((c->reply)->len))\n        {\n            clientReplyBlock *o = ((((c->reply)->head))->value);\n            proto = <recovery-expr>()(proto, o->buf, <recovery-expr>(o));\n            listDelNode(c->reply, ((c->reply)->head));\n        }\n    reply = callReplyCreate(proto, c->deferred_reply_errors, ctx);\n  cleanup:\n    if (reply)\n        autoMemoryAdd(ctx, 2, reply);\n    if (ctx->module)\n        ctx->module->in_call--;\n    moduleReleaseTempClient(c);\n    return reply;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6837:1#RM_LoadFloat",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (io->error)\n        return 0;\n    if (<recovery-expr>())\n        goto loaderr;\n    float value;\n    int retval = rdbLoadBinaryFloatValue(io->rio, &value);\n    if (retval == -1)\n        goto loaderr;\n    return value;\n  loaderr:\n    moduleRDBLoadError(io);\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6801:1#RM_LoadDouble",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (io->error)\n        return 0;\n    if (<recovery-expr>())\n        goto loaderr;\n    double value;\n    int retval = rdbLoadBinaryDoubleValue(io->rio, &value);\n    if (retval == -1)\n        goto loaderr;\n    return value;\n  loaderr:\n    moduleRDBLoadError(io);\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6650:1#RM_SaveUnsigned",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    if (io->error)\n        return;\n    if (flushRedisModuleIOBuffer(io) == -1)\n        goto saveerr;\n    int retval = <recovery-expr>()(io->rio, 2);\n    if (retval == -1)\n        goto saveerr;\n    <recovery-expr>(io) += retval;\n    retval = <recovery-expr>()(io->rio, <recovery-expr>());\n    if (retval == -1)\n        goto saveerr;\n    <recovery-expr>(io) += retval;\n    return;\n  saveerr:\n    io->error = 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#5695:1#moduleCreateArgvFromUserFormat",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int argc = 0, argv_size, j;\n    robj **argv;\n    argv_size = strlen(fmt) + 1;\n    argv = <recovery-expr>()(argv, sizeof(robj *) * argv_size);\n    argv[0] = createStringObject(cmdname, strlen(cmdname));\n    argc++;\n    const char *p = fmt;\n    while (*p)\n        {\n            if (*p == 'c') {\n                char *cstr;\n                argv[argc++] = createStringObject(cstr, strlen(cstr));\n            } else if (*p == 's') {\n                robj *obj;\n                if (<recovery-expr>())\n                    obj = createStringObject(obj->ptr, <recovery-expr>()(obj->ptr));\n                else\n                    incrRefCount(obj);\n                argv[argc++] = obj;\n            } else if (*p == 'b') {\n                char *buf;\n                int len(int *);\n                argv[argc++] = createStringObject(buf, <recovery-expr>());\n            } else if (*p == 'l') {\n                long long ll;\n                argv[argc++] = createObject(0, sdsfromlonglong(ll));\n            } else if (*p == 'v') {\n                robj **v;\n                int vlen(int *);\n                argv_size += <recovery-expr>() - 1;\n                argv = <recovery-expr>()(argv, sizeof(robj *) * argv_size);\n                int i(int *);\n                for (<recovery-expr>() = 0; <recovery-expr>() < <recovery-expr>(); <recovery-expr>()++) {\n                    incrRefCount(v[<recovery-expr>()]);\n                    argv[argc++] = v[<recovery-expr>()];\n                }\n            } else if (*p == '!') {\n                if (flags)\n                    (*flags) |= (1 << 0);\n            } else if (*p == 'A') {\n                if (flags)\n                    (*flags) |= (1 << 1);\n            } else if (*p == 'R') {\n                if (flags)\n                    (*flags) |= (1 << 2);\n            } else if (*p == '3') {\n                if (flags)\n                    (*flags) |= (1 << 3);\n            } else if (*p == '0') {\n                if (flags)\n                    (*flags) |= (1 << 4);\n            } else if (*p == 'C') {\n                if (flags)\n                    (*flags) |= (1 << 5);\n            } else if (*p == 'S') {\n                if (flags)\n                    (*flags) |= (1 << 6);\n            } else if (*p == 'W') {\n                if (flags)\n                    (*flags) |= (1 << 7);\n            } else if (*p == 'M') {\n                if (flags)\n                    (*flags) |= (1 << 9);\n            } else if (*p == 'E') {\n                if (flags)\n                    (*flags) |= (1 << 8);\n            } else if (*p == 'D') {\n                if (flags)\n                    (*flags) |= ((1 << 10) | (1 << 8));\n            } else {\n                goto fmterr;\n            }\n            p++;\n        }\n    if (argcp)\n        *argcp = argc;\n    return argv;\n  fmterr:\n    for (j = 0; j < argc; j++)\n        decrRefCount(argv[j]);\n    zfree(argv);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6741:1#moduleLoadString",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (<recovery-expr>())\n        goto loaderr;\n    void *s = rdbGenericLoadStringObject(io->rio, plain ? (1 << 1) : 0, lenptr);\n    if (<recovery-expr>())\n        goto loaderr;\n    return s;\n  loaderr:\n    moduleRDBLoadError(io);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6670:1#RM_LoadUnsigned",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    if (io->error)\n        return 0;\n    if (<recovery-expr>())\n        goto loaderr;\n    int retval;\n    if (retval == -1)\n        goto loaderr;\n  loaderr:\n    moduleRDBLoadError(io);\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6782:1#RM_SaveDouble",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    if (io->error)\n        return;\n    if (flushRedisModuleIOBuffer(io) == -1)\n        goto saveerr;\n    int retval = <recovery-expr>()(io->rio, 4);\n    if (retval == -1)\n        goto saveerr;\n    <recovery-expr>(io) += retval;\n    retval = rdbSaveBinaryDoubleValue(io->rio, value);\n    if (retval == -1)\n        goto saveerr;\n    <recovery-expr>(io) += retval;\n    return;\n  saveerr:\n    io->error = 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6818:1#RM_SaveFloat",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    if (io->error)\n        return;\n    if (flushRedisModuleIOBuffer(io) == -1)\n        goto saveerr;\n    int retval = <recovery-expr>()(io->rio, 3);\n    if (retval == -1)\n        goto saveerr;\n    <recovery-expr>(io) += retval;\n    retval = rdbSaveBinaryFloatValue(io->rio, value);\n    if (retval == -1)\n        goto saveerr;\n    <recovery-expr>(io) += retval;\n    return;\n  saveerr:\n    io->error = 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6723:1#RM_SaveStringBuffer",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    if (io->error)\n        return;\n    if (flushRedisModuleIOBuffer(io) == -1)\n        goto saveerr;\n    if (<recovery-expr>())\n        goto saveerr;\n    if (<recovery-expr>())\n        goto saveerr;\n    return;\n  saveerr:\n    io->error = 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/module.c#6704:1#RM_SaveString",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    if (io->error)\n        return;\n    if (flushRedisModuleIOBuffer(io) == -1)\n        goto saveerr;\n    if (<recovery-expr>())\n        goto saveerr;\n    if (<recovery-expr>())\n        goto saveerr;\n    return;\n  saveerr:\n    io->error = 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/cluster.c#6273:1#migrateCommand",
    "gotos": 6,
    "labels": 2,
    "body": "{\n    migrateCachedSocket *cs;\n    int copy = 0, replace = 0, j;\n    char *username;\n    char *password;\n    long timeout;\n    long dbid;\n    robj **ov;\n    robj **kv;\n    robj **newargv;\n    rio cmd, payload;\n    int may_retry = 1;\n    int write_error = 0;\n    int argv_rewritten = 0;\n    int first_key = 3;\n    int num_keys = 1;\n    for (j = 6; j < c->argc; j++) {\n        int moreargs = (c->argc - 1) - j;\n        if (!strcasecmp(c->argv[j]->ptr, \"copy\")) {\n            copy = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr, \"replace\")) {\n            replace = 1;\n        } else if (!strcasecmp(c->argv[j]->ptr, \"auth\")) {\n            if (!moreargs) {\n                addReplyErrorObject(c, shared.syntaxerr);\n                return;\n            }\n            j++;\n            password = c->argv[j]->ptr;\n            redactClientCommandArgument(c, j);\n        } else if (!strcasecmp(c->argv[j]->ptr, \"auth2\")) {\n            if (moreargs < 2) {\n                addReplyErrorObject(c, shared.syntaxerr);\n                return;\n            }\n            username = c->argv[++j]->ptr;\n            redactClientCommandArgument(c, j);\n            password = c->argv[++j]->ptr;\n            redactClientCommandArgument(c, j);\n        } else if (!strcasecmp(c->argv[j]->ptr, \"keys\")) {\n            if (<recovery-expr>()(c->argv[3]->ptr) != 0) {\n                addReplyError(c, \"When using MIGRATE KEYS option, the key argument must be set to the empty string\");\n                return;\n            }\n            first_key = j + 1;\n            num_keys = c->argc - j - 1;\n            break;\n        } else {\n            addReplyErrorObject(c, shared.syntaxerr);\n            return;\n        }\n    }\n    if (<recovery-expr>()) {\n        return;\n    }\n    if (timeout <= 0)\n        timeout = 1000;\n    ov = <recovery-expr>()(ov, sizeof(robj *) * num_keys);\n    kv = <recovery-expr>()(kv, sizeof(robj *) * num_keys);\n    int oi = 0;\n    for (j = 0; j < num_keys; j++) {\n        if (<recovery-expr>()) {\n            kv[oi] = c->argv[first_key + j];\n            oi++;\n        }\n    }\n    num_keys = oi;\n    if (num_keys == 0) {\n        zfree(ov);\n        zfree(kv);\n        addReplySds(c, sdsnew(\"+NOKEY\\r\\n\"));\n        return;\n    }\n  try_again:\n    write_error = 0;\n    cs = migrateGetSocket(c, c->argv[1], c->argv[2], timeout);\n    if (<recovery-expr>()) {\n        zfree(ov);\n        zfree(kv);\n        return;\n    }\n    rioInitWithBuffer(&cmd, sdsempty());\n    if (password) {\n        int arity = username ? 3 : 2;\n        if (username) {\n        }\n    }\n    int select = cs->last_dbid != dbid;\n    if (select) {\n    }\n    int non_expired = 0;\n    for (j = 0; j < num_keys; j++) {\n        long long ttl = 0;\n        long long expireat = getExpire(c->db, kv[j]);\n        if (expireat != -1) {\n            ttl = expireat - commandTimeSnapshot();\n            if (ttl < 0) {\n                continue;\n            }\n            if (ttl < 1)\n                ttl = 1;\n        }\n        ov[non_expired] = ov[j];\n        kv[non_expired++] = kv[j];\n        createDumpPayload(&payload, ov[j], kv[j], dbid);\n        sdsfree(<recovery-expr>(payload).buffer.ptr);\n    }\n    num_keys = non_expired;\n    {\n        sds buf = <recovery-expr>(cmd).buffer.ptr;\n        int pos(int *), towrite(int *);\n        int nwritten = 0;\n        while ((towrite = <recovery-expr>()(buf) - <recovery-expr>()) > 0)\n            {\n                <recovery-expr>(towrite, (towrite > (64 * 1024) ? (64 * 1024) : towrite));\n                nwritten = <recovery-expr>()(cs->conn, buf + <recovery-expr>(), towrite, timeout);\n                if (nwritten != (int)towrite) {\n                    write_error = 1;\n                    goto socket_err;\n                }\n                <recovery-expr>() += nwritten;\n            }\n    }\n    char buf0[1024];\n    char buf1[1024];\n    char buf2[1024];\n    if (password && <recovery-expr>()(cs->conn, buf0, sizeof (buf0), timeout) <= 0)\n        goto socket_err;\n    if (select && <recovery-expr>()(cs->conn, buf1, sizeof (buf1), timeout) <= 0)\n        goto socket_err;\n    int error_from_target = 0;\n    int socket_error = 0;\n    int del_idx = 1;\n    if (!copy)\n        newargv = <recovery-expr>()(sizeof(robj *) * (num_keys + 1));\n    for (j = 0; j < num_keys; j++) {\n        if (<recovery-expr>()(cs->conn, buf2, sizeof (buf2), timeout) <= 0) {\n            socket_error = 1;\n            break;\n        }\n        if ((password && buf0[0] == '-') || (select && buf1[0] == '-') || buf2[0] == '-') {\n            if (!error_from_target) {\n                cs->last_dbid = -1;\n                char *errbuf;\n                if (password && buf0[0] == '-')\n                    errbuf = buf0;\n                else if (select && buf1[0] == '-')\n                    errbuf = buf1;\n                else\n                    errbuf = buf2;\n                error_from_target = 1;\n                addReplyErrorFormat(c, \"Target instance replied with error: %s\", errbuf + 1);\n            }\n        } else {\n            if (!copy) {\n                dbDelete(c->db, kv[j]);\n                signalModifiedKey(c, c->db, kv[j]);\n                notifyKeyspaceEvent((1 << 2), \"del\", kv[j], c->db->id);\n                server.dirty++;\n                newargv[del_idx++] = kv[j];\n                incrRefCount(kv[j]);\n            }\n        }\n    }\n    if (<recovery-expr>()) {\n        goto socket_err;\n    }\n    if (socket_error)\n        migrateCloseSocket(c->argv[1], c->argv[2]);\n    if (!copy) {\n        if (del_idx > 1) {\n            newargv[0] = createStringObject(\"DEL\", 3);\n            replaceClientCommandVector(c, del_idx, newargv);\n            argv_rewritten = 1;\n        } else {\n            zfree(newargv);\n        }\n    }\n    if (!error_from_target && socket_error) {\n        may_retry = 0;\n        goto socket_err;\n    }\n    if (!error_from_target) {\n        cs->last_dbid = dbid;\n        addReply(c, shared.ok);\n    } else {\n    }\n    sdsfree(<recovery-expr>(cmd).buffer.ptr);\n    zfree(ov);\n    zfree(kv);\n    zfree(newargv);\n    return;\n  socket_err:\n    sdsfree(<recovery-expr>(cmd).buffer.ptr);\n    if (!argv_rewritten)\n        migrateCloseSocket(c->argv[1], c->argv[2]);\n    zfree(newargv);\n    if (<recovery-expr>()) {\n        may_retry = 0;\n        goto try_again;\n    }\n    zfree(ov);\n    zfree(kv);\n    addReplyErrorSds(c, sdscatprintf(sdsempty(), \"-IOERR error or timeout %s to target instance\", write_error ? \"writing\" : \"reading\"));\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/cluster.c#424:1#clusterSaveConfig",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    sds ci, tmpfilename;\n    int content_size(int *), offset(int *);\n    int fd = -1;\n    int retval = -1;\n    server.cluster->todo_before_sleep &= ~(1 << 2);\n    ci = clusterGenNodesDescription(32, 0);\n    ci = sdscatprintf(ci, \"vars currentEpoch %llu lastVoteEpoch %llu\\n\", (unsigned long long)<recovery-expr>(server.cluster), (unsigned long long)<recovery-expr>(server.cluster));\n    content_size = <recovery-expr>()(ci);\n    tmpfilename = sdscatfmt(sdsempty(), \"%s.tmp-%i-%I\", server.cluster_configfile, (int)getpid(), mstime());\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    while (<recovery-expr>() < content_size)\n        {\n            if (<recovery-expr>()) {\n                if (<recovery-expr>())\n                    continue;\n                do {\n                    if (((3) & 255) < server.verbosity)\n                        break;\n                } while (0);\n                goto cleanup;\n            }\n        }\n    if (do_fsync) {\n        server.cluster->todo_before_sleep &= ~(1 << 3);\n        if (<recovery-expr>()) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto cleanup;\n        }\n    }\n    if (rename(tmpfilename, server.cluster_configfile) == -1) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        goto cleanup;\n    }\n    if (do_fsync) {\n        if (fsyncFileDir(server.cluster_configfile) == -1) {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            goto cleanup;\n        }\n    }\n    retval = 0;\n  cleanup:\n    if (fd != -1)\n        close(fd);\n    if (retval)\n        unlink(tmpfilename);\n    sdsfree(tmpfilename);\n    sdsfree(ci);\n    return retval;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/cluster.c#148:1#clusterLoadConfig",
    "gotos": 10,
    "labels": 1,
    "body": "{\n    struct stat sb;\n    char *line;\n    int maxline, j;\n    if (<recovery-expr>()) {\n        if (<recovery-expr>()) {\n            return -1;\n        } else {\n            do {\n                if (((3) & 255) < server.verbosity)\n                    break;\n            } while (0);\n            exit(1);\n        }\n    }\n    if (<recovery-expr>()) {\n        do {\n            if (((3) & 255) < server.verbosity)\n                break;\n        } while (0);\n        exit(1);\n    }\n    if (<recovery-expr>().st_size == 0) {\n        return -1;\n    }\n    maxline = 1024 + 16384 * 128;\n    line = <recovery-expr>()(maxline);\n    while (<recovery-expr>())\n        {\n            int argc;\n            sds *argv;\n            clusterNode *n, *master;\n            char *p, *s;\n            if (line[0] == '\\n' || line[0] == '\\x00')\n                continue;\n            argv = sdssplitargs(line, &argc);\n            if (<recovery-expr>())\n                goto fmterr;\n            if (strcasecmp(argv[0], \"vars\") == 0) {\n                if (!(argc % 2))\n                    goto fmterr;\n                for (j = 1; j < argc; j += 2) {\n                    if (strcasecmp(argv[j], \"currentEpoch\") == 0) {\n                    } else if (strcasecmp(argv[j], \"lastVoteEpoch\") == 0) {\n                    } else {\n                        do {\n                            if (((3) & 255) < server.verbosity)\n                                break;\n                            _serverLog(3, \"Skipping unknown cluster config variable '%s'\", argv[j]);\n                        } while (0);\n                    }\n                }\n                sdsfreesplitres(argv, argc);\n                continue;\n            }\n            if (argc < 8) {\n                sdsfreesplitres(argv, argc);\n                goto fmterr;\n            }\n            if (verifyClusterNodeId(argv[0], <recovery-expr>()(argv[0])) == -1) {\n                sdsfreesplitres(argv, argc);\n                goto fmterr;\n            }\n            n = clusterLookupNode(argv[0], <recovery-expr>()(argv[0]));\n            if (!n) {\n                n = createClusterNode(argv[0], 0);\n                clusterAddNode(n);\n            }\n            char *hostname = strchr(argv[1], ',');\n            if (hostname) {\n                *hostname = '\\x00';\n                hostname++;\n                n->hostname = sdscpy(n->hostname, hostname);\n            } else if (<recovery-expr>()(n->hostname) != 0) {\n                sdsclear(n->hostname);\n            }\n            if (<recovery-expr>()) {\n                sdsfreesplitres(argv, argc);\n                goto fmterr;\n            }\n            *p = '\\x00';\n            memcpy(n->ip, argv[1], strlen(argv[1]) + 1);\n            char *port = p + 1;\n            char *busp = strchr(port, '@');\n            if (busp) {\n                *busp = '\\x00';\n                busp++;\n            }\n            n->port = atoi(port);\n            n->cport = busp ? atoi(busp) : n->port + 10000;\n            p = s = argv[2];\n            while (p)\n                {\n                    p = strchr(s, ',');\n                    if (p)\n                        *p = '\\x00';\n                    if (!strcasecmp(s, \"myself\")) {\n                        myself = server.cluster->myself = n;\n                        n->flags |= 16;\n                    } else if (!strcasecmp(s, \"master\")) {\n                        n->flags |= 1;\n                    } else if (!strcasecmp(s, \"slave\")) {\n                        n->flags |= 2;\n                    } else if (!strcasecmp(s, \"fail?\")) {\n                        n->flags |= 4;\n                    } else if (!strcasecmp(s, \"fail\")) {\n                        n->flags |= 8;\n                        n->fail_time = mstime();\n                    } else if (!strcasecmp(s, \"handshake\")) {\n                        n->flags |= 32;\n                    } else if (!strcasecmp(s, \"noaddr\")) {\n                        n->flags |= 64;\n                    } else if (!strcasecmp(s, \"nofailover\")) {\n                        n->flags |= 512;\n                    } else if (!strcasecmp(s, \"noflags\")) {\n                    } else {\n                        _serverPanic(\"/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/redis/src/cluster.c\", 302, \"Unknown flag in redis cluster config file\") , __builtin_unreachable();\n                    }\n                    if (p)\n                        s = p + 1;\n                }\n            if (argv[3][0] != '-') {\n                if (verifyClusterNodeId(argv[3], <recovery-expr>()(argv[3])) == -1) {\n                    sdsfreesplitres(argv, argc);\n                    goto fmterr;\n                }\n                master = clusterLookupNode(argv[3], <recovery-expr>()(argv[3]));\n                if (!master) {\n                    master = createClusterNode(argv[3], 0);\n                    clusterAddNode(master);\n                }\n                n->slaveof = master;\n                clusterNodeAddSlave(master, n);\n            }\n            if (atoi(argv[4]))\n                n->ping_sent = mstime();\n            if (atoi(argv[5]))\n                n->pong_received = mstime();\n            for (j = 8; j < argc; j++) {\n                int start, stop;\n                if (argv[j][0] == '[') {\n                    int slot;\n                    char direction;\n                    clusterNode *cn;\n                    p = strchr(argv[j], '-');\n                    *p = '\\x00';\n                    direction = p[1];\n                    slot = atoi(argv[j] + 1);\n                    if (slot < 0 || slot >= 16384) {\n                        sdsfreesplitres(argv, argc);\n                        goto fmterr;\n                    }\n                    p += 3;\n                    char *pr = strchr(p, ']');\n                    int node_len(int *);\n                    if (<recovery-expr>()) {\n                        sdsfreesplitres(argv, argc);\n                        goto fmterr;\n                    }\n                    cn = clusterLookupNode(p, 40);\n                    if (!cn) {\n                        cn = createClusterNode(p, 0);\n                        clusterAddNode(cn);\n                    }\n                    if (direction == '>') {\n                        server.cluster->migrating_slots_to[slot] = cn;\n                    } else {\n                        server.cluster->importing_slots_from[slot] = cn;\n                    }\n                    continue;\n                } else if (<recovery-expr>()) {\n                    *p = '\\x00';\n                    start = atoi(argv[j]);\n                    stop = atoi(p + 1);\n                } else {\n                    start = stop = atoi(argv[j]);\n                }\n                if (start < 0 || start >= 16384 || stop < 0 || stop >= 16384) {\n                    sdsfreesplitres(argv, argc);\n                    goto fmterr;\n                }\n                while (start <= stop)\n                    clusterAddSlot(n, start++);\n            }\n            sdsfreesplitres(argv, argc);\n        }\n    if (<recovery-expr>())\n        goto fmterr;\n    zfree(line);\n    do {\n        if (((2) & 255) < server.verbosity)\n            break;\n        _serverLog(2, \"Node configuration loaded, I'm %.40s\", myself->name);\n    } while (0);\n    if (<recovery-expr>()() > <recovery-expr>(server.cluster)) {\n        <recovery-expr>(server.cluster) = <recovery-expr>()();\n    }\n    return 0;\n  fmterr:\n    do {\n        if (((3) & 255) < server.verbosity)\n            break;\n        _serverLog(3, \"Unrecoverable error: corrupted cluster config file.\");\n    } while (0);\n    zfree(line);\n    exit(1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/../tool/lemon.c#2793:1#eval_preprocessor_boolean",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    int neg = 0;\n    int res = 0;\n    int okTerm = 1;\n    int i;\n    for (i = 0; z[i] != 0; i++) {\n        if (isspace((unsigned char)(z[i])))\n            continue;\n        if (z[i] == '!') {\n            if (!okTerm)\n                goto pp_syntax_error;\n            neg = !neg;\n            continue;\n        }\n        if (z[i] == '|' && z[i + 1] == '|') {\n            if (okTerm)\n                goto pp_syntax_error;\n            if (res)\n                return 1;\n            i++;\n            okTerm = 1;\n            continue;\n        }\n        if (z[i] == '&' && z[i + 1] == '&') {\n            if (okTerm)\n                goto pp_syntax_error;\n            if (!res)\n                return 0;\n            i++;\n            okTerm = 1;\n            continue;\n        }\n        if (z[i] == '(') {\n            int k;\n            int n = 1;\n            if (!okTerm)\n                goto pp_syntax_error;\n            for (k = i + 1; z[k]; k++) {\n                if (z[k] == ')') {\n                    n--;\n                    if (n == 0) {\n                        z[k] = 0;\n                        res = eval_preprocessor_boolean(&z[i + 1], -1);\n                        z[k] = ')';\n                        if (res < 0) {\n                            i = i - res;\n                            goto pp_syntax_error;\n                        }\n                        i = k;\n                        break;\n                    }\n                } else if (z[k] == '(') {\n                    n++;\n                } else if (z[k] == 0) {\n                    i = k;\n                    goto pp_syntax_error;\n                }\n            }\n            if (neg) {\n                res = !res;\n                neg = 0;\n            }\n            okTerm = 0;\n            continue;\n        }\n        if (isalpha((unsigned char)(z[i]))) {\n            int j, k, n;\n            if (!okTerm)\n                goto pp_syntax_error;\n            for (k = i + 1; isalnum((unsigned char)(z[k])) || z[k] == '_'; k++) {\n            }\n            n = k - i;\n            res = 0;\n            for (j = 0; j < nDefine; j++) {\n                if (strncmp(azDefine[j], &z[i], n) == 0 && azDefine[j][n] == 0) {\n                    res = 1;\n                    break;\n                }\n            }\n            i = k - 1;\n            if (neg) {\n                res = !res;\n                neg = 0;\n            }\n            okTerm = 0;\n            continue;\n        }\n        goto pp_syntax_error;\n    }\n    return res;\n  pp_syntax_error:\n    if (lineno > 0) {\n        exit(1);\n    } else {\n        return -(i + 1);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#199033:1#jsonSetFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    int bApnd;\n    int bIsSet = sqlite3_user_data(ctx) != 0;\n    if (argc < 1)\n        return;\n    if ((argc & 1) == 0) {\n        jsonWrongNumArgs(ctx, bIsSet ? \"set\" : \"insert\");\n        return;\n    }\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    assert(x.nNode);\n    for (i = 1; i < (u32)argc; i += 2) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        bApnd = 0;\n        pNode = jsonLookup(&x, zPath, &bApnd, ctx);\n        if (x.oom) {\n            sqlite3_result_error_nomem(ctx);\n            goto jsonSetDone;\n        } else if (x.nErr) {\n            goto jsonSetDone;\n        } else if (pNode && (bApnd || bIsSet)) {\n            ;\n            assert(pNode->eU != 3 && pNode->eU != 5);\n            ;\n            pNode->jnFlags |= (u8)8;\n            pNode->u.iReplace = i + 1;\n        }\n    }\n    if (x.aNode[0].jnFlags & 8) {\n        assert(x.aNode[0].eU == 4);\n        sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);\n    } else {\n        jsonReturnJson(x.aNode, ctx, argv);\n    }\n  jsonSetDone:\n    jsonParseReset(&x);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#198981:1#jsonReplaceFunc",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    if (argc < 1)\n        return;\n    if ((argc & 1) == 0) {\n        jsonWrongNumArgs(ctx, \"replace\");\n        return;\n    }\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    assert(x.nNode);\n    for (i = 1; i < (u32)argc; i += 2) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        pNode = jsonLookup(&x, zPath, 0, ctx);\n        if (x.nErr)\n            goto replace_err;\n        if (pNode) {\n            assert(pNode->eU == 0 || pNode->eU == 1 || pNode->eU == 4);\n            ;\n            pNode->jnFlags |= (u8)8;\n            ;\n            pNode->u.iReplace = i + 1;\n        }\n    }\n    if (x.aNode[0].jnFlags & 8) {\n        assert(x.aNode[0].eU == 4);\n        sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);\n    } else {\n        jsonReturnJson(x.aNode, ctx, argv);\n    }\n  replace_err:\n    jsonParseReset(&x);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#197432:1#jsonAppendString",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    u32 i;\n    if (zIn == 0 || ((N + p->nUsed + 2 >= p->nAlloc) && jsonGrow(p, N + 2) != 0))\n        return;\n    p->zBuf[p->nUsed++] = '\"';\n    for (i = 0; i < N; i++) {\n        unsigned char c = ((const unsigned char *)zIn)[i];\n        if (c == '\"' || c == '\\\\') {\n          json_simple_escape:\n            if ((p->nUsed + N + 3 - i > p->nAlloc) && jsonGrow(p, N + 3 - i) != 0)\n                return;\n            p->zBuf[p->nUsed++] = '\\\\';\n        } else if (c <= 31) {\n            static const char aSpecial[] = {0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n            assert(sizeof (aSpecial) == 32);\n            assert(aSpecial['\\b'] == 'b');\n            assert(aSpecial['\\f'] == 'f');\n            assert(aSpecial['\\n'] == 'n');\n            assert(aSpecial['\\r'] == 'r');\n            assert(aSpecial['\\t'] == 't');\n            if (aSpecial[c]) {\n                c = aSpecial[c];\n                goto json_simple_escape;\n            }\n            if ((p->nUsed + N + 7 + i > p->nAlloc) && jsonGrow(p, N + 7 - i) != 0)\n                return;\n            p->zBuf[p->nUsed++] = '\\\\';\n            p->zBuf[p->nUsed++] = 'u';\n            p->zBuf[p->nUsed++] = '0';\n            p->zBuf[p->nUsed++] = '0';\n            p->zBuf[p->nUsed++] = '0' + (c >> 4);\n            c = \"0123456789abcdef\"[c & 15];\n        }\n        p->zBuf[p->nUsed++] = c;\n    }\n    p->zBuf[p->nUsed++] = '\"';\n    assert(p->nUsed < p->nAlloc);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#175569:1#openDatabase",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    sqlite3 *db;\n    int rc;\n    int isThreadsafe;\n    char *zOpen = 0;\n    char *zErrMsg = 0;\n    int i;\n    *ppDb = 0;\n    rc = sqlite3_initialize();\n    if (rc)\n        return rc;\n    if (sqlite3Config.bCoreMutex == 0) {\n        isThreadsafe = 0;\n    } else if (flags & 32768) {\n        isThreadsafe = 0;\n    } else if (flags & 65536) {\n        isThreadsafe = 1;\n    } else {\n        isThreadsafe = sqlite3Config.bFullMutex;\n    }\n    if (flags & 262144) {\n        flags &= ~131072;\n    } else if (sqlite3Config.sharedCacheEnabled) {\n        flags |= 131072;\n    }\n    flags &= ~(8 | 16 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768 | 65536 | 524288);\n    db = sqlite3MallocZero(sizeof(sqlite3));\n    if (db == 0)\n        goto opendb_out;\n    if (isThreadsafe) {\n        db->mutex = sqlite3MutexAlloc(1);\n        if (db->mutex == 0) {\n            sqlite3_free(db);\n            db = 0;\n            goto opendb_out;\n        }\n        if (isThreadsafe == 0) {\n            ;\n        }\n    }\n    sqlite3_mutex_enter(db->mutex);\n    db->errMask = (flags & 33554432) != 0 ? 4294967295U : 255;\n    db->nDb = 2;\n    db->eOpenState = 109;\n    db->aDb = db->aDbStatic;\n    db->lookaside.bDisable = 1;\n    db->lookaside.sz = 0;\n    assert(sizeof (db->aLimit) == sizeof (aHardLimit));\n    memcpy(db->aLimit, aHardLimit, sizeof (db->aLimit));\n    db->aLimit[11] = 0;\n    db->autoCommit = 1;\n    db->nextAutovac = -1;\n    db->szMmap = sqlite3Config.szMmap;\n    db->nextPagesize = 0;\n    db->init.azInit = sqlite3StdType;\n    db->flags |= 64 | 262144 | 2147483648U | 32 | 128 | 1073741824 | 536870912 | 32768;\n    sqlite3HashInit(&db->aCollSeq);\n    sqlite3HashInit(&db->aModule);\n    createCollation(db, sqlite3StrBINARY, 1, 0, binCollFunc, 0);\n    createCollation(db, sqlite3StrBINARY, 3, 0, binCollFunc, 0);\n    createCollation(db, sqlite3StrBINARY, 2, 0, binCollFunc, 0);\n    createCollation(db, \"NOCASE\", 1, 0, nocaseCollatingFunc, 0);\n    createCollation(db, \"RTRIM\", 1, 0, rtrimCollFunc, 0);\n    if (db->mallocFailed) {\n        goto opendb_out;\n    }\n    db->openFlags = flags;\n    assert(1 == 1);\n    assert(2 == 2);\n    assert(4 == 4);\n    ;\n    ;\n    ;\n    if (((1 << (flags & 7)) & 70) == 0) {\n        rc = sqlite3MisuseError(175795);\n    } else {\n        rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);\n    }\n    if (rc != 0) {\n        if (rc == 7)\n            sqlite3OomFault(db);\n        sqlite3ErrorWithMsg(db, rc, zErrMsg ? \"%s\" : 0, zErrMsg);\n        sqlite3_free(zErrMsg);\n        goto opendb_out;\n    }\n    assert(db->pVfs != 0);\n    rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, &db->aDb[0].pBt, 0, flags | 256);\n    if (rc != 0) {\n        if (rc == (10 | (12 << 8))) {\n            rc = 7;\n        }\n        sqlite3Error(db, rc);\n        goto opendb_out;\n    }\n    sqlite3BtreeEnter(db->aDb[0].pBt);\n    db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);\n    if (!db->mallocFailed) {\n        sqlite3SetTextEncoding(db, ((db)->aDb[0].pSchema->enc));\n    }\n    sqlite3BtreeLeave(db->aDb[0].pBt);\n    db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);\n    db->aDb[0].zDbSName = \"main\";\n    db->aDb[0].safety_level = 2 + 1;\n    db->aDb[1].zDbSName = \"temp\";\n    db->aDb[1].safety_level = 1;\n    db->eOpenState = 118;\n    if (db->mallocFailed) {\n        goto opendb_out;\n    }\n    sqlite3Error(db, 0);\n    sqlite3RegisterPerConnectionBuiltinFunctions(db);\n    rc = sqlite3_errcode(db);\n    for (i = 0; rc == 0 && i < ((int)(sizeof (sqlite3BuiltinExtensions) / sizeof (sqlite3BuiltinExtensions[0]))); i++) {\n        rc = sqlite3BuiltinExtensions[i](db);\n    }\n    if (rc == 0) {\n        sqlite3AutoLoadExtensions(db);\n        rc = sqlite3_errcode(db);\n        if (rc != 0) {\n            goto opendb_out;\n        }\n    }\n    if (rc)\n        sqlite3Error(db, rc);\n    setupLookaside(db, 0, sqlite3Config.szLookaside, sqlite3Config.nLookaside);\n    sqlite3_wal_autocheckpoint(db, 1000);\n  opendb_out:\n    if (db) {\n        assert(db->mutex != 0 || isThreadsafe == 0 || sqlite3Config.bFullMutex == 0);\n        sqlite3_mutex_leave(db->mutex);\n    }\n    rc = sqlite3_errcode(db);\n    assert(db != 0 || (rc & 255) == 7);\n    if ((rc & 255) == 7) {\n        sqlite3_close(db);\n        db = 0;\n    } else if (rc != 0) {\n        db->eOpenState = 186;\n    }\n    *ppDb = db;\n    sqlite3_free_filename(zOpen);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3WindowAlloc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Window *pWin = 0;\n    int bImplicitFrame = 0;\n    assert(eType == 0 || eType == 89 || eType == 76 || eType == 92);\n    assert(eStart == 85 || eStart == 88 || eStart == 90 || eStart == 86);\n    assert(eEnd == 85 || eEnd == 86 || eEnd == 90 || eEnd == 88);\n    assert((eStart == 88 || eStart == 86) == (pStart != 0));\n    assert((eEnd == 86 || eEnd == 88) == (pEnd != 0));\n    if (eType == 0) {\n        bImplicitFrame = 1;\n        eType = 89;\n    }\n    if ((eStart == 85 && eEnd == 88) || (eStart == 86 && (eEnd == 88 || eEnd == 85))) {\n        sqlite3ErrorMsg(pParse, \"unsupported frame specification\");\n        goto windowAllocErr;\n    }\n    pWin = (Window *)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n    if (pWin == 0)\n        goto windowAllocErr;\n    pWin->eFrmType = eType;\n    pWin->eStart = eStart;\n    pWin->eEnd = eEnd;\n    if (eExclude == 0 && (((pParse->db)->dbOptFlags & (2)) != 0)) {\n        eExclude = 66;\n    }\n    pWin->eExclude = eExclude;\n    pWin->bImplicitFrame = bImplicitFrame;\n    pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);\n    pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);\n    return pWin;\n  windowAllocErr:\n    sqlite3ExprDelete(pParse->db, pEnd);\n    sqlite3ExprDelete(pParse->db, pStart);\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#162336:1#nth_valueStepFunc",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    struct NthValueCtx *p;\n    p = (struct NthValueCtx *)sqlite3_aggregate_context(pCtx, sizeof (*p));\n    if (p) {\n        i64 iVal;\n        switch (sqlite3_value_numeric_type(apArg[1])) {\n          case 1:\n            iVal = sqlite3_value_int64(apArg[1]);\n            break;\n          case 2:\n            {\n                double fVal = sqlite3_value_double(apArg[1]);\n                if (((i64)fVal) != fVal)\n                    goto error_out;\n                iVal = (i64)fVal;\n                break;\n            }\n          default:\n            goto error_out;\n        }\n        if (iVal <= 0)\n            goto error_out;\n        p->nStep++;\n        if (iVal == p->nStep) {\n            p->pValue = sqlite3_value_dup(apArg[0]);\n            if (!p->pValue) {\n                sqlite3_result_error_nomem(pCtx);\n            }\n        }\n    }\n    (void)(nArg);\n    (void)(apArg);\n    return;\n  error_out:\n    sqlite3_result_error(pCtx, \"second argument to nth_value must be a positive integer\", -1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#155753:1#whereOrInsert",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    u16 i;\n    WhereOrCost *p;\n    for (i = pSet->n , p = pSet->a; i > 0; i-- , p++) {\n        if (rRun <= p->rRun && (prereq & p->prereq) == prereq) {\n            goto whereOrInsert_done;\n        }\n        if (p->rRun <= rRun && (p->prereq & prereq) == p->prereq) {\n            return 0;\n        }\n    }\n    if (pSet->n < 3) {\n        p = &pSet->a[pSet->n++];\n        p->nOut = nOut;\n    } else {\n        p = pSet->a;\n        for (i = 1; i < pSet->n; i++) {\n            if (p->rRun > pSet->a[i].rRun)\n                p = pSet->a + i;\n        }\n        if (p->rRun <= rRun)\n            return 0;\n    }\n  whereOrInsert_done:\n    p->prereq = prereq;\n    p->rRun = rRun;\n    if (p->nOut > nOut)\n        p->nOut = nOut;\n    return 1;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Update",
    "gotos": 13,
    "labels": 1,
    "body": "{\n    int i, j, k;\n    Table *pTab;\n    int addrTop = 0;\n    WhereInfo *pWInfo = 0;\n    Vdbe *v;\n    Index *pIdx;\n    Index *pPk;\n    int nIdx;\n    int nAllIdx;\n    int iBaseCur;\n    int iDataCur;\n    int iIdxCur;\n    sqlite3 *db;\n    int *aRegIdx = 0;\n    int *aXRef = 0;\n    u8 *aToOpen;\n    u8 chngPk;\n    u8 chngRowid;\n    u8 chngKey;\n    Expr *pRowidExpr = 0;\n    int iRowidExpr = -1;\n    AuthContext sContext;\n    NameContext sNC;\n    int iDb;\n    int eOnePass;\n    int hasFK;\n    int labelBreak;\n    int labelContinue;\n    int flags;\n    int isView;\n    Trigger *pTrigger;\n    int tmask;\n    int newmask;\n    int iEph = 0;\n    int nKey = 0;\n    int aiCurOnePass[2];\n    int addrOpen = 0;\n    int iPk = 0;\n    i16 nPk = 0;\n    int bReplace = 0;\n    int bFinishSeek = 1;\n    int nChangeFrom = 0;\n    int regRowCount = 0;\n    int regOldRowid = 0;\n    int regNewRowid = 0;\n    int regNew = 0;\n    int regOld = 0;\n    int regRowSet = 0;\n    int regKey = 0;\n    memset(&sContext, 0, sizeof (sContext));\n    db = pParse->db;\n    assert(db->pParse == pParse);\n    if (pParse->nErr) {\n        goto update_cleanup;\n    }\n    assert(db->mallocFailed == 0);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0)\n        goto update_cleanup;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 129, pChanges, &tmask);\n    isView = ((pTab)->eTabType == 2);\n    assert(pTrigger || tmask == 0);\n    nChangeFrom = (pTabList->nSrc > 1) ? pChanges->nExpr : 0;\n    assert(nChangeFrom == 0 || pUpsert == 0);\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto update_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, tmask)) {\n        goto update_cleanup;\n    }\n    iBaseCur = iDataCur = pParse->nTab++;\n    iIdxCur = iDataCur + 1;\n    pPk = (((pTab)->tabFlags & 128) == 0) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n    ;\n    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n        if (pPk == pIdx) {\n            iDataCur = pParse->nTab;\n        }\n        pParse->nTab++;\n    }\n    if (pUpsert) {\n        iDataCur = pUpsert->iDataCur;\n        iIdxCur = pUpsert->iIdxCur;\n        pParse->nTab = iBaseCur;\n    }\n    pTabList->a[0].iCursor = iDataCur;\n    aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol + nIdx + 1) + nIdx + 2);\n    if (aXRef == 0)\n        goto update_cleanup;\n    aRegIdx = aXRef + pTab->nCol;\n    aToOpen = (u8 *)(aRegIdx + nIdx + 1);\n    memset(aToOpen, 1, nIdx + 1);\n    aToOpen[nIdx + 1] = 0;\n    for (i = 0; i < pTab->nCol; i++)\n        aXRef[i] = -1;\n    memset(&sNC, 0, sizeof (sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pUpsert = pUpsert;\n    sNC.ncFlags = 512;\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0)\n        goto update_cleanup;\n    chngRowid = chngPk = 0;\n    for (i = 0; i < pChanges->nExpr; i++) {\n        u8 hCol = sqlite3StrIHash(pChanges->a[i].zEName);\n        if (nChangeFrom == 0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr)) {\n            goto update_cleanup;\n        }\n        for (j = 0; j < pTab->nCol; j++) {\n            if (pTab->aCol[j].hName == hCol && sqlite3StrICmp(pTab->aCol[j].zCnName, pChanges->a[i].zEName) == 0) {\n                if (j == pTab->iPKey) {\n                    chngRowid = 1;\n                    pRowidExpr = pChanges->a[i].pExpr;\n                    iRowidExpr = i;\n                } else if (pPk && (pTab->aCol[j].colFlags & 1) != 0) {\n                    chngPk = 1;\n                } else if (pTab->aCol[j].colFlags & 96) {\n                    ;\n                    ;\n                    sqlite3ErrorMsg(pParse, \"cannot UPDATE generated column \\\"%s\\\"\", pTab->aCol[j].zCnName);\n                    goto update_cleanup;\n                }\n                aXRef[j] = i;\n                break;\n            }\n        }\n        if (j >= pTab->nCol) {\n            if (pPk == 0 && sqlite3IsRowid(pChanges->a[i].zEName)) {\n                j = -1;\n                chngRowid = 1;\n                pRowidExpr = pChanges->a[i].pExpr;\n                iRowidExpr = i;\n            } else {\n                sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zEName);\n                pParse->checkSchema = 1;\n                goto update_cleanup;\n            }\n        }\n        {\n            int rc;\n            rc = sqlite3AuthCheck(pParse, 23, pTab->zName, j < 0 ? \"ROWID\" : pTab->aCol[j].zCnName, db->aDb[iDb].zDbSName);\n            if (rc == 1) {\n                goto update_cleanup;\n            } else if (rc == 2) {\n                aXRef[j] = -1;\n            }\n        }\n    }\n    assert((chngRowid & chngPk) == 0);\n    assert(chngRowid == 0 || chngRowid == 1);\n    assert(chngPk == 0 || chngPk == 1);\n    chngKey = chngRowid + chngPk;\n    if (pTab->tabFlags & 96) {\n        int bProgress;\n        ;\n        ;\n        do {\n            bProgress = 0;\n            for (i = 0; i < pTab->nCol; i++) {\n                if (aXRef[i] >= 0)\n                    continue;\n                if ((pTab->aCol[i].colFlags & 96) == 0)\n                    continue;\n                if (sqlite3ExprReferencesUpdatedColumn(sqlite3ColumnExpr(pTab, &pTab->aCol[i]), aXRef, chngRowid)) {\n                    aXRef[i] = 99999;\n                    bProgress = 1;\n                }\n            }\n        } while (bProgress);\n    }\n    pTabList->a[0].colUsed = ((pTab)->eTabType == 1) ? ((Bitmask)-1) : 0;\n    hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);\n    if (onError == 5)\n        bReplace = 1;\n    for (nAllIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nAllIdx++) {\n        int reg;\n        if (chngKey || hasFK > 1 || pIdx == pPk || indexWhereClauseMightChange(pIdx, aXRef, chngRowid)) {\n            reg = ++pParse->nMem;\n            pParse->nMem += pIdx->nColumn;\n        } else {\n            reg = 0;\n            for (i = 0; i < pIdx->nKeyCol; i++) {\n                if (indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid)) {\n                    reg = ++pParse->nMem;\n                    pParse->nMem += pIdx->nColumn;\n                    if (onError == 11 && pIdx->onError == 5) {\n                        bReplace = 1;\n                    }\n                    break;\n                }\n            }\n        }\n        if (reg == 0)\n            aToOpen[nAllIdx + 1] = 0;\n        aRegIdx[nAllIdx] = reg;\n    }\n    aRegIdx[nAllIdx] = ++pParse->nMem;\n    if (bReplace) {\n        memset(aToOpen, 1, nIdx + 1);\n    }\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);\n    if (!((pTab)->eTabType == 1)) {\n        assert(aRegIdx[nAllIdx] == pParse->nMem);\n        regRowSet = aRegIdx[nAllIdx];\n        regOldRowid = regNewRowid = ++pParse->nMem;\n        if (chngPk || pTrigger || hasFK) {\n            regOld = pParse->nMem + 1;\n            pParse->nMem += pTab->nCol;\n        }\n        if (chngKey || pTrigger || hasFK) {\n            regNewRowid = ++pParse->nMem;\n        }\n        regNew = pParse->nMem + 1;\n        pParse->nMem += pTab->nCol;\n    }\n    if (isView) {\n        sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n    }\n    if (nChangeFrom == 0 && isView) {\n        sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iDataCur);\n        pOrderBy = 0;\n        pLimit = 0;\n    }\n    if (nChangeFrom == 0 && sqlite3ResolveExprNames(&sNC, pWhere)) {\n        goto update_cleanup;\n    }\n    if (((pTab)->eTabType == 1)) {\n        updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere, onError);\n        goto update_cleanup;\n    }\n    labelContinue = labelBreak = sqlite3VdbeMakeLabel(pParse);\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning && pUpsert == 0) {\n        regRowCount = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, regRowCount);\n    }\n    if (nChangeFrom == 0 && (((pTab)->tabFlags & 128) == 0)) {\n        sqlite3VdbeAddOp3(v, 75, 0, regRowSet, regOldRowid);\n        iEph = pParse->nTab++;\n        addrOpen = sqlite3VdbeAddOp3(v, 118, iEph, 0, regRowSet);\n    } else {\n        assert(pPk != 0 || (((pTab)->tabFlags & 128) == 0));\n        nPk = pPk ? pPk->nKeyCol : 0;\n        iPk = pParse->nMem + 1;\n        pParse->nMem += nPk;\n        pParse->nMem += nChangeFrom;\n        regKey = ++pParse->nMem;\n        if (pUpsert == 0) {\n            int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);\n            iEph = pParse->nTab++;\n            if (pPk)\n                sqlite3VdbeAddOp3(v, 75, 0, iPk, iPk + nPk - 1);\n            addrOpen = sqlite3VdbeAddOp2(v, 118, iEph, nEphCol);\n            if (pPk) {\n                KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);\n                if (pKeyInfo) {\n                    pKeyInfo->nAllField = nEphCol;\n                    sqlite3VdbeAppendP4(v, pKeyInfo, (-8));\n                }\n            }\n            if (nChangeFrom) {\n                updateFromSelect(pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit);\n                if (isView)\n                    iDataCur = iEph;\n            }\n        }\n    }\n    if (nChangeFrom) {\n        sqlite3MultiWrite(pParse);\n        eOnePass = 0;\n        nKey = nPk;\n        regKey = iPk;\n    } else {\n        if (pUpsert) {\n            pWInfo = 0;\n            eOnePass = 1;\n            sqlite3ExprIfFalse(pParse, pWhere, labelBreak, 16);\n            bFinishSeek = 0;\n        } else {\n            flags = 4;\n            if (!pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace) {\n                flags |= 8;\n            }\n            pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0, flags, iIdxCur);\n            if (pWInfo == 0)\n                goto update_cleanup;\n            eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n            bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);\n            if (eOnePass != 1) {\n                sqlite3MultiWrite(pParse);\n                if (eOnePass == 2) {\n                    int iCur = aiCurOnePass[1];\n                    if (iCur >= 0 && iCur != iDataCur && aToOpen[iCur - iBaseCur]) {\n                        eOnePass = 0;\n                    }\n                    assert(iCur != iDataCur || !(((pTab)->tabFlags & 128) == 0));\n                }\n            }\n        }\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp2(v, 135, iDataCur, regOldRowid);\n            if (eOnePass == 0) {\n                aRegIdx[nAllIdx] = ++pParse->nMem;\n                sqlite3VdbeAddOp3(v, 128, iEph, regRowSet, regOldRowid);\n            } else {\n                if ((addrOpen))\n                    sqlite3VdbeChangeToNoop(v, addrOpen);\n            }\n        } else {\n            for (i = 0; i < nPk; i++) {\n                assert(pPk->aiColumn[i] >= 0);\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, pPk->aiColumn[i], iPk + i);\n            }\n            if (eOnePass) {\n                if (addrOpen)\n                    sqlite3VdbeChangeToNoop(v, addrOpen);\n                nKey = nPk;\n                regKey = iPk;\n            } else {\n                sqlite3VdbeAddOp4(v, 97, iPk, nPk, regKey, sqlite3IndexAffinityStr(db, pPk), nPk);\n                sqlite3VdbeAddOp4Int(v, 138, iEph, regKey, iPk, nPk);\n            }\n        }\n    }\n    if (pUpsert == 0) {\n        if (nChangeFrom == 0 && eOnePass != 2) {\n            sqlite3WhereEnd(pWInfo);\n        }\n        if (!isView) {\n            int addrOnce = 0;\n            if (eOnePass != 0) {\n                if (aiCurOnePass[0] >= 0)\n                    aToOpen[aiCurOnePass[0] - iBaseCur] = 0;\n                if (aiCurOnePass[1] >= 0)\n                    aToOpen[aiCurOnePass[1] - iBaseCur] = 0;\n            }\n            if (eOnePass == 2 && (nIdx - (aiCurOnePass[1] >= 0)) > 0) {\n                addrOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n            }\n            sqlite3OpenTableAndIndices(pParse, pTab, 113, 0, iBaseCur, aToOpen, 0, 0);\n            if (addrOnce) {\n                sqlite3VdbeJumpHereOrPopInst(v, addrOnce);\n            }\n        }\n        if (eOnePass != 0) {\n            if (aiCurOnePass[0] != iDataCur && aiCurOnePass[1] != iDataCur) {\n                assert(pPk);\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelBreak, regKey, nKey);\n                ;\n            }\n            if (eOnePass != 1) {\n                labelContinue = sqlite3VdbeMakeLabel(pParse);\n            }\n            sqlite3VdbeAddOp2(v, 50, pPk ? regKey : regOldRowid, labelBreak);\n            ;\n            ;\n        } else if (pPk || nChangeFrom) {\n            labelContinue = sqlite3VdbeMakeLabel(pParse);\n            sqlite3VdbeAddOp2(v, 36, iEph, labelBreak);\n            ;\n            addrTop = sqlite3VdbeCurrentAddr(v);\n            if (nChangeFrom) {\n                if (!isView) {\n                    if (pPk) {\n                        for (i = 0; i < nPk; i++) {\n                            sqlite3VdbeAddOp3(v, 94, iEph, i, iPk + i);\n                        }\n                        sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, iPk, nPk);\n                        ;\n                    } else {\n                        sqlite3VdbeAddOp2(v, 135, iEph, regOldRowid);\n                        sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n                        ;\n                    }\n                }\n            } else {\n                sqlite3VdbeAddOp2(v, 134, iEph, regKey);\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, 0);\n                ;\n            }\n        } else {\n            sqlite3VdbeAddOp2(v, 36, iEph, labelBreak);\n            ;\n            labelContinue = sqlite3VdbeMakeLabel(pParse);\n            addrTop = sqlite3VdbeAddOp2(v, 135, iEph, regOldRowid);\n            ;\n            sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n            ;\n        }\n    }\n    assert(chngKey || pTrigger || hasFK || regOldRowid == regNewRowid);\n    if (chngRowid) {\n        assert(iRowidExpr >= 0);\n        if (nChangeFrom == 0) {\n            sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);\n        } else {\n            sqlite3VdbeAddOp3(v, 94, iEph, iRowidExpr, regNewRowid);\n        }\n        sqlite3VdbeAddOp1(v, 13, regNewRowid);\n        ;\n    }\n    if (chngPk || hasFK || pTrigger) {\n        u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);\n        oldmask |= sqlite3TriggerColmask(pParse, pTrigger, pChanges, 0, 1 | 2, pTab, onError);\n        for (i = 0; i < pTab->nCol; i++) {\n            u32 colFlags = pTab->aCol[i].colFlags;\n            k = sqlite3TableColumnToStorage(pTab, i) + regOld;\n            if (oldmask == 4294967295U || (i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0) || (colFlags & 1) != 0) {\n                ;\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, k);\n            }\n        }\n        if (chngRowid == 0 && pPk == 0) {\n            sqlite3VdbeAddOp2(v, 80, regOldRowid, regNewRowid);\n        }\n    }\n    newmask = sqlite3TriggerColmask(pParse, pTrigger, pChanges, 1, 1, pTab, onError);\n    for (i = 0 , k = regNew; i < pTab->nCol; i++ , k++) {\n        if (i == pTab->iPKey) {\n            sqlite3VdbeAddOp2(v, 75, 0, k);\n        } else if ((pTab->aCol[i].colFlags & 96) != 0) {\n            if (pTab->aCol[i].colFlags & 32)\n                k--;\n        } else {\n            j = aXRef[i];\n            if (j >= 0) {\n                if (nChangeFrom) {\n                    int nOff = (isView ? pTab->nCol : nPk);\n                    assert(eOnePass == 0);\n                    sqlite3VdbeAddOp3(v, 94, iEph, nOff + j, k);\n                } else {\n                    sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);\n                }\n            } else if (0 == (tmask & 1) || i > 31 || (newmask & (((unsigned int)1) << (i)))) {\n                ;\n                ;\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n                bFinishSeek = 0;\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, k);\n            }\n        }\n    }\n    if (pTab->tabFlags & 96) {\n        ;\n        ;\n        sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n    }\n    if (tmask & 1) {\n        sqlite3TableAffinity(v, pTab, regNew);\n        sqlite3CodeRowTrigger(pParse, pTrigger, 129, pChanges, 1, pTab, regOldRowid, onError, labelContinue);\n        if (!isView) {\n            if (pPk) {\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, nKey);\n                ;\n            } else {\n                sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n                ;\n            }\n            for (i = 0 , k = regNew; i < pTab->nCol; i++ , k++) {\n                if (pTab->aCol[i].colFlags & 96) {\n                    if (pTab->aCol[i].colFlags & 32)\n                        k--;\n                } else if (aXRef[i] < 0 && i != pTab->iPKey) {\n                    sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n                }\n            }\n            if (pTab->tabFlags & 96) {\n                ;\n                ;\n                sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n            }\n        }\n    }\n    if (!isView) {\n        assert(regOldRowid > 0);\n        sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace, aXRef, 0);\n        if (bReplace || chngKey) {\n            if (pPk) {\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, nKey);\n            } else {\n                sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);\n            }\n            ;\n        }\n        if (hasFK) {\n            sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);\n        }\n        sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);\n        if (bFinishSeek) {\n            sqlite3VdbeAddOp1(v, 143, iDataCur);\n        }\n        assert(regNew == regNewRowid + 1);\n        if (hasFK > 1 || chngKey) {\n            sqlite3VdbeAddOp2(v, 130, iDataCur, 0);\n        }\n        if (hasFK) {\n            sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);\n        }\n        sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx, 4 | (eOnePass == 2 ? 2 : 0), 0, 0);\n        if (hasFK) {\n            sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);\n        }\n    }\n    if (regRowCount) {\n        sqlite3VdbeAddOp2(v, 86, regRowCount, 1);\n    }\n    sqlite3CodeRowTrigger(pParse, pTrigger, 129, pChanges, 2, pTab, regOldRowid, onError, labelContinue);\n    if (eOnePass == 1) {\n    } else if (eOnePass == 2) {\n        sqlite3VdbeResolveLabel(v, labelContinue);\n        sqlite3WhereEnd(pWInfo);\n    } else {\n        sqlite3VdbeResolveLabel(v, labelContinue);\n        sqlite3VdbeAddOp2(v, 39, iEph, addrTop);\n        ;\n    }\n    sqlite3VdbeResolveLabel(v, labelBreak);\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0 && pUpsert == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (regRowCount) {\n        sqlite3CodeChangeCount(v, regRowCount, \"rows updated\");\n    }\n  update_cleanup:\n    sqlite3AuthContextPop(&sContext);\n    sqlite3DbFree(db, aXRef);\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprListDelete(db, pChanges);\n    sqlite3ExprDelete(db, pWhere);\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#146134:1#triggersReallyExist",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int mask = 0;\n    Trigger *pList = 0;\n    Trigger *p;\n    pList = sqlite3TriggerList(pParse, pTab);\n    assert(pList == 0 || ((pTab)->eTabType == 1) == 0 || (pList->bReturning && pList->pNext == 0));\n    if (pList != 0) {\n        p = pList;\n        if ((pParse->db->flags & 262144) == 0 && pTab->pTrigger != 0) {\n            if (pList == pTab->pTrigger) {\n                pList = 0;\n                goto exit_triggers_exist;\n            }\n            while ((p->pNext) && p->pNext != pTab->pTrigger)\n                p = p->pNext;\n            p->pNext = 0;\n            p = pList;\n        }\n        do {\n            if (p->op == op && checkColumnOverlap(p->pColumns, pChanges)) {\n                mask |= p->tr_tm;\n            } else if (p->op == 150) {\n                assert(((pParse)->pToplevel == 0));\n                p->op = op;\n                if (((pTab)->eTabType == 1)) {\n                    if (op != 127) {\n                        sqlite3ErrorMsg(pParse, \"%s RETURNING is not available on virtual tables\", op == 128 ? \"DELETE\" : \"UPDATE\");\n                    }\n                    p->tr_tm = 1;\n                } else {\n                    p->tr_tm = 2;\n                }\n                mask |= p->tr_tm;\n            } else if (p->bReturning && p->op == 127 && op == 129 && ((pParse)->pToplevel == 0)) {\n                mask |= p->tr_tm;\n            }\n            p = p->pNext;\n        } while (p);\n    }\n  exit_triggers_exist:\n    if (pMask) {\n        *pMask = mask;\n    }\n    return (mask ? pList : 0);\n}\n"
  },
  {
    "id": "#23:25#sqlite3DropTrigger",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    Trigger *pTrigger = 0;\n    int i;\n    const char *zDb;\n    const char *zName;\n    sqlite3 *db = pParse->db;\n    if (db->mallocFailed)\n        goto drop_trigger_cleanup;\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto drop_trigger_cleanup;\n    }\n    assert(pName->nSrc == 1);\n    zDb = pName->a[0].zDatabase;\n    zName = pName->a[0].zName;\n    assert(zDb != 0 || sqlite3BtreeHoldsAllMutexes(db));\n    for (i = 0; i < db->nDb; i++) {\n        int j = (i < 2) ? i ^ 1 : i;\n        if (zDb && sqlite3DbIsNamed(db, j, zDb) == 0)\n            continue;\n        assert(sqlite3SchemaMutexHeld(db, j, 0));\n        pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName);\n        if (pTrigger)\n            break;\n    }\n    if (!pTrigger) {\n        if (!noErr) {\n            sqlite3ErrorMsg(pParse, \"no such trigger: %S\", pName->a);\n        } else {\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n        }\n        pParse->checkSchema = 1;\n        goto drop_trigger_cleanup;\n    }\n    sqlite3DropTriggerPtr(pParse, pTrigger);\n  drop_trigger_cleanup:\n    sqlite3SrcListDelete(db, pName);\n}\n"
  },
  {
    "id": "#23:25#sqlite3FinishTrigger",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    Trigger *pTrig = pParse->pNewTrigger;\n    char *zName;\n    sqlite3 *db = pParse->db;\n    DbFixer sFix;\n    int iDb;\n    Token nameToken;\n    pParse->pNewTrigger = 0;\n    if ((pParse->nErr) || !pTrig)\n        goto triggerfinish_cleanup;\n    zName = pTrig->zName;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);\n    pTrig->step_list = pStepList;\n    while (pStepList)\n        {\n            pStepList->pTrig = pTrig;\n            pStepList = pStepList->pNext;\n        }\n    sqlite3TokenInit(&nameToken, pTrig->zName);\n    sqlite3FixInit(&sFix, pParse, iDb, \"trigger\", &nameToken);\n    if (sqlite3FixTriggerStep(&sFix, pTrig->step_list) || sqlite3FixExpr(&sFix, pTrig->pWhen)) {\n        goto triggerfinish_cleanup;\n    }\n    if ((pParse->eParseMode >= 2)) {\n        assert(!db->init.busy);\n        pParse->pNewTrigger = pTrig;\n        pTrig = 0;\n    } else if (!db->init.busy) {\n        Vdbe *v;\n        char *z;\n        if (sqlite3ReadOnlyShadowTables(db)) {\n            TriggerStep *pStep;\n            for (pStep = pTrig->step_list; pStep; pStep = pStep->pNext) {\n                if (pStep->zTarget != 0 && sqlite3ShadowTableName(db, pStep->zTarget)) {\n                    sqlite3ErrorMsg(pParse, \"trigger \\\"%s\\\" may not write to shadow table \\\"%s\\\"\", pTrig->zName, pStep->zTarget);\n                    goto triggerfinish_cleanup;\n                }\n            }\n        }\n        v = sqlite3GetVdbe(pParse);\n        if (v == 0)\n            goto triggerfinish_cleanup;\n        sqlite3BeginWriteOperation(pParse, 0, iDb);\n        z = sqlite3DbStrNDup(db, (char *)pAll->z, pAll->n);\n        ;\n        sqlite3NestedParse(pParse, \"INSERT INTO %Q.sqlite_master VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')\", db->aDb[iDb].zDbSName, zName, pTrig->table, z);\n        sqlite3DbFree(db, z);\n        sqlite3ChangeCookie(pParse, iDb);\n        sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, \"type='trigger' AND name='%q'\", zName), 0);\n    }\n    if (db->init.busy) {\n        Trigger *pLink = pTrig;\n        Hash *pHash = &db->aDb[iDb].pSchema->trigHash;\n        assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n        assert(pLink != 0);\n        pTrig = sqlite3HashInsert(pHash, zName, pTrig);\n        if (pTrig) {\n            sqlite3OomFault(db);\n        } else if (pLink->pSchema == pLink->pTabSchema) {\n            Table *pTab;\n            pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table);\n            assert(pTab != 0);\n            pLink->pNext = pTab->pTrigger;\n            pTab->pTrigger = pLink;\n        }\n    }\n  triggerfinish_cleanup:\n    sqlite3DeleteTrigger(db, pTrig);\n    assert((pParse->eParseMode >= 2) || !pParse->pNewTrigger);\n    sqlite3DeleteTriggerStep(db, pStepList);\n}\n"
  },
  {
    "id": "#23:25#sqlite3BeginTrigger",
    "gotos": 17,
    "labels": 2,
    "body": "{\n    Trigger *pTrigger = 0;\n    Table *pTab;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    Token *pName;\n    DbFixer sFix;\n    assert(pName1 != 0);\n    assert(pName2 != 0);\n    assert(op == 127 || op == 129 || op == 128);\n    assert(op > 0 && op < 255);\n    if (isTemp) {\n        if (pName2->n > 0) {\n            sqlite3ErrorMsg(pParse, \"temporary trigger may not have qualified name\");\n            goto trigger_cleanup;\n        }\n        iDb = 1;\n        pName = pName1;\n    } else {\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0) {\n            goto trigger_cleanup;\n        }\n    }\n    if (!pTableName || db->mallocFailed) {\n        goto trigger_cleanup;\n    }\n    if (db->init.busy && iDb != 1) {\n        sqlite3DbFree(db, pTableName->a[0].zDatabase);\n        pTableName->a[0].zDatabase = 0;\n    }\n    pTab = sqlite3SrcListLookup(pParse, pTableName);\n    if (db->init.busy == 0 && pName2->n == 0 && pTab && pTab->pSchema == db->aDb[1].pSchema) {\n        iDb = 1;\n    }\n    if (db->mallocFailed)\n        goto trigger_cleanup;\n    assert(pTableName->nSrc == 1);\n    sqlite3FixInit(&sFix, pParse, iDb, \"trigger\", pName);\n    if (sqlite3FixSrcList(&sFix, pTableName)) {\n        goto trigger_cleanup;\n    }\n    pTab = sqlite3SrcListLookup(pParse, pTableName);\n    if (!pTab) {\n        goto trigger_orphan_error;\n    }\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"cannot create triggers on virtual tables\");\n        goto trigger_orphan_error;\n    }\n    zName = sqlite3NameFromToken(db, pName);\n    if (zName == 0) {\n        assert(db->mallocFailed);\n        goto trigger_cleanup;\n    }\n    if (sqlite3CheckObjectName(pParse, zName, \"trigger\", pTab->zName)) {\n        goto trigger_cleanup;\n    }\n    assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n    if (!(pParse->eParseMode >= 2)) {\n        if (sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash), zName)) {\n            if (!noErr) {\n                sqlite3ErrorMsg(pParse, \"trigger %T already exists\", pName);\n            } else {\n                assert(!db->init.busy);\n                sqlite3CodeVerifySchema(pParse, iDb);\n            }\n            goto trigger_cleanup;\n        }\n    }\n    if (sqlite3_strnicmp(pTab->zName, \"sqlite_\", 7) == 0) {\n        sqlite3ErrorMsg(pParse, \"cannot create trigger on system table\");\n        goto trigger_cleanup;\n    }\n    if (((pTab)->eTabType == 2) && tr_tm != 65) {\n        sqlite3ErrorMsg(pParse, \"cannot create %s trigger on view: %S\", (tr_tm == 33) ? \"BEFORE\" : \"AFTER\", pTableName->a);\n        goto trigger_orphan_error;\n    }\n    if (!((pTab)->eTabType == 2) && tr_tm == 65) {\n        sqlite3ErrorMsg(pParse, \"cannot create INSTEAD OF trigger on table: %S\", pTableName->a);\n        goto trigger_orphan_error;\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        int code = 7;\n        const char *zDb = db->aDb[iTabDb].zDbSName;\n        const char *zDbTrig = isTemp ? db->aDb[1].zDbSName : zDb;\n        if (iTabDb == 1 || isTemp)\n            code = 5;\n        if (sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig)) {\n            goto trigger_cleanup;\n        }\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (iTabDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto trigger_cleanup;\n        }\n    }\n    if (tr_tm == 65) {\n        tr_tm = 33;\n    }\n    pTrigger = (Trigger *)sqlite3DbMallocZero(db, sizeof(Trigger));\n    if (pTrigger == 0)\n        goto trigger_cleanup;\n    pTrigger->zName = zName;\n    zName = 0;\n    pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);\n    pTrigger->pSchema = db->aDb[iDb].pSchema;\n    pTrigger->pTabSchema = pTab->pSchema;\n    pTrigger->op = (u8)op;\n    pTrigger->tr_tm = tr_tm == 33 ? 1 : 2;\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameTokenRemap(pParse, pTrigger->table, pTableName->a[0].zName);\n        pTrigger->pWhen = pWhen;\n        pWhen = 0;\n    } else {\n        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 1);\n    }\n    pTrigger->pColumns = pColumns;\n    pColumns = 0;\n    assert(pParse->pNewTrigger == 0);\n    pParse->pNewTrigger = pTrigger;\n  trigger_cleanup:\n    sqlite3DbFree(db, zName);\n    sqlite3SrcListDelete(db, pTableName);\n    sqlite3IdListDelete(db, pColumns);\n    sqlite3ExprDelete(db, pWhen);\n    if (!pParse->pNewTrigger) {\n        sqlite3DeleteTrigger(db, pTrigger);\n    } else {\n        assert(pParse->pNewTrigger == pTrigger);\n    }\n    return;\n  trigger_orphan_error:\n    if (db->init.iDb == 1) {\n        db->init.orphanTrigger = 1;\n    }\n    goto trigger_cleanup;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#145213:1#sqlite3_get_table_cb",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    TabResult *p = (TabResult *)pArg;\n    int need;\n    int i;\n    char *z;\n    if (p->nRow == 0 && argv != 0) {\n        need = nCol * 2;\n    } else {\n        need = nCol;\n    }\n    if (p->nData + need > p->nAlloc) {\n        char **azNew;\n        p->nAlloc = p->nAlloc * 2 + need;\n        azNew = sqlite3Realloc(p->azResult, sizeof(char *) * p->nAlloc);\n        if (azNew == 0)\n            goto malloc_failed;\n        p->azResult = azNew;\n    }\n    if (p->nRow == 0) {\n        p->nColumn = nCol;\n        for (i = 0; i < nCol; i++) {\n            z = sqlite3_mprintf(\"%s\", colv[i]);\n            if (z == 0)\n                goto malloc_failed;\n            p->azResult[p->nData++] = z;\n        }\n    } else if ((int)p->nColumn != nCol) {\n        sqlite3_free(p->zErrMsg);\n        p->zErrMsg = sqlite3_mprintf(\"sqlite3_get_table() called with two or more incompatible queries\");\n        p->rc = 1;\n        return 1;\n    }\n    if (argv != 0) {\n        for (i = 0; i < nCol; i++) {\n            if (argv[i] == 0) {\n                z = 0;\n            } else {\n                int n = sqlite3Strlen30(argv[i]) + 1;\n                z = sqlite3_malloc64(n);\n                if (z == 0)\n                    goto malloc_failed;\n                memcpy(z, argv[i], n);\n            }\n            p->azResult[p->nData++] = z;\n        }\n        p->nRow++;\n    }\n    return 0;\n  malloc_failed:\n    p->rc = 7;\n    return 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#140062:1#multiSelect",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    Select *pPrior;\n    Vdbe *v;\n    SelectDest dest;\n    Select *pDelete = 0;\n    sqlite3 *db;\n    assert(p && p->pPrior);\n    assert((p->selFlags & 8192) == 0 || p->op == 135 || p->op == 134);\n    assert(p->selFlags & 256);\n    db = pParse->db;\n    pPrior = p->pPrior;\n    dest = *pDest;\n    assert(pPrior->pOrderBy == 0);\n    assert(pPrior->pLimit == 0);\n    v = sqlite3GetVdbe(pParse);\n    assert(v != 0);\n    if (dest.eDest == 12) {\n        assert(p->pEList);\n        sqlite3VdbeAddOp2(v, 118, dest.iSDParm, p->pEList->nExpr);\n        dest.eDest = 14;\n    }\n    if (p->selFlags & 1024) {\n        rc = multiSelectValues(pParse, p, &dest);\n        if (rc >= 0)\n            goto multi_select_end;\n        rc = 0;\n    }\n    assert(p->pEList && pPrior->pEList);\n    assert(p->pEList->nExpr == pPrior->pEList->nExpr);\n    if ((p->selFlags & 8192) != 0 && hasAnchor(p)) {\n        generateWithRecursiveQuery(pParse, p, &dest);\n    } else if (p->pOrderBy) {\n        return multiSelectOrderBy(pParse, p, pDest);\n    } else {\n        if (pPrior->pPrior == 0) {\n            sqlite3VdbeExplain(pParse, 1, \"COMPOUND QUERY\");\n            sqlite3VdbeExplain(pParse, 1, \"LEFT-MOST SUBQUERY\");\n        }\n        switch (p->op) {\n          case 135:\n            {\n                int addr = 0;\n                int nLimit = 0;\n                assert(!pPrior->pLimit);\n                pPrior->iLimit = p->iLimit;\n                pPrior->iOffset = p->iOffset;\n                pPrior->pLimit = p->pLimit;\n                ;\n                rc = sqlite3Select(pParse, pPrior, &dest);\n                pPrior->pLimit = 0;\n                if (rc) {\n                    goto multi_select_end;\n                }\n                p->pPrior = 0;\n                p->iLimit = pPrior->iLimit;\n                p->iOffset = pPrior->iOffset;\n                if (p->iLimit) {\n                    addr = sqlite3VdbeAddOp1(v, 17, p->iLimit);\n                    ;\n                    ;\n                    if (p->iOffset) {\n                        sqlite3VdbeAddOp3(v, 160, p->iLimit, p->iOffset + 1, p->iOffset);\n                    }\n                }\n                sqlite3VdbeExplain(pParse, 1, \"UNION ALL\");\n                ;\n                rc = sqlite3Select(pParse, p, &dest);\n                ;\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n                if (p->pLimit && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit) && nLimit > 0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)) {\n                    p->nSelectRow = sqlite3LogEst((u64)nLimit);\n                }\n                if (addr) {\n                    sqlite3VdbeJumpHere(v, addr);\n                }\n                break;\n            }\n          case 136:\n          case 134:\n            {\n                int unionTab;\n                u8 op = 0;\n                int priorOp;\n                Expr *pLimit;\n                int addr;\n                SelectDest uniondest;\n                ;\n                ;\n                priorOp = 1;\n                if (dest.eDest == priorOp) {\n                    assert(p->pLimit == 0);\n                    unionTab = dest.iSDParm;\n                } else {\n                    unionTab = pParse->nTab++;\n                    assert(p->pOrderBy == 0);\n                    addr = sqlite3VdbeAddOp2(v, 118, unionTab, 0);\n                    assert(p->addrOpenEphm[0] == -1);\n                    p->addrOpenEphm[0] = addr;\n                    findRightmost(p)->selFlags |= 32;\n                    assert(p->pEList);\n                }\n                assert(!pPrior->pOrderBy);\n                sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n                ;\n                rc = sqlite3Select(pParse, pPrior, &uniondest);\n                if (rc) {\n                    goto multi_select_end;\n                }\n                if (p->op == 136) {\n                    op = 2;\n                } else {\n                    assert(p->op == 134);\n                    op = 1;\n                }\n                p->pPrior = 0;\n                pLimit = p->pLimit;\n                p->pLimit = 0;\n                uniondest.eDest = op;\n                sqlite3VdbeExplain(pParse, 1, \"%s USING TEMP B-TREE\", sqlite3SelectOpName(p->op));\n                ;\n                rc = sqlite3Select(pParse, p, &uniondest);\n                ;\n                assert(p->pOrderBy == 0);\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                p->pOrderBy = 0;\n                if (p->op == 134) {\n                    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n                }\n                sqlite3ExprDelete(db, p->pLimit);\n                p->pLimit = pLimit;\n                p->iLimit = 0;\n                p->iOffset = 0;\n                assert(unionTab == dest.iSDParm || dest.eDest != priorOp);\n                assert(p->pEList || db->mallocFailed);\n                if (dest.eDest != priorOp && db->mallocFailed == 0) {\n                    int iCont, iBreak, iStart;\n                    iBreak = sqlite3VdbeMakeLabel(pParse);\n                    iCont = sqlite3VdbeMakeLabel(pParse);\n                    computeLimitRegisters(pParse, p, iBreak);\n                    sqlite3VdbeAddOp2(v, 36, unionTab, iBreak);\n                    ;\n                    iStart = sqlite3VdbeCurrentAddr(v);\n                    selectInnerLoop(pParse, p, unionTab, 0, 0, &dest, iCont, iBreak);\n                    sqlite3VdbeResolveLabel(v, iCont);\n                    sqlite3VdbeAddOp2(v, 39, unionTab, iStart);\n                    ;\n                    sqlite3VdbeResolveLabel(v, iBreak);\n                    sqlite3VdbeAddOp2(v, 122, unionTab, 0);\n                }\n                break;\n            }\n          default:\n            assert(p->op == 137);\n            {\n                int tab1, tab2;\n                int iCont, iBreak, iStart;\n                Expr *pLimit;\n                int addr;\n                SelectDest intersectdest;\n                int r1;\n                tab1 = pParse->nTab++;\n                tab2 = pParse->nTab++;\n                assert(p->pOrderBy == 0);\n                addr = sqlite3VdbeAddOp2(v, 118, tab1, 0);\n                assert(p->addrOpenEphm[0] == -1);\n                p->addrOpenEphm[0] = addr;\n                findRightmost(p)->selFlags |= 32;\n                assert(p->pEList);\n                sqlite3SelectDestInit(&intersectdest, 1, tab1);\n                ;\n                rc = sqlite3Select(pParse, pPrior, &intersectdest);\n                if (rc) {\n                    goto multi_select_end;\n                }\n                addr = sqlite3VdbeAddOp2(v, 118, tab2, 0);\n                assert(p->addrOpenEphm[1] == -1);\n                p->addrOpenEphm[1] = addr;\n                p->pPrior = 0;\n                pLimit = p->pLimit;\n                p->pLimit = 0;\n                intersectdest.iSDParm = tab2;\n                sqlite3VdbeExplain(pParse, 1, \"%s USING TEMP B-TREE\", sqlite3SelectOpName(p->op));\n                ;\n                rc = sqlite3Select(pParse, p, &intersectdest);\n                ;\n                pDelete = p->pPrior;\n                p->pPrior = pPrior;\n                if (p->nSelectRow > pPrior->nSelectRow) {\n                    p->nSelectRow = pPrior->nSelectRow;\n                }\n                sqlite3ExprDelete(db, p->pLimit);\n                p->pLimit = pLimit;\n                if (rc)\n                    break;\n                assert(p->pEList);\n                iBreak = sqlite3VdbeMakeLabel(pParse);\n                iCont = sqlite3VdbeMakeLabel(pParse);\n                computeLimitRegisters(pParse, p, iBreak);\n                sqlite3VdbeAddOp2(v, 36, tab1, iBreak);\n                ;\n                r1 = sqlite3GetTempReg(pParse);\n                iStart = sqlite3VdbeAddOp2(v, 134, tab1, r1);\n                sqlite3VdbeAddOp4Int(v, 28, tab2, iCont, r1, 0);\n                ;\n                sqlite3ReleaseTempReg(pParse, r1);\n                selectInnerLoop(pParse, p, tab1, 0, 0, &dest, iCont, iBreak);\n                sqlite3VdbeResolveLabel(v, iCont);\n                sqlite3VdbeAddOp2(v, 39, tab1, iStart);\n                ;\n                sqlite3VdbeResolveLabel(v, iBreak);\n                sqlite3VdbeAddOp2(v, 122, tab2, 0);\n                sqlite3VdbeAddOp2(v, 122, tab1, 0);\n                break;\n            }\n        }\n        if (p->pNext == 0) {\n            sqlite3VdbeExplainPop(pParse);\n        }\n    }\n    if (pParse->nErr)\n        goto multi_select_end;\n    if (p->selFlags & 32) {\n        int i;\n        KeyInfo *pKeyInfo;\n        Select *pLoop;\n        CollSeq **apColl;\n        int nCol;\n        assert(p->pNext == 0);\n        assert(p->pEList != 0);\n        nCol = p->pEList->nExpr;\n        pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n        if (!pKeyInfo) {\n            rc = 7;\n            goto multi_select_end;\n        }\n        for (i = 0 , apColl = pKeyInfo->aColl; i < nCol; i++ , apColl++) {\n            *apColl = multiSelectCollSeq(pParse, p, i);\n            if (0 == *apColl) {\n                *apColl = db->pDfltColl;\n            }\n        }\n        for (pLoop = p; pLoop; pLoop = pLoop->pPrior) {\n            for (i = 0; i < 2; i++) {\n                int addr = pLoop->addrOpenEphm[i];\n                if (addr < 0) {\n                    assert(pLoop->addrOpenEphm[1] < 0);\n                    break;\n                }\n                sqlite3VdbeChangeP2(v, addr, nCol);\n                sqlite3VdbeChangeP4(v, addr, (char *)sqlite3KeyInfoRef(pKeyInfo), (-8));\n                pLoop->addrOpenEphm[i] = -1;\n            }\n        }\n        sqlite3KeyInfoUnref(pKeyInfo);\n    }\n  multi_select_end:\n    pDest->iSdst = dest.iSdst;\n    pDest->nSdst = dest.nSdst;\n    if (pDelete) {\n        sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3SelectDelete, pDelete);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#139813:1#generateWithRecursiveQuery",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    SrcList *pSrc = p->pSrc;\n    int nCol = p->pEList->nExpr;\n    Vdbe *v = pParse->pVdbe;\n    Select *pSetup;\n    Select *pFirstRec;\n    int addrTop;\n    int addrCont, addrBreak;\n    int iCurrent = 0;\n    int regCurrent;\n    int iQueue;\n    int iDistinct = 0;\n    int eDest = 8;\n    SelectDest destQueue;\n    int i;\n    int rc;\n    ExprList *pOrderBy;\n    Expr *pLimit;\n    int regLimit, regOffset;\n    if (p->pWin) {\n        sqlite3ErrorMsg(pParse, \"cannot use window functions in recursive queries\");\n        return;\n    }\n    if (sqlite3AuthCheck(pParse, 33, 0, 0, 0))\n        return;\n    addrBreak = sqlite3VdbeMakeLabel(pParse);\n    p->nSelectRow = 320;\n    computeLimitRegisters(pParse, p, addrBreak);\n    pLimit = p->pLimit;\n    regLimit = p->iLimit;\n    regOffset = p->iOffset;\n    p->pLimit = 0;\n    p->iLimit = p->iOffset = 0;\n    pOrderBy = p->pOrderBy;\n    for (i = 0; (i < pSrc->nSrc); i++) {\n        if (pSrc->a[i].fg.isRecursive) {\n            iCurrent = pSrc->a[i].iCursor;\n            break;\n        }\n    }\n    iQueue = pParse->nTab++;\n    if (p->op == 134) {\n        eDest = pOrderBy ? 6 : 5;\n        iDistinct = pParse->nTab++;\n    } else {\n        eDest = pOrderBy ? 7 : 8;\n    }\n    sqlite3SelectDestInit(&destQueue, eDest, iQueue);\n    regCurrent = ++pParse->nMem;\n    sqlite3VdbeAddOp3(v, 121, iCurrent, regCurrent, nCol);\n    if (pOrderBy) {\n        KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);\n        sqlite3VdbeAddOp4(v, 118, iQueue, pOrderBy->nExpr + 2, 0, (char *)pKeyInfo, (-8));\n        destQueue.pOrderBy = pOrderBy;\n    } else {\n        sqlite3VdbeAddOp2(v, 118, iQueue, nCol);\n    }\n    ;\n    if (iDistinct) {\n        p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, 118, iDistinct, 0);\n        p->selFlags |= 32;\n    }\n    p->pOrderBy = 0;\n    for (pFirstRec = p; (pFirstRec != 0); pFirstRec = pFirstRec->pPrior) {\n        if (pFirstRec->selFlags & 8) {\n            sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");\n            goto end_of_recursive_query;\n        }\n        pFirstRec->op = 135;\n        if ((pFirstRec->pPrior->selFlags & 8192) == 0)\n            break;\n    }\n    pSetup = pFirstRec->pPrior;\n    pSetup->pNext = 0;\n    sqlite3VdbeExplain(pParse, 1, \"SETUP\");\n    rc = sqlite3Select(pParse, pSetup, &destQueue);\n    pSetup->pNext = p;\n    if (rc)\n        goto end_of_recursive_query;\n    addrTop = sqlite3VdbeAddOp2(v, 36, iQueue, addrBreak);\n    ;\n    sqlite3VdbeAddOp1(v, 136, iCurrent);\n    if (pOrderBy) {\n        sqlite3VdbeAddOp3(v, 94, iQueue, pOrderBy->nExpr + 1, regCurrent);\n    } else {\n        sqlite3VdbeAddOp2(v, 134, iQueue, regCurrent);\n    }\n    sqlite3VdbeAddOp1(v, 130, iQueue);\n    addrCont = sqlite3VdbeMakeLabel(pParse);\n    codeOffset(v, regOffset, addrCont);\n    selectInnerLoop(pParse, p, iCurrent, 0, 0, pDest, addrCont, addrBreak);\n    if (regLimit) {\n        sqlite3VdbeAddOp2(v, 61, regLimit, addrBreak);\n        ;\n    }\n    sqlite3VdbeResolveLabel(v, addrCont);\n    pFirstRec->pPrior = 0;\n    sqlite3VdbeExplain(pParse, 1, \"RECURSIVE STEP\");\n    sqlite3Select(pParse, p, &destQueue);\n    assert(pFirstRec->pPrior == 0);\n    pFirstRec->pPrior = pSetup;\n    sqlite3VdbeGoto(v, addrTop);\n    sqlite3VdbeResolveLabel(v, addrBreak);\n  end_of_recursive_query:\n    sqlite3ExprListDelete(pParse->db, p->pOrderBy);\n    p->pOrderBy = pOrderBy;\n    p->pLimit = pLimit;\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Pragma",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    char *zLeft = 0;\n    char *zRight = 0;\n    const char *zDb = 0;\n    Token *pId;\n    char *aFcntl[4];\n    int iDb;\n    int rc;\n    sqlite3 *db = pParse->db;\n    Db *pDb;\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    const PragmaName *pPragma;\n    if (v == 0)\n        return;\n    sqlite3VdbeRunOnlyOnce(v);\n    pParse->nMem = 2;\n    iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);\n    if (iDb < 0)\n        return;\n    pDb = &db->aDb[iDb];\n    if (iDb == 1 && sqlite3OpenTempDatabase(pParse)) {\n        return;\n    }\n    zLeft = sqlite3NameFromToken(db, pId);\n    if (!zLeft)\n        return;\n    if (minusFlag) {\n        zRight = sqlite3MPrintf(db, \"-%T\", pValue);\n    } else {\n        zRight = sqlite3NameFromToken(db, pValue);\n    }\n    assert(pId2);\n    zDb = pId2->n > 0 ? pDb->zDbSName : 0;\n    if (sqlite3AuthCheck(pParse, 19, zLeft, zRight, zDb)) {\n        goto pragma_out;\n    }\n    aFcntl[0] = 0;\n    aFcntl[1] = zLeft;\n    aFcntl[2] = zRight;\n    aFcntl[3] = 0;\n    db->busyHandler.nBusy = 0;\n    rc = sqlite3_file_control(db, zDb, 14, (void *)aFcntl);\n    if (rc == 0) {\n        sqlite3VdbeSetNumCols(v, 1);\n        sqlite3VdbeSetColName(v, 0, 0, aFcntl[0], ((sqlite3_destructor_type)-1));\n        returnSingleText(v, aFcntl[0]);\n        sqlite3_free(aFcntl[0]);\n        goto pragma_out;\n    }\n    if (rc != 12) {\n        if (aFcntl[0]) {\n            sqlite3ErrorMsg(pParse, \"%s\", aFcntl[0]);\n            sqlite3_free(aFcntl[0]);\n        }\n        pParse->nErr++;\n        pParse->rc = rc;\n        goto pragma_out;\n    }\n    pPragma = pragmaLocate(zLeft);\n    if (pPragma == 0) {\n        goto pragma_out;\n    }\n    if ((pPragma->mPragFlg & 1) != 0) {\n        if (sqlite3ReadSchema(pParse))\n            goto pragma_out;\n    }\n    if ((pPragma->mPragFlg & 2) == 0 && ((pPragma->mPragFlg & 4) == 0 || zRight == 0)) {\n        setPragmaResultColumnNames(v, pPragma);\n    }\n    switch (pPragma->ePragTyp) {\n      case 13:\n        {\n            static const int iLn = 0;\n            static const VdbeOpList getCacheSize[] = {{2, 0, 0, 0}, {99, 0, 1, 3}, {59, 1, 8, 0}, {71, 0, 2, 0}, {107, 1, 2, 1}, {59, 1, 8, 0}, {71, 0, 1, 0}, {184, 0, 0, 0}, {84, 1, 1, 0}};\n            VdbeOp *aOp;\n            sqlite3VdbeUsesBtree(v, iDb);\n            if (!zRight) {\n                pParse->nMem += 2;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (getCacheSize) / sizeof (getCacheSize[0]))), getCacheSize, iLn);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[6].p1 = -2000;\n            } else {\n                int size = sqlite3AbsInt32(sqlite3Atoi(zRight));\n                sqlite3BeginWriteOperation(pParse, 0, iDb);\n                sqlite3VdbeAddOp3(v, 100, iDb, 3, size);\n                assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n                pDb->pSchema->cache_size = size;\n                sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n            }\n            break;\n        }\n      case 31:\n        {\n            Btree *pBt = pDb->pBt;\n            assert(pBt != 0);\n            if (!zRight) {\n                int size = (pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;\n                returnSingleInt(v, size);\n            } else {\n                db->nextPagesize = sqlite3Atoi(zRight);\n                if (7 == sqlite3BtreeSetPageSize(pBt, db->nextPagesize, 0, 0)) {\n                    sqlite3OomFault(db);\n                }\n            }\n            break;\n        }\n      case 33:\n        {\n            Btree *pBt = pDb->pBt;\n            int b = -1;\n            assert(pBt != 0);\n            if (zRight) {\n                if (sqlite3_stricmp(zRight, \"fast\") == 0) {\n                    b = 2;\n                } else {\n                    b = sqlite3GetBoolean(zRight, 0);\n                }\n            }\n            if (pId2->n == 0 && b >= 0) {\n                int ii;\n                for (ii = 0; ii < db->nDb; ii++) {\n                    sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);\n                }\n            }\n            b = sqlite3BtreeSecureDelete(pBt, b);\n            returnSingleInt(v, b);\n            break;\n        }\n      case 27:\n        {\n            int iReg;\n            i64 x = 0;\n            sqlite3CodeVerifySchema(pParse, iDb);\n            iReg = ++pParse->nMem;\n            if ((sqlite3UpperToLower[(unsigned char)(zLeft[0])]) == 'p') {\n                sqlite3VdbeAddOp2(v, 177, iDb, iReg);\n            } else {\n                if (zRight && sqlite3DecOrHexToI64(zRight, &x) == 0) {\n                    if (x < 0)\n                        x = 0;\n                    else if (x > 4294967294U)\n                        x = 4294967294U;\n                } else {\n                    x = 0;\n                }\n                sqlite3VdbeAddOp3(v, 178, iDb, iReg, (int)x);\n            }\n            sqlite3VdbeAddOp2(v, 84, iReg, 1);\n            break;\n        }\n      case 26:\n        {\n            const char *zRet = \"normal\";\n            int eMode = getLockingMode(zRight);\n            if (pId2->n == 0 && eMode == -1) {\n                eMode = db->dfltLockMode;\n            } else {\n                Pager *pPager;\n                if (pId2->n == 0) {\n                    int ii;\n                    assert(pDb == &db->aDb[0]);\n                    for (ii = 2; ii < db->nDb; ii++) {\n                        pPager = sqlite3BtreePager(db->aDb[ii].pBt);\n                        sqlite3PagerLockingMode(pPager, eMode);\n                    }\n                    db->dfltLockMode = (u8)eMode;\n                }\n                pPager = sqlite3BtreePager(pDb->pBt);\n                eMode = sqlite3PagerLockingMode(pPager, eMode);\n            }\n            assert(eMode == 0 || eMode == 1);\n            if (eMode == 1) {\n                zRet = \"exclusive\";\n            }\n            returnSingleText(v, zRet);\n            break;\n        }\n      case 23:\n        {\n            int eMode;\n            int ii;\n            if (zRight == 0) {\n                eMode = (-1);\n            } else {\n                const char *zMode;\n                int n = sqlite3Strlen30(zRight);\n                for (eMode = 0; (zMode = sqlite3JournalModename(eMode)) != 0; eMode++) {\n                    if (sqlite3_strnicmp(zRight, zMode, n) == 0)\n                        break;\n                }\n                if (!zMode) {\n                    eMode = (-1);\n                }\n                if (eMode == 2 && (db->flags & 268435456) != 0) {\n                    eMode = (-1);\n                }\n            }\n            if (eMode == (-1) && pId2->n == 0) {\n                iDb = 0;\n                pId2->n = 1;\n            }\n            for (ii = db->nDb - 1; ii >= 0; ii--) {\n                if (db->aDb[ii].pBt && (ii == iDb || pId2->n == 0)) {\n                    sqlite3VdbeUsesBtree(v, ii);\n                    sqlite3VdbeAddOp3(v, 4, ii, 1, eMode);\n                }\n            }\n            sqlite3VdbeAddOp2(v, 84, 1, 1);\n            break;\n        }\n      case 24:\n        {\n            Pager *pPager = sqlite3BtreePager(pDb->pBt);\n            i64 iLimit = -2;\n            if (zRight) {\n                sqlite3DecOrHexToI64(zRight, &iLimit);\n                if (iLimit < -1)\n                    iLimit = -1;\n            }\n            iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);\n            returnSingleInt(v, iLimit);\n            break;\n        }\n      case 3:\n        {\n            Btree *pBt = pDb->pBt;\n            assert(pBt != 0);\n            if (!zRight) {\n                returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));\n            } else {\n                int eAuto = getAutoVacuum(zRight);\n                assert(eAuto >= 0 && eAuto <= 2);\n                db->nextAutovac = (u8)eAuto;\n                rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);\n                if (rc == 0 && (eAuto == 1 || eAuto == 2)) {\n                    static const int iLn = 0;\n                    static const VdbeOpList setMeta6[] = {{2, 0, 1, 0}, {99, 0, 1, 4}, {16, 1, 0, 0}, {70, 0, 2, 0}, {100, 0, 7, 0}};\n                    VdbeOp *aOp;\n                    int iAddr = sqlite3VdbeCurrentAddr(v);\n                    ;\n                    aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (setMeta6) / sizeof (setMeta6[0]))), setMeta6, iLn);\n                    if ((0))\n                        break;\n                    aOp[0].p1 = iDb;\n                    aOp[1].p1 = iDb;\n                    aOp[2].p2 = iAddr + 4;\n                    aOp[4].p1 = iDb;\n                    aOp[4].p3 = eAuto - 1;\n                    sqlite3VdbeUsesBtree(v, iDb);\n                }\n            }\n            break;\n        }\n      case 19:\n        {\n            int iLimit = 0, addr;\n            if (zRight == 0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit <= 0) {\n                iLimit = 2147483647;\n            }\n            sqlite3BeginWriteOperation(pParse, 0, iDb);\n            sqlite3VdbeAddOp2(v, 71, iLimit, 1);\n            addr = sqlite3VdbeAddOp1(v, 62, iDb);\n            ;\n            sqlite3VdbeAddOp1(v, 84, 1);\n            sqlite3VdbeAddOp2(v, 86, 1, -1);\n            sqlite3VdbeAddOp2(v, 59, 1, addr);\n            ;\n            sqlite3VdbeJumpHere(v, addr);\n            break;\n        }\n      case 6:\n        {\n            assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n            if (!zRight) {\n                returnSingleInt(v, pDb->pSchema->cache_size);\n            } else {\n                int size = sqlite3Atoi(zRight);\n                pDb->pSchema->cache_size = size;\n                sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n            }\n            break;\n        }\n      case 7:\n        {\n            assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n            if (!zRight) {\n                returnSingleInt(v, (db->flags & 32) == 0 ? 0 : sqlite3BtreeSetSpillSize(pDb->pBt, 0));\n            } else {\n                int size = 1;\n                if (sqlite3GetInt32(zRight, &size)) {\n                    sqlite3BtreeSetSpillSize(pDb->pBt, size);\n                }\n                if (sqlite3GetBoolean(zRight, size != 0)) {\n                    db->flags |= 32;\n                } else {\n                    db->flags &= ~(u64)32;\n                }\n                setAllPagerFlags(db);\n            }\n            break;\n        }\n      case 28:\n        {\n            sqlite3_int64 sz;\n            assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n            if (zRight) {\n                int ii;\n                sqlite3DecOrHexToI64(zRight, &sz);\n                if (sz < 0)\n                    sz = sqlite3Config.szMmap;\n                if (pId2->n == 0)\n                    db->szMmap = sz;\n                for (ii = db->nDb - 1; ii >= 0; ii--) {\n                    if (db->aDb[ii].pBt && (ii == iDb || pId2->n == 0)) {\n                        sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);\n                    }\n                }\n            }\n            sz = -1;\n            rc = sqlite3_file_control(db, zDb, 18, &sz);\n            if (rc == 0) {\n                returnSingleInt(v, sz);\n            } else if (rc != 12) {\n                pParse->nErr++;\n                pParse->rc = rc;\n            }\n            break;\n        }\n      case 39:\n        {\n            if (!zRight) {\n                returnSingleInt(v, db->temp_store);\n            } else {\n                changeTempStorage(pParse, zRight);\n            }\n            break;\n        }\n      case 40:\n        {\n            sqlite3_mutex_enter(sqlite3MutexAlloc(11));\n            if (!zRight) {\n                returnSingleText(v, sqlite3_temp_directory);\n            } else {\n                if (zRight[0]) {\n                    int res;\n                    rc = sqlite3OsAccess(db->pVfs, zRight, 1, &res);\n                    if (rc != 0 || res == 0) {\n                        sqlite3ErrorMsg(pParse, \"not a writable directory\");\n                        sqlite3_mutex_leave(sqlite3MutexAlloc(11));\n                        goto pragma_out;\n                    }\n                }\n                if (1 == 0 || (1 == 1 && db->temp_store <= 1) || (1 == 2 && db->temp_store == 1)) {\n                    invalidateTempStorage(pParse);\n                }\n                sqlite3_free(sqlite3_temp_directory);\n                if (zRight[0]) {\n                    sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zRight);\n                } else {\n                    sqlite3_temp_directory = 0;\n                }\n            }\n            sqlite3_mutex_leave(sqlite3MutexAlloc(11));\n            break;\n        }\n      case 25:\n        {\n            if (!zRight) {\n                Pager *pPager = sqlite3BtreePager(pDb->pBt);\n                char *proxy_file_path;\n                sqlite3_file *pFile = sqlite3PagerFile(pPager);\n                sqlite3OsFileControlHint(pFile, 2, &proxy_file_path);\n                returnSingleText(v, proxy_file_path);\n            } else {\n                Pager *pPager = sqlite3BtreePager(pDb->pBt);\n                sqlite3_file *pFile = sqlite3PagerFile(pPager);\n                int res;\n                if (zRight[0]) {\n                    res = sqlite3OsFileControl(pFile, 3, zRight);\n                } else {\n                }\n                if (res != 0) {\n                    sqlite3ErrorMsg(pParse, \"failed to set lock proxy file\");\n                    goto pragma_out;\n                }\n            }\n            break;\n        }\n      case 36:\n        {\n            if (!zRight) {\n                returnSingleInt(v, pDb->safety_level - 1);\n            } else {\n                if (!db->autoCommit) {\n                    sqlite3ErrorMsg(pParse, \"Safety level may not be changed inside a transaction\");\n                } else if (iDb != 1) {\n                    int iLevel = (getSafetyLevel(zRight, 0, 1) + 1) & 7;\n                    if (iLevel == 0)\n                        iLevel = 1;\n                    pDb->safety_level = iLevel;\n                    pDb->bSyncSet = 1;\n                    setAllPagerFlags(db);\n                }\n            }\n            break;\n        }\n      case 4:\n        {\n            if (zRight == 0) {\n                setPragmaResultColumnNames(v, pPragma);\n                returnSingleInt(v, (db->flags & pPragma->iArg) != 0);\n            } else {\n                u64 mask = pPragma->iArg;\n                if (db->autoCommit == 0) {\n                    mask &= ~(16384);\n                }\n                if (sqlite3GetBoolean(zRight, 0)) {\n                    db->flags |= mask;\n                } else {\n                    db->flags &= ~mask;\n                    if (mask == 524288)\n                        db->nDeferredImmCons = 0;\n                    if ((mask & 1) != 0 && sqlite3_stricmp(zRight, \"reset\") == 0) {\n                        sqlite3ResetAllSchemasOfConnection(db);\n                    }\n                }\n                sqlite3VdbeAddOp0(v, 166);\n                setAllPagerFlags(db);\n            }\n            break;\n        }\n      case 37:\n        if (zRight) {\n            Table *pTab;\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n            pTab = sqlite3LocateTable(pParse, 2, zRight, zDb);\n            if (pTab) {\n                int i, k;\n                int nHidden = 0;\n                Column *pCol;\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                pParse->nMem = 7;\n                sqlite3ViewGetColumnNames(pParse, pTab);\n                for (i = 0 , pCol = pTab->aCol; i < pTab->nCol; i++ , pCol++) {\n                    int isHidden = 0;\n                    const Expr *pColExpr;\n                    if (pCol->colFlags & 98) {\n                        if (pPragma->iArg == 0) {\n                            nHidden++;\n                            continue;\n                        }\n                        if (pCol->colFlags & 32) {\n                            isHidden = 2;\n                        } else if (pCol->colFlags & 64) {\n                            isHidden = 3;\n                        } else {\n                            assert(pCol->colFlags & 2);\n                            isHidden = 1;\n                        }\n                    }\n                    if ((pCol->colFlags & 1) == 0) {\n                        k = 0;\n                    } else if (pPk == 0) {\n                        k = 1;\n                    } else {\n                        for (k = 1; k <= pTab->nCol && pPk->aiColumn[k - 1] != i; k++) {\n                        }\n                    }\n                    pColExpr = sqlite3ColumnExpr(pTab, pCol);\n                    assert(pColExpr == 0 || pColExpr->op == 181 || isHidden >= 2);\n                    assert(pColExpr == 0 || !(((pColExpr)->flags & (2048)) != 0) || isHidden >= 2);\n                    sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? \"issisii\" : \"issisi\", i - nHidden, pCol->zCnName, sqlite3ColumnType(pCol, \"\"), pCol->notNull ? 1 : 0, (isHidden >= 2 || pColExpr == 0) ? 0 : pColExpr->u.zToken, k, isHidden);\n                }\n            }\n        }\n        break;\n      case 38:\n        {\n            int ii;\n            pParse->nMem = 6;\n            sqlite3CodeVerifyNamedSchema(pParse, zDb);\n            for (ii = 0; ii < db->nDb; ii++) {\n                HashElem *k;\n                Hash *pHash;\n                int initNCol;\n                if (zDb && sqlite3_stricmp(zDb, db->aDb[ii].zDbSName) != 0)\n                    continue;\n                pHash = &db->aDb[ii].pSchema->tblHash;\n                initNCol = ((pHash)->count);\n                while (initNCol--)\n                    {\n                        for (k = ((pHash)->first); 1; k = ((k)->next)) {\n                            Table *pTab;\n                            if (k == 0) {\n                                initNCol = 0;\n                                break;\n                            }\n                            pTab = ((k)->data);\n                            if (pTab->nCol == 0) {\n                                char *zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\"\", pTab->zName);\n                                if (zSql) {\n                                    sqlite3_stmt *pDummy = 0;\n                                    (void)sqlite3_prepare(db, zSql, -1, &pDummy, 0);\n                                    (void)sqlite3_finalize(pDummy);\n                                    sqlite3DbFree(db, zSql);\n                                }\n                                if (db->mallocFailed) {\n                                    sqlite3ErrorMsg(db->pParse, \"out of memory\");\n                                    db->pParse->rc = 7;\n                                }\n                                pHash = &db->aDb[ii].pSchema->tblHash;\n                                break;\n                            }\n                        }\n                    }\n                for (k = ((pHash)->first); k; k = ((k)->next)) {\n                    Table *pTab = ((k)->data);\n                    const char *zType;\n                    if (zRight && sqlite3_stricmp(zRight, pTab->zName) != 0)\n                        continue;\n                    if (((pTab)->eTabType == 2)) {\n                        zType = \"view\";\n                    } else if (((pTab)->eTabType == 1)) {\n                        zType = \"virtual\";\n                    } else if (pTab->tabFlags & 4096) {\n                        zType = \"shadow\";\n                    } else {\n                        zType = \"table\";\n                    }\n                    sqlite3VdbeMultiLoad(v, 1, \"sssiii\", db->aDb[ii].zDbSName, sqlite3PreferredTableName(pTab->zName), zType, pTab->nCol, (pTab->tabFlags & 128) != 0, (pTab->tabFlags & 65536) != 0);\n                }\n            }\n        }\n        break;\n      case 20:\n        if (zRight) {\n            Index *pIdx;\n            Table *pTab;\n            pIdx = sqlite3FindIndex(db, zRight, zDb);\n            if (pIdx == 0) {\n                pTab = sqlite3LocateTable(pParse, 2, zRight, zDb);\n                if (pTab && !(((pTab)->tabFlags & 128) == 0)) {\n                    pIdx = sqlite3PrimaryKeyIndex(pTab);\n                }\n            }\n            if (pIdx) {\n                int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);\n                int i;\n                int mx;\n                if (pPragma->iArg) {\n                    mx = pIdx->nColumn;\n                    pParse->nMem = 6;\n                } else {\n                    mx = pIdx->nKeyCol;\n                    pParse->nMem = 3;\n                }\n                pTab = pIdx->pTable;\n                sqlite3CodeVerifySchema(pParse, iIdxDb);\n                assert(pParse->nMem <= pPragma->nPragCName);\n                for (i = 0; i < mx; i++) {\n                    i16 cnum = pIdx->aiColumn[i];\n                    sqlite3VdbeMultiLoad(v, 1, \"iisX\", i, cnum, cnum < 0 ? 0 : pTab->aCol[cnum].zCnName);\n                    if (pPragma->iArg) {\n                        sqlite3VdbeMultiLoad(v, 4, \"isiX\", pIdx->aSortOrder[i], pIdx->azColl[i], i < pIdx->nKeyCol);\n                    }\n                    sqlite3VdbeAddOp2(v, 84, 1, pParse->nMem);\n                }\n            }\n        }\n        break;\n      case 21:\n        if (zRight) {\n            Index *pIdx;\n            Table *pTab;\n            int i;\n            pTab = sqlite3FindTable(db, zRight, zDb);\n            if (pTab) {\n                int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                pParse->nMem = 5;\n                sqlite3CodeVerifySchema(pParse, iTabDb);\n                for (pIdx = pTab->pIndex , i = 0; pIdx; pIdx = pIdx->pNext , i++) {\n                    const char *azOrigin[] = {\"c\", \"u\", \"pk\"};\n                    sqlite3VdbeMultiLoad(v, 1, \"isisi\", i, pIdx->zName, ((pIdx)->onError != 0), azOrigin[pIdx->idxType], pIdx->pPartIdxWhere != 0);\n                }\n            }\n        }\n        break;\n      case 12:\n        {\n            int i;\n            pParse->nMem = 3;\n            for (i = 0; i < db->nDb; i++) {\n                if (db->aDb[i].pBt == 0)\n                    continue;\n                assert(db->aDb[i].zDbSName != 0);\n                sqlite3VdbeMultiLoad(v, 1, \"iss\", i, db->aDb[i].zDbSName, sqlite3BtreeGetFilename(db->aDb[i].pBt));\n            }\n        }\n        break;\n      case 9:\n        {\n            int i = 0;\n            HashElem *p;\n            pParse->nMem = 2;\n            for (p = ((&db->aCollSeq)->first); p; p = ((p)->next)) {\n                CollSeq *pColl = (CollSeq *)((p)->data);\n                sqlite3VdbeMultiLoad(v, 1, \"is\", i++, pColl->zName);\n            }\n        }\n        break;\n      case 17:\n        {\n            int i;\n            HashElem *j;\n            FuncDef *p;\n            int showInternFunc = (db->mDbFlags & 32) != 0;\n            pParse->nMem = 6;\n            for (i = 0; i < 23; i++) {\n                for (p = sqlite3BuiltinFunctions.a[i]; p; p = p->u.pHash) {\n                    assert(p->funcFlags & 8388608);\n                    pragmaFunclistLine(v, p, 1, showInternFunc);\n                }\n            }\n            for (j = ((&db->aFunc)->first); j; j = ((j)->next)) {\n                p = (FuncDef *)((j)->data);\n                assert((p->funcFlags & 8388608) == 0);\n                pragmaFunclistLine(v, p, 0, showInternFunc);\n            }\n        }\n        break;\n      case 29:\n        {\n            HashElem *j;\n            pParse->nMem = 1;\n            for (j = ((&db->aModule)->first); j; j = ((j)->next)) {\n                Module *pMod = (Module *)((j)->data);\n                sqlite3VdbeMultiLoad(v, 1, \"s\", pMod->zName);\n            }\n        }\n        break;\n      case 32:\n        {\n            int i;\n            for (i = 0; i < ((int)(sizeof (aPragmaName) / sizeof (aPragmaName[0]))); i++) {\n                sqlite3VdbeMultiLoad(v, 1, \"s\", aPragmaName[i].zName);\n            }\n        }\n        break;\n      case 16:\n        if (zRight) {\n            FKey *pFK;\n            Table *pTab;\n            pTab = sqlite3FindTable(db, zRight, zDb);\n            if (pTab && ((pTab)->eTabType == 0)) {\n                pFK = pTab->u.tab.pFKey;\n                if (pFK) {\n                    int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                    int i = 0;\n                    pParse->nMem = 8;\n                    sqlite3CodeVerifySchema(pParse, iTabDb);\n                    while (pFK)\n                        {\n                            int j;\n                            for (j = 0; j < pFK->nCol; j++) {\n                                sqlite3VdbeMultiLoad(v, 1, \"iissssss\", i, j, pFK->zTo, pTab->aCol[pFK->aCol[j].iFrom].zCnName, pFK->aCol[j].zCol, actionName(pFK->aAction[1]), actionName(pFK->aAction[0]), \"NONE\");\n                            }\n                            ++i;\n                            pFK = pFK->pNextFrom;\n                        }\n                }\n            }\n        }\n        break;\n      case 15:\n        {\n            FKey *pFK;\n            Table *pTab;\n            Table *pParent;\n            Index *pIdx;\n            int i;\n            int j;\n            HashElem *k;\n            int x;\n            int regResult;\n            int regRow;\n            int addrTop;\n            int addrOk;\n            int *aiCols;\n            regResult = pParse->nMem + 1;\n            pParse->nMem += 4;\n            regRow = ++pParse->nMem;\n            k = ((&db->aDb[iDb].pSchema->tblHash)->first);\n            while (k)\n                {\n                    if (zRight) {\n                        pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);\n                        k = 0;\n                    } else {\n                        pTab = (Table *)((k)->data);\n                        k = ((k)->next);\n                    }\n                    if (pTab == 0 || !((pTab)->eTabType == 0) || pTab->u.tab.pFKey == 0)\n                        continue;\n                    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                    zDb = db->aDb[iDb].zDbSName;\n                    sqlite3CodeVerifySchema(pParse, iDb);\n                    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n                    if (pTab->nCol + regRow > pParse->nMem)\n                        pParse->nMem = pTab->nCol + regRow;\n                    sqlite3OpenTable(pParse, 0, iDb, pTab, 112);\n                    sqlite3VdbeLoadString(v, regResult, pTab->zName);\n                    assert(((pTab)->eTabType == 0));\n                    for (i = 1 , pFK = pTab->u.tab.pFKey; pFK; i++ , pFK = pFK->pNextFrom) {\n                        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n                        if (pParent == 0)\n                            continue;\n                        pIdx = 0;\n                        sqlite3TableLock(pParse, iDb, pParent->tnum, 0, pParent->zName);\n                        x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);\n                        if (x == 0) {\n                            if (pIdx == 0) {\n                                sqlite3OpenTable(pParse, i, iDb, pParent, 112);\n                            } else {\n                                sqlite3VdbeAddOp3(v, 112, i, pIdx->tnum, iDb);\n                                sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n                            }\n                        } else {\n                            k = 0;\n                            break;\n                        }\n                    }\n                    assert(pParse->nErr > 0 || pFK == 0);\n                    if (pFK)\n                        break;\n                    if (pParse->nTab < i)\n                        pParse->nTab = i;\n                    addrTop = sqlite3VdbeAddOp1(v, 36, 0);\n                    ;\n                    assert(((pTab)->eTabType == 0));\n                    for (i = 1 , pFK = pTab->u.tab.pFKey; pFK; i++ , pFK = pFK->pNextFrom) {\n                        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n                        pIdx = 0;\n                        aiCols = 0;\n                        if (pParent) {\n                            x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);\n                            assert(x == 0 || db->mallocFailed);\n                        }\n                        addrOk = sqlite3VdbeMakeLabel(pParse);\n                        if (regRow + pFK->nCol > pParse->nMem)\n                            pParse->nMem = regRow + pFK->nCol;\n                        for (j = 0; j < pFK->nCol; j++) {\n                            int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow + j);\n                            sqlite3VdbeAddOp2(v, 50, regRow + j, addrOk);\n                            ;\n                        }\n                        if (pIdx) {\n                            sqlite3VdbeAddOp4(v, 96, regRow, pFK->nCol, 0, sqlite3IndexAffinityStr(db, pIdx), pFK->nCol);\n                            sqlite3VdbeAddOp4Int(v, 29, i, addrOk, regRow, pFK->nCol);\n                            ;\n                        } else if (pParent) {\n                            int jmp = sqlite3VdbeCurrentAddr(v) + 2;\n                            sqlite3VdbeAddOp3(v, 30, i, jmp, regRow);\n                            ;\n                            sqlite3VdbeGoto(v, addrOk);\n                            assert(pFK->nCol == 1 || db->mallocFailed);\n                        }\n                        if ((((pTab)->tabFlags & 128) == 0)) {\n                            sqlite3VdbeAddOp2(v, 135, 0, regResult + 1);\n                        } else {\n                            sqlite3VdbeAddOp2(v, 75, 0, regResult + 1);\n                        }\n                        sqlite3VdbeMultiLoad(v, regResult + 2, \"siX\", pFK->zTo, i - 1);\n                        sqlite3VdbeAddOp2(v, 84, regResult, 4);\n                        sqlite3VdbeResolveLabel(v, addrOk);\n                        sqlite3DbFree(db, aiCols);\n                    }\n                    sqlite3VdbeAddOp2(v, 39, 0, addrTop + 1);\n                    ;\n                    sqlite3VdbeJumpHere(v, addrTop);\n                }\n        }\n        break;\n      case 8:\n        {\n            if (zRight) {\n                sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));\n            }\n        }\n        break;\n      case 22:\n        {\n            int i, j, addr, mxErr;\n            Table *pObjTab = 0;\n            int isQuick = ((sqlite3UpperToLower[(unsigned char)(zLeft[0])]) == 'q');\n            assert(iDb >= 0);\n            assert(iDb == 0 || pId2->z);\n            if (pId2->z == 0)\n                iDb = -1;\n            pParse->nMem = 6;\n            mxErr = 100;\n            if (zRight) {\n                if (sqlite3GetInt32(zRight, &mxErr)) {\n                    if (mxErr <= 0) {\n                        mxErr = 100;\n                    }\n                } else {\n                    pObjTab = sqlite3LocateTable(pParse, 0, zRight, iDb >= 0 ? db->aDb[iDb].zDbSName : 0);\n                }\n            }\n            sqlite3VdbeAddOp2(v, 71, mxErr - 1, 1);\n            for (i = 0; i < db->nDb; i++) {\n                HashElem *x;\n                Hash *pTbls;\n                int *aRoot;\n                int cnt = 0;\n                int mxIdx = 0;\n                if (0 && i == 1)\n                    continue;\n                if (iDb >= 0 && i != iDb)\n                    continue;\n                sqlite3CodeVerifySchema(pParse, i);\n                assert(sqlite3SchemaMutexHeld(db, i, 0));\n                pTbls = &db->aDb[i].pSchema->tblHash;\n                for (cnt = 0 , x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx;\n                    int nIdx;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if ((((pTab)->tabFlags & 128) == 0))\n                        cnt++;\n                    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n                        cnt++;\n                    }\n                    if (nIdx > mxIdx)\n                        mxIdx = nIdx;\n                }\n                if (cnt == 0)\n                    continue;\n                if (pObjTab)\n                    cnt++;\n                aRoot = sqlite3DbMallocRawNN(db, sizeof(int) * (cnt + 1));\n                if (aRoot == 0)\n                    break;\n                cnt = 0;\n                if (pObjTab)\n                    aRoot[++cnt] = 0;\n                for (x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if ((((pTab)->tabFlags & 128) == 0))\n                        aRoot[++cnt] = pTab->tnum;\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        aRoot[++cnt] = pIdx->tnum;\n                    }\n                }\n                aRoot[0] = cnt;\n                pParse->nMem = ((pParse->nMem) > (8 + mxIdx) ? (pParse->nMem) : (8 + mxIdx));\n                sqlite3ClearTempRegCache(pParse);\n                sqlite3VdbeAddOp4(v, 155, 2, cnt, 1, (char *)aRoot, (-14));\n                sqlite3VdbeChangeP5(v, (u8)i);\n                addr = sqlite3VdbeAddOp1(v, 50, 2);\n                ;\n                sqlite3VdbeAddOp4(v, 117, 0, 3, 0, sqlite3MPrintf(db, \"*** in database %s ***\\n\", db->aDb[i].zDbSName), (-6));\n                sqlite3VdbeAddOp3(v, 111, 2, 3, 3);\n                integrityCheckResultRow(v);\n                sqlite3VdbeJumpHere(v, addr);\n                for (x = ((pTbls)->first); x; x = ((x)->next)) {\n                    Table *pTab = ((x)->data);\n                    Index *pIdx, *pPk;\n                    Index *pPrior = 0;\n                    int loopTop;\n                    int iDataCur, iIdxCur;\n                    int r1 = -1;\n                    int bStrict;\n                    int r2;\n                    int mxCol;\n                    if (!((pTab)->eTabType == 0))\n                        continue;\n                    if (pObjTab && pObjTab != pTab)\n                        continue;\n                    if (isQuick || (((pTab)->tabFlags & 128) == 0)) {\n                        pPk = 0;\n                        r2 = 0;\n                    } else {\n                        pPk = sqlite3PrimaryKeyIndex(pTab);\n                        r2 = sqlite3GetTempRange(pParse, pPk->nKeyCol);\n                        sqlite3VdbeAddOp3(v, 75, 1, r2, r2 + pPk->nKeyCol - 1);\n                    }\n                    sqlite3OpenTableAndIndices(pParse, pTab, 112, 0, 1, 0, &iDataCur, &iIdxCur);\n                    sqlite3VdbeAddOp2(v, 71, 0, 7);\n                    for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                        sqlite3VdbeAddOp2(v, 71, 0, 8 + j);\n                    }\n                    assert(pParse->nMem >= 8 + j);\n                    assert(sqlite3NoTempsInRange(pParse, 1, 7 + j));\n                    sqlite3VdbeAddOp2(v, 36, iDataCur, 0);\n                    ;\n                    loopTop = sqlite3VdbeAddOp2(v, 86, 7, 1);\n                    mxCol = pTab->nCol - 1;\n                    while (mxCol >= 0 && ((pTab->aCol[mxCol].colFlags & 32) != 0 || pTab->iPKey == mxCol))\n                        mxCol--;\n                    if (mxCol >= 0) {\n                        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, mxCol, 3);\n                        sqlite3VdbeTypeofColumn(v, 3);\n                    }\n                    if (!isQuick) {\n                        if (pPk) {\n                            int a1;\n                            char *zErr;\n                            a1 = sqlite3VdbeAddOp4Int(v, 41, iDataCur, 0, r2, pPk->nKeyCol);\n                            ;\n                            sqlite3VdbeAddOp1(v, 50, r2);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"row not in PRIMARY KEY order for %s\", pTab->zName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, a1);\n                            sqlite3VdbeJumpHere(v, a1 + 1);\n                            for (j = 0; j < pPk->nKeyCol; j++) {\n                                sqlite3ExprCodeLoadIndexColumn(pParse, pPk, iDataCur, j, r2 + j);\n                            }\n                        }\n                    }\n                    bStrict = (pTab->tabFlags & 65536) != 0;\n                    for (j = 0; j < pTab->nCol; j++) {\n                        char *zErr;\n                        Column *pCol = pTab->aCol + j;\n                        int labelError;\n                        int labelOk;\n                        int p1, p3, p4;\n                        int doTypeCheck;\n                        if (j == pTab->iPKey)\n                            continue;\n                        if (bStrict) {\n                            doTypeCheck = pCol->eCType > 1;\n                        } else {\n                            doTypeCheck = pCol->affinity > 65;\n                        }\n                        if (pCol->notNull == 0 && !doTypeCheck)\n                            continue;\n                        p4 = 5;\n                        if (pCol->colFlags & 32) {\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n                            p1 = -1;\n                            p3 = 3;\n                        } else {\n                            if (pCol->iDflt) {\n                                sqlite3_value *pDfltValue = 0;\n                                sqlite3ValueFromExpr(db, sqlite3ColumnExpr(pTab, pCol), ((db)->enc), pCol->affinity, &pDfltValue);\n                                if (pDfltValue) {\n                                    p4 = sqlite3_value_type(pDfltValue);\n                                    sqlite3ValueFree(pDfltValue);\n                                }\n                            }\n                            p1 = iDataCur;\n                            if (!(((pTab)->tabFlags & 128) == 0)) {\n                                ;\n                                p3 = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), j);\n                            } else {\n                                p3 = sqlite3TableColumnToStorage(pTab, j);\n                                ;\n                            }\n                        }\n                        labelError = sqlite3VdbeMakeLabel(pParse);\n                        labelOk = sqlite3VdbeMakeLabel(pParse);\n                        if (pCol->notNull) {\n                            int jmp2 = sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 15);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName, pCol->zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            if (doTypeCheck) {\n                                sqlite3VdbeGoto(v, labelError);\n                                sqlite3VdbeJumpHere(v, jmp2);\n                            } else {\n                            }\n                        }\n                        if (bStrict && doTypeCheck) {\n                            static unsigned char aStdTypeMask[] = {31, 24, 17, 17, 19, 20};\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            assert(pCol->eCType >= 1 && pCol->eCType <= sizeof (aStdTypeMask));\n                            sqlite3VdbeChangeP5(v, aStdTypeMask[pCol->eCType - 1]);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"non-%s value in %s.%s\", sqlite3StdType[pCol->eCType - 1], pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        } else if (!bStrict && pCol->affinity == 66) {\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 28);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"NUMERIC value in %s.%s\", pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        } else if (!bStrict && pCol->affinity >= 67) {\n                            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);\n                            sqlite3VdbeChangeP5(v, 27);\n                            ;\n                            if (p1 >= 0) {\n                                sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n                            }\n                            sqlite3VdbeAddOp4(v, 96, 3, 1, 0, \"C\", (-1));\n                            sqlite3VdbeAddOp4Int(v, 18, -1, labelOk, 3, p4);\n                            sqlite3VdbeChangeP5(v, 28);\n                            ;\n                            zErr = sqlite3MPrintf(db, \"TEXT value in %s.%s\", pTab->zName, pTab->aCol[j].zCnName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                        }\n                        sqlite3VdbeResolveLabel(v, labelError);\n                        integrityCheckResultRow(v);\n                        sqlite3VdbeResolveLabel(v, labelOk);\n                    }\n                    if (pTab->pCheck && (db->flags & 512) == 0) {\n                        ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);\n                        if (db->mallocFailed == 0) {\n                            int addrCkFault = sqlite3VdbeMakeLabel(pParse);\n                            int addrCkOk = sqlite3VdbeMakeLabel(pParse);\n                            char *zErr;\n                            int k;\n                            pParse->iSelfTab = iDataCur + 1;\n                            for (k = pCheck->nExpr - 1; k > 0; k--) {\n                                sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);\n                            }\n                            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, 16);\n                            sqlite3VdbeResolveLabel(v, addrCkFault);\n                            pParse->iSelfTab = 0;\n                            zErr = sqlite3MPrintf(db, \"CHECK constraint failed in %s\", pTab->zName);\n                            sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, (-6));\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeResolveLabel(v, addrCkOk);\n                        }\n                        sqlite3ExprListDelete(db, pCheck);\n                    }\n                    if (!isQuick) {\n                        for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                            int jmp2, jmp3, jmp4, jmp5;\n                            int ckUniq = sqlite3VdbeMakeLabel(pParse);\n                            if (pPk == pIdx)\n                                continue;\n                            r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3, pPrior, r1);\n                            pPrior = pIdx;\n                            sqlite3VdbeAddOp2(v, 86, 8 + j, 1);\n                            jmp2 = sqlite3VdbeAddOp4Int(v, 29, iIdxCur + j, ckUniq, r1, pIdx->nColumn);\n                            ;\n                            sqlite3VdbeLoadString(v, 3, \"row \");\n                            sqlite3VdbeAddOp3(v, 111, 7, 3, 3);\n                            sqlite3VdbeLoadString(v, 4, \" missing from index \");\n                            sqlite3VdbeAddOp3(v, 111, 4, 3, 3);\n                            jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);\n                            sqlite3VdbeAddOp3(v, 111, 4, 3, 3);\n                            jmp4 = integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, jmp2);\n                            if (((pIdx)->onError != 0)) {\n                                int uniqOk = sqlite3VdbeMakeLabel(pParse);\n                                int jmp6;\n                                int kk;\n                                for (kk = 0; kk < pIdx->nKeyCol; kk++) {\n                                    int iCol = pIdx->aiColumn[kk];\n                                    assert(iCol != (-1) && iCol < pTab->nCol);\n                                    if (iCol >= 0 && pTab->aCol[iCol].notNull)\n                                        continue;\n                                    sqlite3VdbeAddOp2(v, 50, r1 + kk, uniqOk);\n                                    ;\n                                }\n                                jmp6 = sqlite3VdbeAddOp1(v, 39, iIdxCur + j);\n                                ;\n                                sqlite3VdbeGoto(v, uniqOk);\n                                sqlite3VdbeJumpHere(v, jmp6);\n                                sqlite3VdbeAddOp4Int(v, 41, iIdxCur + j, uniqOk, r1, pIdx->nKeyCol);\n                                ;\n                                sqlite3VdbeLoadString(v, 3, \"non-unique entry in index \");\n                                sqlite3VdbeGoto(v, jmp5);\n                                sqlite3VdbeResolveLabel(v, uniqOk);\n                            }\n                            sqlite3VdbeJumpHere(v, jmp4);\n                            sqlite3ResolvePartIdxLabel(pParse, jmp3);\n                        }\n                    }\n                    sqlite3VdbeAddOp2(v, 39, iDataCur, loopTop);\n                    ;\n                    sqlite3VdbeJumpHere(v, loopTop - 1);\n                    if (!isQuick) {\n                        sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");\n                        for (j = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , j++) {\n                            if (pPk == pIdx)\n                                continue;\n                            sqlite3VdbeAddOp2(v, 98, iIdxCur + j, 3);\n                            addr = sqlite3VdbeAddOp3(v, 53, 8 + j, 0, 3);\n                            ;\n                            sqlite3VdbeChangeP5(v, 144);\n                            sqlite3VdbeLoadString(v, 4, pIdx->zName);\n                            sqlite3VdbeAddOp3(v, 111, 4, 2, 3);\n                            integrityCheckResultRow(v);\n                            sqlite3VdbeJumpHere(v, addr);\n                        }\n                        if (pPk) {\n                            sqlite3ReleaseTempRange(pParse, r2, pPk->nKeyCol);\n                        }\n                    }\n                }\n            }\n            {\n                static const int iLn = 0;\n                static const VdbeOpList endCode[] = {{86, 1, 0, 0}, {60, 1, 4, 0}, {117, 0, 3, 0}, {84, 3, 1, 0}, {70, 0, 0, 0}, {117, 0, 3, 0}, {9, 0, 3, 0}};\n                VdbeOp *aOp;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (endCode) / sizeof (endCode[0]))), endCode, iLn);\n                if (aOp) {\n                    aOp[0].p2 = 1 - mxErr;\n                    aOp[2].p4type = (-1);\n                    aOp[2].p4.z = \"ok\";\n                    aOp[5].p4type = (-1);\n                    aOp[5].p4.z = (char *)sqlite3ErrStr(11);\n                }\n                sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v) - 2);\n            }\n        }\n        break;\n      case 14:\n        {\n            static const struct EncName {\n                char *zName;\n                u8 enc;\n            } encnames[] = {{\"UTF8\", 1}, {\"UTF-8\", 1}, {\"UTF-16le\", 2}, {\"UTF-16be\", 3}, {\"UTF16le\", 2}, {\"UTF16be\", 3}, {\"UTF-16\", 0}, {\"UTF16\", 0}, {0, 0}};\n            const struct EncName *pEnc;\n            if (!zRight) {\n                if (sqlite3ReadSchema(pParse))\n                    goto pragma_out;\n                assert(encnames[1].enc == 1);\n                assert(encnames[2].enc == 2);\n                assert(encnames[3].enc == 3);\n                returnSingleText(v, encnames[((pParse->db)->enc)].zName);\n            } else {\n                if ((db->mDbFlags & 64) == 0) {\n                    for (pEnc = &encnames[0]; pEnc->zName; pEnc++) {\n                        if (0 == sqlite3StrICmp(zRight, pEnc->zName)) {\n                            u8 enc = pEnc->enc ? pEnc->enc : 2;\n                            ((db)->aDb[0].pSchema->enc) = enc;\n                            sqlite3SetTextEncoding(db, enc);\n                            break;\n                        }\n                    }\n                    if (!pEnc->zName) {\n                        sqlite3ErrorMsg(pParse, \"unsupported encoding: %s\", zRight);\n                    }\n                }\n            }\n        }\n        break;\n      case 2:\n        {\n            int iCookie = pPragma->iArg;\n            sqlite3VdbeUsesBtree(v, iDb);\n            if (zRight && (pPragma->mPragFlg & 8) == 0) {\n                static const VdbeOpList setCookie[] = {{2, 0, 1, 0}, {100, 0, 0, 0}};\n                VdbeOp *aOp;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (setCookie) / sizeof (setCookie[0]))), setCookie, 0);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[1].p2 = iCookie;\n                aOp[1].p3 = sqlite3Atoi(zRight);\n                aOp[1].p5 = 1;\n            } else {\n                static const VdbeOpList readCookie[] = {{2, 0, 0, 0}, {99, 0, 1, 0}, {84, 1, 1, 0}};\n                VdbeOp *aOp;\n                ;\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (readCookie) / sizeof (readCookie[0]))), readCookie, 0);\n                if ((0))\n                    break;\n                aOp[0].p1 = iDb;\n                aOp[1].p1 = iDb;\n                aOp[1].p3 = iCookie;\n                sqlite3VdbeReusable(v);\n            }\n        }\n        break;\n      case 10:\n        {\n            int i = 0;\n            const char *zOpt;\n            pParse->nMem = 1;\n            while ((zOpt = sqlite3_compileoption_get(i++)) != 0)\n                {\n                    sqlite3VdbeLoadString(v, 1, zOpt);\n                    sqlite3VdbeAddOp2(v, 84, 1, 1);\n                }\n            sqlite3VdbeReusable(v);\n        }\n        break;\n      case 43:\n        {\n            int iBt = (pId2->z ? iDb : (10 + 2));\n            int eMode = 0;\n            if (zRight) {\n                if (sqlite3StrICmp(zRight, \"full\") == 0) {\n                    eMode = 1;\n                } else if (sqlite3StrICmp(zRight, \"restart\") == 0) {\n                    eMode = 2;\n                } else if (sqlite3StrICmp(zRight, \"truncate\") == 0) {\n                    eMode = 3;\n                }\n            }\n            pParse->nMem = 3;\n            sqlite3VdbeAddOp3(v, 3, iBt, eMode, 1);\n            sqlite3VdbeAddOp2(v, 84, 1, 3);\n        }\n        break;\n      case 42:\n        {\n            if (zRight) {\n                sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));\n            }\n            returnSingleInt(v, db->xWalCallback == sqlite3WalDefaultHook ? ((int)(long)(db->pWalArg)) : 0);\n        }\n        break;\n      case 34:\n        {\n            sqlite3_db_release_memory(db);\n            break;\n        }\n      case 30:\n        {\n            int iDbLast;\n            int iTabCur;\n            HashElem *k;\n            Schema *pSchema;\n            Table *pTab;\n            Index *pIdx;\n            LogEst szThreshold;\n            char *zSubSql;\n            u32 opMask;\n            if (zRight) {\n                opMask = (u32)sqlite3Atoi(zRight);\n                if ((opMask & 2) == 0)\n                    break;\n            } else {\n                opMask = 65534;\n            }\n            iTabCur = pParse->nTab++;\n            for (iDbLast = zDb ? iDb : db->nDb - 1; iDb <= iDbLast; iDb++) {\n                if (iDb == 1)\n                    continue;\n                sqlite3CodeVerifySchema(pParse, iDb);\n                pSchema = db->aDb[iDb].pSchema;\n                for (k = ((&pSchema->tblHash)->first); k; k = ((k)->next)) {\n                    pTab = (Table *)((k)->data);\n                    if ((pTab->tabFlags & 256) == 0)\n                        continue;\n                    szThreshold = pTab->nRowLogEst + 46;\n                    assert(sqlite3LogEst(25) == 46);\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        if (!pIdx->hasStat1) {\n                            szThreshold = 0;\n                            break;\n                        }\n                    }\n                    if (szThreshold) {\n                        sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 112);\n                        sqlite3VdbeAddOp3(v, 33, iTabCur, sqlite3VdbeCurrentAddr(v) + 2 + (opMask & 1), szThreshold);\n                        ;\n                    }\n                    zSubSql = sqlite3MPrintf(db, \"ANALYZE \\\"%w\\\".\\\"%w\\\"\", db->aDb[iDb].zDbSName, pTab->zName);\n                    if (opMask & 1) {\n                        int r1 = sqlite3GetTempReg(pParse);\n                        sqlite3VdbeAddOp4(v, 117, 0, r1, 0, zSubSql, (-6));\n                        sqlite3VdbeAddOp2(v, 84, r1, 1);\n                    } else {\n                        sqlite3VdbeAddOp4(v, 148, 0, 0, 0, zSubSql, (-6));\n                    }\n                }\n            }\n            sqlite3VdbeAddOp0(v, 166);\n            break;\n        }\n      default:\n        {\n            assert(pPragma->ePragTyp == 5);\n            if (zRight) {\n                sqlite3_busy_timeout(db, sqlite3Atoi(zRight));\n            }\n            returnSingleInt(v, db->busyTimeout);\n            break;\n        }\n      case 35:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0) {\n                sqlite3_soft_heap_limit64(N);\n            }\n            returnSingleInt(v, sqlite3_soft_heap_limit64(-1));\n            break;\n        }\n      case 18:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0) {\n                sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);\n                if (N > 0 && (iPrior == 0 || iPrior > N))\n                    sqlite3_hard_heap_limit64(N);\n            }\n            returnSingleInt(v, sqlite3_hard_heap_limit64(-1));\n            break;\n        }\n      case 41:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0 && N >= 0) {\n                sqlite3_limit(db, 11, (int)(N & 2147483647));\n            }\n            returnSingleInt(v, sqlite3_limit(db, 11, -1));\n            break;\n        }\n      case 1:\n        {\n            sqlite3_int64 N;\n            if (zRight && sqlite3DecOrHexToI64(zRight, &N) == 0 && N >= 0) {\n                db->nAnalysisLimit = (int)(N & 2147483647);\n            }\n            returnSingleInt(v, db->nAnalysisLimit);\n            break;\n        }\n    }\n    if ((pPragma->mPragFlg & 4) && zRight) {\n        ;\n    }\n  pragma_out:\n    sqlite3DbFree(db, zLeft);\n    sqlite3DbFree(db, zRight);\n}\n"
  },
  {
    "id": "#23:25#sqlite3Insert",
    "gotos": 18,
    "labels": 2,
    "body": "{\n    sqlite3 *db;\n    Table *pTab;\n    int i, j;\n    Vdbe *v;\n    Index *pIdx;\n    int nColumn;\n    int nHidden = 0;\n    int iDataCur = 0;\n    int iIdxCur = 0;\n    int ipkColumn = -1;\n    int endOfLoop;\n    int srcTab = 0;\n    int addrInsTop = 0;\n    int addrCont = 0;\n    SelectDest dest;\n    int iDb;\n    u8 useTempTable = 0;\n    u8 appendFlag = 0;\n    u8 withoutRowid;\n    u8 bIdListInOrder;\n    ExprList *pList = 0;\n    int iRegStore;\n    int regFromSelect = 0;\n    int regAutoinc = 0;\n    int regRowCount = 0;\n    int regIns;\n    int regRowid;\n    int regData;\n    int *aRegIdx = 0;\n    int isView;\n    Trigger *pTrigger;\n    int tmask;\n    db = pParse->db;\n    assert(db->pParse == pParse);\n    if (pParse->nErr) {\n        goto insert_cleanup;\n    }\n    assert(db->mallocFailed == 0);\n    dest.iSDParm = 0;\n    if (pSelect && (pSelect->selFlags & 512) != 0 && pSelect->pPrior == 0) {\n        pList = pSelect->pEList;\n        pSelect->pEList = 0;\n        sqlite3SelectDelete(db, pSelect);\n        pSelect = 0;\n    }\n    assert(pTabList->nSrc == 1);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0) {\n        goto insert_cleanup;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iDb < db->nDb);\n    if (sqlite3AuthCheck(pParse, 18, pTab->zName, 0, db->aDb[iDb].zDbSName)) {\n        goto insert_cleanup;\n    }\n    withoutRowid = !(((pTab)->tabFlags & 128) == 0);\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 127, 0, &tmask);\n    isView = ((pTab)->eTabType == 2);\n    assert((pTrigger && tmask) || (pTrigger == 0 && tmask == 0));\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto insert_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, tmask)) {\n        goto insert_cleanup;\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0)\n        goto insert_cleanup;\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);\n    if (pColumn == 0 && pSelect != 0 && pTrigger == 0 && xferOptimization(pParse, pTab, pSelect, onError, iDb)) {\n        assert(!pTrigger);\n        assert(pList == 0);\n        goto insert_end;\n    }\n    regAutoinc = autoIncBegin(pParse, iDb, pTab);\n    regRowid = regIns = pParse->nMem + 1;\n    pParse->nMem += pTab->nCol + 1;\n    if (((pTab)->eTabType == 1)) {\n        regRowid++;\n        pParse->nMem++;\n    }\n    regData = regRowid + 1;\n    bIdListInOrder = (pTab->tabFlags & (1024 | 64)) == 0;\n    if (pColumn) {\n        assert(pColumn->eU4 != 2);\n        pColumn->eU4 = 1;\n        for (i = 0; i < pColumn->nId; i++) {\n            pColumn->a[i].u4.idx = -1;\n        }\n        for (i = 0; i < pColumn->nId; i++) {\n            for (j = 0; j < pTab->nCol; j++) {\n                if (sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zCnName) == 0) {\n                    pColumn->a[i].u4.idx = j;\n                    if (i != j)\n                        bIdListInOrder = 0;\n                    if (j == pTab->iPKey) {\n                        ipkColumn = i;\n                        assert(!withoutRowid);\n                    }\n                    if (pTab->aCol[j].colFlags & (64 | 32)) {\n                        sqlite3ErrorMsg(pParse, \"cannot INSERT into generated column \\\"%s\\\"\", pTab->aCol[j].zCnName);\n                        goto insert_cleanup;\n                    }\n                    break;\n                }\n            }\n            if (j >= pTab->nCol) {\n                if (sqlite3IsRowid(pColumn->a[i].zName) && !withoutRowid) {\n                    ipkColumn = i;\n                    bIdListInOrder = 0;\n                } else {\n                    sqlite3ErrorMsg(pParse, \"table %S has no column named %s\", pTabList->a, pColumn->a[i].zName);\n                    pParse->checkSchema = 1;\n                    goto insert_cleanup;\n                }\n            }\n        }\n    }\n    if (pSelect) {\n        int regYield;\n        int addrTop;\n        int rc;\n        regYield = ++pParse->nMem;\n        addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, addrTop);\n        sqlite3SelectDestInit(&dest, 13, regYield);\n        dest.iSdst = bIdListInOrder ? regData : 0;\n        dest.nSdst = pTab->nCol;\n        rc = sqlite3Select(pParse, pSelect, &dest);\n        regFromSelect = dest.iSdst;\n        assert(db->pParse == pParse);\n        if (rc || pParse->nErr)\n            goto insert_cleanup;\n        assert(db->mallocFailed == 0);\n        sqlite3VdbeEndCoroutine(v, regYield);\n        sqlite3VdbeJumpHere(v, addrTop - 1);\n        assert(pSelect->pEList);\n        nColumn = pSelect->pEList->nExpr;\n        if (pTrigger || readsTable(pParse, iDb, pTab)) {\n            useTempTable = 1;\n        }\n        if (useTempTable) {\n            int regRec;\n            int regTempRowid;\n            int addrL;\n            srcTab = pParse->nTab++;\n            regRec = sqlite3GetTempReg(pParse);\n            regTempRowid = sqlite3GetTempReg(pParse);\n            sqlite3VdbeAddOp2(v, 118, srcTab, nColumn);\n            addrL = sqlite3VdbeAddOp1(v, 12, dest.iSDParm);\n            ;\n            sqlite3VdbeAddOp3(v, 97, regFromSelect, nColumn, regRec);\n            sqlite3VdbeAddOp2(v, 127, srcTab, regTempRowid);\n            sqlite3VdbeAddOp3(v, 128, srcTab, regRec, regTempRowid);\n            sqlite3VdbeGoto(v, addrL);\n            sqlite3VdbeJumpHere(v, addrL);\n            sqlite3ReleaseTempReg(pParse, regRec);\n            sqlite3ReleaseTempReg(pParse, regTempRowid);\n        }\n    } else {\n        NameContext sNC;\n        memset(&sNC, 0, sizeof (sNC));\n        sNC.pParse = pParse;\n        srcTab = -1;\n        assert(useTempTable == 0);\n        if (pList) {\n            nColumn = pList->nExpr;\n            if (sqlite3ResolveExprListNames(&sNC, pList)) {\n                goto insert_cleanup;\n            }\n        } else {\n            nColumn = 0;\n        }\n    }\n    if (pColumn == 0 && nColumn > 0) {\n        ipkColumn = pTab->iPKey;\n        if (ipkColumn >= 0 && (pTab->tabFlags & 96) != 0) {\n            ;\n            ;\n            for (i = ipkColumn - 1; i >= 0; i--) {\n                if (pTab->aCol[i].colFlags & 96) {\n                    ;\n                    ;\n                    ipkColumn--;\n                }\n            }\n        }\n        assert(2 == 2);\n        assert(96 == 96);\n        assert(98 == (96 | 2));\n        if ((pTab->tabFlags & (96 | 2)) != 0) {\n            for (i = 0; i < pTab->nCol; i++) {\n                if (pTab->aCol[i].colFlags & 98)\n                    nHidden++;\n            }\n        }\n        if (nColumn != (pTab->nCol - nHidden)) {\n            sqlite3ErrorMsg(pParse, \"table %S has %d columns but %d values were supplied\", pTabList->a, pTab->nCol - nHidden, nColumn);\n            goto insert_cleanup;\n        }\n    }\n    if (pColumn != 0 && nColumn != pColumn->nId) {\n        sqlite3ErrorMsg(pParse, \"%d values for %d columns\", nColumn, pColumn->nId);\n        goto insert_cleanup;\n    }\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning) {\n        regRowCount = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, regRowCount);\n    }\n    if (!isView) {\n        int nIdx;\n        nIdx = sqlite3OpenTableAndIndices(pParse, pTab, 113, 0, -1, 0, &iDataCur, &iIdxCur);\n        aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int) * (nIdx + 2));\n        if (aRegIdx == 0) {\n            goto insert_cleanup;\n        }\n        for (i = 0 , pIdx = pTab->pIndex; i < nIdx; pIdx = pIdx->pNext , i++) {\n            assert(pIdx);\n            aRegIdx[i] = ++pParse->nMem;\n            pParse->nMem += pIdx->nColumn;\n        }\n        aRegIdx[i] = ++pParse->nMem;\n    }\n    if (pUpsert) {\n        Upsert *pNx;\n        if (((pTab)->eTabType == 1)) {\n            sqlite3ErrorMsg(pParse, \"UPSERT not implemented for virtual table \\\"%s\\\"\", pTab->zName);\n            goto insert_cleanup;\n        }\n        if (((pTab)->eTabType == 2)) {\n            sqlite3ErrorMsg(pParse, \"cannot UPSERT a view\");\n            goto insert_cleanup;\n        }\n        if (sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget)) {\n            goto insert_cleanup;\n        }\n        pTabList->a[0].iCursor = iDataCur;\n        pNx = pUpsert;\n        do {\n            pNx->pUpsertSrc = pTabList;\n            pNx->regData = regData;\n            pNx->iDataCur = iDataCur;\n            pNx->iIdxCur = iIdxCur;\n            if (pNx->pUpsertTarget) {\n                if (sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx)) {\n                    goto insert_cleanup;\n                }\n            }\n            pNx = pNx->pNextUpsert;\n        } while (pNx != 0);\n    }\n    if (useTempTable) {\n        addrInsTop = sqlite3VdbeAddOp1(v, 36, srcTab);\n        ;\n        addrCont = sqlite3VdbeCurrentAddr(v);\n    } else if (pSelect) {\n        ;\n        addrInsTop = addrCont = sqlite3VdbeAddOp1(v, 12, dest.iSDParm);\n        ;\n        if (ipkColumn >= 0) {\n            sqlite3VdbeAddOp2(v, 80, regFromSelect + ipkColumn, regRowid);\n        }\n    }\n    nHidden = 0;\n    iRegStore = regData;\n    assert(regData == regRowid + 1);\n    for (i = 0; i < pTab->nCol; i++ , iRegStore++) {\n        int k;\n        u32 colFlags;\n        assert(i >= nHidden);\n        if (i == pTab->iPKey) {\n            sqlite3VdbeAddOp1(v, 76, iRegStore);\n            continue;\n        }\n        if (((colFlags = pTab->aCol[i].colFlags) & 98) != 0) {\n            nHidden++;\n            if ((colFlags & 32) != 0) {\n                iRegStore--;\n                continue;\n            } else if ((colFlags & 64) != 0) {\n                if (tmask & 1) {\n                    sqlite3VdbeAddOp1(v, 76, iRegStore);\n                }\n                continue;\n            } else if (pColumn == 0) {\n                sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n                continue;\n            }\n        }\n        if (pColumn) {\n            assert(pColumn->eU4 == 1);\n            for (j = 0; j < pColumn->nId && pColumn->a[j].u4.idx != i; j++) {\n            }\n            if (j >= pColumn->nId) {\n                sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n                continue;\n            }\n            k = j;\n        } else if (nColumn == 0) {\n            sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &pTab->aCol[i]), iRegStore);\n            continue;\n        } else {\n            k = i - nHidden;\n        }\n        if (useTempTable) {\n            sqlite3VdbeAddOp3(v, 94, srcTab, k, iRegStore);\n        } else if (pSelect) {\n            if (regFromSelect != regData) {\n                sqlite3VdbeAddOp2(v, 81, regFromSelect + k, iRegStore);\n            }\n        } else {\n            Expr *pX = pList->a[k].pExpr;\n            int y = sqlite3ExprCodeTarget(pParse, pX, iRegStore);\n            if (y != iRegStore) {\n                sqlite3VdbeAddOp2(v, (((pX)->flags & (4194304)) != 0) ? 80 : 81, y, iRegStore);\n            }\n        }\n    }\n    endOfLoop = sqlite3VdbeMakeLabel(pParse);\n    if (tmask & 1) {\n        int regCols = sqlite3GetTempRange(pParse, pTab->nCol + 1);\n        if (ipkColumn < 0) {\n            sqlite3VdbeAddOp2(v, 71, -1, regCols);\n        } else {\n            int addr1;\n            assert(!withoutRowid);\n            if (useTempTable) {\n                sqlite3VdbeAddOp3(v, 94, srcTab, ipkColumn, regCols);\n            } else {\n                assert(pSelect == 0);\n                sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);\n            }\n            addr1 = sqlite3VdbeAddOp1(v, 51, regCols);\n            ;\n            sqlite3VdbeAddOp2(v, 71, -1, regCols);\n            sqlite3VdbeJumpHere(v, addr1);\n            sqlite3VdbeAddOp1(v, 13, regCols);\n            ;\n        }\n        assert(pTab->nNVCol > 0);\n        sqlite3VdbeAddOp3(v, 80, regRowid + 1, regCols + 1, pTab->nNVCol - 1);\n        if (pTab->tabFlags & 96) {\n            ;\n            ;\n            sqlite3ComputeGeneratedColumns(pParse, regCols + 1, pTab);\n        }\n        if (!isView) {\n            sqlite3TableAffinity(v, pTab, regCols + 1);\n        }\n        sqlite3CodeRowTrigger(pParse, pTrigger, 127, 0, 1, pTab, regCols - pTab->nCol - 1, onError, endOfLoop);\n        sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol + 1);\n    }\n    if (!isView) {\n        if (((pTab)->eTabType == 1)) {\n            sqlite3VdbeAddOp2(v, 75, 0, regIns);\n        }\n        if (ipkColumn >= 0) {\n            if (useTempTable) {\n                sqlite3VdbeAddOp3(v, 94, srcTab, ipkColumn, regRowid);\n            } else if (pSelect) {\n            } else {\n                Expr *pIpk = pList->a[ipkColumn].pExpr;\n                if (pIpk->op == 121 && !((pTab)->eTabType == 1)) {\n                    sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n                    appendFlag = 1;\n                } else {\n                    sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);\n                }\n            }\n            if (!appendFlag) {\n                int addr1;\n                if (!((pTab)->eTabType == 1)) {\n                    addr1 = sqlite3VdbeAddOp1(v, 51, regRowid);\n                    ;\n                    sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n                    sqlite3VdbeJumpHere(v, addr1);\n                } else {\n                    addr1 = sqlite3VdbeCurrentAddr(v);\n                    sqlite3VdbeAddOp2(v, 50, regRowid, addr1 + 2);\n                    ;\n                }\n                sqlite3VdbeAddOp1(v, 13, regRowid);\n                ;\n            }\n        } else if (((pTab)->eTabType == 1) || withoutRowid) {\n            sqlite3VdbeAddOp2(v, 75, 0, regRowid);\n        } else {\n            sqlite3VdbeAddOp3(v, 127, iDataCur, regRowid, regAutoinc);\n            appendFlag = 1;\n        }\n        autoIncStep(pParse, regAutoinc, regRowid);\n        if (pTab->tabFlags & 96) {\n            sqlite3ComputeGeneratedColumns(pParse, regRowid + 1, pTab);\n        }\n        if (((pTab)->eTabType == 1)) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            sqlite3VtabMakeWritable(pParse, pTab);\n            sqlite3VdbeAddOp4(v, 7, 1, pTab->nCol + 2, regIns, pVTab, (-11));\n            sqlite3VdbeChangeP5(v, onError == 11 ? 2 : onError);\n            sqlite3MayAbort(pParse);\n        } else {\n            int isReplace = 0;\n            int bUseSeek;\n            sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regIns, 0, ipkColumn >= 0, onError, endOfLoop, &isReplace, 0, pUpsert);\n            if (db->flags & 16384) {\n                sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);\n            }\n            bUseSeek = (isReplace == 0 || !sqlite3VdbeHasSubProgram(v));\n            sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regIns, aRegIdx, 0, appendFlag, bUseSeek);\n        }\n    }\n    if (regRowCount) {\n        sqlite3VdbeAddOp2(v, 86, regRowCount, 1);\n    }\n    if (pTrigger) {\n        sqlite3CodeRowTrigger(pParse, pTrigger, 127, 0, 2, pTab, regData - 2 - pTab->nCol, onError, endOfLoop);\n    }\n    sqlite3VdbeResolveLabel(v, endOfLoop);\n    if (useTempTable) {\n        sqlite3VdbeAddOp2(v, 39, srcTab, addrCont);\n        ;\n        sqlite3VdbeJumpHere(v, addrInsTop);\n        sqlite3VdbeAddOp1(v, 122, srcTab);\n    } else if (pSelect) {\n        sqlite3VdbeGoto(v, addrCont);\n        sqlite3VdbeJumpHere(v, addrInsTop);\n    }\n  insert_end:\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (regRowCount) {\n        sqlite3CodeChangeCount(v, regRowCount, \"rows inserted\");\n    }\n  insert_cleanup:\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprListDelete(db, pList);\n    sqlite3UpsertDelete(db, pUpsert);\n    sqlite3SelectDelete(db, pSelect);\n    sqlite3IdListDelete(db, pColumn);\n    if (aRegIdx)\n        sqlite3DbNNFreeNN(db, aRegIdx);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#124104:1#instrFunc",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    const unsigned char *zHaystack;\n    const unsigned char *zNeedle;\n    int nHaystack;\n    int nNeedle;\n    int typeHaystack, typeNeedle;\n    int N = 1;\n    int isText;\n    unsigned char firstChar;\n    sqlite3_value *pC1 = 0;\n    sqlite3_value *pC2 = 0;\n    (void)(argc);\n    typeHaystack = sqlite3_value_type(argv[0]);\n    typeNeedle = sqlite3_value_type(argv[1]);\n    if (typeHaystack == 5 || typeNeedle == 5)\n        return;\n    nHaystack = sqlite3_value_bytes(argv[0]);\n    nNeedle = sqlite3_value_bytes(argv[1]);\n    if (nNeedle > 0) {\n        if (typeHaystack == 4 && typeNeedle == 4) {\n            zHaystack = sqlite3_value_blob(argv[0]);\n            zNeedle = sqlite3_value_blob(argv[1]);\n            isText = 0;\n        } else if (typeHaystack != 4 && typeNeedle != 4) {\n            zHaystack = sqlite3_value_text(argv[0]);\n            zNeedle = sqlite3_value_text(argv[1]);\n            isText = 1;\n        } else {\n            pC1 = sqlite3_value_dup(argv[0]);\n            zHaystack = sqlite3_value_text(pC1);\n            if (zHaystack == 0)\n                goto endInstrOOM;\n            nHaystack = sqlite3_value_bytes(pC1);\n            pC2 = sqlite3_value_dup(argv[1]);\n            zNeedle = sqlite3_value_text(pC2);\n            if (zNeedle == 0)\n                goto endInstrOOM;\n            nNeedle = sqlite3_value_bytes(pC2);\n            isText = 1;\n        }\n        if (zNeedle == 0 || (nHaystack && zHaystack == 0))\n            goto endInstrOOM;\n        firstChar = zNeedle[0];\n        while (nNeedle <= nHaystack && (zHaystack[0] != firstChar || memcmp(zHaystack, zNeedle, nNeedle) != 0))\n            {\n                N++;\n                do {\n                    nHaystack--;\n                    zHaystack++;\n                } while (isText && (zHaystack[0] & 192) == 128);\n            }\n        if (nNeedle > nHaystack)\n            N = 0;\n    }\n    sqlite3_result_int(context, N);\n  endInstr:\n    sqlite3_value_free(pC1);\n    sqlite3_value_free(pC2);\n    return;\n  endInstrOOM:\n    sqlite3_result_error_nomem(context);\n    goto endInstr;\n}\n"
  },
  {
    "id": "#23:25#sqlite3SrcListAppendFromTerm",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    SrcItem *pItem;\n    sqlite3 *db = pParse->db;\n    if (!p && pOnUsing != 0 && (pOnUsing->pOn || pOnUsing->pUsing)) {\n        sqlite3ErrorMsg(pParse, \"a JOIN clause is required before %s\", (pOnUsing->pOn ? \"ON\" : \"USING\"));\n        goto append_from_error;\n    }\n    p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);\n    if (p == 0) {\n        goto append_from_error;\n    }\n    assert(p->nSrc > 0);\n    pItem = &p->a[p->nSrc - 1];\n    assert((pTable == 0) == (pDatabase == 0));\n    assert(pItem->zName == 0 || pDatabase != 0);\n    if ((pParse->eParseMode >= 2) && pItem->zName) {\n        Token *pToken = ((pDatabase) && pDatabase->z) ? pDatabase : pTable;\n        sqlite3RenameTokenMap(pParse, pItem->zName, pToken);\n    }\n    assert(pAlias != 0);\n    if (pAlias->n) {\n        pItem->zAlias = sqlite3NameFromToken(db, pAlias);\n    }\n    if (pSubquery) {\n        pItem->pSelect = pSubquery;\n        if (pSubquery->selFlags & 2048) {\n            pItem->fg.isNestedFrom = 1;\n        }\n    }\n    assert(pOnUsing == 0 || pOnUsing->pOn == 0 || pOnUsing->pUsing == 0);\n    assert(pItem->fg.isUsing == 0);\n    if (pOnUsing == 0) {\n        pItem->u3.pOn = 0;\n    } else if (pOnUsing->pUsing) {\n        pItem->fg.isUsing = 1;\n        pItem->u3.pUsing = pOnUsing->pUsing;\n    } else {\n        pItem->u3.pOn = pOnUsing->pOn;\n    }\n    return p;\n  append_from_error:\n    assert(p == 0);\n    sqlite3ClearOnOrUsing(db, pOnUsing);\n    sqlite3SelectDelete(db, pSubquery);\n    return 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3DropIndex",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    Index *pIndex;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    if (db->mallocFailed) {\n        goto exit_drop_index;\n    }\n    assert(pParse->nErr == 0);\n    assert(pName->nSrc == 1);\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto exit_drop_index;\n    }\n    pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);\n    if (pIndex == 0) {\n        if (!ifExists) {\n            sqlite3ErrorMsg(pParse, \"no such index: %S\", pName->a);\n        } else {\n            sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n            sqlite3ForceNotReadOnly(pParse);\n        }\n        pParse->checkSchema = 1;\n        goto exit_drop_index;\n    }\n    if (pIndex->idxType != 0) {\n        sqlite3ErrorMsg(pParse, \"index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped\", 0);\n        goto exit_drop_index;\n    }\n    iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n    {\n        int code = 10;\n        Table *pTab = pIndex->pTable;\n        const char *zDb = db->aDb[iDb].zDbSName;\n        const char *zTab = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n        if (sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)) {\n            goto exit_drop_index;\n        }\n        if (!0 && iDb == 1)\n            code = 12;\n        if (sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb)) {\n            goto exit_drop_index;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v) {\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        sqlite3NestedParse(pParse, \"DELETE FROM %Q.sqlite_master WHERE name=%Q AND type='index'\", db->aDb[iDb].zDbSName, pIndex->zName);\n        sqlite3ClearStatTables(pParse, iDb, \"idx\", pIndex->zName);\n        sqlite3ChangeCookie(pParse, iDb);\n        destroyRootPage(pParse, pIndex->tnum, iDb);\n        sqlite3VdbeAddOp4(v, 152, iDb, 0, 0, pIndex->zName, 0);\n    }\n  exit_drop_index:\n    sqlite3SrcListDelete(db, pName);\n}\n"
  },
  {
    "id": "#23:25#sqlite3DropTable",
    "gotos": 10,
    "labels": 1,
    "body": "{\n    Table *pTab;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int iDb;\n    if (db->mallocFailed) {\n        goto exit_drop_table;\n    }\n    assert(pParse->nErr == 0);\n    assert(pName->nSrc == 1);\n    if (sqlite3ReadSchema(pParse))\n        goto exit_drop_table;\n    if (noErr)\n        db->suppressErr++;\n    assert(isView == 0 || isView == 1);\n    pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);\n    if (noErr)\n        db->suppressErr--;\n    if (pTab == 0) {\n        if (noErr) {\n            sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n            sqlite3ForceNotReadOnly(pParse);\n        }\n        goto exit_drop_table;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iDb >= 0 && iDb < db->nDb);\n    if (((pTab)->eTabType == 1) && sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto exit_drop_table;\n    }\n    {\n        int code;\n        const char *zTab = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n        const char *zDb = db->aDb[iDb].zDbSName;\n        const char *zArg2 = 0;\n        if (sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)) {\n            goto exit_drop_table;\n        }\n        if (isView) {\n            if (!0 && iDb == 1) {\n                code = 15;\n            } else {\n                code = 17;\n            }\n        } else if (((pTab)->eTabType == 1)) {\n            code = 30;\n            zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;\n        } else {\n            if (!0 && iDb == 1) {\n                code = 13;\n            } else {\n                code = 11;\n            }\n        }\n        if (sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb)) {\n            goto exit_drop_table;\n        }\n        if (sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb)) {\n            goto exit_drop_table;\n        }\n    }\n    if (tableMayNotBeDropped(db, pTab)) {\n        sqlite3ErrorMsg(pParse, \"table %s may not be dropped\", pTab->zName);\n        goto exit_drop_table;\n    }\n    if (isView && !((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"use DROP TABLE to delete table %s\", pTab->zName);\n        goto exit_drop_table;\n    }\n    if (!isView && ((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"use DROP VIEW to delete view %s\", pTab->zName);\n        goto exit_drop_table;\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v) {\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        if (!isView) {\n            sqlite3ClearStatTables(pParse, iDb, \"tbl\", pTab->zName);\n            sqlite3FkDropTable(pParse, pName, pTab);\n        }\n        sqlite3CodeDropTable(pParse, pTab, iDb, isView);\n    }\n  exit_drop_table:\n    sqlite3SrcListDelete(db, pName);\n}\n"
  },
  {
    "id": "#23:25#sqlite3AddGenerated",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    u8 eType = 32;\n    Table *pTab = pParse->pNewTable;\n    Column *pCol;\n    if (pTab == 0) {\n        goto generated_done;\n    }\n    pCol = &(pTab->aCol[pTab->nCol - 1]);\n    if ((pParse->eParseMode == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables cannot use computed columns\");\n        goto generated_done;\n    }\n    if (pCol->iDflt > 0)\n        goto generated_error;\n    if (pType) {\n        if (pType->n == 7 && sqlite3_strnicmp(\"virtual\", pType->z, 7) == 0) {\n        } else if (pType->n == 6 && sqlite3_strnicmp(\"stored\", pType->z, 6) == 0) {\n            eType = 64;\n        } else {\n            goto generated_error;\n        }\n    }\n    if (eType == 32)\n        pTab->nNVCol--;\n    pCol->colFlags |= eType;\n    assert(32 == 32);\n    assert(64 == 64);\n    pTab->tabFlags |= eType;\n    if (pCol->colFlags & 1) {\n        makeColumnPartOfPrimaryKey(pParse, pCol);\n    }\n    sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);\n    pExpr = 0;\n    goto generated_done;\n  generated_error:\n    sqlite3ErrorMsg(pParse, \"error in generated column \\\"%s\\\"\", pCol->zCnName);\n  generated_done:\n    sqlite3ExprDelete(pParse->db, pExpr);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#130964:12#sqlite3_exec",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    const char *zLeftover;\n    sqlite3_stmt *pStmt = 0;\n    char **azCols = 0;\n    int callbackIsInit;\n    if (!sqlite3SafetyCheckOk(db))\n        return sqlite3MisuseError(130977);\n    if (zSql == 0)\n        zSql = \"\";\n    sqlite3_mutex_enter(db->mutex);\n    sqlite3Error(db, 0);\n    while (rc == 0 && zSql[0])\n        {\n            int nCol = 0;\n            char **azVals = 0;\n            pStmt = 0;\n            rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);\n            assert(rc == 0 || pStmt == 0);\n            if (rc != 0) {\n                continue;\n            }\n            if (!pStmt) {\n                zSql = zLeftover;\n                continue;\n            }\n            callbackIsInit = 0;\n            while (1)\n                {\n                    int i;\n                    rc = sqlite3_step(pStmt);\n                    if (xCallback && (100 == rc || (101 == rc && !callbackIsInit && db->flags & 256))) {\n                        if (!callbackIsInit) {\n                            nCol = sqlite3_column_count(pStmt);\n                            azCols = sqlite3DbMallocRaw(db, (2 * nCol + 1) * sizeof(const char *));\n                            if (azCols == 0) {\n                                goto exec_out;\n                            }\n                            for (i = 0; i < nCol; i++) {\n                                azCols[i] = (char *)sqlite3_column_name(pStmt, i);\n                                assert(azCols[i] != 0);\n                            }\n                            callbackIsInit = 1;\n                        }\n                        if (rc == 100) {\n                            azVals = &azCols[nCol];\n                            for (i = 0; i < nCol; i++) {\n                                azVals[i] = (char *)sqlite3_column_text(pStmt, i);\n                                if (!azVals[i] && sqlite3_column_type(pStmt, i) != 5) {\n                                    sqlite3OomFault(db);\n                                    goto exec_out;\n                                }\n                            }\n                            azVals[i] = 0;\n                        }\n                        if (xCallback(pArg, nCol, azVals, azCols)) {\n                            rc = 4;\n                            sqlite3VdbeFinalize((Vdbe *)pStmt);\n                            pStmt = 0;\n                            sqlite3Error(db, 4);\n                            goto exec_out;\n                        }\n                    }\n                    if (rc != 100) {\n                        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);\n                        pStmt = 0;\n                        zSql = zLeftover;\n                        while ((sqlite3CtypeMap[(unsigned char)(zSql[0])] & 1))\n                            zSql++;\n                        break;\n                    }\n                }\n            sqlite3DbFree(db, azCols);\n            azCols = 0;\n        }\n  exec_out:\n    if (pStmt)\n        sqlite3VdbeFinalize((Vdbe *)pStmt);\n    sqlite3DbFree(db, azCols);\n    rc = sqlite3ApiExit(db, rc);\n    if (rc != 0 && pzErrMsg) {\n        *pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));\n        if (*pzErrMsg == 0) {\n            rc = 7;\n            sqlite3Error(db, 7);\n        }\n    } else if (pzErrMsg) {\n        *pzErrMsg = 0;\n    }\n    assert((rc & db->errMask) == rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#115852:1#attachFunc",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int i;\n    int rc = 0;\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    const char *zName;\n    const char *zFile;\n    char *zPath = 0;\n    char *zErr = 0;\n    unsigned int flags;\n    Db *aNew;\n    Db *pNew;\n    char *zErrDyn = 0;\n    sqlite3_vfs *pVfs;\n    (void)(NotUsed);\n    zFile = (const char *)sqlite3_value_text(argv[0]);\n    zName = (const char *)sqlite3_value_text(argv[1]);\n    if (zFile == 0)\n        zFile = \"\";\n    if (zName == 0)\n        zName = \"\";\n    if ((db->init.reopenMemdb)) {\n        pVfs = sqlite3_vfs_find(\"memdb\");\n        if (pVfs == 0)\n            return;\n        pNew = &db->aDb[db->init.iDb];\n        if (pNew->pBt)\n            sqlite3BtreeClose(pNew->pBt);\n        pNew->pBt = 0;\n        pNew->pSchema = 0;\n        rc = sqlite3BtreeOpen(pVfs, \"x\\000\", db, &pNew->pBt, 0, 256);\n    } else {\n        if (db->nDb >= db->aLimit[7] + 2) {\n            zErrDyn = sqlite3MPrintf(db, \"too many attached databases - max %d\", db->aLimit[7]);\n            goto attach_error;\n        }\n        for (i = 0; i < db->nDb; i++) {\n            assert(zName);\n            if (sqlite3DbIsNamed(db, i, zName)) {\n                zErrDyn = sqlite3MPrintf(db, \"database %s is already in use\", zName);\n                goto attach_error;\n            }\n        }\n        if (db->aDb == db->aDbStatic) {\n            aNew = sqlite3DbMallocRawNN(db, sizeof (db->aDb[0]) * 3);\n            if (aNew == 0)\n                return;\n            memcpy(aNew, db->aDb, sizeof (db->aDb[0]) * 2);\n        } else {\n            aNew = sqlite3DbRealloc(db, db->aDb, sizeof (db->aDb[0]) * (db->nDb + 1));\n            if (aNew == 0)\n                return;\n        }\n        db->aDb = aNew;\n        pNew = &db->aDb[db->nDb];\n        memset(pNew, 0, sizeof (*pNew));\n        flags = db->openFlags;\n        rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);\n        if (rc != 0) {\n            if (rc == 7)\n                sqlite3OomFault(db);\n            sqlite3_result_error(context, zErr, -1);\n            sqlite3_free(zErr);\n            return;\n        }\n        assert(pVfs);\n        flags |= 256;\n        rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);\n        db->nDb++;\n        pNew->zDbSName = sqlite3DbStrDup(db, zName);\n    }\n    db->noSharedCache = 0;\n    if (rc == 19) {\n        rc = 1;\n        zErrDyn = sqlite3MPrintf(db, \"database is already attached\");\n    } else if (rc == 0) {\n        Pager *pPager;\n        pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);\n        if (!pNew->pSchema) {\n            rc = 7;\n        } else if (pNew->pSchema->file_format && pNew->pSchema->enc != ((db)->enc)) {\n            zErrDyn = sqlite3MPrintf(db, \"attached databases must use the same text encoding as main database\");\n            rc = 1;\n        }\n        sqlite3BtreeEnter(pNew->pBt);\n        pPager = sqlite3BtreePager(pNew->pBt);\n        sqlite3PagerLockingMode(pPager, db->dfltLockMode);\n        sqlite3BtreeSecureDelete(pNew->pBt, sqlite3BtreeSecureDelete(db->aDb[0].pBt, -1));\n        sqlite3BtreeSetPagerFlags(pNew->pBt, 3 | (db->flags & 56));\n        sqlite3BtreeLeave(pNew->pBt);\n    }\n    pNew->safety_level = 2 + 1;\n    if (rc == 0 && pNew->zDbSName == 0) {\n        rc = 7;\n    }\n    sqlite3_free_filename(zPath);\n    if (rc == 0) {\n        sqlite3BtreeEnterAll(db);\n        db->init.iDb = 0;\n        db->mDbFlags &= ~(16);\n        if (!(db->init.reopenMemdb)) {\n            rc = sqlite3Init(db, &zErrDyn);\n        }\n        sqlite3BtreeLeaveAll(db);\n        assert(zErrDyn == 0 || rc != 0);\n    }\n    if (rc) {\n        if (!(db->init.reopenMemdb)) {\n            int iDb = db->nDb - 1;\n            assert(iDb >= 2);\n            if (db->aDb[iDb].pBt) {\n                sqlite3BtreeClose(db->aDb[iDb].pBt);\n                db->aDb[iDb].pBt = 0;\n                db->aDb[iDb].pSchema = 0;\n            }\n            sqlite3ResetAllSchemasOfConnection(db);\n            db->nDb = iDb;\n            if (rc == 7 || rc == (10 | (12 << 8))) {\n                sqlite3OomFault(db);\n                sqlite3DbFree(db, zErrDyn);\n                zErrDyn = sqlite3MPrintf(db, \"out of memory\");\n            } else if (zErrDyn == 0) {\n                zErrDyn = sqlite3MPrintf(db, \"unable to open database: %s\", zFile);\n            }\n        }\n        goto attach_error;\n    }\n    return;\n  attach_error:\n    if (zErrDyn) {\n        sqlite3_result_error(context, zErrDyn, -1);\n        sqlite3DbFree(db, zErrDyn);\n    }\n    if (rc)\n        sqlite3_result_error_code(context, rc);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#132323:1#sqlite3LoadExtension",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    sqlite3_vfs *pVfs = db->pVfs;\n    void *handle;\n    sqlite3_loadext_entry xInit;\n    char *zErrmsg = 0;\n    const char *zEntry;\n    char *zAltEntry = 0;\n    void **aHandle;\n    u64 nMsg = strlen(zFile);\n    int ii;\n    int rc;\n    static const char *azEndings[] = {\"dylib\"};\n    if (pzErrMsg)\n        *pzErrMsg = 0;\n    if ((db->flags & 65536) == 0) {\n        if (pzErrMsg) {\n            *pzErrMsg = sqlite3_mprintf(\"not authorized\");\n        }\n        return 1;\n    }\n    zEntry = zProc ? zProc : \"sqlite3_extension_init\";\n    if (<recovery-expr>())\n        goto extension_not_found;\n    handle = sqlite3OsDlOpen(pVfs, zFile);\n    for (ii = 0; ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && handle == 0; ii++) {\n        char *zAltFile = sqlite3_mprintf(\"%s.%s\", zFile, azEndings[ii]);\n        if (zAltFile == 0)\n            return 7;\n        handle = sqlite3OsDlOpen(pVfs, zAltFile);\n        sqlite3_free(zAltFile);\n    }\n    if (handle == 0)\n        goto extension_not_found;\n    xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);\n    if (xInit == 0 && zProc == 0) {\n        int iFile, iEntry, c;\n        int ncFile = sqlite3Strlen30(zFile);\n        zAltEntry = sqlite3_malloc64(ncFile + 30);\n        if (zAltEntry == 0) {\n            sqlite3OsDlClose(pVfs, handle);\n            return 7;\n        }\n        memcpy(zAltEntry, \"sqlite3_\", 8);\n        for (iFile = ncFile - 1; iFile >= 0 && !((zFile[iFile]) == '/'); iFile--) {\n        }\n        iFile++;\n        if (sqlite3_strnicmp(zFile + iFile, \"lib\", 3) == 0)\n            iFile += 3;\n        for (iEntry = 8; (c = zFile[iFile]) != 0 && c != '.'; iFile++) {\n            if ((sqlite3CtypeMap[(unsigned char)(c)] & 2)) {\n                zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned int)c];\n            }\n        }\n        memcpy(zAltEntry + iEntry, \"_init\", 6);\n        zEntry = zAltEntry;\n        xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);\n    }\n    if (xInit == 0) {\n        if (pzErrMsg) {\n            nMsg += strlen(zEntry) + 300;\n            *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n            if (zErrmsg) {\n                assert(nMsg < 2147483647);\n                sqlite3_snprintf((int)nMsg, zErrmsg, \"no entry point [%s] in shared library [%s]\", zEntry, zFile);\n                sqlite3OsDlError(pVfs, nMsg - 1, zErrmsg);\n            }\n        }\n        sqlite3OsDlClose(pVfs, handle);\n        sqlite3_free(zAltEntry);\n        return 1;\n    }\n    sqlite3_free(zAltEntry);\n    rc = xInit(db, &zErrmsg, &sqlite3Apis);\n    if (rc) {\n        if (rc == (0 | (1 << 8)))\n            return 0;\n        if (pzErrMsg) {\n            *pzErrMsg = sqlite3_mprintf(\"error during initialization: %s\", zErrmsg);\n        }\n        sqlite3_free(zErrmsg);\n        sqlite3OsDlClose(pVfs, handle);\n        return 1;\n    }\n    aHandle = sqlite3DbMallocZero(db, sizeof (handle) * (db->nExtension + 1));\n    if (aHandle == 0) {\n        return 7;\n    }\n    if (db->nExtension > 0) {\n        memcpy(aHandle, db->aExtension, sizeof (handle) * db->nExtension);\n    }\n    sqlite3DbFree(db, db->aExtension);\n    db->aExtension = aHandle;\n    db->aExtension[db->nExtension++] = handle;\n    return 0;\n  extension_not_found:\n    if (pzErrMsg) {\n        nMsg += 300;\n        *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);\n        if (zErrmsg) {\n            assert(nMsg < 2147483647);\n            sqlite3OsDlError(pVfs, nMsg - 1, zErrmsg);\n        }\n    }\n    return 1;\n}\n"
  },
  {
    "id": "#23:25#sqlite3AddPrimaryKey",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Table *pTab = pParse->pNewTable;\n    Column *pCol = 0;\n    int iCol = -1, i;\n    int nTerm;\n    if (pTab == 0)\n        goto primary_key_exit;\n    if (pTab->tabFlags & 4) {\n        sqlite3ErrorMsg(pParse, \"table \\\"%s\\\" has more than one primary key\", pTab->zName);\n        goto primary_key_exit;\n    }\n    pTab->tabFlags |= 4;\n    if (pList == 0) {\n        iCol = pTab->nCol - 1;\n        pCol = &pTab->aCol[iCol];\n        makeColumnPartOfPrimaryKey(pParse, pCol);\n        nTerm = 1;\n    } else {\n        nTerm = pList->nExpr;\n        for (i = 0; i < nTerm; i++) {\n            Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);\n            assert(pCExpr != 0);\n            sqlite3StringToId(pCExpr);\n            if (pCExpr->op == 59) {\n                const char *zCName;\n                assert(!(((pCExpr)->flags & (2048)) != 0));\n                zCName = pCExpr->u.zToken;\n                for (iCol = 0; iCol < pTab->nCol; iCol++) {\n                    if (sqlite3StrICmp(zCName, pTab->aCol[iCol].zCnName) == 0) {\n                        pCol = &pTab->aCol[iCol];\n                        makeColumnPartOfPrimaryKey(pParse, pCol);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (nTerm == 1 && pCol && pCol->eCType == 4 && sortOrder != 1) {\n        if ((pParse->eParseMode >= 2) && pList) {\n            Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[0].pExpr);\n            sqlite3RenameTokenRemap(pParse, &pTab->iPKey, pCExpr);\n        }\n        pTab->iPKey = iCol;\n        pTab->keyConf = (u8)onError;\n        assert(autoInc == 0 || autoInc == 1);\n        pTab->tabFlags |= autoInc * 8;\n        if (pList)\n            pParse->iPkSortOrder = pList->a[0].fg.sortFlags;\n        (void)sqlite3HasExplicitNulls(pParse, pList);\n    } else if (autoInc) {\n        sqlite3ErrorMsg(pParse, \"AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY\");\n    } else {\n        sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0, 2);\n        pList = 0;\n    }\n  primary_key_exit:\n    sqlite3ExprListDelete(pParse->db, pList);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprListAppendVector",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    sqlite3 *db = pParse->db;\n    int n;\n    int i;\n    int iFirst = pList ? pList->nExpr : 0;\n    if ((pColumns == 0))\n        goto vector_append_error;\n    if (pExpr == 0)\n        goto vector_append_error;\n    if (pExpr->op != 138 && pColumns->nId != (n = sqlite3ExprVectorSize(pExpr))) {\n        sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\", pColumns->nId, n);\n        goto vector_append_error;\n    }\n    for (i = 0; i < pColumns->nId; i++) {\n        Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i, pColumns->nId);\n        assert(pSubExpr != 0 || db->mallocFailed);\n        if (pSubExpr == 0)\n            continue;\n        pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);\n        if (pList) {\n            assert(pList->nExpr == iFirst + i + 1);\n            pList->a[pList->nExpr - 1].zEName = pColumns->a[i].zName;\n            pColumns->a[i].zName = 0;\n        }\n    }\n    if (!db->mallocFailed && pExpr->op == 138 && (pList != 0)) {\n        Expr *pFirst = pList->a[iFirst].pExpr;\n        assert(pFirst != 0);\n        assert(pFirst->op == 178);\n        pFirst->pRight = pExpr;\n        pExpr = 0;\n        pFirst->iTable = pColumns->nId;\n    }\n  vector_append_error:\n    sqlite3ExprUnmapAndDelete(pParse, pExpr);\n    sqlite3IdListDelete(db, pColumns);\n    return pList;\n}\n"
  },
  {
    "id": "#23:25#sqlite3AlterBeginAddColumn",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    Table *pNew;\n    Table *pTab;\n    int iDb;\n    int i;\n    int nAlloc;\n    sqlite3 *db = pParse->db;\n    assert(pParse->pNewTable == 0);\n    assert(sqlite3BtreeHoldsAllMutexes(db));\n    if (db->mallocFailed)\n        goto exit_begin_add_column;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_begin_add_column;\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables may not be altered\");\n        goto exit_begin_add_column;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"Cannot add a column to a view\");\n        goto exit_begin_add_column;\n    }\n    if (0 != isAlterableTable(pParse, pTab)) {\n        goto exit_begin_add_column;\n    }\n    sqlite3MayAbort(pParse);\n    assert(((pTab)->eTabType == 0));\n    assert(pTab->u.tab.addColOffset > 0);\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    pNew = (Table *)sqlite3DbMallocZero(db, sizeof(Table));\n    if (!pNew)\n        goto exit_begin_add_column;\n    pParse->pNewTable = pNew;\n    pNew->nTabRef = 1;\n    pNew->nCol = pTab->nCol;\n    assert(pNew->nCol > 0);\n    nAlloc = (((pNew->nCol - 1) / 8) * 8) + 8;\n    assert(nAlloc >= pNew->nCol && nAlloc % 8 == 0 && nAlloc - pNew->nCol < 8);\n    pNew->aCol = (Column *)sqlite3DbMallocZero(db, sizeof(Column) * nAlloc);\n    pNew->zName = sqlite3MPrintf(db, \"sqlite_altertab_%s\", pTab->zName);\n    if (!pNew->aCol || !pNew->zName) {\n        assert(db->mallocFailed);\n        goto exit_begin_add_column;\n    }\n    memcpy(pNew->aCol, pTab->aCol, sizeof(Column) * pNew->nCol);\n    for (i = 0; i < pNew->nCol; i++) {\n        Column *pCol = &pNew->aCol[i];\n        pCol->zCnName = sqlite3DbStrDup(db, pCol->zCnName);\n        pCol->hName = sqlite3StrIHash(pCol->zCnName);\n    }\n    assert(((pNew)->eTabType == 0));\n    pNew->u.tab.pDfltList = sqlite3ExprListDup(db, pTab->u.tab.pDfltList, 0);\n    pNew->pSchema = db->aDb[iDb].pSchema;\n    pNew->u.tab.addColOffset = pTab->u.tab.addColOffset;\n    pNew->nTabRef = 1;\n  exit_begin_add_column:\n    sqlite3SrcListDelete(db, pSrc);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3AlterDropColumn",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    sqlite3 *db = pParse->db;\n    Table *pTab;\n    int iDb;\n    const char *zDb;\n    char *zCol = 0;\n    int iCol;\n    assert(pParse->pNewTable == 0);\n    assert(sqlite3BtreeHoldsAllMutexes(db));\n    if ((db->mallocFailed))\n        goto exit_drop_column;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_drop_column;\n    if (0 != isAlterableTable(pParse, pTab))\n        goto exit_drop_column;\n    if (0 != isRealTable(pParse, pTab, 1))\n        goto exit_drop_column;\n    zCol = sqlite3NameFromToken(db, pName);\n    if (zCol == 0) {\n        assert(db->mallocFailed);\n        goto exit_drop_column;\n    }\n    iCol = sqlite3ColumnIndex(pTab, zCol);\n    if (iCol < 0) {\n        sqlite3ErrorMsg(pParse, \"no such column: \\\"%T\\\"\", pName);\n        goto exit_drop_column;\n    }\n    if (pTab->aCol[iCol].colFlags & (1 | 8)) {\n        sqlite3ErrorMsg(pParse, \"cannot drop %s column: \\\"%s\\\"\", (pTab->aCol[iCol].colFlags & 1) ? \"PRIMARY KEY\" : \"UNIQUE\", zCol);\n        goto exit_drop_column;\n    }\n    if (pTab->nCol <= 1) {\n        sqlite3ErrorMsg(pParse, \"cannot drop column \\\"%s\\\": no other columns exist\", zCol);\n        goto exit_drop_column;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iDb >= 0);\n    zDb = db->aDb[iDb].zDbSName;\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, zCol)) {\n        goto exit_drop_column;\n    }\n    renameTestSchema(pParse, zDb, iDb == 1, \"\", 0);\n    renameFixQuotes(pParse, zDb, iDb == 1);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_drop_column(%d, sql, %d) WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)\", zDb, iDb, iCol, pTab->zName);\n    renameReloadSchema(pParse, iDb, 2);\n    renameTestSchema(pParse, zDb, iDb == 1, \"after drop column\", 1);\n    if (pParse->nErr == 0 && (pTab->aCol[iCol].colFlags & 32) == 0) {\n        int i;\n        int addr;\n        int reg;\n        int regRec;\n        Index *pPk = 0;\n        int nField = 0;\n        int iCur;\n        Vdbe *v = sqlite3GetVdbe(pParse);\n        iCur = pParse->nTab++;\n        sqlite3OpenTable(pParse, iCur, iDb, pTab, 113);\n        addr = sqlite3VdbeAddOp1(v, 36, iCur);\n        ;\n        reg = ++pParse->nMem;\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp2(v, 135, iCur, reg);\n            pParse->nMem += pTab->nCol;\n        } else {\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n            pParse->nMem += pPk->nColumn;\n            for (i = 0; i < pPk->nKeyCol; i++) {\n                sqlite3VdbeAddOp3(v, 94, iCur, i, reg + i + 1);\n            }\n            nField = pPk->nKeyCol;\n        }\n        regRec = ++pParse->nMem;\n        for (i = 0; i < pTab->nCol; i++) {\n            if (i != iCol && (pTab->aCol[i].colFlags & 32) == 0) {\n                int regOut;\n                if (pPk) {\n                    int iPos = sqlite3TableColumnToIndex(pPk, i);\n                    int iColPos = sqlite3TableColumnToIndex(pPk, iCol);\n                    if (iPos < pPk->nKeyCol)\n                        continue;\n                    regOut = reg + 1 + iPos - (iPos > iColPos);\n                } else {\n                    regOut = reg + 1 + nField;\n                }\n                if (i == pTab->iPKey) {\n                    sqlite3VdbeAddOp2(v, 75, 0, regOut);\n                } else {\n                    sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOut);\n                }\n                nField++;\n            }\n        }\n        if (nField == 0) {\n            pParse->nMem++;\n            sqlite3VdbeAddOp2(v, 75, 0, reg + 1);\n            nField = 1;\n        }\n        sqlite3VdbeAddOp3(v, 97, reg + 1, nField, regRec);\n        if (pPk) {\n            sqlite3VdbeAddOp4Int(v, 138, iCur, regRec, reg + 1, pPk->nKeyCol);\n        } else {\n            sqlite3VdbeAddOp3(v, 128, iCur, regRec, reg);\n        }\n        sqlite3VdbeChangeP5(v, 2);\n        sqlite3VdbeAddOp2(v, 39, iCur, addr + 1);\n        ;\n        sqlite3VdbeJumpHere(v, addr);\n    }\n  exit_drop_column:\n    sqlite3DbFree(db, zCol);\n    sqlite3SrcListDelete(db, pSrc);\n}\n"
  },
  {
    "id": "#23:25#sqlite3AlterRenameTable",
    "gotos": 10,
    "labels": 1,
    "body": "{\n    int iDb;\n    char *zDb;\n    Table *pTab;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    int nTabName;\n    const char *zTabName;\n    Vdbe *v;\n    VTable *pVTab = 0;\n    if ((db->mallocFailed))\n        goto exit_rename_table;\n    assert(pSrc->nSrc == 1);\n    assert(sqlite3BtreeHoldsAllMutexes(pParse->db));\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_rename_table;\n    iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n    zDb = db->aDb[iDb].zDbSName;\n    zName = sqlite3NameFromToken(db, pName);\n    if (!zName)\n        goto exit_rename_table;\n    if (sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) || sqlite3IsShadowTableOf(db, pTab, zName)) {\n        sqlite3ErrorMsg(pParse, \"there is already another table or index with this name: %s\", zName);\n        goto exit_rename_table;\n    }\n    if (0 != isAlterableTable(pParse, pTab)) {\n        goto exit_rename_table;\n    }\n    if (0 != sqlite3CheckObjectName(pParse, zName, \"table\", zName)) {\n        goto exit_rename_table;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"view %s may not be altered\", pTab->zName);\n        goto exit_rename_table;\n    }\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0)) {\n        goto exit_rename_table;\n    }\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto exit_rename_table;\n    }\n    if (((pTab)->eTabType == 1)) {\n        pVTab = sqlite3GetVTable(db, pTab);\n        if (pVTab->pVtab->pModule->xRename == 0) {\n            pVTab = 0;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0) {\n        goto exit_rename_table;\n    }\n    sqlite3MayAbort(pParse);\n    zTabName = pTab->zName;\n    nTabName = sqlite3Utf8CharLen(zTabName, -1);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\", zDb, zDb, zTabName, zName, (iDb == 1), zTabName);\n    sqlite3NestedParse(pParse, \"UPDATE %Q.sqlite_master SET tbl_name = %Q, name = CASE WHEN type='table' THEN %Q WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X'      AND type='index' THEN 'sqlite_autoindex_' || %Q || substr(name,%d+18) ELSE name END WHERE tbl_name=%Q COLLATE nocase AND (type='table' OR type='index' OR type='trigger');\", zDb, zName, zName, zName, nTabName, zTabName);\n    if (sqlite3FindTable(db, \"sqlite_sequence\", zDb)) {\n        sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_sequence set name = %Q WHERE name = %Q\", zDb, zName, pTab->zName);\n    }\n    if (iDb != 1) {\n        sqlite3NestedParse(pParse, \"UPDATE sqlite_temp_schema SET sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), tbl_name = CASE WHEN tbl_name=%Q COLLATE nocase AND   sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) THEN %Q ELSE tbl_name END WHERE type IN ('view', 'trigger')\", zDb, zTabName, zName, zTabName, zDb, zName);\n    }\n    if (pVTab) {\n        int i = ++pParse->nMem;\n        sqlite3VdbeLoadString(v, i, zName);\n        sqlite3VdbeAddOp4(v, 176, i, 0, 0, (const char *)pVTab, (-11));\n    }\n    renameReloadSchema(pParse, iDb, 1);\n    renameTestSchema(pParse, zDb, iDb == 1, \"after rename\", 0);\n  exit_rename_table:\n    sqlite3SrcListDelete(db, pSrc);\n    sqlite3DbFree(db, zName);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#23552:1#parseTimezone",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int sgn = 0;\n    int nHr, nMn;\n    int c;\n    while ((sqlite3CtypeMap[(unsigned char)(*zDate)] & 1))\n        {\n            zDate++;\n        }\n    p->tz = 0;\n    c = *zDate;\n    if (c == '-') {\n        sgn = -1;\n    } else if (c == '+') {\n        sgn = +1;\n    } else if (c == 'Z' || c == 'z') {\n        zDate++;\n        goto zulu_time;\n    } else {\n        return c != 0;\n    }\n    zDate++;\n    if (getDigits(zDate, \"20b:20e\", &nHr, &nMn) != 2) {\n        return 1;\n    }\n    zDate += 5;\n    p->tz = sgn * (nMn + nHr * 60);\n  zulu_time:\n    while ((sqlite3CtypeMap[(unsigned char)(*zDate)] & 1))\n        {\n            zDate++;\n        }\n    p->tzSet = 1;\n    return *zDate != 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprIfTrue",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    assert(jumpIfNull == 16 || jumpIfNull == 0);\n    if ((v == 0))\n        return;\n    if ((pExpr == 0))\n        return;\n    assert(!0);\n    op = pExpr->op;\n    switch (op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);\n            } else if (op == 44) {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            } else {\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            } else {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 16 : 0);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (op == 45) ? 53 : 52;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            assert(56 == 56);\n            ;\n            ;\n            assert(55 == 55);\n            ;\n            ;\n            assert(54 == 54);\n            ;\n            ;\n            assert(57 == 57);\n            ;\n            ;\n            assert(53 == 53);\n            ;\n            ;\n            ;\n            assert(52 == 52);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            assert(50 == 50);\n            ;\n            assert(51 == 51);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = jumpIfNull ? dest : destIfFalse;\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeGoto(v, dest);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 16, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprCodeTarget",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op;\n    int inReg = target;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    Expr tempX;\n    int p5 = 0;\n    assert(target > 0 && target <= pParse->nMem);\n    assert(v != 0);\n  expr_code_doover:\n    if (pExpr == 0) {\n        op = 121;\n    } else if (pParse->pIdxExpr != 0 && !(((pExpr)->flags & (8388608)) != 0) && (r1 = sqlite3IndexedExprLookup(pParse, pExpr, target)) >= 0) {\n        return r1;\n    } else {\n        assert(!0);\n        op = pExpr->op;\n    }\n    switch (op) {\n      case 169:\n        {\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            struct AggInfo_col *pCol;\n            assert(pAggInfo != 0);\n            assert(pExpr->iAgg >= 0 && pExpr->iAgg < pAggInfo->nColumn);\n            pCol = &pAggInfo->aCol[pExpr->iAgg];\n            if (!pAggInfo->directMode) {\n                assert(pCol->iMem > 0);\n                return pCol->iMem;\n            } else if (pAggInfo->useSortingIdx) {\n                Table *pTab = pCol->pTab;\n                sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pCol->iSorterColumn, target);\n                if (pCol->iColumn < 0) {\n                    ;\n                } else if ((pTab != 0)) {\n                    ;\n                    if (pTab->aCol[pCol->iColumn].affinity == 69) {\n                        sqlite3VdbeAddOp1(v, 87, target);\n                    }\n                }\n                return target;\n            }\n        }\n      case 167:\n        {\n            int iTab = pExpr->iTable;\n            int iReg;\n            if ((((pExpr)->flags & (32)) != 0)) {\n                int aff;\n                iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                assert(pExpr->y.pTab != 0);\n                aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n                if (aff > 65) {\n                    static const char zAff[] = \"B\\000C\\000D\\000E\";\n                    assert(65 == 'A');\n                    assert(66 == 'B');\n                    sqlite3VdbeAddOp4(v, 96, iReg, 1, 0, &zAff[(aff - 'B') * 2], (-1));\n                }\n                return iReg;\n            }\n            if (iTab < 0) {\n                if (pParse->iSelfTab < 0) {\n                    Column *pCol;\n                    Table *pTab;\n                    int iSrc;\n                    int iCol = pExpr->iColumn;\n                    assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                    pTab = pExpr->y.pTab;\n                    assert(pTab != 0);\n                    assert(iCol >= (-1));\n                    assert(iCol < pTab->nCol);\n                    if (iCol < 0) {\n                        return -1 - pParse->iSelfTab;\n                    }\n                    pCol = pTab->aCol + iCol;\n                    ;\n                    iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;\n                    if (pCol->colFlags & 96) {\n                        if (pCol->colFlags & 256) {\n                            sqlite3ErrorMsg(pParse, \"generated column loop on \\\"%s\\\"\", pCol->zCnName);\n                            return 0;\n                        }\n                        pCol->colFlags |= 256;\n                        if (pCol->colFlags & 128) {\n                            sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc);\n                        }\n                        pCol->colFlags &= ~(256 | 128);\n                        return iSrc;\n                    } else if (pCol->affinity == 69) {\n                        sqlite3VdbeAddOp2(v, 81, iSrc, target);\n                        sqlite3VdbeAddOp1(v, 87, target);\n                        return target;\n                    } else {\n                        return iSrc;\n                    }\n                } else {\n                    iTab = pParse->iSelfTab - 1;\n                }\n            }\n            assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n            assert(pExpr->y.pTab != 0);\n            iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab, pExpr->iColumn, iTab, target, pExpr->op2);\n            return iReg;\n        }\n      case 155:\n        {\n            codeInteger(pParse, pExpr, 0, target);\n            return target;\n        }\n      case 170:\n        {\n            sqlite3VdbeAddOp2(v, 71, sqlite3ExprTruthValue(pExpr), target);\n            return target;\n        }\n      case 153:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            codeReal(v, pExpr->u.zToken, 0, target);\n            return target;\n        }\n      case 117:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            sqlite3VdbeLoadString(v, target, pExpr->u.zToken);\n            return target;\n        }\n      default:\n        {\n            assert(op == 121 || op == 182 || pParse->db->mallocFailed);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            return target;\n        }\n      case 154:\n        {\n            int n;\n            const char *z;\n            char *zBlob;\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            assert(pExpr->u.zToken[0] == 'x' || pExpr->u.zToken[0] == 'X');\n            assert(pExpr->u.zToken[1] == '\\'');\n            z = &pExpr->u.zToken[2];\n            n = sqlite3Strlen30(z) - 1;\n            assert(z[n] == '\\'');\n            zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n            sqlite3VdbeAddOp4(v, 77, n / 2, target, 0, zBlob, (-6));\n            return target;\n        }\n      case 156:\n        {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            assert(pExpr->u.zToken != 0);\n            assert(pExpr->u.zToken[0] != 0);\n            sqlite3VdbeAddOp2(v, 78, pExpr->iColumn, target);\n            if (pExpr->u.zToken[1] != 0) {\n                const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n                assert(pExpr->u.zToken[0] == '?' || (z && !strcmp(pExpr->u.zToken, z)));\n                pParse->pVList[0] = 0;\n                sqlite3VdbeAppendP4(v, (char *)z, (-1));\n            }\n            return target;\n        }\n      case 176:\n        {\n            return pExpr->iTable;\n        }\n      case 36:\n        {\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            if (inReg != target) {\n                sqlite3VdbeAddOp2(v, 81, inReg, target);\n                inReg = target;\n            }\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            sqlite3VdbeAddOp2(v, 88, target, sqlite3AffinityType(pExpr->u.zToken, 0));\n            return inReg;\n        }\n      case 45:\n      case 171:\n        op = (op == 45) ? 53 : 52;\n        p5 = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            if (sqlite3ExprIsVector(pLeft)) {\n                codeVectorCompare(pParse, pExpr, target, op, p5);\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n                sqlite3VdbeAddOp2(v, 71, 1, inReg);\n                codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2, sqlite3VdbeCurrentAddr(v) + 2, p5, (((pExpr)->flags & (1024)) != 0));\n                assert(56 == 56);\n                ;\n                ;\n                assert(55 == 55);\n                ;\n                ;\n                assert(54 == 54);\n                ;\n                ;\n                assert(57 == 57);\n                ;\n                ;\n                assert(53 == 53);\n                ;\n                ;\n                assert(52 == 52);\n                ;\n                ;\n                if (p5 == 128) {\n                    sqlite3VdbeAddOp2(v, 71, 0, inReg);\n                } else {\n                    sqlite3VdbeAddOp3(v, 92, r1, inReg, r2);\n                }\n                ;\n                ;\n            }\n            break;\n        }\n      case 44:\n      case 43:\n      case 106:\n      case 108:\n      case 107:\n      case 110:\n      case 102:\n      case 103:\n      case 109:\n      case 104:\n      case 105:\n      case 111:\n        {\n            assert(44 == 44);\n            ;\n            assert(43 == 43);\n            ;\n            assert(106 == 106);\n            ;\n            assert(107 == 107);\n            ;\n            assert(110 == 110);\n            ;\n            assert(102 == 102);\n            ;\n            assert(103 == 103);\n            ;\n            assert(109 == 109);\n            ;\n            assert(104 == 104);\n            ;\n            assert(105 == 105);\n            ;\n            assert(111 == 111);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            sqlite3VdbeAddOp3(v, op, r2, r1, target);\n            ;\n            ;\n            break;\n        }\n      case 173:\n        {\n            Expr *pLeft = pExpr->pLeft;\n            assert(pLeft);\n            if (pLeft->op == 155) {\n                codeInteger(pParse, pLeft, 1, target);\n                return target;\n            } else if (pLeft->op == 153) {\n                assert(!(((pExpr)->flags & (2048)) != 0));\n                codeReal(v, pLeft->u.zToken, 1, target);\n                return target;\n            } else {\n                tempX.op = 155;\n                tempX.flags = 2048 | 65536;\n                tempX.u.iValue = 0;\n                ;\n                r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);\n                r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n                sqlite3VdbeAddOp3(v, 107, r2, r1, target);\n                ;\n            }\n            break;\n        }\n      case 114:\n      case 19:\n        {\n            assert(114 == 114);\n            ;\n            assert(19 == 19);\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            sqlite3VdbeAddOp2(v, op, r1, inReg);\n            break;\n        }\n      case 175:\n        {\n            int isTrue;\n            int bNormal;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            bNormal = pExpr->op2 == 45;\n            ;\n            ;\n            sqlite3VdbeAddOp4Int(v, 91, r1, inReg, !isTrue, isTrue ^ bNormal);\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            int addr;\n            assert(50 == 50);\n            ;\n            assert(51 == 51);\n            ;\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            ;\n            addr = sqlite3VdbeAddOp1(v, op, r1);\n            ;\n            ;\n            sqlite3VdbeAddOp2(v, 71, 0, target);\n            sqlite3VdbeJumpHere(v, addr);\n            break;\n        }\n      case 168:\n        {\n            AggInfo *pInfo = pExpr->pAggInfo;\n            if (pInfo == 0 || (pExpr->iAgg < 0) || (pExpr->iAgg >= pInfo->nFunc)) {\n                assert(!(((pExpr)->flags & (2048)) != 0));\n                sqlite3ErrorMsg(pParse, \"misuse of aggregate: %#T()\", pExpr);\n            } else {\n                return pInfo->aFunc[pExpr->iAgg].iMem;\n            }\n            break;\n        }\n      case 172:\n        {\n            ExprList *pFarg;\n            int nFarg;\n            FuncDef *pDef;\n            const char *zId;\n            u32 constMask = 0;\n            int i;\n            sqlite3 *db = pParse->db;\n            u8 enc = ((db)->enc);\n            CollSeq *pColl = 0;\n            if ((((pExpr)->flags & (16777216)) != 0)) {\n                return pExpr->y.pWin->regResult;\n            }\n            if (((pParse)->okConstFactor) && sqlite3ExprIsConstantNotJoin(pExpr)) {\n                return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);\n            }\n            assert(!(((pExpr)->flags & (65536)) != 0));\n            assert((((pExpr)->flags & 4096) == 0));\n            pFarg = pExpr->x.pList;\n            nFarg = pFarg ? pFarg->nExpr : 0;\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            zId = pExpr->u.zToken;\n            pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);\n            if (pDef == 0 || pDef->xFinalize != 0) {\n                sqlite3ErrorMsg(pParse, \"unknown function: %#T()\", pExpr);\n                break;\n            }\n            if (pDef->funcFlags & 4194304) {\n                assert((pDef->funcFlags & 2097152) == 0);\n                assert((pDef->funcFlags & 524288) == 0);\n                return exprCodeInlineFunction(pParse, pFarg, ((int)(long)(pDef->pUserData)), target);\n            } else if (pDef->funcFlags & (524288 | 2097152)) {\n                sqlite3ExprFunctionUsable(pParse, pExpr, pDef);\n            }\n            for (i = 0; i < nFarg; i++) {\n                if (i < 32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr)) {\n                    ;\n                    constMask |= (((unsigned int)1) << (i));\n                }\n                if ((pDef->funcFlags & 32) != 0 && !pColl) {\n                    pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n                }\n            }\n            if (pFarg) {\n                if (constMask) {\n                    r1 = pParse->nMem + 1;\n                    pParse->nMem += nFarg;\n                } else {\n                    r1 = sqlite3GetTempRange(pParse, nFarg);\n                }\n                if ((pDef->funcFlags & (64 | 128)) != 0) {\n                    u8 exprOp;\n                    assert(nFarg == 1);\n                    assert(pFarg->a[0].pExpr != 0);\n                    exprOp = pFarg->a[0].pExpr->op;\n                    if (exprOp == 167 || exprOp == 169) {\n                        assert(64 == 64);\n                        assert(128 == 128);\n                        ;\n                        pFarg->a[0].pExpr->op2 = pDef->funcFlags & (64 | 128);\n                    }\n                }\n                sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, 1 | 2);\n            } else {\n                r1 = 0;\n            }\n            if (nFarg >= 2 && (((pExpr)->flags & (256)) != 0)) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n            } else if (nFarg > 0) {\n                pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n            }\n            if (pDef->funcFlags & 32) {\n                if (!pColl)\n                    pColl = db->pDfltColl;\n                sqlite3VdbeAddOp4(v, 85, 0, 0, 0, (char *)pColl, (-2));\n            }\n            sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg, pDef, pExpr->op2);\n            if (nFarg) {\n                if (constMask == 0) {\n                    sqlite3ReleaseTempRange(pParse, r1, nFarg);\n                } else {\n                    ;\n                }\n            }\n            return target;\n        }\n      case 20:\n      case 138:\n        {\n            int nCol;\n            ;\n            ;\n            if (pParse->db->mallocFailed) {\n                return 0;\n            } else if (op == 138 && ((((pExpr)->flags & 4096) != 0)) && (nCol = pExpr->x.pSelect->pEList->nExpr) != 1) {\n                sqlite3SubselectError(pParse, nCol, 1);\n            } else {\n                return sqlite3CodeSubselect(pParse, pExpr);\n            }\n            break;\n        }\n      case 178:\n        {\n            int n;\n            Expr *pLeft = pExpr->pLeft;\n            if (pLeft->iTable == 0 || pParse->withinRJSubrtn > pLeft->op2) {\n                pLeft->iTable = sqlite3CodeSubselect(pParse, pLeft);\n                pLeft->op2 = pParse->withinRJSubrtn;\n            }\n            assert(pLeft->op == 138 || pLeft->op == 182);\n            n = sqlite3ExprVectorSize(pLeft);\n            if (pExpr->iTable != n) {\n                sqlite3ErrorMsg(pParse, \"%d columns assigned %d values\", pExpr->iTable, n);\n            }\n            return pLeft->iTable + pExpr->iColumn;\n        }\n      case 49:\n        {\n            int destIfFalse = sqlite3VdbeMakeLabel(pParse);\n            int destIfNull = sqlite3VdbeMakeLabel(pParse);\n            sqlite3VdbeAddOp2(v, 75, 0, target);\n            sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n            sqlite3VdbeAddOp2(v, 71, 1, target);\n            sqlite3VdbeResolveLabel(v, destIfFalse);\n            sqlite3VdbeAddOp2(v, 86, target, 0);\n            sqlite3VdbeResolveLabel(v, destIfNull);\n            return target;\n        }\n      case 48:\n        {\n            exprCodeBetween(pParse, pExpr, target, 0, 0);\n            return target;\n        }\n      case 113:\n        {\n            if (!(((pExpr)->flags & (512)) != 0) && (pExpr->pLeft) && pExpr->pLeft->op == 172) {\n                inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n                if (inReg != target) {\n                    sqlite3VdbeAddOp2(v, 81, inReg, target);\n                    inReg = target;\n                }\n                sqlite3VdbeAddOp1(v, 179, inReg);\n                return inReg;\n            } else {\n                pExpr = pExpr->pLeft;\n                goto expr_code_doover;\n            }\n        }\n      case 181:\n      case 174:\n        {\n            pExpr = pExpr->pLeft;\n            goto expr_code_doover;\n        }\n      case 77:\n        {\n            Table *pTab;\n            int iCol;\n            int p1;\n            assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n            pTab = pExpr->y.pTab;\n            iCol = pExpr->iColumn;\n            p1 = pExpr->iTable * (pTab->nCol + 1) + 1 + sqlite3TableColumnToStorage(pTab, iCol);\n            assert(pExpr->iTable == 0 || pExpr->iTable == 1);\n            assert(iCol >= -1 && iCol < pTab->nCol);\n            assert(pTab->iPKey < 0 || iCol != pTab->iPKey);\n            assert(p1 >= 0 && p1 < (pTab->nCol * 2 + 2));\n            sqlite3VdbeAddOp2(v, 157, p1, target);\n            ;\n            if (iCol >= 0 && pTab->aCol[iCol].affinity == 69) {\n                sqlite3VdbeAddOp1(v, 87, target);\n            }\n            break;\n        }\n      case 177:\n        {\n            sqlite3ErrorMsg(pParse, \"row value misused\");\n            break;\n        }\n      case 179:\n        {\n            int addrINR;\n            u8 okConstFactor = pParse->okConstFactor;\n            AggInfo *pAggInfo = pExpr->pAggInfo;\n            if (pAggInfo) {\n                assert(pExpr->iAgg >= 0 && pExpr->iAgg < pAggInfo->nColumn);\n                if (!pAggInfo->directMode) {\n                    inReg = pAggInfo->aCol[pExpr->iAgg].iMem;\n                    break;\n                }\n                if (pExpr->pAggInfo->useSortingIdx) {\n                    sqlite3VdbeAddOp3(v, 94, pAggInfo->sortingIdxPTab, pAggInfo->aCol[pExpr->iAgg].iSorterColumn, target);\n                    inReg = target;\n                    break;\n                }\n            }\n            addrINR = sqlite3VdbeAddOp1(v, 20, pExpr->iTable);\n            pParse->okConstFactor = 0;\n            inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n            pParse->okConstFactor = okConstFactor;\n            sqlite3VdbeJumpHere(v, addrINR);\n            sqlite3VdbeChangeP3(v, addrINR, inReg);\n            break;\n        }\n      case 157:\n        {\n            int endLabel;\n            int nextCase;\n            int nExpr;\n            int i;\n            ExprList *pEList;\n            struct ExprList_item *aListelem;\n            Expr opCompare;\n            Expr *pX;\n            Expr *pTest = 0;\n            Expr *pDel = 0;\n            sqlite3 *db = pParse->db;\n            assert((((pExpr)->flags & 4096) == 0) && pExpr->x.pList != 0);\n            assert(pExpr->x.pList->nExpr > 0);\n            pEList = pExpr->x.pList;\n            aListelem = pEList->a;\n            nExpr = pEList->nExpr;\n            endLabel = sqlite3VdbeMakeLabel(pParse);\n            if ((pX = pExpr->pLeft) != 0) {\n                pDel = sqlite3ExprDup(db, pX, 0);\n                if (db->mallocFailed) {\n                    sqlite3ExprDelete(db, pDel);\n                    break;\n                }\n                ;\n                exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n                ;\n                memset(&opCompare, 0, sizeof (opCompare));\n                opCompare.op = 53;\n                opCompare.pLeft = pDel;\n                pTest = &opCompare;\n                regFree1 = 0;\n            }\n            for (i = 0; i < nExpr - 1; i = i + 2) {\n                if (pX) {\n                    assert(pTest != 0);\n                    opCompare.pRight = aListelem[i].pExpr;\n                } else {\n                    pTest = aListelem[i].pExpr;\n                }\n                nextCase = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfFalse(pParse, pTest, nextCase, 16);\n                ;\n                sqlite3ExprCode(pParse, aListelem[i + 1].pExpr, target);\n                sqlite3VdbeGoto(v, endLabel);\n                sqlite3VdbeResolveLabel(v, nextCase);\n            }\n            if ((nExpr & 1) != 0) {\n                sqlite3ExprCode(pParse, pEList->a[nExpr - 1].pExpr, target);\n            } else {\n                sqlite3VdbeAddOp2(v, 75, 0, target);\n            }\n            sqlite3ExprDelete(db, pDel);\n            setDoNotMergeFlagOnCopy(v);\n            sqlite3VdbeResolveLabel(v, endLabel);\n            break;\n        }\n      case 71:\n        {\n            assert(pExpr->affExpr == 1 || pExpr->affExpr == 2 || pExpr->affExpr == 3 || pExpr->affExpr == 4);\n            if (!pParse->pTriggerTab && !pParse->nested) {\n                sqlite3ErrorMsg(pParse, \"RAISE() may only be used within a trigger-program\");\n                return 0;\n            }\n            if (pExpr->affExpr == 2) {\n                sqlite3MayAbort(pParse);\n            }\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            if (pExpr->affExpr == 4) {\n                sqlite3VdbeAddOp4(v, 70, 0, 4, 0, pExpr->u.zToken, 0);\n                ;\n            } else {\n                sqlite3HaltConstraint(pParse, pParse->pTriggerTab ? (19 | (7 << 8)) : 1, pExpr->affExpr, pExpr->u.zToken, 0, 0);\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n    return inReg;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#77857:1#clearDatabasePage",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    MemPage *pPage;\n    int rc;\n    unsigned char *pCell;\n    int i;\n    int hdr;\n    CellInfo info;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    if (pgno > btreePagecount(pBt)) {\n        return sqlite3CorruptError(77872);\n    }\n    rc = getAndInitPage(pBt, pgno, &pPage, 0, 0);\n    if (rc)\n        return rc;\n    if ((pBt->openFlags & 4) == 0 && sqlite3PagerPageRefcount(pPage->pDbPage) != (1 + (pgno == 1))) {\n        rc = sqlite3CorruptError(77879);\n        goto cleardatabasepage_out;\n    }\n    hdr = pPage->hdrOffset;\n    for (i = 0; i < pPage->nCell; i++) {\n        pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (i)])[0] << 8 | (&(pPage)->aCellIdx[2 * (i)])[1])));\n        if (!pPage->leaf) {\n            rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell), 1, pnChange);\n            if (rc)\n                goto cleardatabasepage_out;\n        }\n        pPage->xParseCell(pPage, pCell, &info);\n        if (info.nLocal != info.nPayload) {\n            rc = clearCellOverflow(pPage, pCell, &info);\n        } else {\n            rc = 0;\n        }\n        ;\n        if (rc)\n            goto cleardatabasepage_out;\n    }\n    if (!pPage->leaf) {\n        rc = clearDatabasePage(pBt, sqlite3Get4byte(&pPage->aData[hdr + 8]), 1, pnChange);\n        if (rc)\n            goto cleardatabasepage_out;\n        if (pPage->intKey)\n            pnChange = 0;\n    }\n    if (pnChange) {\n        ;\n        *pnChange += pPage->nCell;\n    }\n    if (freePageFlag) {\n        freePage(pPage, &rc);\n    } else if ((rc = sqlite3PagerWrite(pPage->pDbPage)) == 0) {\n        zeroPage(pPage, pPage->aData[hdr] | 8);\n    }\n  cleardatabasepage_out:\n    releasePage(pPage);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#136870:1#sqlite3Prepare",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    int i;\n    Parse sParse;\n    memset((((char *)(&sParse)) + ((int)((char *)&((Parse *)0)->zErrMsg))), 0, (((int)((char *)&((Parse *)0)->aTempReg)) - ((int)((char *)&((Parse *)0)->zErrMsg))));\n    memset((((char *)(&sParse)) + ((int)((char *)&((Parse *)0)->sLastToken))), 0, (sizeof(Parse) - ((int)((char *)&((Parse *)0)->sLastToken))));\n    sParse.pOuterParse = db->pParse;\n    db->pParse = &sParse;\n    sParse.db = db;\n    sParse.pReprepare = pReprepare;\n    assert(ppStmt && *ppStmt == 0);\n    if (db->mallocFailed)\n        sqlite3ErrorMsg(&sParse, \"out of memory\");\n    assert(sqlite3_mutex_held(db->mutex));\n    if (prepFlags & 1) {\n        sParse.disableLookaside++;\n        db->lookaside.bDisable++;\n        db->lookaside.sz = 0;\n    }\n    sParse.prepFlags = prepFlags & 255;\n    if (!db->noSharedCache) {\n        for (i = 0; i < db->nDb; i++) {\n            Btree *pBt = db->aDb[i].pBt;\n            if (pBt) {\n                assert(sqlite3BtreeHoldsMutex(pBt));\n                rc = sqlite3BtreeSchemaLocked(pBt);\n                if (rc) {\n                    const char *zDb = db->aDb[i].zDbSName;\n                    sqlite3ErrorWithMsg(db, rc, \"database schema is locked: %s\", zDb);\n                    ;\n                    goto end_prepare;\n                }\n            }\n        }\n    }\n    if (db->pDisconnect)\n        sqlite3VtabUnlockList(db);\n    if (nBytes >= 0 && (nBytes == 0 || zSql[nBytes - 1] != 0)) {\n        char *zSqlCopy;\n        int mxLen = db->aLimit[1];\n        ;\n        ;\n        if (nBytes > mxLen) {\n            sqlite3ErrorWithMsg(db, 18, \"statement too long\");\n            rc = sqlite3ApiExit(db, 18);\n            goto end_prepare;\n        }\n        zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);\n        if (zSqlCopy) {\n            sqlite3RunParser(&sParse, zSqlCopy);\n            sParse.zTail = &zSql[sParse.zTail - zSqlCopy];\n            sqlite3DbFree(db, zSqlCopy);\n        } else {\n            sParse.zTail = &zSql[nBytes];\n        }\n    } else {\n        sqlite3RunParser(&sParse, zSql);\n    }\n    assert(0 == sParse.nQueryLoop);\n    if (pzTail) {\n        *pzTail = sParse.zTail;\n    }\n    if (db->init.busy == 0) {\n        sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail - zSql), prepFlags);\n    }\n    if (db->mallocFailed) {\n        sParse.rc = 7;\n        sParse.checkSchema = 0;\n    }\n    if (sParse.rc != 0 && sParse.rc != 101) {\n        if (sParse.checkSchema && db->init.busy == 0) {\n            schemaIsValid(&sParse);\n        }\n        if (sParse.pVdbe) {\n            sqlite3VdbeFinalize(sParse.pVdbe);\n        }\n        assert(0 == (*ppStmt));\n        rc = sParse.rc;\n        if (sParse.zErrMsg) {\n            sqlite3ErrorWithMsg(db, rc, \"%s\", sParse.zErrMsg);\n            sqlite3DbFree(db, sParse.zErrMsg);\n        } else {\n            sqlite3Error(db, rc);\n        }\n    } else {\n        assert(sParse.zErrMsg == 0);\n        *ppStmt = (sqlite3_stmt *)sParse.pVdbe;\n        rc = 0;\n        sqlite3ErrorClear(db);\n    }\n    while (sParse.pTriggerPrg)\n        {\n            TriggerPrg *pT = sParse.pTriggerPrg;\n            sParse.pTriggerPrg = pT->pNext;\n            sqlite3DbFree(db, pT);\n        }\n  end_prepare:\n    sqlite3ParseObjectReset(&sParse);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#60610:1#getPageNormal",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    PgHdr *pPg;\n    u8 noContent;\n    sqlite3_pcache_page *pBase;\n    assert(pPager->errCode == 0);\n    assert(pPager->eState >= 1);\n    assert(assert_pager_state(pPager));\n    assert(pPager->hasHeldSharedLock == 1);\n    if (pgno == 0)\n        return sqlite3CorruptError(60626);\n    pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);\n    if (pBase == 0) {\n        pPg = 0;\n        rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);\n        if (rc != 0)\n            goto pager_acquire_err;\n        if (pBase == 0) {\n            rc = 7;\n            goto pager_acquire_err;\n        }\n    }\n    pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);\n    assert(pPg == (*ppPage));\n    assert(pPg->pgno == pgno);\n    assert(pPg->pPager == pPager || pPg->pPager == 0);\n    noContent = (flags & 1) != 0;\n    if (pPg->pPager && !noContent) {\n        assert(pgno != ((pPager)->lckPgno));\n        pPager->aStat[0]++;\n        return 0;\n    } else {\n        if (pgno == ((pPager)->lckPgno)) {\n            rc = sqlite3CorruptError(60658);\n            goto pager_acquire_err;\n        }\n        pPg->pPager = pPager;\n        assert(!((pPager->fd)->pMethods != 0) || !pPager->memDb);\n        if (!((pPager->fd)->pMethods != 0) || pPager->dbSize < pgno || noContent) {\n            if (pgno > pPager->mxPgno) {\n                rc = 13;\n                goto pager_acquire_err;\n            }\n            if (noContent) {\n                sqlite3BeginBenignMalloc();\n                if (pgno <= pPager->dbOrigSize) {\n                    sqlite3BitvecSet(pPager->pInJournal, pgno);\n                    ;\n                }\n                addToSavepointBitvecs(pPager, pgno);\n                ;\n                sqlite3EndBenignMalloc();\n            }\n            memset(pPg->pData, 0, pPager->pageSize);\n            ;\n        } else {\n            assert(pPg->pPager == pPager);\n            pPager->aStat[1]++;\n            rc = readDbPage(pPg);\n            if (rc != 0) {\n                goto pager_acquire_err;\n            }\n        }\n        ;\n    }\n    return 0;\n  pager_acquire_err:\n    assert(rc != 0);\n    if (pPg) {\n        sqlite3PcacheDrop(pPg);\n    }\n    pagerUnlockIfUnused(pPager);\n    *ppPage = 0;\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#198464:1#jsonLookup",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    const char *zErr = 0;\n    JsonNode *pNode = 0;\n    char *zMsg;\n    if (zPath == 0)\n        return 0;\n    if (zPath[0] != '$') {\n        zErr = zPath;\n        goto lookup_err;\n    }\n    zPath++;\n    pNode = jsonLookupStep(pParse, 0, zPath, pApnd, &zErr);\n    if (zErr == 0)\n        return pNode;\n  lookup_err:\n    pParse->nErr++;\n    assert(zErr != 0 && pCtx != 0);\n    zMsg = jsonPathSyntaxError(zErr);\n    if (zMsg) {\n        sqlite3_result_error(pCtx, zMsg, -1);\n        sqlite3_free(zMsg);\n    } else {\n        sqlite3_result_error_nomem(pCtx);\n    }\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#103139:1#lookupName",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int i, j;\n    int cnt = 0;\n    int cntTab = 0;\n    int nSubquery = 0;\n    sqlite3 *db = pParse->db;\n    SrcItem *pItem;\n    SrcItem *pMatch = 0;\n    NameContext *pTopNC = pNC;\n    Schema *pSchema = 0;\n    int eNewExprOp = 167;\n    Table *pTab = 0;\n    Column *pCol;\n    ExprList *pFJMatch = 0;\n    assert(pNC);\n    assert(zCol);\n    assert(zDb == 0 || zTab != 0);\n    assert(!(((pExpr)->flags & (65536 | 16384)) != 0));\n    pExpr->iTable = -1;\n    ;\n    if (zDb) {\n        ;\n        ;\n        if ((pNC->ncFlags & (2 | 4)) != 0) {\n            zDb = 0;\n        } else {\n            for (i = 0; i < db->nDb; i++) {\n                assert(db->aDb[i].zDbSName);\n                if (sqlite3StrICmp(db->aDb[i].zDbSName, zDb) == 0) {\n                    pSchema = db->aDb[i].pSchema;\n                    break;\n                }\n            }\n            if (i == db->nDb && sqlite3StrICmp(\"main\", zDb) == 0) {\n                pSchema = db->aDb[0].pSchema;\n                zDb = db->aDb[0].zDbSName;\n            }\n        }\n    }\n    assert(pNC && cnt == 0);\n    do {\n        ExprList *pEList;\n        SrcList *pSrcList = pNC->pSrcList;\n        if (pSrcList) {\n            for (i = 0 , pItem = pSrcList->a; i < pSrcList->nSrc; i++ , pItem++) {\n                u8 hCol;\n                pTab = pItem->pTab;\n                assert(pTab != 0 && pTab->zName != 0);\n                assert(pTab->nCol > 0 || pParse->nErr);\n                assert((int)pItem->fg.isNestedFrom == ((pItem->pSelect) != 0 && ((pItem->pSelect)->selFlags & 2048) != 0));\n                if (pItem->fg.isNestedFrom) {\n                    int hit = 0;\n                    assert(pItem->pSelect != 0);\n                    pEList = pItem->pSelect->pEList;\n                    assert(pEList != 0);\n                    assert(pEList->nExpr == pTab->nCol);\n                    for (j = 0; j < pEList->nExpr; j++) {\n                        if (!sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb)) {\n                            continue;\n                        }\n                        if (cnt > 0) {\n                            if (pItem->fg.isUsing == 0 || sqlite3IdListIndex(pItem->u3.pUsing, zCol) < 0) {\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else if ((pItem->fg.jointype & 16) == 0) {\n                                continue;\n                            } else if ((pItem->fg.jointype & 8) == 0) {\n                                cnt = 0;\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else {\n                                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                            }\n                        }\n                        cnt++;\n                        cntTab = 2;\n                        pMatch = pItem;\n                        pExpr->iColumn = j;\n                        pEList->a[j].fg.bUsed = 1;\n                        hit = 1;\n                        if (pEList->a[j].fg.bUsingTerm)\n                            break;\n                    }\n                    if (hit || zTab == 0)\n                        continue;\n                }\n                assert(zDb == 0 || zTab != 0);\n                if (zTab) {\n                    const char *zTabName;\n                    if (zDb) {\n                        if (pTab->pSchema != pSchema)\n                            continue;\n                        if (pSchema == 0 && strcmp(zDb, \"*\") != 0)\n                            continue;\n                    }\n                    zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;\n                    assert(zTabName != 0);\n                    if (sqlite3StrICmp(zTabName, zTab) != 0) {\n                        continue;\n                    }\n                    assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                    if ((pParse->eParseMode >= 2) && pItem->zAlias) {\n                        sqlite3RenameTokenRemap(pParse, 0, (void *)&pExpr->y.pTab);\n                    }\n                }\n                hCol = sqlite3StrIHash(zCol);\n                for (j = 0 , pCol = pTab->aCol; j < pTab->nCol; j++ , pCol++) {\n                    if (pCol->hName == hCol && sqlite3StrICmp(pCol->zCnName, zCol) == 0) {\n                        if (cnt > 0) {\n                            if (pItem->fg.isUsing == 0 || sqlite3IdListIndex(pItem->u3.pUsing, zCol) < 0) {\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else if ((pItem->fg.jointype & 16) == 0) {\n                                continue;\n                            } else if ((pItem->fg.jointype & 8) == 0) {\n                                cnt = 0;\n                                sqlite3ExprListDelete(db, pFJMatch);\n                                pFJMatch = 0;\n                            } else {\n                                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                            }\n                        }\n                        cnt++;\n                        pMatch = pItem;\n                        pExpr->iColumn = j == pTab->iPKey ? -1 : (i16)j;\n                        if (pItem->fg.isNestedFrom) {\n                            sqlite3SrcItemColumnUsed(pItem, j);\n                        }\n                        break;\n                    }\n                }\n                if (0 == cnt && (((pTab)->tabFlags & 512) == 0)) {\n                    cntTab++;\n                    pMatch = pItem;\n                }\n            }\n            if (pMatch) {\n                pExpr->iTable = pMatch->iCursor;\n                assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                pExpr->y.pTab = pMatch->pTab;\n                if ((pMatch->fg.jointype & (8 | 64)) != 0) {\n                    (pExpr)->flags |= (2097152);\n                }\n                pSchema = pExpr->y.pTab->pSchema;\n            }\n        }\n        if (cnt == 0 && zDb == 0) {\n            pTab = 0;\n            if (pParse->pTriggerTab != 0) {\n                int op = pParse->eTriggerOp;\n                assert(op == 128 || op == 129 || op == 127);\n                if (pParse->bReturning) {\n                    if ((pNC->ncFlags & 1024) != 0 && (zTab == 0 || sqlite3StrICmp(zTab, pParse->pTriggerTab->zName) == 0)) {\n                        pExpr->iTable = op != 128;\n                        pTab = pParse->pTriggerTab;\n                    }\n                } else if (op != 128 && zTab && sqlite3StrICmp(\"new\", zTab) == 0) {\n                    pExpr->iTable = 1;\n                    pTab = pParse->pTriggerTab;\n                } else if (op != 127 && zTab && sqlite3StrICmp(\"old\", zTab) == 0) {\n                    pExpr->iTable = 0;\n                    pTab = pParse->pTriggerTab;\n                }\n            }\n            if ((pNC->ncFlags & 512) != 0 && zTab != 0) {\n                Upsert *pUpsert = pNC->uNC.pUpsert;\n                if (pUpsert && sqlite3StrICmp(\"excluded\", zTab) == 0) {\n                    pTab = pUpsert->pUpsertSrc->a[0].pTab;\n                    pExpr->iTable = 2;\n                }\n            }\n            if (pTab) {\n                int iCol;\n                u8 hCol = sqlite3StrIHash(zCol);\n                pSchema = pTab->pSchema;\n                cntTab++;\n                for (iCol = 0 , pCol = pTab->aCol; iCol < pTab->nCol; iCol++ , pCol++) {\n                    if (pCol->hName == hCol && sqlite3StrICmp(pCol->zCnName, zCol) == 0) {\n                        if (iCol == pTab->iPKey) {\n                            iCol = -1;\n                        }\n                        break;\n                    }\n                }\n                if (iCol >= pTab->nCol && sqlite3IsRowid(zCol) && (((pTab)->tabFlags & 512) == 0)) {\n                    iCol = -1;\n                }\n                if (iCol < pTab->nCol) {\n                    cnt++;\n                    pMatch = 0;\n                    if (pExpr->iTable == 2) {\n                        ;\n                        assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                        if ((pParse->eParseMode >= 2)) {\n                            pExpr->iColumn = iCol;\n                            pExpr->y.pTab = pTab;\n                            eNewExprOp = 167;\n                        } else {\n                            pExpr->iTable = pNC->uNC.pUpsert->regData + sqlite3TableColumnToStorage(pTab, iCol);\n                            eNewExprOp = 176;\n                        }\n                    } else {\n                        assert((((pExpr)->flags & (16777216 | 33554432)) == 0));\n                        pExpr->y.pTab = pTab;\n                        if (pParse->bReturning) {\n                            eNewExprOp = 176;\n                            pExpr->op2 = 167;\n                            pExpr->iTable = pNC->uNC.iBaseReg + (pTab->nCol + 1) * pExpr->iTable + sqlite3TableColumnToStorage(pTab, iCol) + 1;\n                        } else {\n                            pExpr->iColumn = (i16)iCol;\n                            eNewExprOp = 77;\n                            if (iCol < 0) {\n                                pExpr->affExpr = 68;\n                            } else if (pExpr->iTable == 0) {\n                                ;\n                                ;\n                                pParse->oldmask |= (iCol >= 32 ? 4294967295U : (((u32)1) << iCol));\n                            } else {\n                                ;\n                                ;\n                                pParse->newmask |= (iCol >= 32 ? 4294967295U : (((u32)1) << iCol));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (cnt == 0 && cntTab == 1 && pMatch && (pNC->ncFlags & (32 | 8)) == 0 && sqlite3IsRowid(zCol) && ((((pMatch->pTab)->tabFlags & 512) == 0))) {\n            cnt = 1;\n            pExpr->iColumn = -1;\n            pExpr->affExpr = 68;\n        }\n        if (cnt == 0 && (pNC->ncFlags & 128) != 0 && zTab == 0) {\n            pEList = pNC->uNC.pEList;\n            assert(pEList != 0);\n            for (j = 0; j < pEList->nExpr; j++) {\n                char *zAs = pEList->a[j].zEName;\n                if (pEList->a[j].fg.eEName == 0 && sqlite3_stricmp(zAs, zCol) == 0) {\n                    Expr *pOrig;\n                    assert(pExpr->pLeft == 0 && pExpr->pRight == 0);\n                    assert((((pExpr)->flags & 4096) == 0) == 0 || pExpr->x.pList == 0);\n                    assert((((pExpr)->flags & 4096) != 0) == 0 || pExpr->x.pSelect == 0);\n                    pOrig = pEList->a[j].pExpr;\n                    if ((pNC->ncFlags & 1) == 0 && (((pOrig)->flags & (16)) != 0)) {\n                        sqlite3ErrorMsg(pParse, \"misuse of aliased aggregate %s\", zAs);\n                        return 2;\n                    }\n                    if ((((pOrig)->flags & (32768)) != 0) && ((pNC->ncFlags & 16384) == 0 || pNC != pTopNC)) {\n                        sqlite3ErrorMsg(pParse, \"misuse of aliased window function %s\", zAs);\n                        return 2;\n                    }\n                    if (sqlite3ExprVectorSize(pOrig) != 1) {\n                        sqlite3ErrorMsg(pParse, \"row value misused\");\n                        return 2;\n                    }\n                    resolveAlias(pParse, pEList, j, pExpr, nSubquery);\n                    cnt = 1;\n                    pMatch = 0;\n                    assert(zTab == 0 && zDb == 0);\n                    if ((pParse->eParseMode >= 2)) {\n                        sqlite3RenameTokenRemap(pParse, 0, (void *)pExpr);\n                    }\n                    goto lookupname_end;\n                }\n            }\n        }\n        if (cnt)\n            break;\n        pNC = pNC->pNext;\n        nSubquery++;\n    } while (pNC);\n    if (cnt == 0 && zTab == 0) {\n        assert(pExpr->op == 59);\n        if ((((pExpr)->flags & (128)) != 0) && areDoubleQuotedStringsEnabled(db, pTopNC)) {\n            sqlite3_log(28, \"double-quoted string literal: \\\"%w\\\"\", zCol);\n            pExpr->op = 117;\n            memset(&pExpr->y, 0, sizeof (pExpr->y));\n            return 1;\n        }\n        if (sqlite3ExprIdToTrueFalse(pExpr)) {\n            return 1;\n        }\n    }\n    assert(pFJMatch == 0 || cnt > 0);\n    assert(!(((pExpr)->flags & (4096 | 2048)) != 0));\n    if (cnt != 1) {\n        const char *zErr;\n        if (pFJMatch) {\n            if (pFJMatch->nExpr == cnt - 1) {\n                if ((((pExpr)->flags & (8388608)) != 0)) {\n                    (pExpr)->flags &= ~(8388608);\n                } else {\n                    sqlite3ExprDelete(db, pExpr->pLeft);\n                    pExpr->pLeft = 0;\n                    sqlite3ExprDelete(db, pExpr->pRight);\n                    pExpr->pRight = 0;\n                }\n                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n                pExpr->op = 172;\n                pExpr->u.zToken = \"coalesce\";\n                pExpr->x.pList = pFJMatch;\n                cnt = 1;\n                goto lookupname_end;\n            } else {\n                sqlite3ExprListDelete(db, pFJMatch);\n                pFJMatch = 0;\n            }\n        }\n        zErr = cnt == 0 ? \"no such column\" : \"ambiguous column name\";\n        if (zDb) {\n            sqlite3ErrorMsg(pParse, \"%s: %s.%s.%s\", zErr, zDb, zTab, zCol);\n        } else if (zTab) {\n            sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zErr, zTab, zCol);\n        } else {\n            sqlite3ErrorMsg(pParse, \"%s: %s\", zErr, zCol);\n        }\n        sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);\n        pParse->checkSchema = 1;\n        pTopNC->nNcErr++;\n    }\n    assert(pFJMatch == 0);\n    if (!(((pExpr)->flags & ((65536 | 8388608))) != 0)) {\n        sqlite3ExprDelete(db, pExpr->pLeft);\n        pExpr->pLeft = 0;\n        sqlite3ExprDelete(db, pExpr->pRight);\n        pExpr->pRight = 0;\n        (pExpr)->flags |= (8388608);\n    }\n    if (pExpr->iColumn >= 0 && pMatch != 0) {\n        pMatch->colUsed |= sqlite3ExprColUsed(pExpr);\n    }\n    pExpr->op = eNewExprOp;\n  lookupname_end:\n    if (cnt == 1) {\n        assert(pNC != 0);\n        if (pParse->db->xAuth && (pExpr->op == 167 || pExpr->op == 77)) {\n            sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);\n        }\n        for (;;) {\n            assert(pTopNC != 0);\n            pTopNC->nRef++;\n            if (pTopNC == pNC)\n                break;\n            pTopNC = pTopNC->pNext;\n        }\n        return 1;\n    } else {\n        return 2;\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#116107:1#codeAttach",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int rc;\n    NameContext sName;\n    Vdbe *v;\n    sqlite3 *db = pParse->db;\n    int regArgs;\n    if (pParse->nErr)\n        goto attach_end;\n    memset(&sName, 0, sizeof(NameContext));\n    sName.pParse = pParse;\n    if (0 != resolveAttachExpr(&sName, pFilename) || 0 != resolveAttachExpr(&sName, pDbname) || 0 != resolveAttachExpr(&sName, pKey)) {\n        goto attach_end;\n    }\n    if ((pAuthArg)) {\n        char *zAuthArg;\n        if (pAuthArg->op == 117) {\n            assert(!(((pAuthArg)->flags & (2048)) != 0));\n            zAuthArg = pAuthArg->u.zToken;\n        } else {\n            zAuthArg = 0;\n        }\n        rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);\n        if (rc != 0) {\n            goto attach_end;\n        }\n    }\n    v = sqlite3GetVdbe(pParse);\n    regArgs = sqlite3GetTempRange(pParse, 4);\n    sqlite3ExprCode(pParse, pFilename, regArgs);\n    sqlite3ExprCode(pParse, pDbname, regArgs + 1);\n    sqlite3ExprCode(pParse, pKey, regArgs + 2);\n    assert(v || db->mallocFailed);\n    if (v) {\n        sqlite3VdbeAddFunctionCall(pParse, 0, regArgs + 3 - pFunc->nArg, regArgs + 3, pFunc->nArg, pFunc, 0);\n        sqlite3VdbeAddOp1(v, 166, (type == 24));\n    }\n  attach_end:\n    sqlite3ExprDelete(db, pFilename);\n    sqlite3ExprDelete(db, pDbname);\n    sqlite3ExprDelete(db, pKey);\n}\n"
  },
  {
    "id": "#23:25#sqlite3CreateForeignKey",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    sqlite3 *db = pParse->db;\n    FKey *pFKey = 0;\n    FKey *pNextTo;\n    Table *p = pParse->pNewTable;\n    i64 nByte;\n    int i;\n    int nCol;\n    char *z;\n    assert(pTo != 0);\n    if (p == 0 || (pParse->eParseMode == 1))\n        goto fk_end;\n    if (pFromCol == 0) {\n        int iCol = p->nCol - 1;\n        if ((iCol < 0))\n            goto fk_end;\n        if (pToCol && pToCol->nExpr != 1) {\n            sqlite3ErrorMsg(pParse, \"foreign key on %s should reference only one column of table %T\", p->aCol[iCol].zCnName, pTo);\n            goto fk_end;\n        }\n        nCol = 1;\n    } else if (pToCol && pToCol->nExpr != pFromCol->nExpr) {\n        sqlite3ErrorMsg(pParse, \"number of columns in foreign key does not match the number of columns in the referenced table\");\n        goto fk_end;\n    } else {\n        nCol = pFromCol->nExpr;\n    }\n    nByte = sizeof (*pFKey) + (nCol - 1) * sizeof (pFKey->aCol[0]) + pTo->n + 1;\n    if (pToCol) {\n        for (i = 0; i < pToCol->nExpr; i++) {\n            nByte += sqlite3Strlen30(pToCol->a[i].zEName) + 1;\n        }\n    }\n    pFKey = sqlite3DbMallocZero(db, nByte);\n    if (pFKey == 0) {\n        goto fk_end;\n    }\n    pFKey->pFrom = p;\n    assert(((p)->eTabType == 0));\n    pFKey->pNextFrom = p->u.tab.pFKey;\n    z = (char *)&pFKey->aCol[nCol];\n    pFKey->zTo = z;\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameTokenMap(pParse, (void *)z, pTo);\n    }\n    memcpy(z, pTo->z, pTo->n);\n    z[pTo->n] = 0;\n    sqlite3Dequote(z);\n    z += pTo->n + 1;\n    pFKey->nCol = nCol;\n    if (pFromCol == 0) {\n        pFKey->aCol[0].iFrom = p->nCol - 1;\n    } else {\n        for (i = 0; i < nCol; i++) {\n            int j;\n            for (j = 0; j < p->nCol; j++) {\n                if (sqlite3StrICmp(p->aCol[j].zCnName, pFromCol->a[i].zEName) == 0) {\n                    pFKey->aCol[i].iFrom = j;\n                    break;\n                }\n            }\n            if (j >= p->nCol) {\n                sqlite3ErrorMsg(pParse, \"unknown column \\\"%s\\\" in foreign key definition\", pFromCol->a[i].zEName);\n                goto fk_end;\n            }\n            if ((pParse->eParseMode >= 2)) {\n                sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zEName);\n            }\n        }\n    }\n    if (pToCol) {\n        for (i = 0; i < nCol; i++) {\n            int n = sqlite3Strlen30(pToCol->a[i].zEName);\n            pFKey->aCol[i].zCol = z;\n            if ((pParse->eParseMode >= 2)) {\n                sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zEName);\n            }\n            memcpy(z, pToCol->a[i].zEName, n);\n            z[n] = 0;\n            z += n + 1;\n        }\n    }\n    pFKey->isDeferred = 0;\n    pFKey->aAction[0] = (u8)(flags & 255);\n    pFKey->aAction[1] = (u8)((flags >> 8) & 255);\n    assert(sqlite3SchemaMutexHeld(db, 0, p->pSchema));\n    pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash, pFKey->zTo, (void *)pFKey);\n    if (pNextTo == pFKey) {\n        sqlite3OomFault(db);\n        goto fk_end;\n    }\n    if (pNextTo) {\n        assert(pNextTo->pPrevTo == 0);\n        pFKey->pNextTo = pNextTo;\n        pNextTo->pPrevTo = pFKey;\n    }\n    assert(((p)->eTabType == 0));\n    p->u.tab.pFKey = pFKey;\n    pFKey = 0;\n  fk_end:\n    sqlite3DbFree(db, pFKey);\n    sqlite3ExprListDelete(db, pFromCol);\n    sqlite3ExprListDelete(db, pToCol);\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeExec",
    "gotos": 232,
    "labels": 21,
    "body": "{\n    Op *aOp = p->aOp;\n    Op *pOp = aOp;\n    int rc = 0;\n    sqlite3 *db = p->db;\n    u8 resetSchemaOnFault = 0;\n    u8 encoding = ((db)->enc);\n    int iCompare = 0;\n    u64 nVmStep = 0;\n    u64 nProgressLimit;\n    Mem *aMem = p->aMem;\n    Mem *pIn1 = 0;\n    Mem *pIn2 = 0;\n    Mem *pIn3 = 0;\n    Mem *pOut = 0;\n    assert(p->eVdbeState == 2);\n    sqlite3VdbeEnter(p);\n    if (db->xProgress) {\n        u32 iPrior = p->aCounter[4];\n        assert(0 < db->nProgressOps);\n        nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);\n    } else {\n        nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n    }\n    if (p->rc == 7) {\n        goto no_mem;\n    }\n    assert(p->rc == 0 || (p->rc & 255) == 5);\n    ;\n    p->rc = 0;\n    assert(p->bIsReader || p->readOnly != 0);\n    p->iCurrentTime = 0;\n    assert(p->explain == 0);\n    p->pResultSet = 0;\n    db->busyHandler.nBusy = 0;\n    if (__atomic_load_n((&db->u1.isInterrupted), 0))\n        goto abort_due_to_interrupt;\n    ;\n    for (pOp = &aOp[p->pc]; 1; pOp++) {\n        assert(rc == 0);\n        assert(pOp >= aOp && pOp < &aOp[p->nOp]);\n        nVmStep++;\n        switch (pOp->opcode) {\n          case 9:\n            {\n              jump_to_p2_and_check_for_interrupt:\n                pOp = &aOp[pOp->p2 - 1];\n              check_for_interrupt:\n                if (__atomic_load_n((&db->u1.isInterrupted), 0))\n                    goto abort_due_to_interrupt;\n                while (nVmStep >= nProgressLimit && db->xProgress != 0)\n                    {\n                        assert(db->nProgressOps != 0);\n                        nProgressLimit += db->nProgressOps;\n                        if (db->xProgress(db->pProgressArg)) {\n                            nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                            rc = 9;\n                            goto abort_due_to_error;\n                        }\n                    }\n                break;\n            }\n          case 10:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert((((pIn1)->flags & (32768 | 4096)) != 0) == 0);\n                ;\n                pIn1->flags = 4;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                goto jump_to_p2_and_check_for_interrupt;\n            }\n          case 67:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & 4) {\n                    if (pOp->p3) {\n                        ;\n                    }\n                    pOp = &aOp[pIn1->u.i];\n                } else if ((pOp->p3)) {\n                    ;\n                }\n                break;\n            }\n          case 11:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                assert(pOp->p2 >= 0 && pOp->p2 < p->nOp);\n                assert(pOp->p3 >= 0 && pOp->p3 < p->nOp);\n                pOut = &aMem[pOp->p1];\n                assert(!(((pOut)->flags & (32768 | 4096)) != 0));\n                pOut->u.i = pOp->p3 - 1;\n                pOut->flags = 4;\n                if (pOp->p2 == 0)\n                    break;\n              jump_to_p2:\n                assert(pOp->p2 > 0);\n                assert(pOp->p2 < p->nOp);\n                pOp = &aOp[pOp->p2 - 1];\n                break;\n            }\n          case 68:\n            {\n                VdbeOp *pCaller;\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags == 4);\n                assert(pIn1->u.i >= 0 && pIn1->u.i < p->nOp);\n                pCaller = &aOp[pIn1->u.i];\n                assert(pCaller->opcode == 12);\n                assert(pCaller->p2 >= 0 && pCaller->p2 < p->nOp);\n                pOp = &aOp[pCaller->p2 - 1];\n                pIn1->flags = 0;\n                break;\n            }\n          case 12:\n            {\n                int pcDest;\n                pIn1 = &aMem[pOp->p1];\n                assert((((pIn1)->flags & (32768 | 4096)) != 0) == 0);\n                pIn1->flags = 4;\n                pcDest = (int)pIn1->u.i;\n                pIn1->u.i = (int)(pOp - aOp);\n                ;\n                pOp = &aOp[pcDest];\n                break;\n            }\n          case 69:\n            {\n                pIn3 = &aMem[pOp->p3];\n                if ((pIn3->flags & 1) == 0)\n                    break;\n            }\n          case 70:\n            {\n                VdbeFrame *pFrame;\n                int pcx;\n                if (p->pFrame && pOp->p1 == 0) {\n                    pFrame = p->pFrame;\n                    p->pFrame = pFrame->pParent;\n                    p->nFrame--;\n                    sqlite3VdbeSetChanges(db, p->nChange);\n                    pcx = sqlite3VdbeFrameRestore(pFrame);\n                    if (pOp->p2 == 4) {\n                        pcx = p->aOp[pcx].p2 - 1;\n                    }\n                    aOp = p->aOp;\n                    aMem = p->aMem;\n                    pOp = &aOp[pcx];\n                    break;\n                }\n                p->rc = pOp->p1;\n                p->errorAction = (u8)pOp->p2;\n                assert(pOp->p5 <= 4);\n                if (p->rc) {\n                    if (pOp->p5) {\n                        static const char *const azType[] = {\"NOT NULL\", \"UNIQUE\", \"CHECK\", \"FOREIGN KEY\"};\n                        ;\n                        ;\n                        ;\n                        ;\n                        sqlite3VdbeError(p, \"%s constraint failed\", azType[pOp->p5 - 1]);\n                        if (pOp->p4.z) {\n                            p->zErrMsg = sqlite3MPrintf(db, \"%z: %s\", p->zErrMsg, pOp->p4.z);\n                        }\n                    } else {\n                        sqlite3VdbeError(p, \"%s\", pOp->p4.z);\n                    }\n                    pcx = (int)(pOp - aOp);\n                    sqlite3_log(pOp->p1, \"abort at %d in [%s]: %s\", pcx, p->zSql, p->zErrMsg);\n                }\n                rc = sqlite3VdbeHalt(p);\n                assert(rc == 5 || rc == 0 || rc == 1);\n                if (rc == 5) {\n                    p->rc = 5;\n                } else {\n                    assert(rc == 0 || (p->rc & 255) == 19);\n                    assert(rc == 0 || db->nDeferredCons > 0 || db->nDeferredImmCons > 0);\n                    rc = p->rc ? 1 : 101;\n                }\n                goto vdbe_return;\n            }\n          case 71:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = pOp->p1;\n                break;\n            }\n          case 72:\n            {\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p4.pI64 != 0);\n                pOut->u.i = *pOp->p4.pI64;\n                break;\n            }\n          case 153:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 8;\n                assert(!sqlite3IsNaN(*pOp->p4.pReal));\n                pOut->u.r = *pOp->p4.pReal;\n                break;\n            }\n          case 117:\n            {\n                assert(pOp->p4.z != 0);\n                pOut = out2Prerelease(p, pOp);\n                pOp->p1 = sqlite3Strlen30(pOp->p4.z);\n                if (encoding != 1) {\n                    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, 1, ((sqlite3_destructor_type)0));\n                    assert(rc == 0 || rc == 18);\n                    if (rc)\n                        goto too_big;\n                    if (0 != sqlite3VdbeChangeEncoding(pOut, encoding))\n                        goto no_mem;\n                    assert(pOut->szMalloc > 0 && pOut->zMalloc == pOut->z);\n                    assert((((pOut)->flags & (32768 | 4096)) != 0) == 0);\n                    pOut->szMalloc = 0;\n                    pOut->flags |= 8192;\n                    if (pOp->p4type == (-6)) {\n                        sqlite3DbFree(db, pOp->p4.z);\n                    }\n                    pOp->p4type = (-6);\n                    pOp->p4.z = pOut->z;\n                    pOp->p1 = pOut->n;\n                }\n                if (pOp->p1 > db->aLimit[0]) {\n                    goto too_big;\n                }\n                pOp->opcode = 73;\n                assert(rc == 0);\n            }\n          case 73:\n            {\n                assert(pOp->p4.z != 0);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = pOp->p4.z;\n                pOut->n = pOp->p1;\n                pOut->enc = encoding;\n                ;\n                if (pOp->p3 > 0) {\n                    assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                    pIn3 = &aMem[pOp->p3];\n                    assert(pIn3->flags & 4);\n                    if (pIn3->u.i == pOp->p5)\n                        pOut->flags = 16 | 8192 | 512;\n                }\n                break;\n            }\n          case 74:\n          case 75:\n            {\n                int cnt;\n                u16 nullFlag;\n                pOut = out2Prerelease(p, pOp);\n                cnt = pOp->p3 - pOp->p2;\n                assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pOut->flags = nullFlag = pOp->p1 ? (1 | 256) : 1;\n                pOut->n = 0;\n                while (cnt > 0)\n                    {\n                        pOut++;\n                        ;\n                        sqlite3VdbeMemSetNull(pOut);\n                        pOut->flags = nullFlag;\n                        pOut->n = 0;\n                        cnt--;\n                    }\n                break;\n            }\n          case 76:\n            {\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pOut = &aMem[pOp->p1];\n                pOut->flags = (pOut->flags & ~(0 | 63)) | 1;\n                break;\n            }\n          case 77:\n            {\n                assert(pOp->p1 <= 1000000000);\n                pOut = out2Prerelease(p, pOp);\n                if (pOp->p4.z == 0) {\n                    sqlite3VdbeMemSetZeroBlob(pOut, pOp->p1);\n                    if (sqlite3VdbeMemExpandBlob(pOut))\n                        goto no_mem;\n                } else {\n                    sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);\n                }\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 78:\n            {\n                Mem *pVar;\n                assert(pOp->p1 > 0 && pOp->p1 <= p->nVar);\n                assert(pOp->p4.z == 0 || pOp->p4.z == sqlite3VListNumToName(p->pVList, pOp->p1));\n                pVar = &p->aVar[pOp->p1 - 1];\n                if (sqlite3VdbeMemTooBig(pVar)) {\n                    goto too_big;\n                }\n                pOut = &aMem[pOp->p2];\n                if ((((pOut)->flags & (32768 | 4096)) != 0))\n                    sqlite3VdbeMemSetNull(pOut);\n                memcpy(pOut, pVar, ((int)((char *)&((Mem *)0)->db)));\n                pOut->flags &= ~(4096 | 16384);\n                pOut->flags |= 8192 | 64;\n                ;\n                break;\n            }\n          case 79:\n            {\n                int n;\n                int p1;\n                int p2;\n                n = pOp->p3;\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                assert(n > 0 && p1 > 0 && p2 > 0);\n                assert(p1 + n <= p2 || p2 + n <= p1);\n                pIn1 = &aMem[p1];\n                pOut = &aMem[p2];\n                do {\n                    assert(pOut <= &aMem[(p->nMem + 1 - p->nCursor)]);\n                    assert(pIn1 <= &aMem[(p->nMem + 1 - p->nCursor)]);\n                    assert(memIsValid(pIn1));\n                    ;\n                    sqlite3VdbeMemMove(pOut, pIn1);\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                    ;\n                    ;\n                    pIn1++;\n                    pOut++;\n                } while (--n);\n                break;\n            }\n          case 80:\n            {\n                int n;\n                n = pOp->p3;\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                assert(pOut != pIn1);\n                while (1)\n                    {\n                        ;\n                        sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                        if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                            goto no_mem;\n                        }\n                        ;\n                        if ((pOut->flags & 2048) != 0 && (pOp->p5 & 2) != 0) {\n                            pOut->flags &= ~2048;\n                        }\n                        ;\n                        if ((n--) == 0)\n                            break;\n                        pOut++;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 81:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                assert(pOut != pIn1);\n                sqlite3VdbeMemShallowCopy(pOut, pIn1, 16384);\n                break;\n            }\n          case 82:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 4) != 0);\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);\n                break;\n            }\n          case 83:\n            {\n                if ((rc = sqlite3VdbeCheckFk(p, 0)) != 0) {\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 84:\n            {\n                assert(p->nResColumn == pOp->p2);\n                assert(pOp->p1 > 0 || (sqlite3Config.neverCorrupt == 0));\n                assert(pOp->p1 + pOp->p2 <= (p->nMem + 1 - p->nCursor) + 1);\n                p->cacheCtr = (p->cacheCtr + 2) | 1;\n                p->pResultSet = &aMem[pOp->p1];\n                if (db->mallocFailed)\n                    goto no_mem;\n                if (db->mTrace & 4) {\n                    db->trace.xV2(4, db->pTraceArg, p, 0);\n                }\n                p->pc = (int)(pOp - aOp) + 1;\n                rc = 100;\n                goto vdbe_return;\n            }\n          case 111:\n            {\n                i64 nByte;\n                u16 flags1;\n                u16 flags2;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                ;\n                assert(pIn1 != pOut);\n                flags1 = pIn1->flags;\n                ;\n                ;\n                if ((flags1 | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                if ((flags1 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn1, encoding, 0))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                } else if ((flags1 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn1))\n                        goto no_mem;\n                    flags1 = pIn1->flags & ~2;\n                }\n                flags2 = pIn2->flags;\n                if ((flags2 & (2 | 16)) == 0) {\n                    if (sqlite3VdbeMemStringify(pIn2, encoding, 0))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                } else if ((flags2 & 1024) != 0) {\n                    if (sqlite3VdbeMemExpandBlob(pIn2))\n                        goto no_mem;\n                    flags2 = pIn2->flags & ~2;\n                }\n                nByte = pIn1->n + pIn2->n;\n                if (nByte > db->aLimit[0]) {\n                    goto too_big;\n                }\n                if (sqlite3VdbeMemGrow(pOut, (int)nByte + 2, pOut == pIn2)) {\n                    goto no_mem;\n                }\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 2);\n                if (pOut != pIn2) {\n                    memcpy(pOut->z, pIn2->z, pIn2->n);\n                    assert((pIn2->flags & 4096) == (flags2 & 4096));\n                    pIn2->flags = flags2;\n                }\n                memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);\n                assert((pIn1->flags & 4096) == (flags1 & 4096));\n                pIn1->flags = flags1;\n                if (encoding > 1)\n                    nByte &= ~1;\n                pOut->z[nByte] = 0;\n                pOut->z[nByte + 1] = 0;\n                pOut->flags |= 512;\n                pOut->n = (int)nByte;\n                pOut->enc = encoding;\n                ;\n                break;\n            }\n          case 106:\n          case 107:\n          case 108:\n          case 109:\n          case 110:\n            {\n                u16 type1;\n                u16 type2;\n                i64 iA;\n                i64 iB;\n                double rA;\n                double rB;\n                pIn1 = &aMem[pOp->p1];\n                type1 = pIn1->flags;\n                pIn2 = &aMem[pOp->p2];\n                type2 = pIn2->flags;\n                pOut = &aMem[pOp->p3];\n                if ((type1 & type2 & 4) != 0) {\n                  int_math:\n                    iA = pIn1->u.i;\n                    iB = pIn2->u.i;\n                    switch (pOp->opcode) {\n                      case 106:\n                        if (sqlite3AddInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 107:\n                        if (sqlite3SubInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 108:\n                        if (sqlite3MulInt64(&iB, iA))\n                            goto fp_math;\n                        break;\n                      case 109:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1 && iB == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                                goto fp_math;\n                            iB /= iA;\n                            break;\n                        }\n                      default:\n                        {\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            iB %= iA;\n                            break;\n                        }\n                    }\n                    pOut->u.i = iB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                } else if (((type1 | type2) & 1) != 0) {\n                    goto arithmetic_result_is_null;\n                } else {\n                    type1 = numericType(pIn1);\n                    type2 = numericType(pIn2);\n                    if ((type1 & type2 & 4) != 0)\n                        goto int_math;\n                  fp_math:\n                    rA = sqlite3VdbeRealValue(pIn1);\n                    rB = sqlite3VdbeRealValue(pIn2);\n                    switch (pOp->opcode) {\n                      case 106:\n                        rB += rA;\n                        break;\n                      case 107:\n                        rB -= rA;\n                        break;\n                      case 108:\n                        rB *= rA;\n                        break;\n                      case 109:\n                        {\n                            if (rA == (double)0)\n                                goto arithmetic_result_is_null;\n                            rB /= rA;\n                            break;\n                        }\n                      default:\n                        {\n                            iA = sqlite3VdbeIntValue(pIn1);\n                            iB = sqlite3VdbeIntValue(pIn2);\n                            if (iA == 0)\n                                goto arithmetic_result_is_null;\n                            if (iA == -1)\n                                iA = 1;\n                            rB = (double)(iB % iA);\n                            break;\n                        }\n                    }\n                    if (sqlite3IsNaN(rB)) {\n                        goto arithmetic_result_is_null;\n                    }\n                    pOut->u.r = rB;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 8);\n                }\n                break;\n              arithmetic_result_is_null:\n                sqlite3VdbeMemSetNull(pOut);\n                break;\n            }\n          case 85:\n            {\n                assert(pOp->p4type == (-2));\n                if (pOp->p1) {\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);\n                }\n                break;\n            }\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n            {\n                i64 iA;\n                u64 uA;\n                i64 iB;\n                u8 op;\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                pOut = &aMem[pOp->p3];\n                if ((pIn1->flags | pIn2->flags) & 1) {\n                    sqlite3VdbeMemSetNull(pOut);\n                    break;\n                }\n                iA = sqlite3VdbeIntValue(pIn2);\n                iB = sqlite3VdbeIntValue(pIn1);\n                op = pOp->opcode;\n                if (op == 102) {\n                    iA &= iB;\n                } else if (op == 103) {\n                    iA |= iB;\n                } else if (iB != 0) {\n                    assert(op == 105 || op == 104);\n                    if (iB < 0) {\n                        assert(105 == 104 + 1);\n                        op = 2 * 104 + 1 - op;\n                        iB = iB > (-64) ? -iB : 64;\n                    }\n                    if (iB >= 64) {\n                        iA = (iA >= 0 || op == 104) ? 0 : -1;\n                    } else {\n                        memcpy(&uA, &iA, sizeof (uA));\n                        if (op == 104) {\n                            uA <<= iB;\n                        } else {\n                            uA >>= iB;\n                            if (iA < 0)\n                                uA |= ((((u64)4294967295U) << 32) | 4294967295U) << (64 - iB);\n                        }\n                        memcpy(&iA, &uA, sizeof (iA));\n                    }\n                }\n                pOut->u.i = iA;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 86:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn1->u.i += pOp->p2;\n                break;\n            }\n          case 13:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if ((pIn1->flags & 4) == 0) {\n                    applyAffinity(pIn1, 67, encoding);\n                    if ((pIn1->flags & 4) == 0) {\n                        ;\n                        if (pOp->p2 == 0) {\n                            rc = 20;\n                            goto abort_due_to_error;\n                        } else {\n                            goto jump_to_p2;\n                        }\n                    }\n                }\n                ;\n                ((pIn1)->flags = ((pIn1)->flags & ~(3519 | 1024)) | 4);\n                break;\n            }\n          case 87:\n            {\n                pIn1 = &aMem[pOp->p1];\n                if (pIn1->flags & (4 | 32)) {\n                    ;\n                    ;\n                    sqlite3VdbeMemRealify(pIn1);\n                    ;\n                }\n                break;\n            }\n          case 88:\n            {\n                assert(pOp->p2 >= 65 && pOp->p2 <= 69);\n                ;\n                ;\n                ;\n                ;\n                ;\n                pIn1 = &aMem[pOp->p1];\n                ;\n                rc = (((pIn1)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn1) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                ;\n                ;\n                break;\n            }\n          case 53:\n          case 52:\n          case 56:\n          case 55:\n          case 54:\n          case 57:\n            {\n                int res, res2;\n                char affinity;\n                u16 flags1;\n                u16 flags3;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                flags1 = pIn1->flags;\n                flags3 = pIn3->flags;\n                if ((flags1 & flags3 & 4) != 0) {\n                    assert((pOp->p5 & 71) != 66 || (sqlite3Config.neverCorrupt == 0));\n                    if (pIn3->u.i > pIn1->u.i) {\n                        if (sqlite3aGTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = +1;\n                    } else if (pIn3->u.i < pIn1->u.i) {\n                        if (sqlite3aLTb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = -1;\n                    } else {\n                        if (sqlite3aEQb[pOp->opcode]) {\n                            ;\n                            goto jump_to_p2;\n                        }\n                        iCompare = 0;\n                    }\n                    ;\n                    break;\n                }\n                if ((flags1 | flags3) & 1) {\n                    if (pOp->p5 & 128) {\n                        assert((flags1 & 256) == 0);\n                        assert((pOp->p5 & 16) == 0 || (sqlite3Config.neverCorrupt == 0));\n                        ;\n                        if ((flags1 & flags3 & 1) != 0 && (flags3 & 256) == 0) {\n                            res = 0;\n                        } else {\n                            res = ((flags3 & 1) ? -1 : +1);\n                        }\n                    } else {\n                        ;\n                        if (pOp->p5 & 16) {\n                            goto jump_to_p2;\n                        }\n                        iCompare = 1;\n                        break;\n                    }\n                } else {\n                    affinity = pOp->p5 & 71;\n                    if (affinity >= 67) {\n                        if ((flags1 | flags3) & 2) {\n                            if ((flags1 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn1, 0);\n                                ;\n                                flags3 = pIn3->flags;\n                            }\n                            if ((flags3 & (4 | 32 | 8 | 2)) == 2) {\n                                applyNumericAffinity(pIn3, 0);\n                            }\n                        }\n                    } else if (affinity == 66) {\n                        if ((flags1 & 2) == 0 && (flags1 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn1, encoding, 1);\n                            ;\n                            flags1 = (pIn1->flags & ~3519) | (flags1 & 3519);\n                            if (pIn1 == pIn3)\n                                flags3 = flags1 | 2;\n                        }\n                        if ((flags3 & 2) == 0 && (flags3 & (4 | 8 | 32)) != 0) {\n                            ;\n                            ;\n                            ;\n                            sqlite3VdbeMemStringify(pIn3, encoding, 1);\n                            ;\n                            flags3 = (pIn3->flags & ~3519) | (flags3 & 3519);\n                        }\n                    }\n                    assert(pOp->p4type == (-2) || pOp->p4.pColl == 0);\n                    res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);\n                }\n                assert(53 == 52 + 1);\n                assert(54 == 52 + 2);\n                assert(55 == 52 + 3);\n                assert(56 == 52 + 4);\n                assert(57 == 52 + 5);\n                if (res < 0) {\n                    res2 = sqlite3aLTb[pOp->opcode];\n                } else if (res == 0) {\n                    res2 = sqlite3aEQb[pOp->opcode];\n                } else {\n                    res2 = sqlite3aGTb[pOp->opcode];\n                }\n                iCompare = res;\n                assert((pIn3->flags & 4096) == (flags3 & 4096));\n                pIn3->flags = flags3;\n                assert((pIn1->flags & 4096) == (flags1 & 4096));\n                pIn1->flags = flags1;\n                ;\n                if (res2) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 58:\n            {\n                ;\n                if (iCompare == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 89:\n            {\n                assert(pOp->p4type == (-14));\n                assert(pOp->p4.ai);\n                assert(pOp[1].opcode == 90);\n                assert(pOp[1].p5 & 1);\n                break;\n            }\n          case 90:\n            {\n                int n;\n                int i;\n                int p1;\n                int p2;\n                const KeyInfo *pKeyInfo;\n                u32 idx;\n                CollSeq *pColl;\n                int bRev;\n                u32 *aPermute;\n                if ((pOp->p5 & 1) == 0) {\n                    aPermute = 0;\n                } else {\n                    assert(pOp > aOp);\n                    assert(pOp[-1].opcode == 89);\n                    assert(pOp[-1].p4type == (-14));\n                    aPermute = pOp[-1].p4.ai + 1;\n                    assert(aPermute != 0);\n                }\n                n = pOp->p3;\n                pKeyInfo = pOp->p4.pKeyInfo;\n                assert(n > 0);\n                assert(pKeyInfo != 0);\n                p1 = pOp->p1;\n                p2 = pOp->p2;\n                for (i = 0; i < n; i++) {\n                    idx = aPermute ? aPermute[i] : (u32)i;\n                    assert(memIsValid(&aMem[p1 + idx]));\n                    assert(memIsValid(&aMem[p2 + idx]));\n                    ;\n                    ;\n                    assert(i < pKeyInfo->nKeyField);\n                    pColl = pKeyInfo->aColl[i];\n                    bRev = (pKeyInfo->aSortFlags[i] & 1);\n                    iCompare = sqlite3MemCompare(&aMem[p1 + idx], &aMem[p2 + idx], pColl);\n                    if (iCompare) {\n                        if ((pKeyInfo->aSortFlags[i] & 2) && ((aMem[p1 + idx].flags & 1) || (aMem[p2 + idx].flags & 1))) {\n                            iCompare = -iCompare;\n                        }\n                        if (bRev)\n                            iCompare = -iCompare;\n                        break;\n                    }\n                }\n                assert(pOp[1].opcode == 14);\n                break;\n            }\n          case 14:\n            {\n                assert(pOp > aOp && pOp[-1].opcode == 90);\n                if (iCompare < 0) {\n                    ;\n                    pOp = &aOp[pOp->p1 - 1];\n                } else if (iCompare == 0) {\n                    ;\n                    pOp = &aOp[pOp->p2 - 1];\n                } else {\n                    ;\n                    pOp = &aOp[pOp->p3 - 1];\n                }\n                break;\n            }\n          case 44:\n          case 43:\n            {\n                int v1;\n                int v2;\n                v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);\n                v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);\n                if (pOp->opcode == 44) {\n                    static const unsigned char and_logic[] = {0, 0, 0, 0, 1, 2, 0, 2, 2};\n                    v1 = and_logic[v1 * 3 + v2];\n                } else {\n                    static const unsigned char or_logic[] = {0, 1, 2, 1, 1, 1, 2, 1, 2};\n                    v1 = or_logic[v1 * 3 + v2];\n                }\n                pOut = &aMem[pOp->p3];\n                if (v1 == 2) {\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                } else {\n                    pOut->u.i = v1;\n                    ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 4);\n                }\n                break;\n            }\n          case 91:\n            {\n                assert(pOp->p4type == (-3));\n                assert(pOp->p4.i == 0 || pOp->p4.i == 1);\n                assert(pOp->p3 == 0 || pOp->p3 == 1);\n                sqlite3VdbeMemSetInt64(&aMem[pOp->p2], sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);\n                break;\n            }\n          case 19:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                if ((pIn1->flags & 1) == 0) {\n                    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1, 0));\n                } else {\n                    sqlite3VdbeMemSetNull(pOut);\n                }\n                break;\n            }\n          case 114:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pOut = &aMem[pOp->p2];\n                sqlite3VdbeMemSetNull(pOut);\n                if ((pIn1->flags & 1) == 0) {\n                    pOut->flags = 4;\n                    pOut->u.i = ~sqlite3VdbeIntValue(pIn1);\n                }\n                break;\n            }\n          case 15:\n            {\n                u32 iAddr;\n                assert(p->aOp[0].opcode == 8);\n                if (p->pFrame) {\n                    iAddr = (int)(pOp - p->aOp);\n                    if ((p->pFrame->aOnce[iAddr / 8] & (1 << (iAddr & 7))) != 0) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    p->pFrame->aOnce[iAddr / 8] |= 1 << (iAddr & 7);\n                } else {\n                    if (p->aOp[0].p1 == pOp->p1) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                }\n                ;\n                pOp->p1 = p->aOp[0].p1;\n                break;\n            }\n          case 16:\n            {\n                int c;\n                c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 17:\n            {\n                int c;\n                c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);\n                ;\n                if (c)\n                    goto jump_to_p2;\n                break;\n            }\n          case 50:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) != 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 18:\n            {\n                VdbeCursor *pC;\n                u16 typeMask;\n                u32 serialType;\n                assert(pOp->p1 >= (-1) && pOp->p1 < p->nCursor);\n                assert(pOp->p1 >= 0 || (pOp->p3 >= 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor)));\n                if (pOp->p1 >= 0) {\n                    pC = p->apCsr[pOp->p1];\n                    assert(pC != 0);\n                    assert(pOp->p3 >= 0);\n                    if (pOp->p3 < pC->nHdrParsed) {\n                        serialType = pC->aType[pOp->p3];\n                        if (serialType >= 12) {\n                            if (serialType & 1) {\n                                typeMask = 4;\n                            } else {\n                                typeMask = 8;\n                            }\n                        } else {\n                            static const unsigned char aMask[] = {16, 1, 1, 1, 1, 1, 1, 2, 1, 1, 16, 16};\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            ;\n                            typeMask = aMask[serialType];\n                        }\n                    } else {\n                        typeMask = 1 << (pOp->p4.i - 1);\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                    }\n                } else {\n                    assert(memIsValid(&aMem[pOp->p3]));\n                    typeMask = 1 << (sqlite3_value_type((sqlite3_value *)&aMem[pOp->p3]) - 1);\n                    ;\n                    ;\n                    ;\n                    ;\n                    ;\n                }\n                ;\n                if (typeMask & pOp->p5) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 92:\n            {\n                if ((aMem[pOp->p1].flags & 1) != 0 || (aMem[pOp->p3].flags & 1) != 0) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p2);\n                } else {\n                    sqlite3VdbeMemSetInt64(aMem + pOp->p2, 0);\n                }\n                break;\n            }\n          case 51:\n            {\n                pIn1 = &aMem[pOp->p1];\n                ;\n                if ((pIn1->flags & 1) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 20:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if ((pC) && pC->nullRow) {\n                    sqlite3VdbeMemSetNull(aMem + pOp->p3);\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 94:\n            {\n                u32 p2;\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 *aOffset;\n                int len;\n                int i;\n                Mem *pDest;\n                Mem sMem;\n                const u8 *zData;\n                const u8 *zHdr;\n                const u8 *zEndHdr;\n                u64 offset64;\n                u32 t;\n                Mem *pReg;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pC = p->apCsr[pOp->p1];\n                p2 = (u32)pOp->p2;\n              op_column_restart:\n                assert(pC != 0);\n                assert(p2 < (u32)pC->nField || (pC->eCurType == 3 && pC->seekResult == 0));\n                aOffset = pC->aOffset;\n                assert(aOffset == pC->aType + pC->nField);\n                assert(pC->eCurType != 2);\n                assert(pC->eCurType != 3 || pC->nullRow);\n                assert(pC->eCurType != 1);\n                if (pC->cacheStatus != p->cacheCtr) {\n                    if (pC->nullRow) {\n                        if (pC->eCurType == 3 && pC->seekResult > 0) {\n                            pReg = &aMem[pC->seekResult];\n                            assert(pReg->flags & 16);\n                            assert(memIsValid(pReg));\n                            pC->payloadSize = pC->szRow = pReg->n;\n                            pC->aRow = (u8 *)pReg->z;\n                        } else {\n                            pDest = &aMem[pOp->p3];\n                            ;\n                            sqlite3VdbeMemSetNull(pDest);\n                            goto op_column_out;\n                        }\n                    } else {\n                        pCrsr = pC->uc.pCursor;\n                        if (pC->deferredMoveto) {\n                            u32 iMap;\n                            assert(!pC->isEphemeral);\n                            if (pC->ub.aAltMap && (iMap = pC->ub.aAltMap[1 + p2]) > 0) {\n                                pC = pC->pAltCursor;\n                                p2 = iMap - 1;\n                                goto op_column_restart;\n                            }\n                            rc = sqlite3VdbeFinishMoveto(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                        } else if (sqlite3BtreeCursorHasMoved(pCrsr)) {\n                            rc = sqlite3VdbeHandleMovedCursor(pC);\n                            if (rc)\n                                goto abort_due_to_error;\n                            goto op_column_restart;\n                        }\n                        assert(pC->eCurType == 0);\n                        assert(pCrsr);\n                        assert(sqlite3BtreeCursorIsValid(pCrsr));\n                        pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);\n                        pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &pC->szRow);\n                        assert(pC->szRow <= pC->payloadSize);\n                        assert(pC->szRow <= 65536);\n                    }\n                    pC->cacheStatus = p->cacheCtr;\n                    if ((aOffset[0] = pC->aRow[0]) < 128) {\n                        pC->iHdrOffset = 1;\n                    } else {\n                        pC->iHdrOffset = sqlite3GetVarint32(pC->aRow, aOffset);\n                    }\n                    pC->nHdrParsed = 0;\n                    if (pC->szRow < aOffset[0]) {\n                        pC->aRow = 0;\n                        pC->szRow = 0;\n                        if (aOffset[0] > 98307 || aOffset[0] > pC->payloadSize) {\n                            goto op_column_corrupt;\n                        }\n                    } else {\n                        zData = pC->aRow;\n                        assert(pC->nHdrParsed <= p2);\n                        ;\n                        goto op_column_read_header;\n                    }\n                } else if (sqlite3BtreeCursorHasMoved(pC->uc.pCursor)) {\n                    rc = sqlite3VdbeHandleMovedCursor(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    goto op_column_restart;\n                }\n                if (pC->nHdrParsed <= p2) {\n                    if (pC->iHdrOffset < aOffset[0]) {\n                        if (pC->aRow == 0) {\n                            memset(&sMem, 0, sizeof (sMem));\n                            rc = sqlite3VdbeMemFromBtreeZeroOffset(pC->uc.pCursor, aOffset[0], &sMem);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                            zData = (u8 *)sMem.z;\n                        } else {\n                            zData = pC->aRow;\n                        }\n                      op_column_read_header:\n                        i = pC->nHdrParsed;\n                        offset64 = aOffset[i];\n                        zHdr = zData + pC->iHdrOffset;\n                        zEndHdr = zData + aOffset[0];\n                        ;\n                        do {\n                            if ((pC->aType[i] = t = zHdr[0]) < 128) {\n                                zHdr++;\n                                offset64 += sqlite3VdbeOneByteSerialTypeLen(t);\n                            } else {\n                                zHdr += sqlite3GetVarint32(zHdr, &t);\n                                pC->aType[i] = t;\n                                offset64 += sqlite3VdbeSerialTypeLen(t);\n                            }\n                            aOffset[++i] = (u32)(offset64 & 4294967295U);\n                        } while ((u32)i <= p2 && zHdr < zEndHdr);\n                        if ((zHdr >= zEndHdr && (zHdr > zEndHdr || offset64 != pC->payloadSize)) || (offset64 > pC->payloadSize)) {\n                            if (aOffset[0] == 0) {\n                                i = 0;\n                                zHdr = zEndHdr;\n                            } else {\n                                if (pC->aRow == 0)\n                                    sqlite3VdbeMemRelease(&sMem);\n                                goto op_column_corrupt;\n                            }\n                        }\n                        pC->nHdrParsed = i;\n                        pC->iHdrOffset = (u32)(zHdr - zData);\n                        if (pC->aRow == 0)\n                            sqlite3VdbeMemRelease(&sMem);\n                    } else {\n                        t = 0;\n                    }\n                    if (pC->nHdrParsed <= p2) {\n                        pDest = &aMem[pOp->p3];\n                        ;\n                        if (pOp->p4type == (-10)) {\n                            sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, 8192);\n                        } else {\n                            sqlite3VdbeMemSetNull(pDest);\n                        }\n                        goto op_column_out;\n                    }\n                } else {\n                    t = pC->aType[p2];\n                }\n                assert(p2 < pC->nHdrParsed);\n                assert(rc == 0);\n                pDest = &aMem[pOp->p3];\n                ;\n                assert(sqlite3VdbeCheckMemInvariants(pDest));\n                if ((((pDest)->flags & (32768 | 4096)) != 0)) {\n                    sqlite3VdbeMemSetNull(pDest);\n                }\n                assert(t == pC->aType[p2]);\n                if (pC->szRow >= aOffset[p2 + 1]) {\n                    zData = pC->aRow + aOffset[p2];\n                    if (t < 12) {\n                        sqlite3VdbeSerialGet(zData, t, pDest);\n                    } else {\n                        static const u16 aFlag[] = {16, 2 | 512};\n                        pDest->n = len = (t - 12) / 2;\n                        pDest->enc = encoding;\n                        if (pDest->szMalloc < len + 2) {\n                            if (len > db->aLimit[0])\n                                goto too_big;\n                            pDest->flags = 1;\n                            if (sqlite3VdbeMemGrow(pDest, len + 2, 0))\n                                goto no_mem;\n                        } else {\n                            pDest->z = pDest->zMalloc;\n                        }\n                        memcpy(pDest->z, zData, len);\n                        pDest->z[len] = 0;\n                        pDest->z[len + 1] = 0;\n                        pDest->flags = aFlag[t & 1];\n                    }\n                } else {\n                    pDest->enc = encoding;\n                    if (((pOp->p5 & (64 | 128)) != 0 && ((t >= 12 && (t & 1) == 0) || (pOp->p5 & 128) != 0)) || (len = sqlite3VdbeSerialTypeLen(t)) == 0) {\n                        sqlite3VdbeSerialGet((u8 *)sqlite3CtypeMap, t, pDest);\n                    } else {\n                        if (len > db->aLimit[0])\n                            goto too_big;\n                        rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, aOffset[p2], len, pDest);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        sqlite3VdbeSerialGet((const u8 *)pDest->z, t, pDest);\n                        pDest->flags &= ~16384;\n                    }\n                }\n              op_column_out:\n                ;\n                ;\n                break;\n              op_column_corrupt:\n                if (aOp[0].p3 > 0) {\n                    pOp = &aOp[aOp[0].p3 - 1];\n                    break;\n                } else {\n                    rc = sqlite3CorruptError(92699);\n                    goto abort_due_to_error;\n                }\n            }\n          case 95:\n            {\n                Table *pTab;\n                Column *aCol;\n                int i;\n                assert(pOp->p4type == (-5));\n                pTab = pOp->p4.pTab;\n                assert(pTab->tabFlags & 65536);\n                assert(pTab->nNVCol == pOp->p2);\n                aCol = pTab->aCol;\n                pIn1 = &aMem[pOp->p1];\n                for (i = 0; i < pTab->nCol; i++) {\n                    if (aCol[i].colFlags & 96) {\n                        if (aCol[i].colFlags & 32)\n                            continue;\n                        if (pOp->p3) {\n                            pIn1++;\n                            continue;\n                        }\n                    }\n                    assert(pIn1 < &aMem[pOp->p1 + pOp->p2]);\n                    applyAffinity(pIn1, aCol[i].affinity, encoding);\n                    if ((pIn1->flags & 1) == 0) {\n                        switch (aCol[i].eCType) {\n                          case 2:\n                            {\n                                if ((pIn1->flags & 16) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 4:\n                          case 3:\n                            {\n                                if ((pIn1->flags & 4) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 6:\n                            {\n                                if ((pIn1->flags & 2) == 0)\n                                    goto vdbe_type_error;\n                                break;\n                            }\n                          case 5:\n                            {\n                                ;\n                                ;\n                                if (pIn1->flags & 4) {\n                                    ;\n                                    ;\n                                    ;\n                                    ;\n                                    if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                        pIn1->flags |= 32;\n                                        pIn1->flags &= ~4;\n                                    } else {\n                                        pIn1->u.r = (double)pIn1->u.i;\n                                        pIn1->flags |= 8;\n                                        pIn1->flags &= ~4;\n                                    }\n                                } else if ((pIn1->flags & (8 | 32)) == 0) {\n                                    goto vdbe_type_error;\n                                }\n                                break;\n                            }\n                          default:\n                            {\n                                break;\n                            }\n                        }\n                    }\n                    ;\n                    pIn1++;\n                }\n                assert(pIn1 == &aMem[pOp->p1 + pOp->p2]);\n                break;\n              vdbe_type_error:\n                sqlite3VdbeError(p, \"cannot store %s value in %s column %s.%s\", vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType - 1], pTab->zName, aCol[i].zCnName);\n                rc = (19 | (12 << 8));\n                goto abort_due_to_error;\n            }\n          case 96:\n            {\n                const char *zAffinity;\n                zAffinity = pOp->p4.z;\n                assert(zAffinity != 0);\n                assert(pOp->p2 > 0);\n                assert(zAffinity[pOp->p2] == 0);\n                pIn1 = &aMem[pOp->p1];\n                while (1)\n                    {\n                        assert(pIn1 <= &p->aMem[(p->nMem + 1 - p->nCursor)]);\n                        assert(zAffinity[0] == 64 || memIsValid(pIn1));\n                        applyAffinity(pIn1, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pIn1->flags & 4) != 0) {\n                            ;\n                            ;\n                            ;\n                            ;\n                            if (pIn1->u.i <= 140737488355327LL && pIn1->u.i >= -140737488355328LL) {\n                                pIn1->flags |= 32;\n                                pIn1->flags &= ~4;\n                            } else {\n                                pIn1->u.r = (double)pIn1->u.i;\n                                pIn1->flags |= 8;\n                                pIn1->flags &= ~4;\n                            }\n                        }\n                        ;\n                        zAffinity++;\n                        if (zAffinity[0] == 0)\n                            break;\n                        pIn1++;\n                    }\n                break;\n            }\n          case 97:\n            {\n                Mem *pRec;\n                u64 nData;\n                int nHdr;\n                i64 nByte;\n                i64 nZero;\n                int nVarint;\n                u32 serial_type;\n                Mem *pData0;\n                Mem *pLast;\n                int nField;\n                char *zAffinity;\n                u32 len;\n                u8 *zHdr;\n                u8 *zPayload;\n                nData = 0;\n                nHdr = 0;\n                nZero = 0;\n                nField = pOp->p1;\n                zAffinity = pOp->p4.z;\n                assert(nField > 0 && pOp->p2 > 0 && pOp->p2 + nField <= (p->nMem + 1 - p->nCursor) + 1);\n                pData0 = &aMem[nField];\n                nField = pOp->p2;\n                pLast = &pData0[nField - 1];\n                assert(pOp->p3 < pOp->p1 || pOp->p3 >= pOp->p1 + pOp->p2);\n                pOut = &aMem[pOp->p3];\n                ;\n                assert(pData0 <= pLast);\n                if (zAffinity) {\n                    pRec = pData0;\n                    do {\n                        applyAffinity(pRec, zAffinity[0], encoding);\n                        if (zAffinity[0] == 69 && (pRec->flags & 4)) {\n                            pRec->flags |= 32;\n                            pRec->flags &= ~(4);\n                        }\n                        ;\n                        zAffinity++;\n                        pRec++;\n                        assert(zAffinity[0] == 0 || pRec <= pLast);\n                    } while (zAffinity[0]);\n                }\n                pRec = pLast;\n                do {\n                    assert(memIsValid(pRec));\n                    if (pRec->flags & 1) {\n                        if (pRec->flags & 1024) {\n                            assert(pOp->p5 == 109 || (sqlite3Config.neverCorrupt == 0));\n                            pRec->uTemp = 10;\n                        } else {\n                            pRec->uTemp = 0;\n                        }\n                        nHdr++;\n                    } else if (pRec->flags & (4 | 32)) {\n                        i64 i = pRec->u.i;\n                        u64 uu;\n                        ;\n                        ;\n                        if (i < 0) {\n                            uu = ~i;\n                        } else {\n                            uu = i;\n                        }\n                        nHdr++;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        ;\n                        if (uu <= 127) {\n                            if ((i & 1) == i && p->minWriteFileFormat >= 4) {\n                                pRec->uTemp = 8 + (u32)uu;\n                            } else {\n                                nData++;\n                                pRec->uTemp = 1;\n                            }\n                        } else if (uu <= 32767) {\n                            nData += 2;\n                            pRec->uTemp = 2;\n                        } else if (uu <= 8388607) {\n                            nData += 3;\n                            pRec->uTemp = 3;\n                        } else if (uu <= 2147483647) {\n                            nData += 4;\n                            pRec->uTemp = 4;\n                        } else if (uu <= 140737488355327LL) {\n                            nData += 6;\n                            pRec->uTemp = 5;\n                        } else {\n                            nData += 8;\n                            if (pRec->flags & 32) {\n                                pRec->u.r = (double)pRec->u.i;\n                                pRec->flags &= ~32;\n                                pRec->flags |= 8;\n                                pRec->uTemp = 7;\n                            } else {\n                                pRec->uTemp = 6;\n                            }\n                        }\n                    } else if (pRec->flags & 8) {\n                        nHdr++;\n                        nData += 8;\n                        pRec->uTemp = 7;\n                    } else {\n                        assert(db->mallocFailed || pRec->flags & (2 | 16));\n                        assert(pRec->n >= 0);\n                        len = (u32)pRec->n;\n                        serial_type = (len * 2) + 12 + ((pRec->flags & 2) != 0);\n                        if (pRec->flags & 1024) {\n                            serial_type += pRec->u.nZero * 2;\n                            if (nData) {\n                                if (sqlite3VdbeMemExpandBlob(pRec))\n                                    goto no_mem;\n                                len += pRec->u.nZero;\n                            } else {\n                                nZero += pRec->u.nZero;\n                            }\n                        }\n                        nData += len;\n                        nHdr += sqlite3VarintLen(serial_type);\n                        pRec->uTemp = serial_type;\n                    }\n                    if (pRec == pData0)\n                        break;\n                    pRec--;\n                } while (1);\n                ;\n                ;\n                if (nHdr <= 126) {\n                    nHdr += 1;\n                } else {\n                    nVarint = sqlite3VarintLen(nHdr);\n                    nHdr += nVarint;\n                    if (nVarint < sqlite3VarintLen(nHdr))\n                        nHdr++;\n                }\n                nByte = nHdr + nData;\n                if (nByte + nZero <= pOut->szMalloc) {\n                    pOut->z = pOut->zMalloc;\n                } else {\n                    if (nByte + nZero > db->aLimit[0]) {\n                        goto too_big;\n                    }\n                    if (sqlite3VdbeMemClearAndResize(pOut, (int)nByte)) {\n                        goto no_mem;\n                    }\n                }\n                pOut->n = (int)nByte;\n                pOut->flags = 16;\n                if (nZero) {\n                    pOut->u.nZero = nZero;\n                    pOut->flags |= 1024;\n                }\n                ;\n                zHdr = (u8 *)pOut->z;\n                zPayload = zHdr + nHdr;\n                if (nHdr < 128) {\n                    *(zHdr++) = nHdr;\n                } else {\n                    zHdr += sqlite3PutVarint(zHdr, nHdr);\n                }\n                assert(pData0 <= pLast);\n                pRec = pData0;\n                while (1)\n                    {\n                        serial_type = pRec->uTemp;\n                        if (serial_type <= 7) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type == 0) {\n                            } else {\n                                u64 v;\n                                u32 i;\n                                if (serial_type == 7) {\n                                    assert(sizeof (v) == sizeof (pRec->u.r));\n                                    memcpy(&v, &pRec->u.r, sizeof (v));\n                                    ;\n                                } else {\n                                    v = pRec->u.i;\n                                }\n                                len = i = sqlite3SmallTypeSizes[serial_type];\n                                assert(i > 0);\n                                while (1)\n                                    {\n                                        zPayload[--i] = (u8)(v & 255);\n                                        if (i == 0)\n                                            break;\n                                        v >>= 8;\n                                    }\n                                zPayload += len;\n                            }\n                        } else if (serial_type < 128) {\n                            *(zHdr++) = serial_type;\n                            if (serial_type >= 14 && pRec->n > 0) {\n                                assert(pRec->z != 0);\n                                memcpy(zPayload, pRec->z, pRec->n);\n                                zPayload += pRec->n;\n                            }\n                        } else {\n                            zHdr += sqlite3PutVarint(zHdr, serial_type);\n                            if (pRec->n) {\n                                assert(pRec->z != 0);\n                                memcpy(zPayload, pRec->z, pRec->n);\n                                zPayload += pRec->n;\n                            }\n                        }\n                        if (pRec == pLast)\n                            break;\n                        pRec++;\n                    }\n                assert(nHdr == (int)(zHdr - (u8 *)pOut->z));\n                assert(nByte == (int)(zPayload - (u8 *)pOut->z));\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                ;\n                break;\n            }\n          case 98:\n            {\n                i64 nEntry;\n                BtCursor *pCrsr;\n                assert(p->apCsr[pOp->p1]->eCurType == 0);\n                pCrsr = p->apCsr[pOp->p1]->uc.pCursor;\n                assert(pCrsr);\n                if (pOp->p3) {\n                    nEntry = sqlite3BtreeRowCountEst(pCrsr);\n                } else {\n                    nEntry = 0;\n                    rc = sqlite3BtreeCount(db, pCrsr, &nEntry);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = nEntry;\n                goto check_for_interrupt;\n            }\n          case 0:\n            {\n                int p1;\n                char *zName;\n                int nName;\n                Savepoint *pNew;\n                Savepoint *pSavepoint;\n                Savepoint *pTmp;\n                int iSavepoint;\n                int ii;\n                p1 = pOp->p1;\n                zName = pOp->p4.z;\n                assert(db->pSavepoint == 0 || db->autoCommit == 0);\n                assert(p1 == 0 || p1 == 1 || p1 == 2);\n                assert(db->pSavepoint || db->isTransactionSavepoint == 0);\n                assert(checkSavepointCount(db));\n                assert(p->bIsReader);\n                if (p1 == 0) {\n                    if (db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot open savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        nName = sqlite3Strlen30(zName);\n                        assert(db->autoCommit == 0 || db->nVTrans == 0);\n                        rc = sqlite3VtabSavepoint(db, 0, db->nStatement + db->nSavepoint);\n                        if (rc != 0)\n                            goto abort_due_to_error;\n                        pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint) + nName + 1);\n                        if (pNew) {\n                            pNew->zName = (char *)&pNew[1];\n                            memcpy(pNew->zName, zName, nName + 1);\n                            if (db->autoCommit) {\n                                db->autoCommit = 0;\n                                db->isTransactionSavepoint = 1;\n                            } else {\n                                db->nSavepoint++;\n                            }\n                            pNew->pNext = db->pSavepoint;\n                            db->pSavepoint = pNew;\n                            pNew->nDeferredCons = db->nDeferredCons;\n                            pNew->nDeferredImmCons = db->nDeferredImmCons;\n                        }\n                    }\n                } else {\n                    assert(p1 == 1 || p1 == 2);\n                    iSavepoint = 0;\n                    for (pSavepoint = db->pSavepoint; pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName); pSavepoint = pSavepoint->pNext) {\n                        iSavepoint++;\n                    }\n                    if (!pSavepoint) {\n                        sqlite3VdbeError(p, \"no such savepoint: %s\", zName);\n                        rc = 1;\n                    } else if (db->nVdbeWrite > 0 && p1 == 1) {\n                        sqlite3VdbeError(p, \"cannot release savepoint - SQL statements in progress\");\n                        rc = 5;\n                    } else {\n                        int isTransaction = pSavepoint->pNext == 0 && db->isTransactionSavepoint;\n                        if (isTransaction && p1 == 1) {\n                            if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                                goto vdbe_return;\n                            }\n                            db->autoCommit = 1;\n                            if (sqlite3VdbeHalt(p) == 5) {\n                                p->pc = (int)(pOp - aOp);\n                                db->autoCommit = 0;\n                                p->rc = rc = 5;\n                                goto vdbe_return;\n                            }\n                            rc = p->rc;\n                            if (rc) {\n                                db->autoCommit = 0;\n                            } else {\n                                db->isTransactionSavepoint = 0;\n                            }\n                        } else {\n                            int isSchemaChange;\n                            iSavepoint = db->nSavepoint - iSavepoint - 1;\n                            if (p1 == 2) {\n                                isSchemaChange = (db->mDbFlags & 1) != 0;\n                                for (ii = 0; ii < db->nDb; ii++) {\n                                    rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt, (4 | (2 << 8)), isSchemaChange == 0);\n                                    if (rc != 0)\n                                        goto abort_due_to_error;\n                                }\n                            } else {\n                                assert(p1 == 1);\n                                isSchemaChange = 0;\n                            }\n                            for (ii = 0; ii < db->nDb; ii++) {\n                                rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);\n                                if (rc != 0) {\n                                    goto abort_due_to_error;\n                                }\n                            }\n                            if (isSchemaChange) {\n                                sqlite3ExpirePreparedStatements(db, 0);\n                                sqlite3ResetAllSchemasOfConnection(db);\n                                db->mDbFlags |= 1;\n                            }\n                        }\n                        if (rc)\n                            goto abort_due_to_error;\n                        while (db->pSavepoint != pSavepoint)\n                            {\n                                pTmp = db->pSavepoint;\n                                db->pSavepoint = pTmp->pNext;\n                                sqlite3DbFree(db, pTmp);\n                                db->nSavepoint--;\n                            }\n                        if (p1 == 1) {\n                            assert(pSavepoint == db->pSavepoint);\n                            db->pSavepoint = pSavepoint->pNext;\n                            sqlite3DbFree(db, pSavepoint);\n                            if (!isTransaction) {\n                                db->nSavepoint--;\n                            }\n                        } else {\n                            assert(p1 == 2);\n                            db->nDeferredCons = pSavepoint->nDeferredCons;\n                            db->nDeferredImmCons = pSavepoint->nDeferredImmCons;\n                        }\n                        if (!isTransaction || p1 == 2) {\n                            rc = sqlite3VtabSavepoint(db, p1, iSavepoint);\n                            if (rc != 0)\n                                goto abort_due_to_error;\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                if (p->eVdbeState == 3) {\n                    rc = 101;\n                    goto vdbe_return;\n                }\n                break;\n            }\n          case 1:\n            {\n                int desiredAutoCommit;\n                int iRollback;\n                desiredAutoCommit = pOp->p1;\n                iRollback = pOp->p2;\n                assert(desiredAutoCommit == 1 || desiredAutoCommit == 0);\n                assert(desiredAutoCommit == 1 || iRollback == 0);\n                assert(db->nVdbeActive > 0);\n                assert(p->bIsReader);\n                if (desiredAutoCommit != db->autoCommit) {\n                    if (iRollback) {\n                        assert(desiredAutoCommit == 1);\n                        sqlite3RollbackAll(db, (4 | (2 << 8)));\n                        db->autoCommit = 1;\n                    } else if (desiredAutoCommit && db->nVdbeWrite > 0) {\n                        sqlite3VdbeError(p, \"cannot commit transaction - SQL statements in progress\");\n                        rc = 5;\n                        goto abort_due_to_error;\n                    } else if ((rc = sqlite3VdbeCheckFk(p, 1)) != 0) {\n                        goto vdbe_return;\n                    } else {\n                        db->autoCommit = (u8)desiredAutoCommit;\n                    }\n                    if (sqlite3VdbeHalt(p) == 5) {\n                        p->pc = (int)(pOp - aOp);\n                        db->autoCommit = (u8)(1 - desiredAutoCommit);\n                        p->rc = rc = 5;\n                        goto vdbe_return;\n                    }\n                    sqlite3CloseSavepoints(db);\n                    if (p->rc == 0) {\n                        rc = 101;\n                    } else {\n                        rc = 1;\n                    }\n                    goto vdbe_return;\n                } else {\n                    sqlite3VdbeError(p, (!desiredAutoCommit) ? \"cannot start a transaction within a transaction\" : ((iRollback) ? \"cannot rollback - no transaction is active\" : \"cannot commit - no transaction is active\"));\n                    rc = 1;\n                    goto abort_due_to_error;\n                }\n                assert(0);\n            }\n          case 2:\n            {\n                Btree *pBt;\n                Db *pDb;\n                int iMeta = 0;\n                assert(p->bIsReader);\n                assert(p->readOnly == 0 || pOp->p2 == 0);\n                assert(pOp->p2 >= 0 && pOp->p2 <= 2);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(rc == 0);\n                if (pOp->p2 && (db->flags & (1048576 | ((u64)(2) << 32))) != 0) {\n                    if (db->flags & 1048576) {\n                        rc = 8;\n                    } else {\n                        rc = 11;\n                    }\n                    goto abort_due_to_error;\n                }\n                pDb = &db->aDb[pOp->p1];\n                pBt = pDb->pBt;\n                if (pBt) {\n                    rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, &iMeta);\n                    ;\n                    ;\n                    if (rc != 0) {\n                        if ((rc & 255) == 5) {\n                            p->pc = (int)(pOp - aOp);\n                            p->rc = rc;\n                            goto vdbe_return;\n                        }\n                        goto abort_due_to_error;\n                    }\n                    if (p->usesStmtJournal && pOp->p2 && (db->autoCommit == 0 || db->nVdbeRead > 1)) {\n                        assert(sqlite3BtreeTxnState(pBt) == 2);\n                        if (p->iStatement == 0) {\n                            assert(db->nStatement >= 0 && db->nSavepoint >= 0);\n                            db->nStatement++;\n                            p->iStatement = db->nSavepoint + db->nStatement;\n                        }\n                        rc = sqlite3VtabSavepoint(db, 0, p->iStatement - 1);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);\n                        }\n                        p->nStmtDefCons = db->nDeferredCons;\n                        p->nStmtDefImmCons = db->nDeferredImmCons;\n                    }\n                }\n                assert(pOp->p5 == 0 || pOp->p4type == (-3));\n                if (rc == 0 && pOp->p5 && (iMeta != pOp->p3 || pDb->pSchema->iGeneration != pOp->p4.i)) {\n                    sqlite3DbFree(db, p->zErrMsg);\n                    p->zErrMsg = sqlite3DbStrDup(db, \"database schema has changed\");\n                    if (db->aDb[pOp->p1].pSchema->schema_cookie != iMeta) {\n                        sqlite3ResetOneSchema(db, pOp->p1);\n                    }\n                    p->expired = 1;\n                    rc = 17;\n                    p->changeCntOn = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 99:\n            {\n                int iMeta;\n                int iDb;\n                int iCookie;\n                assert(p->bIsReader);\n                iDb = pOp->p1;\n                iCookie = pOp->p3;\n                assert(pOp->p3 < 16);\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert(db->aDb[iDb].pBt != 0);\n                assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = iMeta;\n                break;\n            }\n          case 100:\n            {\n                Db *pDb;\n                ;\n                assert(pOp->p2 < 16);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pDb = &db->aDb[pOp->p1];\n                assert(pDb->pBt != 0);\n                assert(sqlite3SchemaMutexHeld(db, pOp->p1, 0));\n                rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);\n                if (pOp->p2 == 1) {\n                    *(u32 *)&pDb->pSchema->schema_cookie = *(u32 *)&pOp->p3 - pOp->p5;\n                    db->mDbFlags |= 1;\n                    sqlite3FkClearTriggerCache(db, pOp->p1);\n                } else if (pOp->p2 == 2) {\n                    pDb->pSchema->file_format = pOp->p3;\n                }\n                if (pOp->p1 == 1) {\n                    sqlite3ExpirePreparedStatements(db, 0);\n                    p->expired = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 101:\n            {\n                int nField;\n                KeyInfo *pKeyInfo;\n                u32 p2;\n                int iDb;\n                int wrFlag;\n                Btree *pX;\n                VdbeCursor *pCur;\n                Db *pDb;\n                assert(pOp->p5 == 0 || pOp->p5 == 2);\n                assert(pOp->p4type == (-8));\n                pCur = p->apCsr[pOp->p1];\n                if (pCur && pCur->pgnoRoot == (u32)pOp->p2) {\n                    assert(pCur->iDb == pOp->p3);\n                    assert(pCur->eCurType == 0);\n                    sqlite3BtreeClearCursor(pCur->uc.pCursor);\n                    goto open_cursor_set_hints;\n                }\n              case 112:\n              case 113:\n                assert(pOp->opcode == 113 || pOp->p5 == 0 || pOp->p5 == 2);\n                assert(p->bIsReader);\n                assert(pOp->opcode == 112 || pOp->opcode == 101 || p->readOnly == 0);\n                if (p->expired == 1) {\n                    rc = (4 | (2 << 8));\n                    goto abort_due_to_error;\n                }\n                nField = 0;\n                pKeyInfo = 0;\n                p2 = (u32)pOp->p2;\n                iDb = pOp->p3;\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                pDb = &db->aDb[iDb];\n                pX = pDb->pBt;\n                assert(pX != 0);\n                if (pOp->opcode == 113) {\n                    assert(8 == 8);\n                    wrFlag = 4 | (pOp->p5 & 8);\n                    assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n                    if (pDb->pSchema->file_format < p->minWriteFileFormat) {\n                        p->minWriteFileFormat = pDb->pSchema->file_format;\n                    }\n                } else {\n                    wrFlag = 0;\n                }\n                if (pOp->p5 & 16) {\n                    assert(p2 > 0);\n                    assert(p2 <= (u32)(p->nMem + 1 - p->nCursor));\n                    assert(pOp->opcode == 113);\n                    pIn2 = &aMem[p2];\n                    assert(memIsValid(pIn2));\n                    assert((pIn2->flags & 4) != 0);\n                    sqlite3VdbeMemIntegerify(pIn2);\n                    p2 = (int)pIn2->u.i;\n                    assert(p2 >= 2);\n                }\n                if (pOp->p4type == (-8)) {\n                    pKeyInfo = pOp->p4.pKeyInfo;\n                    assert(pKeyInfo->enc == ((db)->enc));\n                    assert(pKeyInfo->db == db);\n                    nField = pKeyInfo->nAllField;\n                } else if (pOp->p4type == (-3)) {\n                    nField = pOp->p4.i;\n                }\n                assert(pOp->p1 >= 0);\n                assert(nField >= 0);\n                ;\n                pCur = allocateCursor(p, pOp->p1, nField, 0);\n                if (pCur == 0)\n                    goto no_mem;\n                pCur->iDb = iDb;\n                pCur->nullRow = 1;\n                pCur->isOrdered = 1;\n                pCur->pgnoRoot = p2;\n                rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);\n                pCur->pKeyInfo = pKeyInfo;\n                pCur->isTable = pOp->p4type != (-8);\n              open_cursor_set_hints:\n                assert(1 == 1);\n                assert(2 == 2);\n                ;\n                ;\n                sqlite3BtreeCursorHintFlags(pCur->uc.pCursor, (pOp->p5 & (1 | 2)));\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 115:\n            {\n                VdbeCursor *pOrig;\n                VdbeCursor *pCx;\n                pOrig = p->apCsr[pOp->p2];\n                assert(pOrig);\n                assert(pOrig->isEphemeral);\n                pCx = allocateCursor(p, pOp->p1, pOrig->nField, 0);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->isEphemeral = 1;\n                pCx->pKeyInfo = pOrig->pKeyInfo;\n                pCx->isTable = pOrig->isTable;\n                pCx->pgnoRoot = pOrig->pgnoRoot;\n                pCx->isOrdered = pOrig->isOrdered;\n                pCx->ub.pBtx = pOrig->ub.pBtx;\n                pCx->noReuse = 1;\n                pOrig->noReuse = 1;\n                rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pCx->pKeyInfo, pCx->uc.pCursor);\n                assert(rc == 0);\n                break;\n            }\n          case 116:\n          case 118:\n            {\n                VdbeCursor *pCx;\n                KeyInfo *pKeyInfo;\n                static const int vfsFlags = 2 | 4 | 16 | 8 | 1024;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p2 >= 0);\n                if (pOp->p3 > 0) {\n                    assert(pOp->p2 == 0);\n                    assert(pOp->opcode == 118);\n                    assert(aMem[pOp->p3].flags & 1);\n                    aMem[pOp->p3].n = 0;\n                    aMem[pOp->p3].z = \"\";\n                }\n                pCx = p->apCsr[pOp->p1];\n                if (pCx && !pCx->noReuse && (pOp->p2 <= pCx->nField)) {\n                    assert(pCx->isEphemeral);\n                    pCx->seqCount = 0;\n                    pCx->cacheStatus = 0;\n                    rc = sqlite3BtreeClearTable(pCx->ub.pBtx, pCx->pgnoRoot, 0);\n                } else {\n                    pCx = allocateCursor(p, pOp->p1, pOp->p2, 0);\n                    if (pCx == 0)\n                        goto no_mem;\n                    pCx->isEphemeral = 1;\n                    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->ub.pBtx, 1 | 4 | pOp->p5, vfsFlags);\n                    if (rc == 0) {\n                        rc = sqlite3BtreeBeginTrans(pCx->ub.pBtx, 1, 0);\n                        if (rc == 0) {\n                            if ((pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo) != 0) {\n                                assert(pOp->p4type == (-8));\n                                rc = sqlite3BtreeCreateTable(pCx->ub.pBtx, &pCx->pgnoRoot, 2 | pOp->p5);\n                                if (rc == 0) {\n                                    assert(pCx->pgnoRoot == 1 + 1);\n                                    assert(pKeyInfo->db == db);\n                                    assert(pKeyInfo->enc == ((db)->enc));\n                                    rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 4, pKeyInfo, pCx->uc.pCursor);\n                                }\n                                pCx->isTable = 0;\n                            } else {\n                                pCx->pgnoRoot = 1;\n                                rc = sqlite3BtreeCursor(pCx->ub.pBtx, 1, 4, 0, pCx->uc.pCursor);\n                                pCx->isTable = 1;\n                            }\n                        }\n                        pCx->isOrdered = (pOp->p5 != 8);\n                        if (rc) {\n                            sqlite3BtreeClose(pCx->ub.pBtx);\n                        }\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pCx->nullRow = 1;\n                break;\n            }\n          case 119:\n            {\n                VdbeCursor *pCx;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p2 >= 0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p2, 1);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->pKeyInfo = pOp->p4.pKeyInfo;\n                assert(pCx->pKeyInfo->db == db);\n                assert(pCx->pKeyInfo->enc == ((db)->enc));\n                rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 120:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                if ((pC->seqCount++) == 0) {\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 121:\n            {\n                VdbeCursor *pCx;\n                assert(pOp->p1 >= 0);\n                assert(pOp->p3 >= 0);\n                pCx = allocateCursor(p, pOp->p1, pOp->p3, 3);\n                if (pCx == 0)\n                    goto no_mem;\n                pCx->nullRow = 1;\n                pCx->seekResult = pOp->p2;\n                pCx->isTable = 1;\n                pCx->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                assert(pOp->p5 == 0);\n                break;\n            }\n          case 122:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);\n                p->apCsr[pOp->p1] = 0;\n                break;\n            }\n          case 21:\n          case 22:\n          case 23:\n          case 24:\n            {\n                int res;\n                int oc;\n                VdbeCursor *pC;\n                UnpackedRecord r;\n                int nField;\n                i64 iKey;\n                int eqOnly;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p2 != 0);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(22 == 21 + 1);\n                assert(23 == 21 + 2);\n                assert(24 == 21 + 3);\n                assert(pC->isOrdered);\n                assert(pC->uc.pCursor != 0);\n                oc = pOp->opcode;\n                eqOnly = 0;\n                pC->nullRow = 0;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pC->isTable) {\n                    u16 flags3, newType;\n                    assert(sqlite3BtreeCursorHasHint(pC->uc.pCursor, 2) == 0 || (sqlite3Config.neverCorrupt == 0));\n                    pIn3 = &aMem[pOp->p3];\n                    flags3 = pIn3->flags;\n                    if ((flags3 & (4 | 8 | 32 | 2)) == 2) {\n                        applyNumericAffinity(pIn3, 0);\n                    }\n                    iKey = sqlite3VdbeIntValue(pIn3);\n                    newType = pIn3->flags;\n                    pIn3->flags = flags3;\n                    if ((newType & (4 | 32)) == 0) {\n                        int c;\n                        if ((newType & 8) == 0) {\n                            if ((newType & 1) || oc >= 23) {\n                                ;\n                                goto jump_to_p2;\n                            } else {\n                                rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                                if (rc != 0)\n                                    goto abort_due_to_error;\n                                goto seek_not_found;\n                            }\n                        }\n                        c = sqlite3IntFloatCompare(iKey, pIn3->u.r);\n                        if (c > 0) {\n                            assert(23 == (24 - 1));\n                            assert(21 == (22 - 1));\n                            assert((22 & 1) == (24 & 1));\n                            if ((oc & 1) == (24 & 1))\n                                oc--;\n                        } else if (c < 0) {\n                            assert(22 == (21 + 1));\n                            assert(24 == (23 + 1));\n                            assert((21 & 1) == (23 & 1));\n                            if ((oc & 1) == (21 & 1))\n                                oc++;\n                        }\n                    }\n                    rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)iKey, 0, &res);\n                    pC->movetoTarget = iKey;\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                } else {\n                    if (sqlite3BtreeCursorHasHint(pC->uc.pCursor, 2)) {\n                        eqOnly = 1;\n                        assert(pOp->opcode == 23 || pOp->opcode == 22);\n                        assert(pOp[1].opcode == 42 || pOp[1].opcode == 41);\n                        assert(pOp->opcode == 23 || pOp[1].opcode == 42);\n                        assert(pOp->opcode == 22 || pOp[1].opcode == 41);\n                        assert(pOp[1].p1 == pOp[0].p1);\n                        assert(pOp[1].p2 == pOp[0].p2);\n                        assert(pOp[1].p3 == pOp[0].p3);\n                        assert(pOp[1].p4.i == pOp[0].p4.i);\n                    }\n                    nField = pOp->p4.i;\n                    assert(pOp->p4type == (-3));\n                    assert(nField > 0);\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.nField = (u16)nField;\n                    r.default_rc = ((1 & (oc - 21)) ? -1 : +1);\n                    assert(oc != 24 || r.default_rc == -1);\n                    assert(oc != 22 || r.default_rc == -1);\n                    assert(oc != 23 || r.default_rc == +1);\n                    assert(oc != 21 || r.default_rc == +1);\n                    r.aMem = &aMem[pOp->p3];\n                    r.eqSeen = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &res);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (eqOnly && r.eqSeen == 0) {\n                        assert(res != 0);\n                        goto seek_not_found;\n                    }\n                }\n                if (oc >= 23) {\n                    assert(oc == 23 || oc == 24);\n                    if (res < 0 || (res == 0 && oc == 24)) {\n                        res = 0;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = 0;\n                    }\n                } else {\n                    assert(oc == 21 || oc == 22);\n                    if (res > 0 || (res == 0 && oc == 21)) {\n                        res = 0;\n                        rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);\n                        if (rc != 0) {\n                            if (rc == 101) {\n                                rc = 0;\n                                res = 1;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    } else {\n                        res = sqlite3BtreeEof(pC->uc.pCursor);\n                    }\n                }\n              seek_not_found:\n                assert(pOp->p2 > 0);\n                ;\n                if (res) {\n                    goto jump_to_p2;\n                } else if (eqOnly) {\n                    assert(pOp[1].opcode == 42 || pOp[1].opcode == 41);\n                    pOp++;\n                }\n                break;\n            }\n          case 124:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nStep;\n                UnpackedRecord r;\n                assert(pOp[1].opcode == 23);\n                assert(pOp->p2 >= (int)(pOp - aOp) + 2);\n                assert(pOp->p1 > 0);\n                pC = p->apCsr[pOp[1].p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(!pC->isTable);\n                if (!sqlite3BtreeCursorIsValidNN(pC->uc.pCursor)) {\n                    break;\n                }\n                nStep = pOp->p1;\n                assert(nStep >= 1);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp[1].p4.i;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp[1].p3];\n                res = 0;\n                while (1)\n                    {\n                        rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res > 0 && pOp->p5 == 0) {\n                          seekscan_search_fail:\n                            ;\n                            pOp++;\n                            goto jump_to_p2;\n                        }\n                        if (res >= 0) {\n                            ;\n                            goto jump_to_p2;\n                            break;\n                        }\n                        if (nStep <= 0) {\n                            ;\n                            break;\n                        }\n                        nStep--;\n                        rc = sqlite3BtreeNext(pC->uc.pCursor, 0);\n                        if (rc) {\n                            if (rc == 101) {\n                                rc = 0;\n                                goto seekscan_search_fail;\n                            } else {\n                                goto abort_due_to_error;\n                            }\n                        }\n                    }\n                break;\n            }\n          case 125:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pOp->p3 >= pOp->p2);\n                if (pC->seekHit < pOp->p2) {\n                    pC->seekHit = pOp->p2;\n                } else if (pC->seekHit > pOp->p3) {\n                    pC->seekHit = pOp->p3;\n                }\n                break;\n            }\n          case 25:\n            {\n                VdbeCursor *pCur;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pCur = p->apCsr[pOp->p1];\n                ;\n                if (pCur == 0 || pCur->nullRow) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                break;\n            }\n          case 26:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                if (pC->seekHit >= pOp->p4.i)\n                    break;\n            }\n          case 27:\n          case 28:\n          case 29:\n            {\n                int alreadyExists;\n                int ii;\n                VdbeCursor *pC;\n                UnpackedRecord *pIdxKey;\n                UnpackedRecord r;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p4type == (-3));\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                r.aMem = &aMem[pOp->p3];\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->isTable == 0);\n                r.nField = (u16)pOp->p4.i;\n                if (r.nField > 0) {\n                    r.pKeyInfo = pC->pKeyInfo;\n                    r.default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &pC->seekResult);\n                } else {\n                    assert(r.aMem->flags & 16);\n                    assert(pOp->opcode != 27);\n                    rc = (((r.aMem)->flags & 1024) ? sqlite3VdbeMemExpandBlob(r.aMem) : 0);\n                    assert(rc == 0 || rc == 7);\n                    if (rc)\n                        goto no_mem;\n                    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);\n                    if (pIdxKey == 0)\n                        goto no_mem;\n                    sqlite3VdbeRecordUnpack(pC->pKeyInfo, r.aMem->n, r.aMem->z, pIdxKey);\n                    pIdxKey->default_rc = 0;\n                    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, pIdxKey, &pC->seekResult);\n                    sqlite3DbFreeNN(db, pIdxKey);\n                }\n                if (rc != 0) {\n                    goto abort_due_to_error;\n                }\n                alreadyExists = (pC->seekResult == 0);\n                pC->nullRow = 1 - alreadyExists;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (pOp->opcode == 29) {\n                    ;\n                    if (alreadyExists)\n                        goto jump_to_p2;\n                } else {\n                    if (!alreadyExists) {\n                        ;\n                        goto jump_to_p2;\n                    }\n                    if (pOp->opcode == 27) {\n                        for (ii = 0; ii < r.nField; ii++) {\n                            if (r.aMem[ii].flags & 1) {\n                                ;\n                                goto jump_to_p2;\n                            }\n                        }\n                    }\n                    ;\n                    if (pOp->opcode == 26) {\n                        pC->seekHit = pOp->p4.i;\n                    }\n                }\n                break;\n            }\n          case 30:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                u64 iKey;\n                pIn3 = &aMem[pOp->p3];\n                ;\n                ;\n                ;\n                ;\n                if ((pIn3->flags & (4 | 32)) == 0) {\n                    Mem x = pIn3[0];\n                    applyAffinity(&x, 67, encoding);\n                    if ((x.flags & 4) == 0)\n                        goto jump_to_p2;\n                    iKey = x.u.i;\n                    goto notExistsWithKey;\n                }\n              case 31:\n                pIn3 = &aMem[pOp->p3];\n                assert((pIn3->flags & 4) != 0 || pOp->opcode == 30);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                iKey = pIn3->u.i;\n              notExistsWithKey:\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isTable);\n                assert(pC->eCurType == 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr != 0);\n                res = 0;\n                rc = sqlite3BtreeTableMoveto(pCrsr, iKey, 0, &res);\n                assert(rc == 0 || res == 0);\n                pC->movetoTarget = iKey;\n                pC->nullRow = 0;\n                pC->cacheStatus = 0;\n                pC->deferredMoveto = 0;\n                ;\n                pC->seekResult = res;\n                if (res != 0) {\n                    assert(rc == 0);\n                    if (pOp->p2 == 0) {\n                        rc = sqlite3CorruptError(94942);\n                    } else {\n                        goto jump_to_p2;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 126:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(p->apCsr[pOp->p1] != 0);\n                assert(p->apCsr[pOp->p1]->eCurType != 2);\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = p->apCsr[pOp->p1]->seqCount++;\n                break;\n            }\n          case 127:\n            {\n                i64 v;\n                VdbeCursor *pC;\n                int res;\n                int cnt;\n                Mem *pMem;\n                VdbeFrame *pFrame;\n                v = 0;\n                res = 0;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isTable);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                {\n                    assert(pC->isTable);\n                    if (!pC->useRandomRowid) {\n                        rc = sqlite3BtreeLast(pC->uc.pCursor, &res);\n                        if (rc != 0) {\n                            goto abort_due_to_error;\n                        }\n                        if (res) {\n                            v = 1;\n                        } else {\n                            assert(sqlite3BtreeCursorIsValid(pC->uc.pCursor));\n                            v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                            if (v >= (i64)((((u64)2147483647) << 32) | (u64)4294967295U)) {\n                                pC->useRandomRowid = 1;\n                            } else {\n                                v++;\n                            }\n                        }\n                    }\n                    if (pOp->p3) {\n                        assert(pOp->p3 > 0);\n                        if (p->pFrame) {\n                            for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                                ;\n                            assert(pOp->p3 <= pFrame->nMem);\n                            pMem = &pFrame->aMem[pOp->p3];\n                        } else {\n                            assert(pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                            pMem = &aMem[pOp->p3];\n                            ;\n                        }\n                        assert(memIsValid(pMem));\n                        ;\n                        sqlite3VdbeMemIntegerify(pMem);\n                        assert((pMem->flags & 4) != 0);\n                        if (pMem->u.i == (i64)((((u64)2147483647) << 32) | (u64)4294967295U) || pC->useRandomRowid) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        if (v < pMem->u.i + 1) {\n                            v = pMem->u.i + 1;\n                        }\n                        pMem->u.i = v;\n                    }\n                    if (pC->useRandomRowid) {\n                        assert(pOp->p3 == 0);\n                        cnt = 0;\n                        do {\n                            sqlite3_randomness(sizeof (v), &v);\n                            v &= ((i64)((((u64)2147483647) << 32) | (u64)4294967295U) >> 1);\n                            v++;\n                        } while (((rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)v, 0, &res)) == 0) && (res == 0) && (++cnt < 100));\n                        if (rc)\n                            goto abort_due_to_error;\n                        if (res == 0) {\n                            rc = 13;\n                            goto abort_due_to_error;\n                        }\n                        assert(v > 0);\n                    }\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 128:\n            {\n                Mem *pData;\n                Mem *pKey;\n                VdbeCursor *pC;\n                int seekResult;\n                const char *zDb;\n                Table *pTab;\n                BtreePayload x;\n                pData = &aMem[pOp->p2];\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(memIsValid(pData));\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->uc.pCursor != 0);\n                assert((pOp->p5 & 64) || pC->isTable);\n                assert(pOp->p4type == (-5) || pOp->p4type >= (-1));\n                ;\n                ;\n                pKey = &aMem[pOp->p3];\n                assert(pKey->flags & 4);\n                assert(memIsValid(pKey));\n                ;\n                x.nKey = pKey->u.i;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    assert(pC->iDb >= 0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    assert((pOp->p5 & 64) || (((pTab)->tabFlags & 128) == 0));\n                } else {\n                    pTab = 0;\n                    zDb = 0;\n                }\n                if (pOp->p5 & 1)\n                    p->nChange++;\n                if (pOp->p5 & 32)\n                    db->lastRowid = x.nKey;\n                assert((pData->flags & (16 | 2)) != 0 || pData->n == 0);\n                x.pData = pData->z;\n                x.nData = pData->n;\n                seekResult = ((pOp->p5 & 16) ? pC->seekResult : 0);\n                if (pData->flags & 1024) {\n                    x.nZero = pData->u.nZero;\n                } else {\n                    x.nZero = 0;\n                }\n                x.pKey = 0;\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), seekResult);\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pTab) {\n                    assert(db->xUpdateCallback != 0);\n                    assert(pTab->aCol != 0);\n                    db->xUpdateCallback(db->pUpdateArg, (pOp->p5 & 4) ? 23 : 18, zDb, pTab->zName, x.nKey);\n                }\n                break;\n            }\n          case 129:\n            {\n                VdbeCursor *pDest;\n                VdbeCursor *pSrc;\n                i64 iKey;\n                assert(pOp[1].opcode == 128 || pOp[1].opcode == 138);\n                assert(pOp[1].opcode == 128 || pOp->p3 == 0);\n                assert(pOp[1].opcode == 138 || pOp->p3 > 0);\n                assert(pOp[1].p5 & 128);\n                pDest = p->apCsr[pOp->p1];\n                pSrc = p->apCsr[pOp->p2];\n                iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;\n                rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 130:\n            {\n                VdbeCursor *pC;\n                const char *zDb;\n                Table *pTab;\n                int opflags;\n                opflags = pOp->p2;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->deferredMoveto == 0);\n                ;\n                if (pOp->p4type == (-5) && ((db)->xUpdateCallback)) {\n                    assert(pC->iDb >= 0);\n                    assert(pOp->p4.pTab != 0);\n                    zDb = db->aDb[pC->iDb].zDbSName;\n                    pTab = pOp->p4.pTab;\n                    if ((pOp->p5 & 2) != 0 && pC->isTable) {\n                        pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                    }\n                } else {\n                    zDb = 0;\n                    pTab = 0;\n                }\n                assert((pOp->p5 & ~(2 | 4)) == 0);\n                assert(2 == 2);\n                assert(4 == 4);\n                rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (opflags & 1) {\n                    p->nChange++;\n                    if (db->xUpdateCallback && (pTab != 0) && (((pTab)->tabFlags & 128) == 0)) {\n                        db->xUpdateCallback(db->pUpdateArg, 9, zDb, pTab->zName, pC->movetoTarget);\n                        assert(pC->iDb >= 0);\n                    }\n                }\n                break;\n            }\n          case 131:\n            {\n                sqlite3VdbeSetChanges(db, p->nChange);\n                p->nChange = 0;\n                break;\n            }\n          case 132:\n            {\n                VdbeCursor *pC;\n                int res;\n                int nKeyCol;\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                assert(pOp->p4type == (-3));\n                pIn3 = &aMem[pOp->p3];\n                nKeyCol = pOp->p4.i;\n                res = 0;\n                rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n            ;\n          case 133:\n            {\n                VdbeCursor *pC;\n                pOut = &aMem[pOp->p2];\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                rc = sqlite3VdbeSorterRowkey(pC, pOut);\n                assert(rc != 0 || (pOut->flags & 16));\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                if (rc)\n                    goto abort_due_to_error;\n                p->apCsr[pOp->p3]->cacheStatus = 0;\n                break;\n            }\n          case 134:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                u32 n;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                assert(((pC)->eCurType == 1) == 0);\n                assert(pC->nullRow == 0);\n                assert(pC->uc.pCursor != 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pC->deferredMoveto == 0);\n                assert(sqlite3BtreeCursorIsValid(pCrsr));\n                n = sqlite3BtreePayloadSize(pCrsr);\n                if (n > (u32)db->aLimit[0]) {\n                    goto too_big;\n                }\n                ;\n                rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut);\n                if (rc)\n                    goto abort_due_to_error;\n                if (!pOp->p3)\n                    if (((pOut)->flags & 16384) != 0 && sqlite3VdbeMemMakeWriteable(pOut)) {\n                        goto no_mem;\n                    }\n                ;\n                ;\n                ;\n                break;\n            }\n          case 135:\n            {\n                VdbeCursor *pC;\n                i64 v;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                pOut = out2Prerelease(p, pOp);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType != 3 || pC->nullRow);\n                if (pC->nullRow) {\n                    pOut->flags = 1;\n                    break;\n                } else if (pC->deferredMoveto) {\n                    v = pC->movetoTarget;\n                } else if (pC->eCurType == 2) {\n                    assert(pC->uc.pVCur != 0);\n                    pVtab = pC->uc.pVCur->pVtab;\n                    pModule = pVtab->pModule;\n                    assert(pModule->xRowid);\n                    rc = pModule->xRowid(pC->uc.pVCur, &v);\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else {\n                    assert(pC->eCurType == 0);\n                    assert(pC->uc.pCursor != 0);\n                    rc = sqlite3VdbeCursorRestore(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (pC->nullRow) {\n                        pOut->flags = 1;\n                        break;\n                    }\n                    v = sqlite3BtreeIntegerKey(pC->uc.pCursor);\n                }\n                pOut->u.i = v;\n                break;\n            }\n          case 136:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if (pC == 0) {\n                    pC = allocateCursor(p, pOp->p1, 1, 3);\n                    if (pC == 0)\n                        goto no_mem;\n                    pC->seekResult = 0;\n                    pC->isTable = 1;\n                    pC->noReuse = 1;\n                    pC->uc.pCursor = sqlite3BtreeFakeValidCursor();\n                }\n                pC->nullRow = 1;\n                pC->cacheStatus = 0;\n                if (pC->eCurType == 0) {\n                    assert(pC->uc.pCursor != 0);\n                    sqlite3BtreeClearCursor(pC->uc.pCursor);\n                }\n                break;\n            }\n          case 137:\n          case 32:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                pCrsr = pC->uc.pCursor;\n                res = 0;\n                assert(pCrsr != 0);\n                if (pOp->opcode == 137) {\n                    assert(pOp->p2 == 0);\n                    pC->seekResult = -1;\n                    if (sqlite3BtreeCursorIsValidNN(pCrsr)) {\n                        break;\n                    }\n                }\n                rc = sqlite3BtreeLast(pCrsr, &res);\n                pC->nullRow = (u8)res;\n                pC->deferredMoveto = 0;\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                if (pOp->p2 > 0) {\n                    ;\n                    if (res)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 33:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                i64 sz;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr);\n                rc = sqlite3BtreeFirst(pCrsr, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    sz = sqlite3BtreeRowCountEst(pCrsr);\n                    if ((sz >= 0) && sqlite3LogEst((u64)sz) < pOp->p3)\n                        res = 1;\n                }\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 34:\n          case 35:\n            {\n                p->aCounter[2]++;\n            }\n          case 36:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(((pC)->eCurType == 1) == (pOp->opcode == 34));\n                res = 1;\n                if (((pC)->eCurType == 1)) {\n                    rc = sqlite3VdbeSorterRewind(pC, &res);\n                } else {\n                    assert(pC->eCurType == 0);\n                    pCrsr = pC->uc.pCursor;\n                    assert(pCrsr);\n                    rc = sqlite3BtreeFirst(pCrsr, &res);\n                    pC->deferredMoveto = 0;\n                    pC->cacheStatus = 0;\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                pC->nullRow = (u8)res;\n                assert(pOp->p2 > 0 && pOp->p2 < p->nOp);\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 37:\n            {\n                VdbeCursor *pC;\n                pC = p->apCsr[pOp->p1];\n                assert(((pC)->eCurType == 1));\n                rc = sqlite3VdbeSorterNext(db, pC);\n                goto next_tail;\n              case 38:\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0 || pOp->p5 == 1 || pOp->p5 == 3);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->eCurType == 0);\n                assert(<recovery-expr>(pC) == 21 || <recovery-expr>(pC) == 22 || <recovery-expr>(pC) == 32 || <recovery-expr>(pC) == 26 || <recovery-expr>(pC) == 136);\n                rc = sqlite3BtreePrevious(pC->uc.pCursor, pOp->p3);\n                goto next_tail;\n              case 39:\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                assert(pOp->p5 == 0 || pOp->p5 == 1 || pOp->p5 == 3);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pC->eCurType == 0);\n                assert(<recovery-expr>(pC) == 24 || <recovery-expr>(pC) == 23 || <recovery-expr>(pC) == 36 || <recovery-expr>(pC) == 29 || <recovery-expr>(pC) == 136 || <recovery-expr>(pC) == 30 || <recovery-expr>(pC) == 26);\n                rc = sqlite3BtreeNext(pC->uc.pCursor, pOp->p3);\n              next_tail:\n                pC->cacheStatus = 0;\n                ;\n                if (rc == 0) {\n                    pC->nullRow = 0;\n                    p->aCounter[pOp->p5]++;\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                if (rc != 101)\n                    goto abort_due_to_error;\n                rc = 0;\n                pC->nullRow = 1;\n                goto check_for_interrupt;\n            }\n          case 138:\n            {\n                VdbeCursor *pC;\n                BtreePayload x;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                ;\n                assert(pC != 0);\n                assert(!((pC)->eCurType == 1));\n                pIn2 = &aMem[pOp->p2];\n                assert((pIn2->flags & 16) || (pOp->p5 & 128));\n                if (pOp->p5 & 1)\n                    p->nChange++;\n                assert(pC->eCurType == 0);\n                assert(pC->isTable == 0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                x.nKey = pIn2->n;\n                x.pKey = pIn2->z;\n                x.aMem = aMem + pOp->p3;\n                x.nMem = (u16)pOp->p4.i;\n                rc = sqlite3BtreeInsert(pC->uc.pCursor, &x, (pOp->p5 & (8 | 2 | 128)), ((pOp->p5 & 16) ? pC->seekResult : 0));\n                assert(pC->deferredMoveto == 0);\n                pC->cacheStatus = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 139:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                ;\n                assert(pC != 0);\n                assert(((pC)->eCurType == 1));\n                pIn2 = &aMem[pOp->p2];\n                assert(pIn2->flags & 16);\n                assert(pC->isTable == 0);\n                rc = (((pIn2)->flags & 1024) ? sqlite3VdbeMemExpandBlob(pIn2) : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = sqlite3VdbeSorterWrite(pC, pIn2);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 140:\n            {\n                VdbeCursor *pC;\n                BtCursor *pCrsr;\n                int res;\n                UnpackedRecord r;\n                assert(pOp->p3 > 0);\n                assert(pOp->p2 > 0 && pOp->p2 + pOp->p3 <= (p->nMem + 1 - p->nCursor) + 1);\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                ;\n                pCrsr = pC->uc.pCursor;\n                assert(pCrsr != 0);\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p3;\n                r.default_rc = 0;\n                r.aMem = &aMem[pOp->p2];\n                rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res);\n                if (rc)\n                    goto abort_due_to_error;\n                if (res == 0) {\n                    rc = sqlite3BtreeDelete(pCrsr, 4);\n                    if (rc)\n                        goto abort_due_to_error;\n                } else if (pOp->p5 && !sqlite3WritableSchema(db)) {\n                    rc = sqlite3ReportError((11 | (3 << 8)), 96007, \"index corruption\");\n                    goto abort_due_to_error;\n                }\n                assert(pC->deferredMoveto == 0);\n                pC->cacheStatus = 0;\n                pC->seekResult = 0;\n                break;\n            }\n          case 141:\n          case 142:\n            {\n                VdbeCursor *pC;\n                VdbeCursor *pTabCur;\n                i64 rowid;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0 || ((pC)->eCurType == 3 && (pC)->nullRow && (pC)->seekResult == 0));\n                assert(pC->uc.pCursor != 0);\n                assert(pC->isTable == 0 || ((pC)->eCurType == 3 && (pC)->nullRow && (pC)->seekResult == 0));\n                assert(pC->deferredMoveto == 0);\n                assert(!pC->nullRow || pOp->opcode == 142);\n                rc = sqlite3VdbeCursorRestore(pC);\n                if (rc != 0)\n                    goto abort_due_to_error;\n                if (!pC->nullRow) {\n                    rowid = 0;\n                    rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);\n                    if (rc != 0) {\n                        goto abort_due_to_error;\n                    }\n                    if (pOp->opcode == 141) {\n                        assert(pOp->p3 >= 0 && pOp->p3 < p->nCursor);\n                        pTabCur = p->apCsr[pOp->p3];\n                        assert(pTabCur != 0);\n                        assert(pTabCur->eCurType == 0);\n                        assert(pTabCur->uc.pCursor != 0);\n                        assert(pTabCur->isTable);\n                        pTabCur->nullRow = 0;\n                        pTabCur->movetoTarget = rowid;\n                        pTabCur->deferredMoveto = 1;\n                        pTabCur->cacheStatus = 0;\n                        assert(pOp->p4type == (-14) || pOp->p4.ai == 0);\n                        assert(!pTabCur->isEphemeral);\n                        pTabCur->ub.aAltMap = pOp->p4.ai;\n                        assert(!pC->isEphemeral);\n                        pTabCur->pAltCursor = pC;\n                    } else {\n                        pOut = out2Prerelease(p, pOp);\n                        pOut->u.i = rowid;\n                    }\n                } else {\n                    assert(pOp->opcode == 142);\n                    sqlite3VdbeMemSetNull(&aMem[pOp->p2]);\n                }\n                break;\n            }\n          case 143:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                if (pC->deferredMoveto) {\n                    rc = sqlite3VdbeFinishMoveto(pC);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 40:\n          case 41:\n          case 42:\n          case 45:\n            {\n                VdbeCursor *pC;\n                int res;\n                UnpackedRecord r;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->isOrdered);\n                assert(pC->eCurType == 0);\n                assert(pC->uc.pCursor != 0);\n                assert(pC->deferredMoveto == 0);\n                assert(pOp->p4type == (-3));\n                r.pKeyInfo = pC->pKeyInfo;\n                r.nField = (u16)pOp->p4.i;\n                if (pOp->opcode < 42) {\n                    assert(pOp->opcode == 40 || pOp->opcode == 41);\n                    r.default_rc = -1;\n                } else {\n                    assert(pOp->opcode == 45 || pOp->opcode == 42);\n                    r.default_rc = 0;\n                }\n                r.aMem = &aMem[pOp->p3];\n                {\n                    i64 nCellKey = 0;\n                    BtCursor *pCur;\n                    Mem m;\n                    assert(pC->eCurType == 0);\n                    pCur = pC->uc.pCursor;\n                    assert(sqlite3BtreeCursorIsValid(pCur));\n                    nCellKey = sqlite3BtreePayloadSize(pCur);\n                    if (nCellKey <= 0 || nCellKey > 2147483647) {\n                        rc = sqlite3CorruptError(96212);\n                        goto abort_due_to_error;\n                    }\n                    sqlite3VdbeMemInit(&m, db, 0);\n                    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n                    if (rc)\n                        goto abort_due_to_error;\n                    res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);\n                    sqlite3VdbeMemReleaseMalloc(&m);\n                }\n                assert((40 & 1) == (42 & 1) && (45 & 1) == (41 & 1));\n                if ((pOp->opcode & 1) == (42 & 1)) {\n                    assert(pOp->opcode == 40 || pOp->opcode == 42);\n                    res = -res;\n                } else {\n                    assert(pOp->opcode == 45 || pOp->opcode == 41);\n                    res++;\n                }\n                ;\n                assert(rc == 0);\n                if (res > 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 144:\n            {\n                int iMoved;\n                int iDb;\n                ;\n                assert(p->readOnly == 0);\n                assert(pOp->p1 > 1);\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                if (db->nVdbeRead > db->nVDestroy + 1) {\n                    rc = 6;\n                    p->errorAction = 2;\n                    goto abort_due_to_error;\n                } else {\n                    iDb = pOp->p3;\n                    assert((((p->btreeMask) & (((yDbMask)1) << (iDb))) != 0));\n                    iMoved = 0;\n                    rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);\n                    pOut->flags = 4;\n                    pOut->u.i = iMoved;\n                    if (rc)\n                        goto abort_due_to_error;\n                    if (iMoved != 0) {\n                        sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);\n                        assert(resetSchemaOnFault == 0 || resetSchemaOnFault == iDb + 1);\n                        resetSchemaOnFault = iDb + 1;\n                    }\n                }\n                break;\n            }\n          case 145:\n            {\n                i64 nChange;\n                ;\n                nChange = 0;\n                assert(p->readOnly == 0);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p2))) != 0));\n                rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, (u32)pOp->p1, &nChange);\n                if (pOp->p3) {\n                    p->nChange += nChange;\n                    if (pOp->p3 > 0) {\n                        assert(memIsValid(&aMem[pOp->p3]));\n                        ;\n                        aMem[pOp->p3].u.i += nChange;\n                    }\n                }\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 146:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                if (((pC)->eCurType == 1)) {\n                    sqlite3VdbeSorterReset(db, pC->uc.pSorter);\n                } else {\n                    assert(pC->eCurType == 0);\n                    assert(pC->isEphemeral);\n                    rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 147:\n            {\n                Pgno pgno;\n                Db *pDb;\n                ;\n                pOut = out2Prerelease(p, pOp);\n                pgno = 0;\n                assert(pOp->p3 == 1 || pOp->p3 == 2);\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pDb = &db->aDb[pOp->p1];\n                assert(pDb->pBt != 0);\n                rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, pOp->p3);\n                if (rc)\n                    goto abort_due_to_error;\n                pOut->u.i = pgno;\n                break;\n            }\n          case 148:\n            {\n                ;\n                db->nSqlExec++;\n                rc = sqlite3_exec(db, pOp->p4.z, 0, 0, 0);\n                db->nSqlExec--;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 149:\n            {\n                int iDb;\n                const char *zSchema;\n                char *zSql;\n                InitData initData;\n                iDb = pOp->p1;\n                assert(iDb >= 0 && iDb < db->nDb);\n                assert((((db)->aDb[iDb].pSchema->schemaFlags & (1)) == (1)) || db->mallocFailed || ((sqlite3Config.neverCorrupt == 0) && (db->flags & 134217728) != 0));\n                if (pOp->p4.z == 0) {\n                    sqlite3SchemaClear(db->aDb[iDb].pSchema);\n                    db->mDbFlags &= ~16;\n                    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, pOp->p5);\n                    db->mDbFlags |= 1;\n                    p->expired = 0;\n                } else {\n                    zSchema = \"sqlite_master\";\n                    initData.db = db;\n                    initData.iDb = iDb;\n                    initData.pzErrMsg = &p->zErrMsg;\n                    initData.mInitFlags = 0;\n                    initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);\n                    zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".%s WHERE %s ORDER BY rowid\", db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);\n                    if (zSql == 0) {\n                        rc = 7;\n                    } else {\n                        assert(db->init.busy == 0);\n                        db->init.busy = 1;\n                        initData.rc = 0;\n                        initData.nInitRow = 0;\n                        assert(!db->mallocFailed);\n                        rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n                        if (rc == 0)\n                            rc = initData.rc;\n                        if (rc == 0 && initData.nInitRow == 0) {\n                            rc = sqlite3CorruptError(96464);\n                        }\n                        sqlite3DbFreeNN(db, zSql);\n                        db->init.busy = 0;\n                    }\n                }\n                if (rc) {\n                    sqlite3ResetAllSchemasOfConnection(db);\n                    if (rc == 7) {\n                        goto no_mem;\n                    }\n                    goto abort_due_to_error;\n                }\n                break;\n            }\n          case 150:\n            {\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                rc = sqlite3AnalysisLoad(db, pOp->p1);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 151:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 152:\n            {\n                ;\n                sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 154:\n            {\n                ;\n                sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);\n                break;\n            }\n          case 155:\n            {\n                int nRoot;\n                Pgno *aRoot;\n                int nErr;\n                char *z;\n                Mem *pnErr;\n                assert(p->bIsReader);\n                nRoot = pOp->p2;\n                aRoot = pOp->p4.ai;\n                assert(nRoot > 0);\n                assert(aRoot[0] == (Pgno)nRoot);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pnErr = &aMem[pOp->p3];\n                assert((pnErr->flags & 4) != 0);\n                assert((pnErr->flags & (2 | 16)) == 0);\n                pIn1 = &aMem[pOp->p1];\n                assert(pOp->p5 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p5))) != 0));\n                z = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot, (int)pnErr->u.i + 1, &nErr);\n                sqlite3VdbeMemSetNull(pIn1);\n                if (nErr == 0) {\n                    assert(z == 0);\n                } else if (z == 0) {\n                    goto no_mem;\n                } else {\n                    pnErr->u.i -= nErr - 1;\n                    sqlite3VdbeMemSetStr(pIn1, z, -1, 1, sqlite3_free);\n                }\n                ;\n                sqlite3VdbeChangeEncoding(pIn1, encoding);\n                goto check_for_interrupt;\n            }\n          case 156:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn2 = &aMem[pOp->p2];\n                assert((pIn2->flags & 4) != 0);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                assert(sqlite3VdbeMemIsRowSet(pIn1));\n                sqlite3RowSetInsert((RowSet *)pIn1->z, pIn2->u.i);\n                break;\n            }\n          case 46:\n            {\n                i64 val;\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 16) == 0 || sqlite3VdbeMemIsRowSet(pIn1));\n                if ((pIn1->flags & 16) == 0 || sqlite3RowSetNext((RowSet *)pIn1->z, &val) == 0) {\n                    sqlite3VdbeMemSetNull(pIn1);\n                    ;\n                    goto jump_to_p2_and_check_for_interrupt;\n                } else {\n                    ;\n                    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);\n                }\n                goto check_for_interrupt;\n            }\n          case 47:\n            {\n                int iSet;\n                int exists;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                iSet = pOp->p4.i;\n                assert(pIn3->flags & 4);\n                if ((pIn1->flags & 16) == 0) {\n                    if (sqlite3VdbeMemSetRowSet(pIn1))\n                        goto no_mem;\n                }\n                assert(sqlite3VdbeMemIsRowSet(pIn1));\n                assert(pOp->p4type == (-3));\n                assert(iSet == -1 || iSet >= 0);\n                if (iSet) {\n                    exists = sqlite3RowSetTest((RowSet *)pIn1->z, iSet, pIn3->u.i);\n                    ;\n                    if (exists)\n                        goto jump_to_p2;\n                }\n                if (iSet >= 0) {\n                    sqlite3RowSetInsert((RowSet *)pIn1->z, pIn3->u.i);\n                }\n                break;\n            }\n          case 48:\n            {\n                int nMem;\n                int nByte;\n                Mem *pRt;\n                Mem *pMem;\n                Mem *pEnd;\n                VdbeFrame *pFrame;\n                SubProgram *pProgram;\n                void *t;\n                pProgram = pOp->p4.pProgram;\n                pRt = &aMem[pOp->p3];\n                assert(pProgram->nOp > 0);\n                if (pOp->p5) {\n                    t = pProgram->token;\n                    for (pFrame = p->pFrame; pFrame && pFrame->token != t; pFrame = pFrame->pParent)\n                        ;\n                    if (pFrame)\n                        break;\n                }\n                if (p->nFrame >= db->aLimit[10]) {\n                    rc = 1;\n                    sqlite3VdbeError(p, \"too many levels of trigger recursion\");\n                    goto abort_due_to_error;\n                }\n                if ((pRt->flags & 16) == 0) {\n                    nMem = pProgram->nMem + pProgram->nCsr;\n                    assert(nMem > 0);\n                    if (pProgram->nCsr == 0)\n                        nMem++;\n                    nByte = (((sizeof(VdbeFrame)) + 7) & ~7) + nMem * sizeof(Mem) + pProgram->nCsr * sizeof(VdbeCursor *) + (pProgram->nOp + 7) / 8;\n                    pFrame = sqlite3DbMallocZero(db, nByte);\n                    if (!pFrame) {\n                        goto no_mem;\n                    }\n                    sqlite3VdbeMemRelease(pRt);\n                    pRt->flags = 16 | 4096;\n                    pRt->z = (char *)pFrame;\n                    pRt->n = nByte;\n                    pRt->xDel = sqlite3VdbeFrameMemDel;\n                    pFrame->v = p;\n                    pFrame->nChildMem = nMem;\n                    pFrame->nChildCsr = pProgram->nCsr;\n                    pFrame->pc = (int)(pOp - aOp);\n                    pFrame->aMem = p->aMem;\n                    pFrame->nMem = p->nMem;\n                    pFrame->apCsr = p->apCsr;\n                    pFrame->nCursor = p->nCursor;\n                    pFrame->aOp = p->aOp;\n                    pFrame->nOp = p->nOp;\n                    pFrame->token = pProgram->token;\n                    pEnd = &((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)])[pFrame->nChildMem];\n                    for (pMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]); pMem != pEnd; pMem++) {\n                        pMem->flags = 0;\n                        pMem->db = db;\n                    }\n                } else {\n                    pFrame = (VdbeFrame *)pRt->z;\n                    assert(pRt->xDel == sqlite3VdbeFrameMemDel);\n                    assert(pProgram->nMem + pProgram->nCsr == pFrame->nChildMem || (pProgram->nCsr == 0 && pProgram->nMem + 1 == pFrame->nChildMem));\n                    assert(pProgram->nCsr == pFrame->nChildCsr);\n                    assert((int)(pOp - aOp) == pFrame->pc);\n                }\n                p->nFrame++;\n                pFrame->pParent = p->pFrame;\n                pFrame->lastRowid = db->lastRowid;\n                pFrame->nChange = p->nChange;\n                pFrame->nDbChange = p->db->nChange;\n                assert(pFrame->pAuxData == 0);\n                pFrame->pAuxData = p->pAuxData;\n                p->pAuxData = 0;\n                p->nChange = 0;\n                p->pFrame = pFrame;\n                p->aMem = aMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame)) + 7) & ~7)]);\n                p->nMem = pFrame->nChildMem;\n                p->nCursor = (u16)pFrame->nChildCsr;\n                p->apCsr = (VdbeCursor **)&aMem[p->nMem];\n                pFrame->aOnce = (u8 *)&p->apCsr[pProgram->nCsr];\n                memset(pFrame->aOnce, 0, (pProgram->nOp + 7) / 8);\n                p->aOp = aOp = pProgram->aOp;\n                p->nOp = pProgram->nOp;\n                pOp = &aOp[-1];\n                goto check_for_interrupt;\n            }\n          case 157:\n            {\n                VdbeFrame *pFrame;\n                Mem *pIn;\n                pOut = out2Prerelease(p, pOp);\n                pFrame = p->pFrame;\n                pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];\n                sqlite3VdbeMemShallowCopy(pOut, pIn, 16384);\n                break;\n            }\n          case 158:\n            {\n                if (db->flags & 524288) {\n                    db->nDeferredImmCons += pOp->p2;\n                } else if (pOp->p1) {\n                    db->nDeferredCons += pOp->p2;\n                } else {\n                    p->nFkConstraint += pOp->p2;\n                }\n                break;\n            }\n          case 49:\n            {\n                if (pOp->p1) {\n                    ;\n                    if (db->nDeferredCons == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                } else {\n                    ;\n                    if (p->nFkConstraint == 0 && db->nDeferredImmCons == 0)\n                        goto jump_to_p2;\n                }\n                break;\n            }\n          case 159:\n            {\n                VdbeFrame *pFrame;\n                if (p->pFrame) {\n                    for (pFrame = p->pFrame; pFrame->pParent; pFrame = pFrame->pParent)\n                        ;\n                    pIn1 = &pFrame->aMem[pOp->p1];\n                } else {\n                    pIn1 = &aMem[pOp->p1];\n                }\n                assert(memIsValid(pIn1));\n                sqlite3VdbeMemIntegerify(pIn1);\n                pIn2 = &aMem[pOp->p2];\n                sqlite3VdbeMemIntegerify(pIn2);\n                if (pIn1->u.i < pIn2->u.i) {\n                    pIn1->u.i = pIn2->u.i;\n                }\n                break;\n            }\n          case 59:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                ;\n                if (pIn1->u.i > 0) {\n                    pIn1->u.i -= pOp->p3;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 160:\n            {\n                i64 x;\n                pIn1 = &aMem[pOp->p1];\n                pIn3 = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                assert(pIn1->flags & 4);\n                assert(pIn3->flags & 4);\n                x = pIn1->u.i;\n                if (x <= 0 || sqlite3AddInt64(&x, pIn3->u.i > 0 ? pIn3->u.i : 0)) {\n                    pOut->u.i = -1;\n                } else {\n                    pOut->u.i = x;\n                }\n                break;\n            }\n          case 60:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                ;\n                if (pIn1->u.i) {\n                    if (pIn1->u.i > 0)\n                        pIn1->u.i--;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 61:\n            {\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 4);\n                if (pIn1->u.i > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))\n                    pIn1->u.i--;\n                ;\n                if (pIn1->u.i == 0)\n                    goto jump_to_p2;\n                break;\n            }\n          case 161:\n          case 162:\n            {\n                int n;\n                sqlite3_context *pCtx;\n                assert(pOp->p4type == (-7));\n                n = pOp->p5;\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                assert(n == 0 || (pOp->p2 > 0 && pOp->p2 + n <= (p->nMem + 1 - p->nCursor) + 1));\n                assert(pOp->p3 < pOp->p2 || pOp->p3 >= pOp->p2 + n);\n                pCtx = sqlite3DbMallocRawNN(db, n * sizeof(sqlite3_value *) + (sizeof (pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value *)));\n                if (pCtx == 0)\n                    goto no_mem;\n                pCtx->pMem = 0;\n                pCtx->pOut = (Mem *)&(pCtx->argv[n]);\n                sqlite3VdbeMemInit(pCtx->pOut, db, 1);\n                pCtx->pFunc = pOp->p4.pFunc;\n                pCtx->iOp = (int)(pOp - aOp);\n                pCtx->pVdbe = p;\n                pCtx->skipFlag = 0;\n                pCtx->isError = 0;\n                pCtx->enc = encoding;\n                pCtx->argc = n;\n                pOp->p4type = (-15);\n                pOp->p4.pCtx = pCtx;\n                assert(pOp->p1 == (pOp->opcode == 161));\n                pOp->opcode = 163;\n            }\n          case 163:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                Mem *pMem;\n                assert(pOp->p4type == (-15));\n                pCtx = pOp->p4.pCtx;\n                pMem = &aMem[pOp->p3];\n                if (pCtx->pMem != pMem) {\n                    pCtx->pMem = pMem;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                pMem->n++;\n                assert(pCtx->pOut->flags == 1);\n                assert(pCtx->isError == 0);\n                assert(pCtx->skipFlag == 0);\n                if (pOp->p1) {\n                    (pCtx->pFunc->xInverse)(pCtx, pCtx->argc, pCtx->argv);\n                } else\n                    (pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pCtx->pOut));\n                        rc = pCtx->isError;\n                    }\n                    if (pCtx->skipFlag) {\n                        assert(pOp[-1].opcode == 85);\n                        i = pOp[-1].p1;\n                        if (i)\n                            sqlite3VdbeMemSetInt64(&aMem[i], 1);\n                        pCtx->skipFlag = 0;\n                    }\n                    sqlite3VdbeMemRelease(pCtx->pOut);\n                    pCtx->pOut->flags = 1;\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                assert(pCtx->pOut->flags == 1);\n                assert(pCtx->skipFlag == 0);\n                break;\n            }\n          case 164:\n          case 165:\n            {\n                Mem *pMem;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                assert(pOp->p3 == 0 || pOp->opcode == 164);\n                pMem = &aMem[pOp->p1];\n                assert((pMem->flags & ~(1 | 32768)) == 0);\n                if (pOp->p3) {\n                    ;\n                    rc = sqlite3VdbeMemAggValue(pMem, &aMem[pOp->p3], pOp->p4.pFunc);\n                    pMem = &aMem[pOp->p3];\n                } else {\n                    rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);\n                }\n                if (rc) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pMem));\n                    goto abort_due_to_error;\n                }\n                sqlite3VdbeChangeEncoding(pMem, encoding);\n                ;\n                break;\n            }\n          case 3:\n            {\n                int i;\n                int aRes[3];\n                Mem *pMem;\n                assert(p->readOnly == 0);\n                aRes[0] = 0;\n                aRes[1] = aRes[2] = -1;\n                assert(pOp->p2 == 0 || pOp->p2 == 1 || pOp->p2 == 2 || pOp->p2 == 3);\n                rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);\n                if (rc) {\n                    if (rc != 5)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    aRes[0] = 1;\n                }\n                for (i = 0 , pMem = &aMem[pOp->p3]; i < 3; i++ , pMem++) {\n                    sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);\n                }\n                break;\n            }\n            ;\n          case 4:\n            {\n                Btree *pBt;\n                Pager *pPager;\n                int eNew;\n                int eOld;\n                const char *zFilename;\n                pOut = out2Prerelease(p, pOp);\n                eNew = pOp->p3;\n                assert(eNew == 0 || eNew == 3 || eNew == 1 || eNew == 2 || eNew == 4 || eNew == 5 || eNew == (-1));\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert(p->readOnly == 0);\n                pBt = db->aDb[pOp->p1].pBt;\n                pPager = sqlite3BtreePager(pBt);\n                eOld = sqlite3PagerGetJournalMode(pPager);\n                if (eNew == (-1))\n                    eNew = eOld;\n                assert(sqlite3BtreeHoldsMutex(pBt));\n                if (!sqlite3PagerOkToChangeJournalMode(pPager))\n                    eNew = eOld;\n                zFilename = sqlite3PagerFilename(pPager, 1);\n                if (eNew == 5 && (sqlite3Strlen30(zFilename) == 0 || !sqlite3PagerWalSupported(pPager))) {\n                    eNew = eOld;\n                }\n                if ((eNew != eOld) && (eOld == 5 || eNew == 5)) {\n                    if (!db->autoCommit || db->nVdbeRead > 1) {\n                        rc = 1;\n                        sqlite3VdbeError(p, \"cannot change %s wal mode from within a transaction\", (eNew == 5 ? \"into\" : \"out of\"));\n                        goto abort_due_to_error;\n                    } else {\n                        if (eOld == 5) {\n                            rc = sqlite3PagerCloseWal(pPager, db);\n                            if (rc == 0) {\n                                sqlite3PagerSetJournalMode(pPager, eNew);\n                            }\n                        } else if (eOld == 4) {\n                            sqlite3PagerSetJournalMode(pPager, 2);\n                        }\n                        assert(sqlite3BtreeTxnState(pBt) != 2);\n                        if (rc == 0) {\n                            rc = sqlite3BtreeSetVersion(pBt, (eNew == 5 ? 2 : 1));\n                        }\n                    }\n                }\n                if (rc)\n                    eNew = eOld;\n                eNew = sqlite3PagerSetJournalMode(pPager, eNew);\n                pOut->flags = 2 | 8192 | 512;\n                pOut->z = (char *)sqlite3JournalModename(eNew);\n                pOut->n = sqlite3Strlen30(pOut->z);\n                pOut->enc = 1;\n                sqlite3VdbeChangeEncoding(pOut, encoding);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n            ;\n          case 5:\n            {\n                assert(p->readOnly == 0);\n                rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1, pOp->p2 ? &aMem[pOp->p2] : 0);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 62:\n            {\n                Btree *pBt;\n                assert(pOp->p1 >= 0 && pOp->p1 < db->nDb);\n                assert((((p->btreeMask) & (((yDbMask)1) << (pOp->p1))) != 0));\n                assert(p->readOnly == 0);\n                pBt = db->aDb[pOp->p1].pBt;\n                rc = sqlite3BtreeIncrVacuum(pBt);\n                ;\n                if (rc) {\n                    if (rc != 101)\n                        goto abort_due_to_error;\n                    rc = 0;\n                    goto jump_to_p2;\n                }\n                break;\n            }\n          case 166:\n            {\n                assert(pOp->p2 == 0 || pOp->p2 == 1);\n                if (!pOp->p1) {\n                    sqlite3ExpirePreparedStatements(db, pOp->p2);\n                } else {\n                    p->expired = pOp->p2 + 1;\n                }\n                break;\n            }\n          case 167:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                sqlite3BtreeCursorPin(pC->uc.pCursor);\n                break;\n            }\n          case 168:\n            {\n                VdbeCursor *pC;\n                assert(pOp->p1 >= 0 && pOp->p1 < p->nCursor);\n                pC = p->apCsr[pOp->p1];\n                assert(pC != 0);\n                assert(pC->eCurType == 0);\n                sqlite3BtreeCursorUnpin(pC->uc.pCursor);\n                break;\n            }\n          case 169:\n            {\n                u8 isWriteLock = (u8)pOp->p3;\n                if (isWriteLock || 0 == (db->flags & 1024)) {\n                    int p1 = pOp->p1;\n                    assert(p1 >= 0 && p1 < db->nDb);\n                    assert((((p->btreeMask) & (((yDbMask)1) << (p1))) != 0));\n                    assert(isWriteLock == 0 || isWriteLock == 1);\n                    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);\n                    if (rc) {\n                        if ((rc & 255) == 6) {\n                            const char *z = pOp->p4.z;\n                            sqlite3VdbeError(p, \"database table is locked: %s\", z);\n                        }\n                        goto abort_due_to_error;\n                    }\n                }\n                break;\n            }\n          case 170:\n            {\n                VTable *pVTab;\n                pVTab = pOp->p4.pVtab;\n                rc = sqlite3VtabBegin(db, pVTab);\n                if (pVTab)\n                    sqlite3VtabImportErrmsg(p, pVTab->pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 171:\n            {\n                Mem sMem;\n                const char *zTab;\n                memset(&sMem, 0, sizeof (sMem));\n                sMem.db = db;\n                assert((aMem[pOp->p2].flags & 2) != 0);\n                assert((aMem[pOp->p2].flags & 8192) != 0);\n                rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);\n                assert(rc == 0);\n                zTab = (const char *)sqlite3_value_text(&sMem);\n                assert(zTab || db->mallocFailed);\n                if (zTab) {\n                    rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);\n                }\n                sqlite3VdbeMemRelease(&sMem);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 172:\n            {\n                db->nVDestroy++;\n                rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);\n                db->nVDestroy--;\n                assert(p->errorAction == 2 && p->usesStmtJournal);\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 173:\n            {\n                VdbeCursor *pCur;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                assert(p->bIsReader);\n                pCur = 0;\n                pVCur = 0;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                rc = pModule->xOpen(pVtab, &pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                pVCur->pVtab = pVtab;\n                pCur = allocateCursor(p, pOp->p1, 0, 2);\n                if (pCur) {\n                    pCur->uc.pVCur = pVCur;\n                    pVtab->nRef++;\n                } else {\n                    assert(db->mallocFailed);\n                    pModule->xClose(pVCur);\n                    goto no_mem;\n                }\n                break;\n            }\n          case 174:\n            {\n                VdbeCursor *pC;\n                ValueList *pRhs;\n                pC = p->apCsr[pOp->p1];\n                pRhs = sqlite3_malloc64(sizeof (*pRhs));\n                if (pRhs == 0)\n                    goto no_mem;\n                pRhs->pCsr = pC->uc.pCursor;\n                pRhs->pOut = &aMem[pOp->p3];\n                pOut = out2Prerelease(p, pOp);\n                pOut->flags = 1;\n                sqlite3VdbeMemSetPointer(pOut, pRhs, \"ValueList\", sqlite3_free);\n                break;\n            }\n          case 6:\n            {\n                int nArg;\n                int iQuery;\n                const sqlite3_module *pModule;\n                Mem *pQuery;\n                Mem *pArgc;\n                sqlite3_vtab_cursor *pVCur;\n                sqlite3_vtab *pVtab;\n                VdbeCursor *pCur;\n                int res;\n                int i;\n                Mem **apArg;\n                pQuery = &aMem[pOp->p3];\n                pArgc = &pQuery[1];\n                pCur = p->apCsr[pOp->p1];\n                assert(memIsValid(pQuery));\n                ;\n                assert(pCur != 0);\n                assert(pCur->eCurType == 2);\n                pVCur = pCur->uc.pVCur;\n                pVtab = pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert((pQuery->flags & 4) != 0 && pArgc->flags == 4);\n                nArg = (int)pArgc->u.i;\n                iQuery = (int)pQuery->u.i;\n                apArg = p->apArg;\n                for (i = 0; i < nArg; i++) {\n                    apArg[i] = &pArgc[i + 1];\n                }\n                rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pVCur);\n                pCur->nullRow = 0;\n                ;\n                if (res)\n                    goto jump_to_p2;\n                break;\n            }\n          case 175:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                Mem *pDest;\n                sqlite3_context sContext;\n                VdbeCursor *pCur = p->apCsr[pOp->p1];\n                assert(pCur != 0);\n                assert(pOp->p3 > 0 && pOp->p3 <= (p->nMem + 1 - p->nCursor));\n                pDest = &aMem[pOp->p3];\n                ;\n                if (pCur->nullRow) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    break;\n                }\n                assert(pCur->eCurType == 2);\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert(pModule->xColumn);\n                memset(&sContext, 0, sizeof (sContext));\n                sContext.pOut = pDest;\n                sContext.enc = encoding;\n                assert(pOp->p5 == 1 || pOp->p5 == 0);\n                if (pOp->p5 & 1) {\n                    sqlite3VdbeMemSetNull(pDest);\n                    pDest->flags = 1 | 1024;\n                    pDest->u.nZero = 0;\n                } else {\n                    ((pDest)->flags = ((pDest)->flags & ~(3519 | 1024)) | 1);\n                }\n                rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (sContext.isError > 0) {\n                    sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pDest));\n                    rc = sContext.isError;\n                }\n                sqlite3VdbeChangeEncoding(pDest, encoding);\n                ;\n                ;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 63:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int res;\n                VdbeCursor *pCur;\n                pCur = p->apCsr[pOp->p1];\n                assert(pCur != 0);\n                assert(pCur->eCurType == 2);\n                if (pCur->nullRow) {\n                    break;\n                }\n                pVtab = pCur->uc.pVCur->pVtab;\n                pModule = pVtab->pModule;\n                assert(pModule->xNext);\n                rc = pModule->xNext(pCur->uc.pVCur);\n                sqlite3VtabImportErrmsg(p, pVtab);\n                if (rc)\n                    goto abort_due_to_error;\n                res = pModule->xEof(pCur->uc.pVCur);\n                ;\n                if (!res) {\n                    goto jump_to_p2_and_check_for_interrupt;\n                }\n                goto check_for_interrupt;\n            }\n          case 176:\n            {\n                sqlite3_vtab *pVtab;\n                Mem *pName;\n                int isLegacy;\n                isLegacy = (db->flags & 67108864);\n                db->flags |= 67108864;\n                pVtab = pOp->p4.pVtab->pVtab;\n                pName = &aMem[pOp->p1];\n                assert(pVtab->pModule->xRename);\n                assert(memIsValid(pName));\n                assert(p->readOnly == 0);\n                ;\n                assert(pName->flags & 2);\n                ;\n                ;\n                ;\n                rc = sqlite3VdbeChangeEncoding(pName, 1);\n                if (rc)\n                    goto abort_due_to_error;\n                rc = pVtab->pModule->xRename(pVtab, pName->z);\n                if (isLegacy == 0)\n                    db->flags &= ~(u64)67108864;\n                sqlite3VtabImportErrmsg(p, pVtab);\n                p->expired = 0;\n                if (rc)\n                    goto abort_due_to_error;\n                break;\n            }\n          case 7:\n            {\n                sqlite3_vtab *pVtab;\n                const sqlite3_module *pModule;\n                int nArg;\n                int i;\n                sqlite_int64 rowid = 0;\n                Mem **apArg;\n                Mem *pX;\n                assert(pOp->p2 == 1 || pOp->p5 == 3 || pOp->p5 == 1 || pOp->p5 == 2 || pOp->p5 == 4 || pOp->p5 == 5);\n                assert(p->readOnly == 0);\n                if (db->mallocFailed)\n                    goto no_mem;\n                ;\n                pVtab = pOp->p4.pVtab->pVtab;\n                if (pVtab == 0 || (pVtab->pModule == 0)) {\n                    rc = 6;\n                    goto abort_due_to_error;\n                }\n                pModule = pVtab->pModule;\n                nArg = pOp->p2;\n                assert(pOp->p4type == (-11));\n                if ((pModule->xUpdate)) {\n                    u8 vtabOnConflict = db->vtabOnConflict;\n                    apArg = p->apArg;\n                    pX = &aMem[pOp->p3];\n                    for (i = 0; i < nArg; i++) {\n                        assert(memIsValid(pX));\n                        ;\n                        apArg[i] = pX;\n                        pX++;\n                    }\n                    db->vtabOnConflict = pOp->p5;\n                    rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);\n                    db->vtabOnConflict = vtabOnConflict;\n                    sqlite3VtabImportErrmsg(p, pVtab);\n                    if (rc == 0 && pOp->p1) {\n                        assert(nArg > 1 && apArg[0] && (apArg[0]->flags & 1));\n                        db->lastRowid = rowid;\n                    }\n                    if ((rc & 255) == 19 && pOp->p4.pVtab->bConstraint) {\n                        if (pOp->p5 == 4) {\n                            rc = 0;\n                        } else {\n                            p->errorAction = ((pOp->p5 == 5) ? 2 : pOp->p5);\n                        }\n                    } else {\n                        p->nChange++;\n                    }\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                break;\n            }\n          case 177:\n            {\n                pOut = out2Prerelease(p, pOp);\n                pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);\n                break;\n            }\n          case 178:\n            {\n                unsigned int newMax;\n                Btree *pBt;\n                pOut = out2Prerelease(p, pOp);\n                pBt = db->aDb[pOp->p1].pBt;\n                newMax = 0;\n                if (pOp->p3) {\n                    newMax = sqlite3BtreeLastPage(pBt);\n                    if (newMax < (unsigned int)pOp->p3)\n                        newMax = (unsigned int)pOp->p3;\n                }\n                pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);\n                break;\n            }\n          case 65:\n          case 66:\n            {\n                int i;\n                sqlite3_context *pCtx;\n                assert(pOp->p4type == (-15));\n                pCtx = pOp->p4.pCtx;\n                pOut = &aMem[pOp->p3];\n                if (pCtx->pOut != pOut) {\n                    pCtx->pVdbe = p;\n                    pCtx->pOut = pOut;\n                    pCtx->enc = encoding;\n                    for (i = pCtx->argc - 1; i >= 0; i--)\n                        pCtx->argv[i] = &aMem[pOp->p2 + i];\n                }\n                assert(pCtx->pVdbe == p);\n                ;\n                ((pOut)->flags = ((pOut)->flags & ~(3519 | 1024)) | 1);\n                assert(pCtx->isError == 0);\n                (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);\n                if (pCtx->isError) {\n                    if (pCtx->isError > 0) {\n                        sqlite3VdbeError(p, \"%s\", sqlite3_value_text(pOut));\n                        rc = pCtx->isError;\n                    }\n                    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);\n                    pCtx->isError = 0;\n                    if (rc)\n                        goto abort_due_to_error;\n                }\n                assert((pOut->flags & 2) == 0 || pOut->enc == encoding || db->mallocFailed);\n                assert(!sqlite3VdbeMemTooBig(pOut));\n                ;\n                ;\n                break;\n            }\n          case 179:\n            {\n                pIn1 = &aMem[pOp->p1];\n                pIn1->flags &= ~2048;\n                break;\n            }\n          case 180:\n            {\n                u64 h;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert(pIn1->flags & 16);\n                assert(pIn1->n > 0);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                pIn1->z[h / 8] |= 1 << (h & 7);\n                break;\n            }\n          case 64:\n            {\n                u64 h;\n                assert(pOp->p1 > 0 && pOp->p1 <= (p->nMem + 1 - p->nCursor));\n                pIn1 = &aMem[pOp->p1];\n                assert((pIn1->flags & 16) != 0);\n                assert(pIn1->n >= 1);\n                h = filterHash(aMem, pOp);\n                h %= pIn1->n;\n                if ((pIn1->z[h / 8] & (1 << (h & 7))) == 0) {\n                    ;\n                    p->aCounter[8]++;\n                    goto jump_to_p2;\n                } else {\n                    p->aCounter[7]++;\n                    ;\n                }\n                break;\n            }\n          case 181:\n          case 8:\n            {\n                int i;\n                char *zTrace;\n                assert(pOp->p4.z == 0 || strncmp(pOp->p4.z, \"-- \", 3) == 0);\n                assert(pOp == p->aOp || pOp->opcode == 181);\n                if ((db->mTrace & (1 | 64)) != 0 && p->minWriteFileFormat != 254 && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql)) != 0) {\n                    if (db->mTrace & 64) {\n                        char *z = sqlite3VdbeExpandSql(p, zTrace);\n                        db->trace.xLegacy(db->pTraceArg, z);\n                        sqlite3_free(z);\n                    } else if (db->nVdbeExec > 1) {\n                        char *z = sqlite3MPrintf(db, \"-- %s\", zTrace);\n                        (void)db->trace.xV2(1, db->pTraceArg, p, z);\n                        sqlite3DbFree(db, z);\n                    } else {\n                        (void)db->trace.xV2(1, db->pTraceArg, p, zTrace);\n                    }\n                }\n                assert(pOp->p2 > 0);\n                if (pOp->p1 >= sqlite3Config.iOnceResetThreshold) {\n                    if (pOp->opcode == 181)\n                        break;\n                    for (i = 1; i < p->nOp; i++) {\n                        if (p->aOp[i].opcode == 15)\n                            p->aOp[i].p1 = 0;\n                    }\n                    pOp->p1 = 0;\n                }\n                pOp->p1++;\n                p->aCounter[6]++;\n                goto jump_to_p2;\n            }\n          default:\n            {\n                assert(pOp->opcode == 184 || pOp->opcode == 185);\n                break;\n            }\n        }\n    }\n  abort_due_to_error:\n    if (db->mallocFailed) {\n        rc = 7;\n    } else if (rc == (10 | (33 << 8))) {\n        rc = sqlite3CorruptError(98408);\n    }\n    assert(rc);\n    if (p->zErrMsg == 0 && rc != (10 | (12 << 8))) {\n        sqlite3VdbeError(p, \"%s\", sqlite3ErrStr(rc));\n    }\n    p->rc = rc;\n    sqlite3SystemError(db, rc);\n    ;\n    sqlite3_log(rc, \"statement aborts at %d: [%s] %s\", (int)(pOp - aOp), p->zSql, p->zErrMsg);\n    if (p->eVdbeState == 2)\n        sqlite3VdbeHalt(p);\n    if (rc == (10 | (12 << 8)))\n        sqlite3OomFault(db);\n    if (rc == 11 && db->autoCommit == 0) {\n        db->flags |= ((u64)(2) << 32);\n    }\n    rc = 1;\n    if (resetSchemaOnFault > 0) {\n        sqlite3ResetOneSchema(db, resetSchemaOnFault - 1);\n    }\n  vdbe_return:\n    while (nVmStep >= nProgressLimit && db->xProgress != 0)\n        {\n            nProgressLimit += db->nProgressOps;\n            if (db->xProgress(db->pProgressArg)) {\n                nProgressLimit = (4294967295U | (((u64)4294967295U) << 32));\n                rc = 9;\n                goto abort_due_to_error;\n            }\n        }\n    p->aCounter[4] += (int)nVmStep;\n    sqlite3VdbeLeave(p);\n    return rc;\n  too_big:\n    sqlite3VdbeError(p, \"string or blob too big\");\n    rc = 18;\n    goto abort_due_to_error;\n  no_mem:\n    sqlite3OomFault(db);\n    sqlite3VdbeError(p, \"out of memory\");\n    rc = 7;\n    goto abort_due_to_error;\n  abort_due_to_interrupt:\n    assert(__atomic_load_n((&db->u1.isInterrupted), 0));\n    rc = 9;\n    goto abort_due_to_error;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#116045:1#detachFunc",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    const char *zName = (const char *)sqlite3_value_text(argv[0]);\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    int i;\n    Db *pDb = 0;\n    HashElem *pEntry;\n    char zErr[128];\n    (void)(NotUsed);\n    if (zName == 0)\n        zName = \"\";\n    for (i = 0; i < db->nDb; i++) {\n        pDb = &db->aDb[i];\n        if (pDb->pBt == 0)\n            continue;\n        if (sqlite3DbIsNamed(db, i, zName))\n            break;\n    }\n    if (i >= db->nDb) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"no such database: %s\", zName);\n        goto detach_error;\n    }\n    if (i < 2) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"cannot detach database %s\", zName);\n        goto detach_error;\n    }\n    if (sqlite3BtreeTxnState(pDb->pBt) != 0 || sqlite3BtreeIsInBackup(pDb->pBt)) {\n        sqlite3_snprintf(sizeof (zErr), zErr, \"database %s is locked\", zName);\n        goto detach_error;\n    }\n    assert(db->aDb[1].pSchema);\n    pEntry = ((&db->aDb[1].pSchema->trigHash)->first);\n    while (pEntry)\n        {\n            Trigger *pTrig = (Trigger *)((pEntry)->data);\n            if (pTrig->pTabSchema == pDb->pSchema) {\n                pTrig->pTabSchema = pTrig->pSchema;\n            }\n            pEntry = ((pEntry)->next);\n        }\n    sqlite3BtreeClose(pDb->pBt);\n    pDb->pBt = 0;\n    pDb->pSchema = 0;\n    sqlite3CollapseDatabaseArray(db);\n    return;\n  detach_error:\n    sqlite3_result_error(context, zErr, -1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#57614:1#pager_delsuper",
    "gotos": 8,
    "labels": 1,
    "body": "{\n    sqlite3_vfs *pVfs = pPager->pVfs;\n    int rc;\n    sqlite3_file *pSuper;\n    sqlite3_file *pJournal;\n    char *zSuperJournal = 0;\n    i64 nSuperJournal;\n    char *zJournal;\n    char *zSuperPtr;\n    char *zFree = 0;\n    int nSuperPtr;\n    pSuper = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);\n    if (!pSuper) {\n        rc = 7;\n        pJournal = 0;\n    } else {\n        const int flags = (1 | 16384);\n        rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, 0);\n        pJournal = (sqlite3_file *)(((u8 *)pSuper) + pVfs->szOsFile);\n    }\n    if (rc != 0)\n        goto delsuper_out;\n    rc = sqlite3OsFileSize(pSuper, &nSuperJournal);\n    if (rc != 0)\n        goto delsuper_out;\n    nSuperPtr = pVfs->mxPathname + 1;\n    zFree = sqlite3Malloc(4 + nSuperJournal + nSuperPtr + 2);\n    if (!zFree) {\n        rc = 7;\n        goto delsuper_out;\n    }\n    zFree[0] = zFree[1] = zFree[2] = zFree[3] = 0;\n    zSuperJournal = &zFree[4];\n    zSuperPtr = &zSuperJournal[nSuperJournal + 2];\n    rc = sqlite3OsRead(pSuper, zSuperJournal, (int)nSuperJournal, 0);\n    if (rc != 0)\n        goto delsuper_out;\n    zSuperJournal[nSuperJournal] = 0;\n    zSuperJournal[nSuperJournal + 1] = 0;\n    zJournal = zSuperJournal;\n    while ((zJournal - zSuperJournal) < nSuperJournal)\n        {\n            int exists;\n            rc = sqlite3OsAccess(pVfs, zJournal, 0, &exists);\n            if (rc != 0) {\n                goto delsuper_out;\n            }\n            if (exists) {\n                int c;\n                int flags = (1 | 16384);\n                rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);\n                if (rc != 0) {\n                    goto delsuper_out;\n                }\n                rc = readSuperJournal(pJournal, zSuperPtr, nSuperPtr);\n                sqlite3OsClose(pJournal);\n                if (rc != 0) {\n                    goto delsuper_out;\n                }\n                c = zSuperPtr[0] != 0 && strcmp(zSuperPtr, zSuper) == 0;\n                if (c) {\n                    goto delsuper_out;\n                }\n            }\n            zJournal += (sqlite3Strlen30(zJournal) + 1);\n        }\n    sqlite3OsClose(pSuper);\n    rc = sqlite3OsDelete(pVfs, zSuper, 0);\n  delsuper_out:\n    sqlite3_free(zFree);\n    if (pSuper) {\n        sqlite3OsClose(pSuper);\n        assert(!((pJournal)->pMethods != 0));\n        sqlite3_free(pSuper);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#88299:12#sqlite3_set_auxdata",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    AuxData *pAuxData;\n    Vdbe *pVdbe = pCtx->pVdbe;\n    assert(sqlite3_mutex_held(pCtx->pOut->db->mutex));\n    assert(pVdbe != 0);\n    for (pAuxData = pVdbe->pAuxData; pAuxData; pAuxData = pAuxData->pNextAux) {\n        if (pAuxData->iAuxArg == iArg && (pAuxData->iAuxOp == pCtx->iOp || iArg < 0)) {\n            break;\n        }\n    }\n    if (pAuxData == 0) {\n        pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));\n        if (!pAuxData)\n            goto failed;\n        pAuxData->iAuxOp = pCtx->iOp;\n        pAuxData->iAuxArg = iArg;\n        pAuxData->pNextAux = pVdbe->pAuxData;\n        pVdbe->pAuxData = pAuxData;\n        if (pCtx->isError == 0)\n            pCtx->isError = -1;\n    } else if (pAuxData->xDeleteAux) {\n        pAuxData->xDeleteAux(pAuxData->pAux);\n    }\n    pAuxData->pAux = pAux;\n    pAuxData->xDeleteAux = xDelete;\n    return;\n  failed:\n    if (xDelete) {\n        xDelete(pAux);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#113019:1#renameColumnFunc",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    RenameCtx sCtx;\n    const char *zSql = (const char *)sqlite3_value_text(argv[0]);\n    const char *zDb = (const char *)sqlite3_value_text(argv[3]);\n    const char *zTable = (const char *)sqlite3_value_text(argv[4]);\n    int iCol = sqlite3_value_int(argv[5]);\n    const char *zNew = (const char *)sqlite3_value_text(argv[6]);\n    int bQuote = sqlite3_value_int(argv[7]);\n    int bTemp = sqlite3_value_int(argv[8]);\n    const char *zOld;\n    int rc;\n    Parse sParse;\n    Walker sWalker;\n    Index *pIdx;\n    int i;\n    Table *pTab;\n    sqlite3_xauth xAuth = db->xAuth;\n    (void)(NotUsed);\n    if (zSql == 0)\n        return;\n    if (zTable == 0)\n        return;\n    if (zNew == 0)\n        return;\n    if (iCol < 0)\n        return;\n    sqlite3BtreeEnterAll(db);\n    pTab = sqlite3FindTable(db, zTable, zDb);\n    if (pTab == 0 || iCol >= pTab->nCol) {\n        sqlite3BtreeLeaveAll(db);\n        return;\n    }\n    zOld = pTab->aCol[iCol].zCnName;\n    memset(&sCtx, 0, sizeof (sCtx));\n    sCtx.iCol = ((iCol == pTab->iPKey) ? -1 : iCol);\n    db->xAuth = 0;\n    rc = renameParseSql(&sParse, zDb, db, zSql, bTemp);\n    memset(&sWalker, 0, sizeof(Walker));\n    sWalker.pParse = &sParse;\n    sWalker.xExprCallback = renameColumnExprCb;\n    sWalker.xSelectCallback = renameColumnSelectCb;\n    sWalker.u.pRename = &sCtx;\n    sCtx.pTab = pTab;\n    if (rc != 0)\n        goto renameColumnFunc_done;\n    if (sParse.pNewTable) {\n        if (((sParse.pNewTable)->eTabType == 2)) {\n            Select *pSelect = sParse.pNewTable->u.view.pSelect;\n            pSelect->selFlags &= ~2097152;\n            sParse.rc = 0;\n            sqlite3SelectPrep(&sParse, pSelect, 0);\n            rc = (db->mallocFailed ? 7 : sParse.rc);\n            if (rc == 0) {\n                sqlite3WalkSelect(&sWalker, pSelect);\n            }\n            if (rc != 0)\n                goto renameColumnFunc_done;\n        } else if (((sParse.pNewTable)->eTabType == 0)) {\n            int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);\n            FKey *pFKey;\n            sCtx.pTab = sParse.pNewTable;\n            if (bFKOnly == 0) {\n                if (iCol < sParse.pNewTable->nCol) {\n                    renameTokenFind(&sParse, &sCtx, (void *)sParse.pNewTable->aCol[iCol].zCnName);\n                }\n                if (sCtx.iCol < 0) {\n                    renameTokenFind(&sParse, &sCtx, (void *)&sParse.pNewTable->iPKey);\n                }\n                sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);\n                for (pIdx = sParse.pNewTable->pIndex; pIdx; pIdx = pIdx->pNext) {\n                    sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n                }\n                for (pIdx = sParse.pNewIndex; pIdx; pIdx = pIdx->pNext) {\n                    sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n                }\n                for (i = 0; i < sParse.pNewTable->nCol; i++) {\n                    Expr *pExpr = sqlite3ColumnExpr(sParse.pNewTable, &sParse.pNewTable->aCol[i]);\n                    sqlite3WalkExpr(&sWalker, pExpr);\n                }\n            }\n            assert(((sParse.pNewTable)->eTabType == 0));\n            for (pFKey = sParse.pNewTable->u.tab.pFKey; pFKey; pFKey = pFKey->pNextFrom) {\n                for (i = 0; i < pFKey->nCol; i++) {\n                    if (bFKOnly == 0 && pFKey->aCol[i].iFrom == iCol) {\n                        renameTokenFind(&sParse, &sCtx, (void *)&pFKey->aCol[i]);\n                    }\n                    if (0 == sqlite3_stricmp(pFKey->zTo, zTable) && 0 == sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)) {\n                        renameTokenFind(&sParse, &sCtx, (void *)pFKey->aCol[i].zCol);\n                    }\n                }\n            }\n        }\n    } else if (sParse.pNewIndex) {\n        sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);\n        sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n    } else {\n        TriggerStep *pStep;\n        rc = renameResolveTrigger(&sParse);\n        if (rc != 0)\n            goto renameColumnFunc_done;\n        for (pStep = sParse.pNewTrigger->step_list; pStep; pStep = pStep->pNext) {\n            if (pStep->zTarget) {\n                Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);\n                if (pTarget == pTab) {\n                    if (pStep->pUpsert) {\n                        ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;\n                        renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);\n                    }\n                    renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);\n                    renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);\n                }\n            }\n        }\n        if (sParse.pTriggerTab == pTab) {\n            renameColumnIdlistNames(&sParse, &sCtx, sParse.pNewTrigger->pColumns, zOld);\n        }\n        renameWalkTrigger(&sWalker, sParse.pNewTrigger);\n    }\n    assert(rc == 0);\n    rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);\n  renameColumnFunc_done:\n    if (rc != 0) {\n        if (rc == 1 && sqlite3WritableSchema(db)) {\n            sqlite3_result_value(context, argv[0]);\n        } else if (sParse.zErrMsg) {\n            renameColumnParseError(context, \"\", argv[1], argv[2], &sParse);\n        } else {\n            sqlite3_result_error_code(context, rc);\n        }\n    }\n    renameParseCleanup(&sParse);\n    renameTokenFree(db, sCtx.pList);\n    db->xAuth = xAuth;\n    sqlite3BtreeLeaveAll(db);\n}\n"
  },
  {
    "id": "#23:25#sqlite3AlterRenameColumn",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    sqlite3 *db = pParse->db;\n    Table *pTab;\n    int iCol;\n    char *zOld = 0;\n    char *zNew = 0;\n    const char *zDb;\n    int iSchema;\n    int bQuote;\n    pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n    if (!pTab)\n        goto exit_rename_column;\n    if (0 != isAlterableTable(pParse, pTab))\n        goto exit_rename_column;\n    if (0 != isRealTable(pParse, pTab, 0))\n        goto exit_rename_column;\n    iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iSchema >= 0);\n    zDb = db->aDb[iSchema].zDbSName;\n    if (sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0)) {\n        goto exit_rename_column;\n    }\n    zOld = sqlite3NameFromToken(db, pOld);\n    if (!zOld)\n        goto exit_rename_column;\n    for (iCol = 0; iCol < pTab->nCol; iCol++) {\n        if (0 == sqlite3StrICmp(pTab->aCol[iCol].zCnName, zOld))\n            break;\n    }\n    if (iCol == pTab->nCol) {\n        sqlite3ErrorMsg(pParse, \"no such column: \\\"%T\\\"\", pOld);\n        goto exit_rename_column;\n    }\n    renameTestSchema(pParse, zDb, iSchema == 1, \"\", 0);\n    renameFixQuotes(pParse, zDb, iSchema == 1);\n    sqlite3MayAbort(pParse);\n    zNew = sqlite3NameFromToken(db, pNew);\n    if (!zNew)\n        goto exit_rename_column;\n    assert(pNew->n > 0);\n    bQuote = (sqlite3CtypeMap[(unsigned char)(pNew->z[0])] & 128);\n    sqlite3NestedParse(pParse, \"UPDATE \\\"%w\\\".sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'  AND (type != 'index' OR tbl_name = %Q)\", zDb, zDb, pTab->zName, iCol, zNew, bQuote, iSchema == 1, pTab->zName);\n    sqlite3NestedParse(pParse, \"UPDATE temp.sqlite_master SET sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) WHERE type IN ('trigger', 'view')\", zDb, pTab->zName, iCol, zNew, bQuote);\n    renameReloadSchema(pParse, iSchema, 1);\n    renameTestSchema(pParse, zDb, iSchema == 1, \"after rename\", 1);\n  exit_rename_column:\n    sqlite3SrcListDelete(db, pSrc);\n    sqlite3DbFree(db, zOld);\n    sqlite3DbFree(db, zNew);\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#86779:1#vdbeRecordCompareString",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    const u8 *aKey1 = (const u8 *)pKey1;\n    int serial_type;\n    int res;\n    assert(pPKey2->aMem[0].flags & 2);\n    assert(pPKey2->aMem[0].n == pPKey2->n);\n    assert(pPKey2->aMem[0].z == pPKey2->u.z);\n    ;\n    serial_type = (signed char)(aKey1[1]);\n  vrcs_restart:\n    if (serial_type < 12) {\n        if (serial_type < 0) {\n            sqlite3GetVarint32(&aKey1[1], (u32 *)&serial_type);\n            if (serial_type >= 12)\n                goto vrcs_restart;\n            assert((sqlite3Config.neverCorrupt == 0));\n        }\n        res = pPKey2->r1;\n    } else if (!(serial_type & 1)) {\n        res = pPKey2->r2;\n    } else {\n        int nCmp;\n        int nStr;\n        int szHdr = aKey1[0];\n        nStr = (serial_type - 12) / 2;\n        if ((szHdr + nStr) > nKey1) {\n            pPKey2->errCode = (u8)sqlite3CorruptError(86810);\n            return 0;\n        }\n        nCmp = ((pPKey2->n) < (nStr) ? (pPKey2->n) : (nStr));\n        res = memcmp(&aKey1[szHdr], pPKey2->u.z, nCmp);\n        if (res > 0) {\n            res = pPKey2->r2;\n        } else if (res < 0) {\n            res = pPKey2->r1;\n        } else {\n            res = nStr - pPKey2->n;\n            if (res == 0) {\n                if (pPKey2->nField > 1) {\n                    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);\n                } else {\n                    res = pPKey2->default_rc;\n                    pPKey2->eqSeen = 1;\n                }\n            } else if (res > 0) {\n                res = pPKey2->r2;\n            } else {\n                res = pPKey2->r1;\n            }\n        }\n    }\n    assert(vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res) || (sqlite3Config.neverCorrupt == 0) || pPKey2->pKeyInfo->db->mallocFailed);\n    return res;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#71246:1#lockBtree",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    int rc;\n    MemPage *pPage1;\n    u32 nPage;\n    u32 nPageFile = 0;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(pBt->pPage1 == 0);\n    rc = sqlite3PagerSharedLock(pBt->pPager);\n    if (rc != 0)\n        return rc;\n    rc = btreeGetPage(pBt, 1, &pPage1, 0);\n    if (rc != 0)\n        return rc;\n    nPage = sqlite3Get4byte(28 + (u8 *)pPage1->aData);\n    sqlite3PagerPagecount(pBt->pPager, (int *)&nPageFile);\n    if (nPage == 0 || memcmp(24 + (u8 *)pPage1->aData, 92 + (u8 *)pPage1->aData, 4) != 0) {\n        nPage = nPageFile;\n    }\n    if ((pBt->db->flags & 33554432) != 0) {\n        nPage = 0;\n    }\n    if (nPage > 0) {\n        u32 pageSize;\n        u32 usableSize;\n        u8 *page1 = pPage1->aData;\n        rc = 26;\n        if (memcmp(page1, zMagicHeader, 16) != 0) {\n            goto page1_init_failed;\n        }\n        if (page1[18] > 2) {\n            pBt->btsFlags |= 1;\n        }\n        if (page1[19] > 2) {\n            goto page1_init_failed;\n        }\n        if (page1[19] == 2 && (pBt->btsFlags & 32) == 0) {\n            int isOpen = 0;\n            rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);\n            if (rc != 0) {\n                goto page1_init_failed;\n            } else {\n                ;\n                if (isOpen == 0) {\n                    releasePageOne(pPage1);\n                    return 0;\n                }\n            }\n            rc = 26;\n        } else {\n            ;\n        }\n        if (memcmp(&page1[21], \"@  \", 3) != 0) {\n            goto page1_init_failed;\n        }\n        pageSize = (page1[16] << 8) | (page1[17] << 16);\n        if (((pageSize - 1) & pageSize) != 0 || pageSize > 65536 || pageSize <= 256) {\n            goto page1_init_failed;\n        }\n        pBt->btsFlags |= 2;\n        assert((pageSize & 7) == 0);\n        usableSize = pageSize - page1[20];\n        if ((u32)pageSize != pBt->pageSize) {\n            releasePageOne(pPage1);\n            pBt->usableSize = usableSize;\n            pBt->pageSize = pageSize;\n            freeTempSpace(pBt);\n            rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, pageSize - usableSize);\n            return rc;\n        }\n        if (nPage > nPageFile) {\n            if (sqlite3WritableSchema(pBt->db) == 0) {\n                rc = sqlite3CorruptError(71371);\n                goto page1_init_failed;\n            } else {\n                nPage = nPageFile;\n            }\n        }\n        if (usableSize < 480) {\n            goto page1_init_failed;\n        }\n        pBt->pageSize = pageSize;\n        pBt->usableSize = usableSize;\n        pBt->autoVacuum = (sqlite3Get4byte(&page1[36 + 4 * 4]) ? 1 : 0);\n        pBt->incrVacuum = (sqlite3Get4byte(&page1[36 + 7 * 4]) ? 1 : 0);\n    }\n    pBt->maxLocal = (u16)((pBt->usableSize - 12) * 64 / 255 - 23);\n    pBt->minLocal = (u16)((pBt->usableSize - 12) * 32 / 255 - 23);\n    pBt->maxLeaf = (u16)(pBt->usableSize - 35);\n    pBt->minLeaf = (u16)((pBt->usableSize - 12) * 32 / 255 - 23);\n    if (pBt->maxLocal > 127) {\n        pBt->max1bytePayload = 127;\n    } else {\n        pBt->max1bytePayload = (u8)pBt->maxLocal;\n    }\n    assert(pBt->maxLeaf + 23 <= ((int)(pBt->pageSize - 8)));\n    pBt->pPage1 = pPage1;\n    pBt->nPage = nPage;\n    return 0;\n  page1_init_failed:\n    releasePageOne(pPage1);\n    pBt->pPage1 = 0;\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeIdxRowid",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    i64 nCellKey = 0;\n    int rc;\n    u32 szHdr;\n    u32 typeRowid;\n    u32 lenRowid;\n    Mem m, v;\n    assert(sqlite3BtreeCursorIsValid(pCur));\n    nCellKey = sqlite3BtreePayloadSize(pCur);\n    assert((nCellKey & ((((u64)1) << 32) - 1)) == (u64)nCellKey);\n    sqlite3VdbeMemInit(&m, db, 0);\n    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);\n    if (rc) {\n        return rc;\n    }\n    szHdr = (u32)*((u8 *)m.z);\n    if (szHdr >= 128)\n        sqlite3GetVarint32(((u8 *)m.z), (u32 *)&(szHdr));\n    ;\n    ;\n    ;\n    assert(m.n >= 0);\n    if ((szHdr < 3 || szHdr > (unsigned int)m.n)) {\n        goto idx_rowid_corruption;\n    }\n    typeRowid = (u32)*((u8 *)&m.z[szHdr - 1]);\n    if (typeRowid >= 128)\n        sqlite3GetVarint32(((u8 *)&m.z[szHdr - 1]), (u32 *)&(typeRowid));\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    ;\n    if ((typeRowid < 1 || typeRowid > 9 || typeRowid == 7)) {\n        goto idx_rowid_corruption;\n    }\n    lenRowid = sqlite3SmallTypeSizes[typeRowid];\n    ;\n    if (((u32)m.n < szHdr + lenRowid)) {\n        goto idx_rowid_corruption;\n    }\n    sqlite3VdbeSerialGet((u8 *)&m.z[m.n - lenRowid], typeRowid, &v);\n    *rowid = v.u.i;\n    sqlite3VdbeMemReleaseMalloc(&m);\n    return 0;\n  idx_rowid_corruption:\n    ;\n    sqlite3VdbeMemReleaseMalloc(&m);\n    return sqlite3CorruptError(86968);\n}\n"
  },
  {
    "id": "#23:25#sqlite3InitOne",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    int rc;\n    int i;\n    int size;\n    Db *pDb;\n    const char *azArg[6];\n    int meta[5];\n    InitData initData;\n    const char *zSchemaTabName;\n    int openedTransaction = 0;\n    int mask = ((db->mDbFlags & 64) | ~64);\n    assert((db->mDbFlags & 16) == 0);\n    assert(iDb >= 0 && iDb < db->nDb);\n    assert(db->aDb[iDb].pSchema);\n    assert(sqlite3_mutex_held(db->mutex));\n    assert(iDb == 1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt));\n    db->init.busy = 1;\n    azArg[0] = \"table\";\n    azArg[1] = zSchemaTabName = ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\");\n    azArg[2] = azArg[1];\n    azArg[3] = \"1\";\n    azArg[4] = \"CREATE TABLE x(type text,name text,tbl_name text,rootpage int,sql text)\";\n    azArg[5] = 0;\n    initData.db = db;\n    initData.iDb = iDb;\n    initData.rc = 0;\n    initData.pzErrMsg = pzErrMsg;\n    initData.mInitFlags = mFlags;\n    initData.nInitRow = 0;\n    initData.mxPage = 0;\n    sqlite3InitCallback(&initData, 5, (char **)azArg, 0);\n    db->mDbFlags &= mask;\n    if (initData.rc) {\n        rc = initData.rc;\n        goto error_out;\n    }\n    pDb = &db->aDb[iDb];\n    if (pDb->pBt == 0) {\n        assert(iDb == 1);\n        (db)->aDb[1].pSchema->schemaFlags |= (1);\n        rc = 0;\n        goto error_out;\n    }\n    sqlite3BtreeEnter(pDb->pBt);\n    if (sqlite3BtreeTxnState(pDb->pBt) == 0) {\n        rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, 0);\n        if (rc != 0) {\n            sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));\n            goto initone_error_out;\n        }\n        openedTransaction = 1;\n    }\n    for (i = 0; i < ((int)(sizeof (meta) / sizeof (meta[0]))); i++) {\n        sqlite3BtreeGetMeta(pDb->pBt, i + 1, (u32 *)&meta[i]);\n    }\n    if ((db->flags & 33554432) != 0) {\n        memset(meta, 0, sizeof (meta));\n    }\n    pDb->pSchema->schema_cookie = meta[1 - 1];\n    if (meta[5 - 1]) {\n        if (iDb == 0 && (db->mDbFlags & 64) == 0) {\n            u8 encoding;\n            encoding = (u8)meta[5 - 1] & 3;\n            if (encoding == 0)\n                encoding = 1;\n            sqlite3SetTextEncoding(db, encoding);\n        } else {\n            if ((meta[5 - 1] & 3) != ((db)->enc)) {\n                sqlite3SetString(pzErrMsg, db, \"attached databases must use the same text encoding as main database\");\n                rc = 1;\n                goto initone_error_out;\n            }\n        }\n    }\n    pDb->pSchema->enc = ((db)->enc);\n    if (pDb->pSchema->cache_size == 0) {\n        size = sqlite3AbsInt32(meta[3 - 1]);\n        if (size == 0) {\n            size = -2000;\n        }\n        pDb->pSchema->cache_size = size;\n        sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    pDb->pSchema->file_format = (u8)meta[2 - 1];\n    if (pDb->pSchema->file_format == 0) {\n        pDb->pSchema->file_format = 1;\n    }\n    if (pDb->pSchema->file_format > 4) {\n        sqlite3SetString(pzErrMsg, db, \"unsupported file format\");\n        rc = 1;\n        goto initone_error_out;\n    }\n    if (iDb == 0 && meta[2 - 1] >= 4) {\n        db->flags &= ~(u64)2;\n    }\n    assert(db->init.busy);\n    initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);\n    {\n        char *zSql;\n        zSql = sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".%s ORDER BY rowid\", db->aDb[iDb].zDbSName, zSchemaTabName);\n        {\n            sqlite3_xauth xAuth;\n            xAuth = db->xAuth;\n            db->xAuth = 0;\n            rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n            db->xAuth = xAuth;\n        }\n        if (rc == 0)\n            rc = initData.rc;\n        sqlite3DbFree(db, zSql);\n        if (rc == 0) {\n            sqlite3AnalysisLoad(db, iDb);\n        }\n    }\n    assert(pDb == &(db->aDb[iDb]));\n    if (db->mallocFailed) {\n        rc = 7;\n        sqlite3ResetAllSchemasOfConnection(db);\n        pDb = &db->aDb[iDb];\n    } else if (rc == 0 || ((db->flags & 134217728) && rc != 7)) {\n        (db)->aDb[iDb].pSchema->schemaFlags |= (1);\n        rc = 0;\n    }\n  initone_error_out:\n    if (openedTransaction) {\n        sqlite3BtreeCommit(pDb->pBt);\n    }\n    sqlite3BtreeLeave(pDb->pBt);\n  error_out:\n    if (rc) {\n        if (rc == 7 || rc == (10 | (12 << 8))) {\n            sqlite3OomFault(db);\n        }\n        sqlite3ResetOneSchema(db, iDb);\n    }\n    db->init.busy = 0;\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#78461:1#checkTreePage",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    MemPage *pPage = 0;\n    int i;\n    int rc;\n    int depth = -1, d2;\n    int pgno;\n    int nFrag;\n    int hdr;\n    int cellStart;\n    int nCell;\n    int doCoverageCheck = 1;\n    int keyCanBeEqual = 1;\n    u8 *data;\n    u8 *pCell;\n    u8 *pCellIdx;\n    BtShared *pBt;\n    u32 pc;\n    u32 usableSize;\n    u32 contentOffset;\n    u32 *heap = 0;\n    u32 x, prev = 0;\n    const char *saved_zPfx = pCheck->zPfx;\n    int saved_v1 = pCheck->v1;\n    int saved_v2 = pCheck->v2;\n    u8 savedIsInit = 0;\n    pBt = pCheck->pBt;\n    usableSize = pBt->usableSize;\n    if (iPage == 0)\n        return 0;\n    if (checkRef(pCheck, iPage))\n        return 0;\n    pCheck->zPfx = \"Page %u: \";\n    pCheck->v1 = iPage;\n    if ((rc = btreeGetPage(pBt, iPage, &pPage, 0)) != 0) {\n        checkAppendMsg(pCheck, \"unable to get the page. error code=%d\", rc);\n        goto end_of_check;\n    }\n    savedIsInit = pPage->isInit;\n    pPage->isInit = 0;\n    if ((rc = btreeInitPage(pPage)) != 0) {\n        assert(rc == 11);\n        checkAppendMsg(pCheck, \"btreeInitPage() returns error code %d\", rc);\n        goto end_of_check;\n    }\n    if ((rc = btreeComputeFreeSpace(pPage)) != 0) {\n        assert(rc == 11);\n        checkAppendMsg(pCheck, \"free space corruption\", rc);\n        goto end_of_check;\n    }\n    data = pPage->aData;\n    hdr = pPage->hdrOffset;\n    pCheck->zPfx = \"On tree page %u cell %d: \";\n    contentOffset = (((((int)((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1])) - 1) & 65535) + 1);\n    assert(contentOffset <= usableSize);\n    nCell = ((&data[hdr + 3])[0] << 8 | (&data[hdr + 3])[1]);\n    assert(pPage->nCell == nCell);\n    cellStart = hdr + 12 - 4 * pPage->leaf;\n    assert(pPage->aCellIdx == &data[cellStart]);\n    pCellIdx = &data[cellStart + 2 * (nCell - 1)];\n    if (!pPage->leaf) {\n        pgno = sqlite3Get4byte(&data[hdr + 8]);\n        if (pBt->autoVacuum) {\n            pCheck->zPfx = \"On page %u at right child: \";\n            checkPtrmap(pCheck, pgno, 5, iPage);\n        }\n        depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n        keyCanBeEqual = 0;\n    } else {\n        heap = pCheck->heap;\n        heap[0] = 0;\n    }\n    for (i = nCell - 1; i >= 0 && pCheck->mxErr; i--) {\n        CellInfo info;\n        pCheck->v2 = i;\n        assert(pCellIdx == &data[cellStart + i * 2]);\n        pc = ((pCellIdx)[0] << 8 | (pCellIdx)[1]);\n        pCellIdx -= 2;\n        if (pc < contentOffset || pc > usableSize - 4) {\n            checkAppendMsg(pCheck, \"Offset %d out of range %d..%d\", pc, contentOffset, usableSize - 4);\n            doCoverageCheck = 0;\n            continue;\n        }\n        pCell = &data[pc];\n        pPage->xParseCell(pPage, pCell, &info);\n        if (pc + info.nSize > usableSize) {\n            checkAppendMsg(pCheck, \"Extends off end of page\");\n            doCoverageCheck = 0;\n            continue;\n        }\n        if (pPage->intKey) {\n            if (keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey)) {\n                checkAppendMsg(pCheck, \"Rowid %lld out of order\", info.nKey);\n            }\n            maxKey = info.nKey;\n            keyCanBeEqual = 0;\n        }\n        if (info.nPayload > info.nLocal) {\n            u32 nPage;\n            Pgno pgnoOvfl;\n            assert(pc + info.nSize - 4 <= usableSize);\n            nPage = (info.nPayload - info.nLocal + usableSize - 5) / (usableSize - 4);\n            pgnoOvfl = sqlite3Get4byte(&pCell[info.nSize - 4]);\n            if (pBt->autoVacuum) {\n                checkPtrmap(pCheck, pgnoOvfl, 3, iPage);\n            }\n            checkList(pCheck, 0, pgnoOvfl, nPage);\n        }\n        if (!pPage->leaf) {\n            pgno = sqlite3Get4byte(pCell);\n            if (pBt->autoVacuum) {\n                checkPtrmap(pCheck, pgno, 5, iPage);\n            }\n            d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n            keyCanBeEqual = 0;\n            if (d2 != depth) {\n                checkAppendMsg(pCheck, \"Child page depth differs\");\n                depth = d2;\n            }\n        } else {\n            btreeHeapInsert(heap, (pc << 16) | (pc + info.nSize - 1));\n        }\n    }\n    *piMinKey = maxKey;\n    pCheck->zPfx = 0;\n    if (doCoverageCheck && pCheck->mxErr > 0) {\n        if (!pPage->leaf) {\n            heap = pCheck->heap;\n            heap[0] = 0;\n            for (i = nCell - 1; i >= 0; i--) {\n                u32 size;\n                pc = ((&data[cellStart + i * 2])[0] << 8 | (&data[cellStart + i * 2])[1]);\n                size = pPage->xCellSize(pPage, &data[pc]);\n                btreeHeapInsert(heap, (pc << 16) | (pc + size - 1));\n            }\n        }\n        i = ((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);\n        while (i > 0)\n            {\n                int size, j;\n                assert((u32)i <= usableSize - 4);\n                size = ((&data[i + 2])[0] << 8 | (&data[i + 2])[1]);\n                assert((u32)(i + size) <= usableSize);\n                btreeHeapInsert(heap, (((u32)i) << 16) | (i + size - 1));\n                j = ((&data[i])[0] << 8 | (&data[i])[1]);\n                assert(j == 0 || j > i + size);\n                assert((u32)j <= usableSize - 4);\n                i = j;\n            }\n        nFrag = 0;\n        prev = contentOffset - 1;\n        while (btreeHeapPull(heap, &x))\n            {\n                if ((prev & 65535) >= (x >> 16)) {\n                    checkAppendMsg(pCheck, \"Multiple uses for byte %u of page %u\", x >> 16, iPage);\n                    break;\n                } else {\n                    nFrag += (x >> 16) - (prev & 65535) - 1;\n                    prev = x;\n                }\n            }\n        nFrag += usableSize - (prev & 65535) - 1;\n        if (heap[0] == 0 && nFrag != data[hdr + 7]) {\n            checkAppendMsg(pCheck, \"Fragmentation of %d bytes reported as %d on page %u\", nFrag, data[hdr + 7], iPage);\n        }\n    }\n  end_of_check:\n    if (!doCoverageCheck)\n        pPage->isInit = savedIsInit;\n    releasePage(pPage);\n    pCheck->zPfx = saved_zPfx;\n    pCheck->v1 = saved_v1;\n    pCheck->v2 = saved_v2;\n    return depth + 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#156370:1#constructAutomaticIndex",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int nKeyCol;\n    WhereTerm *pTerm;\n    WhereTerm *pWCEnd;\n    Index *pIdx;\n    Vdbe *v;\n    int addrInit;\n    Table *pTable;\n    int addrTop;\n    int regRecord;\n    int n;\n    int i;\n    int mxBitCol;\n    CollSeq *pColl;\n    WhereLoop *pLoop;\n    char *zNotUsed;\n    Bitmask idxCols;\n    Bitmask extraCols;\n    u8 sentWarning = 0;\n    Expr *pPartial = 0;\n    int iContinue = 0;\n    SrcItem *pTabItem;\n    int addrCounter = 0;\n    int regBase;\n    v = pParse->pVdbe;\n    assert(v != 0);\n    addrInit = sqlite3VdbeAddOp0(v, 15);\n    ;\n    nKeyCol = 0;\n    pTable = pSrc->pTab;\n    pWCEnd = &pWC->a[pWC->nTerm];\n    pLoop = pLevel->pWLoop;\n    idxCols = 0;\n    for (pTerm = pWC->a; pTerm < pWCEnd; pTerm++) {\n        Expr *pExpr = pTerm->pExpr;\n        if ((pTerm->wtFlags & 2) == 0 && sqlite3ExprIsTableConstraint(pExpr, pSrc)) {\n            pPartial = sqlite3ExprAnd(pParse, pPartial, sqlite3ExprDup(pParse->db, pExpr, 0));\n        }\n        if (termCanDriveIndex(pTerm, pSrc, notReady)) {\n            int iCol;\n            Bitmask cMask;\n            assert((pTerm->eOperator & (512 | 1024)) == 0);\n            iCol = pTerm->u.x.leftColumn;\n            cMask = iCol >= ((int)(sizeof(Bitmask) * 8)) ? (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)) : (((Bitmask)1) << (iCol));\n            ;\n            ;\n            if (!sentWarning) {\n                sqlite3_log((28 | (1 << 8)), \"automatic index on %s(%s)\", pTable->zName, pTable->aCol[iCol].zCnName);\n                sentWarning = 1;\n            }\n            if ((idxCols & cMask) == 0) {\n                if (whereLoopResize(pParse->db, pLoop, nKeyCol + 1)) {\n                    goto end_auto_index_create;\n                }\n                pLoop->aLTerm[nKeyCol++] = pTerm;\n                idxCols |= cMask;\n            }\n        }\n    }\n    assert(nKeyCol > 0 || pParse->db->mallocFailed);\n    pLoop->u.btree.nEq = pLoop->nLTerm = nKeyCol;\n    pLoop->wsFlags = 1 | 64 | 512 | 16384;\n    extraCols = pSrc->colUsed & (~idxCols | (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)));\n    mxBitCol = ((((int)(sizeof(Bitmask) * 8)) - 1) < (pTable->nCol) ? (((int)(sizeof(Bitmask) * 8)) - 1) : (pTable->nCol));\n    ;\n    ;\n    for (i = 0; i < mxBitCol; i++) {\n        if (extraCols & (((Bitmask)1) << (i)))\n            nKeyCol++;\n    }\n    if (pSrc->colUsed & (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1))) {\n        nKeyCol += pTable->nCol - ((int)(sizeof(Bitmask) * 8)) + 1;\n    }\n    pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol + 1, 0, &zNotUsed);\n    if (pIdx == 0)\n        goto end_auto_index_create;\n    pLoop->u.btree.pIndex = pIdx;\n    pIdx->zName = \"auto-index\";\n    pIdx->pTable = pTable;\n    n = 0;\n    idxCols = 0;\n    for (pTerm = pWC->a; pTerm < pWCEnd; pTerm++) {\n        if (termCanDriveIndex(pTerm, pSrc, notReady)) {\n            int iCol;\n            Bitmask cMask;\n            assert((pTerm->eOperator & (512 | 1024)) == 0);\n            iCol = pTerm->u.x.leftColumn;\n            cMask = iCol >= ((int)(sizeof(Bitmask) * 8)) ? (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1)) : (((Bitmask)1) << (iCol));\n            ;\n            ;\n            if ((idxCols & cMask) == 0) {\n                Expr *pX = pTerm->pExpr;\n                idxCols |= cMask;\n                pIdx->aiColumn[n] = pTerm->u.x.leftColumn;\n                pColl = sqlite3ExprCompareCollSeq(pParse, pX);\n                assert(pColl != 0 || pParse->nErr > 0);\n                pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;\n                n++;\n            }\n        }\n    }\n    assert((u32)n == pLoop->u.btree.nEq);\n    for (i = 0; i < mxBitCol; i++) {\n        if (extraCols & (((Bitmask)1) << (i))) {\n            pIdx->aiColumn[n] = i;\n            pIdx->azColl[n] = sqlite3StrBINARY;\n            n++;\n        }\n    }\n    if (pSrc->colUsed & (((Bitmask)1) << (((int)(sizeof(Bitmask) * 8)) - 1))) {\n        for (i = ((int)(sizeof(Bitmask) * 8)) - 1; i < pTable->nCol; i++) {\n            pIdx->aiColumn[n] = i;\n            pIdx->azColl[n] = sqlite3StrBINARY;\n            n++;\n        }\n    }\n    assert(n == nKeyCol);\n    pIdx->aiColumn[n] = (-1);\n    pIdx->azColl[n] = sqlite3StrBINARY;\n    assert(pLevel->iIdxCur >= 0);\n    pLevel->iIdxCur = pParse->nTab++;\n    sqlite3VdbeAddOp2(v, 116, pLevel->iIdxCur, nKeyCol + 1);\n    sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n    ;\n    if ((((pParse->db)->dbOptFlags & (524288)) == 0)) {\n        pLevel->regFilter = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 77, 10000, pLevel->regFilter);\n    }\n    pTabItem = &pWC->pWInfo->pTabList->a[pLevel->iFrom];\n    if (pTabItem->fg.viaCoroutine) {\n        int regYield = pTabItem->regReturn;\n        addrCounter = sqlite3VdbeAddOp2(v, 71, 0, 0);\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, pTabItem->addrFillSub);\n        addrTop = sqlite3VdbeAddOp1(v, 12, regYield);\n        ;\n        ;\n    } else {\n        addrTop = sqlite3VdbeAddOp1(v, 36, pLevel->iTabCur);\n        ;\n    }\n    if (pPartial) {\n        iContinue = sqlite3VdbeMakeLabel(pParse);\n        sqlite3ExprIfFalse(pParse, pPartial, iContinue, 16);\n        pLoop->wsFlags |= 131072;\n    }\n    regRecord = sqlite3GetTempReg(pParse);\n    regBase = sqlite3GenerateIndexKey(pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0);\n    if (pLevel->regFilter) {\n        sqlite3VdbeAddOp4Int(v, 180, pLevel->regFilter, 0, regBase, pLoop->u.btree.nEq);\n    }\n    sqlite3VdbeAddOp2(v, 138, pLevel->iIdxCur, regRecord);\n    sqlite3VdbeChangeP5(v, 16);\n    if (pPartial)\n        sqlite3VdbeResolveLabel(v, iContinue);\n    if (pTabItem->fg.viaCoroutine) {\n        sqlite3VdbeChangeP2(v, addrCounter, regBase + n);\n        ;\n        assert(pLevel->iIdxCur > 0);\n        translateColumnToCopy(pParse, addrTop, pLevel->iTabCur, pTabItem->regResult, pLevel->iIdxCur);\n        sqlite3VdbeGoto(v, addrTop);\n        pTabItem->fg.viaCoroutine = 0;\n    } else {\n        sqlite3VdbeAddOp2(v, 39, pLevel->iTabCur, addrTop + 1);\n        ;\n        sqlite3VdbeChangeP5(v, 3);\n    }\n    sqlite3VdbeJumpHere(v, addrTop);\n    sqlite3ReleaseTempReg(pParse, regRecord);\n    sqlite3VdbeJumpHere(v, addrInit);\n  end_auto_index_create:\n    sqlite3ExprDelete(pParse->db, pPartial);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#41240:1#unixOpenSharedMemory",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    struct unixShm *p = 0;\n    struct unixShmNode *pShmNode;\n    int rc = 0;\n    unixInodeInfo *pInode;\n    char *zShm;\n    int nShmFilename;\n    p = sqlite3_malloc64(sizeof (*p));\n    if (p == 0)\n        return 7;\n    memset(p, 0, sizeof (*p));\n    assert(pDbFd->pShm == 0);\n    assert(unixFileMutexNotheld(pDbFd));\n    unixEnterMutex();\n    pInode = pDbFd->pInode;\n    pShmNode = pInode->pShmNode;\n    if (pShmNode == 0) {\n        struct stat sStat;\n        const char *zBasePath = pDbFd->zPath;\n        if (((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pDbFd->h, &<recovery-expr>())) {\n            rc = (10 | (7 << 8));\n            goto shm_open_err;\n        }\n        nShmFilename = 6 + (int)strlen(zBasePath);\n        pShmNode = sqlite3_malloc64(sizeof (*pShmNode) + nShmFilename);\n        if (pShmNode == 0) {\n            rc = 7;\n            goto shm_open_err;\n        }\n        memset(pShmNode, 0, sizeof (*pShmNode) + nShmFilename);\n        zShm = pShmNode->zFilename = (char *)&pShmNode[1];\n        sqlite3_snprintf(nShmFilename, zShm, \"%s-shm\", zBasePath);\n        ;\n        pShmNode->hShm = -1;\n        pDbFd->pInode->pShmNode = pShmNode;\n        pShmNode->pInode = pDbFd->pInode;\n        if (sqlite3Config.bCoreMutex) {\n            pShmNode->pShmMutex = sqlite3_mutex_alloc(0);\n            if (pShmNode->pShmMutex == 0) {\n                rc = 7;\n                goto shm_open_err;\n            }\n        }\n        if (pInode->bProcessLock == 0) {\n            if (0 == sqlite3_uri_boolean(pDbFd->zPath, \"readonly_shm\", 0)) {\n            }\n            if (pShmNode->hShm < 0) {\n                if (pShmNode->hShm < 0) {\n                    rc = unixLogErrorAtLine(sqlite3CantopenError(41316), \"open\", zShm, 41316);\n                    goto shm_open_err;\n                }\n                pShmNode->isReadonly = 1;\n            }\n            <recovery-expr>()(pShmNode->hShm, <recovery-expr>().st_uid, <recovery-expr>().st_gid);\n            rc = unixLockSharedMemory(pDbFd, pShmNode);\n            if (rc != 0 && rc != (8 | (5 << 8)))\n                goto shm_open_err;\n        }\n    }\n    p->pShmNode = pShmNode;\n    pShmNode->nRef++;\n    pDbFd->pShm = p;\n    unixLeaveMutex();\n    sqlite3_mutex_enter(pShmNode->pShmMutex);\n    p->pNext = pShmNode->pFirst;\n    pShmNode->pFirst = p;\n    sqlite3_mutex_leave(pShmNode->pShmMutex);\n    return rc;\n  shm_open_err:\n    unixShmPurge(pDbFd);\n    sqlite3_free(p);\n    unixLeaveMutex();\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#82738:1#resolveP2Values",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int nMaxArgs = *pMaxFuncArgs;\n    Op *pOp;\n    Parse *pParse = p->pParse;\n    int *aLabel = pParse->aLabel;\n    p->readOnly = 1;\n    p->bIsReader = 0;\n    pOp = &p->aOp[p->nOp - 1];\n    assert(p->aOp[0].opcode == 8);\n    while (1)\n        {\n            if (pOp->opcode <= 64) {\n                switch (pOp->opcode) {\n                  case 2:\n                    {\n                        if (pOp->p2 != 0)\n                            p->readOnly = 0;\n                    }\n                  case 1:\n                  case 0:\n                    {\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 3:\n                  case 5:\n                  case 4:\n                    {\n                        p->readOnly = 0;\n                        p->bIsReader = 1;\n                        break;\n                    }\n                  case 8:\n                    {\n                        assert(pOp->p2 >= 0);\n                        goto resolve_p2_values_loop_exit;\n                    }\n                  case 7:\n                    {\n                        if (pOp->p2 > nMaxArgs)\n                            nMaxArgs = pOp->p2;\n                        break;\n                    }\n                  case 6:\n                    {\n                        int n;\n                        assert((pOp - p->aOp) >= 3);\n                        assert(pOp[-1].opcode == 71);\n                        n = pOp[-1].p1;\n                        if (n > nMaxArgs)\n                            nMaxArgs = n;\n                    }\n                  default:\n                    {\n                        if (pOp->p2 < 0) {\n                            assert((sqlite3OpcodeProperty[pOp->opcode] & 1) != 0);\n                            assert((~(pOp->p2)) < -pParse->nLabel);\n                            pOp->p2 = aLabel[(~(pOp->p2))];\n                        }\n                        break;\n                    }\n                }\n                assert((sqlite3OpcodeProperty[pOp->opcode] & 1) == 0 || pOp->p2 >= 0);\n            }\n            assert(pOp > p->aOp);\n            pOp--;\n        }\n  resolve_p2_values_loop_exit:\n    if (aLabel) {\n        sqlite3DbNNFreeNN(p->db, pParse->aLabel);\n        pParse->aLabel = 0;\n    }\n    pParse->nLabel = 0;\n    *pMaxFuncArgs = nMaxArgs;\n    assert(p->bIsReader != 0 || (p->btreeMask) == 0);\n}\n"
  },
  {
    "id": "#23:25#sqlite3ParseUri",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    unsigned int flags = *pFlags;\n    const char *zVfs = zDefaultVfs;\n    char *zFile;\n    char c;\n    int nUri = sqlite3Strlen30(zUri);\n    assert(*pzErrMsg == 0);\n    if (((flags & 64) || sqlite3Config.bOpenUri) && nUri >= 5 && memcmp(zUri, \"file:\", 5) == 0) {\n        char *zOpt;\n        int eState;\n        int iIn;\n        int iOut = 0;\n        u64 nByte = nUri + 8;\n        flags |= 64;\n        for (iIn = 0; iIn < nUri; iIn++)\n            nByte += (zUri[iIn] == '&');\n        zFile = sqlite3_malloc64(nByte);\n        if (!zFile)\n            return 7;\n        memset(zFile, 0, 4);\n        zFile += 4;\n        iIn = 5;\n        if (zUri[5] == '/' && zUri[6] == '/') {\n            iIn = 7;\n            while (zUri[iIn] && zUri[iIn] != '/')\n                iIn++;\n            if (iIn != 7 && (iIn != 16 || memcmp(\"localhost\", &zUri[7], 9))) {\n                *pzErrMsg = sqlite3_mprintf(\"invalid uri authority: %.*s\", iIn - 7, &zUri[7]);\n                rc = 1;\n                goto parse_uri_out;\n            }\n        }\n        eState = 0;\n        while ((c = zUri[iIn]) != 0 && c != '#')\n            {\n                iIn++;\n                if (c == '%' && (sqlite3CtypeMap[(unsigned char)(zUri[iIn])] & 8) && (sqlite3CtypeMap[(unsigned char)(zUri[iIn + 1])] & 8)) {\n                    int octet = (sqlite3HexToInt(zUri[iIn++]) << 4);\n                    octet += sqlite3HexToInt(zUri[iIn++]);\n                    assert(octet >= 0 && octet < 256);\n                    if (octet == 0) {\n                        while ((c = zUri[iIn]) != 0 && c != '#' && (eState != 0 || c != '?') && (eState != 1 || (c != '=' && c != '&')) && (eState != 2 || c != '&'))\n                            {\n                                iIn++;\n                            }\n                        continue;\n                    }\n                    c = octet;\n                } else if (eState == 1 && (c == '&' || c == '=')) {\n                    if (zFile[iOut - 1] == 0) {\n                        while (zUri[iIn] && zUri[iIn] != '#' && zUri[iIn - 1] != '&')\n                            iIn++;\n                        continue;\n                    }\n                    if (c == '&') {\n                        zFile[iOut++] = '\\x00';\n                    } else {\n                        eState = 2;\n                    }\n                    c = 0;\n                } else if ((eState == 0 && c == '?') || (eState == 2 && c == '&')) {\n                    c = 0;\n                    eState = 1;\n                }\n                zFile[iOut++] = c;\n            }\n        if (eState == 1)\n            zFile[iOut++] = '\\x00';\n        memset(zFile + iOut, 0, 4);\n        zOpt = &zFile[sqlite3Strlen30(zFile) + 1];\n        while (zOpt[0])\n            {\n                int nOpt = sqlite3Strlen30(zOpt);\n                char *zVal = &zOpt[nOpt + 1];\n                int nVal = sqlite3Strlen30(zVal);\n                if (nOpt == 3 && memcmp(\"vfs\", zOpt, 3) == 0) {\n                    zVfs = zVal;\n                } else {\n                    struct OpenMode {\n                        const char *z;\n                        int mode;\n                    } *aMode = 0;\n                    char *zModeType = 0;\n                    int mask = 0;\n                    int limit = 0;\n                    if (nOpt == 5 && memcmp(\"cache\", zOpt, 5) == 0) {\n                        static struct OpenMode aCacheMode[] = {{\"shared\", 131072}, {\"private\", 262144}, {0, 0}};\n                        mask = 131072 | 262144;\n                        aMode = aCacheMode;\n                        limit = mask;\n                        zModeType = \"cache\";\n                    }\n                    if (nOpt == 4 && memcmp(\"mode\", zOpt, 4) == 0) {\n                        static struct OpenMode aOpenMode[] = {{\"ro\", 1}, {\"rw\", 2}, {\"rwc\", 2 | 4}, {\"memory\", 128}, {0, 0}};\n                        mask = 1 | 2 | 4 | 128;\n                        aMode = aOpenMode;\n                        limit = mask & flags;\n                        zModeType = \"access\";\n                    }\n                    if (aMode) {\n                        int i;\n                        int mode = 0;\n                        for (i = 0; aMode[i].z; i++) {\n                            const char *z = aMode[i].z;\n                            if (nVal == sqlite3Strlen30(z) && 0 == memcmp(zVal, z, nVal)) {\n                                mode = aMode[i].mode;\n                                break;\n                            }\n                        }\n                        if (mode == 0) {\n                            *pzErrMsg = sqlite3_mprintf(\"no such %s mode: %s\", zModeType, zVal);\n                            rc = 1;\n                            goto parse_uri_out;\n                        }\n                        if ((mode & ~128) > limit) {\n                            *pzErrMsg = sqlite3_mprintf(\"%s mode not allowed: %s\", zModeType, zVal);\n                            rc = 3;\n                            goto parse_uri_out;\n                        }\n                        flags = (flags & ~mask) | mode;\n                    }\n                }\n                zOpt = &zVal[nVal + 1];\n            }\n    } else {\n        zFile = sqlite3_malloc64(nUri + 8);\n        if (!zFile)\n            return 7;\n        memset(zFile, 0, 4);\n        zFile += 4;\n        if (nUri) {\n            memcpy(zFile, zUri, nUri);\n        }\n        memset(zFile + nUri, 0, 4);\n        flags &= ~64;\n    }\n    *ppVfs = sqlite3_vfs_find(zVfs);\n    if (*ppVfs == 0) {\n        *pzErrMsg = sqlite3_mprintf(\"no such vfs: %s\", zVfs);\n        rc = 1;\n    }\n  parse_uri_out:\n    if (rc != 0) {\n        sqlite3_free_filename(zFile);\n        zFile = 0;\n    }\n    *pFlags = flags;\n    *pzFile = zFile;\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#81496:1#valueFromExpr",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int op;\n    char *zVal = 0;\n    sqlite3_value *pVal = 0;\n    int negInt = 1;\n    const char *zNeg = \"\";\n    int rc = 0;\n    assert(pExpr != 0);\n    while ((op = pExpr->op) == 174 || op == 181)\n        pExpr = pExpr->pLeft;\n    if (op == 176)\n        op = pExpr->op2;\n    assert((pExpr->flags & 65536) == 0 || pCtx == 0);\n    if (op == 36) {\n        u8 aff;\n        assert(!(((pExpr)->flags & (2048)) != 0));\n        aff = sqlite3AffinityType(pExpr->u.zToken, 0);\n        rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);\n        ;\n        if (*ppVal) {\n            sqlite3VdbeMemCast(*ppVal, aff, enc);\n            sqlite3ValueApplyAffinity(*ppVal, affinity, enc);\n        }\n        return rc;\n    }\n    if (op == 173 && (pExpr->pLeft->op == 155 || pExpr->pLeft->op == 153)) {\n        pExpr = pExpr->pLeft;\n        op = pExpr->op;\n        negInt = -1;\n        zNeg = \"-\";\n    }\n    if (op == 117 || op == 153 || op == 155) {\n        pVal = valueNew(db, pCtx);\n        if (pVal == 0)\n            goto no_mem;\n        if ((((pExpr)->flags & (2048)) != 0)) {\n            sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue * negInt);\n        } else {\n            zVal = sqlite3MPrintf(db, \"%s%s\", zNeg, pExpr->u.zToken);\n            if (zVal == 0)\n                goto no_mem;\n            sqlite3ValueSetStr(pVal, -1, zVal, 1, ((sqlite3_destructor_type)sqlite3OomClear));\n        }\n        if ((op == 155 || op == 153) && affinity == 65) {\n            sqlite3ValueApplyAffinity(pVal, 67, 1);\n        } else {\n            sqlite3ValueApplyAffinity(pVal, affinity, 1);\n        }\n        assert((pVal->flags & 32) == 0);\n        if (pVal->flags & (4 | 32 | 8)) {\n            ;\n            ;\n            pVal->flags &= ~2;\n        }\n        if (enc != 1) {\n            rc = sqlite3VdbeChangeEncoding(pVal, enc);\n        }\n    } else if (op == 173) {\n        if (0 == valueFromExpr(db, pExpr->pLeft, enc, affinity, &pVal, pCtx) && pVal != 0) {\n            sqlite3VdbeMemNumerify(pVal);\n            if (pVal->flags & 8) {\n                pVal->u.r = -pVal->u.r;\n            } else if (pVal->u.i == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) {\n                pVal->u.r = -(double)(((i64)-1) - (4294967295U | (((i64)2147483647) << 32)));\n                ((pVal)->flags = ((pVal)->flags & ~(3519 | 1024)) | 8);\n            } else {\n                pVal->u.i = -pVal->u.i;\n            }\n            sqlite3ValueApplyAffinity(pVal, affinity, enc);\n        }\n    } else if (op == 121) {\n        pVal = valueNew(db, pCtx);\n        if (pVal == 0)\n            goto no_mem;\n        sqlite3VdbeMemSetNull(pVal);\n    } else if (op == 154) {\n        int nVal;\n        assert(!(((pExpr)->flags & (2048)) != 0));\n        assert(pExpr->u.zToken[0] == 'x' || pExpr->u.zToken[0] == 'X');\n        assert(pExpr->u.zToken[1] == '\\'');\n        pVal = valueNew(db, pCtx);\n        if (!pVal)\n            goto no_mem;\n        zVal = &pExpr->u.zToken[2];\n        nVal = sqlite3Strlen30(zVal) - 1;\n        assert(zVal[nVal] == '\\'');\n        sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal / 2, 0, ((sqlite3_destructor_type)sqlite3OomClear));\n    } else if (op == 170) {\n        assert(!(((pExpr)->flags & (2048)) != 0));\n        pVal = valueNew(db, pCtx);\n        if (pVal) {\n            pVal->flags = 4;\n            pVal->u.i = pExpr->u.zToken[4] == 0;\n        }\n    }\n    *ppVal = pVal;\n    return rc;\n  no_mem:\n    sqlite3OomFault(db);\n    sqlite3DbFree(db, zVal);\n    assert(*ppVal == 0);\n    assert(pCtx == 0);\n    sqlite3ValueFree(pVal);\n    return 7;\n}\n"
  },
  {
    "id": "#23:25#sqlite3StartTable",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    Table *pTable;\n    char *zName = 0;\n    sqlite3 *db = pParse->db;\n    Vdbe *v;\n    int iDb;\n    Token *pName;\n    if (db->init.busy && db->init.newTnum == 1) {\n        iDb = db->init.iDb;\n        zName = sqlite3DbStrDup(db, ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"));\n        pName = pName1;\n    } else {\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0)\n            return;\n        if (!0 && isTemp && pName2->n > 0 && iDb != 1) {\n            sqlite3ErrorMsg(pParse, \"temporary table name must be unqualified\");\n            return;\n        }\n        if (!0 && isTemp)\n            iDb = 1;\n        zName = sqlite3NameFromToken(db, pName);\n        if ((pParse->eParseMode >= 2)) {\n            sqlite3RenameTokenMap(pParse, (void *)zName, pName);\n        }\n    }\n    pParse->sNameToken = *pName;\n    if (zName == 0)\n        return;\n    if (sqlite3CheckObjectName(pParse, zName, isView ? \"view\" : \"table\", zName)) {\n        goto begin_table_error;\n    }\n    if (db->init.iDb == 1)\n        isTemp = 1;\n    assert(isTemp == 0 || isTemp == 1);\n    assert(isView == 0 || isView == 1);\n    {\n        static const u8 aCode[] = {2, 4, 8, 6};\n        char *zDb = db->aDb[iDb].zDbSName;\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (isTemp == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto begin_table_error;\n        }\n        if (!isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp + 2 * isView], zName, 0, zDb)) {\n            goto begin_table_error;\n        }\n    }\n    if (!(pParse->eParseMode != 0)) {\n        char *zDb = db->aDb[iDb].zDbSName;\n        if (0 != sqlite3ReadSchema(pParse)) {\n            goto begin_table_error;\n        }\n        pTable = sqlite3FindTable(db, zName, zDb);\n        if (pTable) {\n            if (!noErr) {\n                sqlite3ErrorMsg(pParse, \"%s %T already exists\", (((pTable)->eTabType == 2) ? \"view\" : \"table\"), pName);\n            } else {\n                assert(!db->init.busy || (sqlite3Config.neverCorrupt == 0));\n                sqlite3CodeVerifySchema(pParse, iDb);\n                sqlite3ForceNotReadOnly(pParse);\n            }\n            goto begin_table_error;\n        }\n        if (sqlite3FindIndex(db, zName, zDb) != 0) {\n            sqlite3ErrorMsg(pParse, \"there is already an index named %s\", zName);\n            goto begin_table_error;\n        }\n    }\n    pTable = sqlite3DbMallocZero(db, sizeof(Table));\n    if (pTable == 0) {\n        assert(db->mallocFailed);\n        pParse->rc = 7;\n        pParse->nErr++;\n        goto begin_table_error;\n    }\n    pTable->zName = zName;\n    pTable->iPKey = -1;\n    pTable->pSchema = db->aDb[iDb].pSchema;\n    pTable->nTabRef = 1;\n    pTable->nRowLogEst = 200;\n    assert(200 == sqlite3LogEst(1048576));\n    assert(pParse->pNewTable == 0);\n    pParse->pNewTable = pTable;\n    if (!db->init.busy && (v = sqlite3GetVdbe(pParse)) != 0) {\n        int addr1;\n        int fileFormat;\n        int reg1, reg2, reg3;\n        static const char nullRow[] = {6, 0, 0, 0, 0, 0};\n        sqlite3BeginWriteOperation(pParse, 1, iDb);\n        if (isVirtual) {\n            sqlite3VdbeAddOp0(v, 170);\n        }\n        reg1 = pParse->regRowid = ++pParse->nMem;\n        reg2 = pParse->regRoot = ++pParse->nMem;\n        reg3 = ++pParse->nMem;\n        sqlite3VdbeAddOp3(v, 99, iDb, reg3, 2);\n        sqlite3VdbeUsesBtree(v, iDb);\n        addr1 = sqlite3VdbeAddOp1(v, 16, reg3);\n        ;\n        fileFormat = (db->flags & 2) != 0 ? 1 : 4;\n        sqlite3VdbeAddOp3(v, 100, iDb, 2, fileFormat);\n        sqlite3VdbeAddOp3(v, 100, iDb, 5, ((db)->enc));\n        sqlite3VdbeJumpHere(v, addr1);\n        if (isView || isVirtual) {\n            sqlite3VdbeAddOp2(v, 71, 0, reg2);\n        } else {\n            assert(!pParse->bReturning);\n            pParse->u1.addrCrTab = sqlite3VdbeAddOp3(v, 147, iDb, reg2, 1);\n        }\n        sqlite3OpenSchemaTable(pParse, iDb);\n        sqlite3VdbeAddOp2(v, 127, 0, reg1);\n        sqlite3VdbeAddOp4(v, 77, 6, reg3, 0, nullRow, (-1));\n        sqlite3VdbeAddOp3(v, 128, 0, reg3, reg1);\n        sqlite3VdbeChangeP5(v, 8);\n        sqlite3VdbeAddOp0(v, 122);\n    }\n    return;\n  begin_table_error:\n    pParse->checkSchema = 1;\n    sqlite3DbFree(db, zName);\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#176177:12#sqlite3_table_column_metadata",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int rc;\n    char *zErrMsg = 0;\n    Table *pTab = 0;\n    Column *pCol = 0;\n    int iCol = 0;\n    const char *zDataType = 0;\n    const char *zCollSeq = 0;\n    int notnull = 0;\n    int primarykey = 0;\n    int autoinc = 0;\n    sqlite3_mutex_enter(db->mutex);\n    sqlite3BtreeEnterAll(db);\n    rc = sqlite3Init(db, &zErrMsg);\n    if (0 != rc) {\n        goto error_out;\n    }\n    pTab = sqlite3FindTable(db, zTableName, zDbName);\n    if (!pTab || ((pTab)->eTabType == 2)) {\n        pTab = 0;\n        goto error_out;\n    }\n    if (zColumnName == 0) {\n    } else {\n        for (iCol = 0; iCol < pTab->nCol; iCol++) {\n            pCol = &pTab->aCol[iCol];\n            if (0 == sqlite3StrICmp(pCol->zCnName, zColumnName)) {\n                break;\n            }\n        }\n        if (iCol == pTab->nCol) {\n            if ((((pTab)->tabFlags & 128) == 0) && sqlite3IsRowid(zColumnName)) {\n                iCol = pTab->iPKey;\n                pCol = iCol >= 0 ? &pTab->aCol[iCol] : 0;\n            } else {\n                pTab = 0;\n                goto error_out;\n            }\n        }\n    }\n    if (pCol) {\n        zDataType = sqlite3ColumnType(pCol, 0);\n        zCollSeq = sqlite3ColumnColl(pCol);\n        notnull = pCol->notNull != 0;\n        primarykey = (pCol->colFlags & 1) != 0;\n        autoinc = pTab->iPKey == iCol && (pTab->tabFlags & 8) != 0;\n    } else {\n        zDataType = \"INTEGER\";\n        primarykey = 1;\n    }\n    if (!zCollSeq) {\n        zCollSeq = sqlite3StrBINARY;\n    }\n  error_out:\n    sqlite3BtreeLeaveAll(db);\n    if (pzDataType)\n        *pzDataType = zDataType;\n    if (pzCollSeq)\n        *pzCollSeq = zCollSeq;\n    if (pNotNull)\n        *pNotNull = notnull;\n    if (pPrimaryKey)\n        *pPrimaryKey = primarykey;\n    if (pAutoinc)\n        *pAutoinc = autoinc;\n    if (0 == rc && !pTab) {\n        sqlite3DbFree(db, zErrMsg);\n        zErrMsg = sqlite3MPrintf(db, \"no such table column: %s.%s\", zTableName, zColumnName);\n        rc = 1;\n    }\n    sqlite3ErrorWithMsg(db, rc, (zErrMsg ? \"%s\" : 0), zErrMsg);\n    sqlite3DbFree(db, zErrMsg);\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#197703:1#jsonReturn",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    switch (pNode->eType) {\n      default:\n        {\n            assert(pNode->eType == 0);\n            sqlite3_result_null(pCtx);\n            break;\n        }\n      case 1:\n        {\n            sqlite3_result_int(pCtx, 1);\n            break;\n        }\n      case 2:\n        {\n            sqlite3_result_int(pCtx, 0);\n            break;\n        }\n      case 3:\n        {\n            sqlite3_int64 i = 0;\n            const char *z;\n            assert(pNode->eU == 1);\n            z = pNode->u.zJContent;\n            if (z[0] == '-') {\n                z++;\n            }\n            while (z[0] >= '0' && z[0] <= '9')\n                {\n                    unsigned int v = *(z++) - '0';\n                    if (i >= (4294967295U | (((i64)2147483647) << 32)) / 10) {\n                        if (i > (4294967295U | (((i64)2147483647) << 32)) / 10)\n                            goto int_as_real;\n                        if (z[0] >= '0' && z[0] <= '9')\n                            goto int_as_real;\n                        if (v == 9)\n                            goto int_as_real;\n                        if (v == 8) {\n                            if (pNode->u.zJContent[0] == '-') {\n                                sqlite3_result_int64(pCtx, (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))));\n                                goto int_done;\n                            } else {\n                                goto int_as_real;\n                            }\n                        }\n                    }\n                    i = i * 10 + v;\n                }\n            if (pNode->u.zJContent[0] == '-') {\n                i = -i;\n            }\n            sqlite3_result_int64(pCtx, i);\n          int_done:\n            break;\n          int_as_real:\n            ;\n        }\n      case 4:\n        {\n            double r;\n            const char *z;\n            assert(pNode->eU == 1);\n            z = pNode->u.zJContent;\n            sqlite3AtoF(z, &r, sqlite3Strlen30(z), 1);\n            sqlite3_result_double(pCtx, r);\n            break;\n        }\n      case 5:\n        {\n            assert((pNode->jnFlags & 1) == 0);\n            if ((pNode->jnFlags & 2) == 0) {\n                assert(pNode->eU == 1);\n                sqlite3_result_text(pCtx, pNode->u.zJContent + 1, pNode->n - 2, ((sqlite3_destructor_type)-1));\n            } else {\n                u32 i;\n                u32 n = pNode->n;\n                const char *z;\n                char *zOut;\n                u32 j;\n                assert(pNode->eU == 1);\n                z = pNode->u.zJContent;\n                zOut = sqlite3_malloc(n + 1);\n                if (zOut == 0) {\n                    sqlite3_result_error_nomem(pCtx);\n                    break;\n                }\n                for (i = 1 , j = 0; i < n - 1; i++) {\n                    char c = z[i];\n                    if (c != '\\\\') {\n                        zOut[j++] = c;\n                    } else {\n                        c = z[++i];\n                        if (c == 'u') {\n                            u32 v = jsonHexToInt4(z + i + 1);\n                            i += 4;\n                            if (v == 0)\n                                break;\n                            if (v <= 127) {\n                                zOut[j++] = (char)v;\n                            } else if (v <= 2047) {\n                                zOut[j++] = (char)(192 | (v >> 6));\n                                zOut[j++] = 128 | (v & 63);\n                            } else {\n                                u32 vlo;\n                                if ((v & 64512) == 55296 && i < n - 6 && z[i + 1] == '\\\\' && z[i + 2] == 'u' && ((vlo = jsonHexToInt4(z + i + 3)) & 64512) == 56320) {\n                                    v = ((v & 1023) << 10) + (vlo & 1023) + 65536;\n                                    i += 6;\n                                    zOut[j++] = 240 | (v >> 18);\n                                    zOut[j++] = 128 | ((v >> 12) & 63);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                } else {\n                                    zOut[j++] = 224 | (v >> 12);\n                                    zOut[j++] = 128 | ((v >> 6) & 63);\n                                    zOut[j++] = 128 | (v & 63);\n                                }\n                            }\n                        } else {\n                            if (c == 'b') {\n                                c = '\\b';\n                            } else if (c == 'f') {\n                                c = '\\f';\n                            } else if (c == 'n') {\n                                c = '\\n';\n                            } else if (c == 'r') {\n                                c = '\\r';\n                            } else if (c == 't') {\n                                c = '\\t';\n                            }\n                            zOut[j++] = c;\n                        }\n                    }\n                }\n                zOut[j] = 0;\n                sqlite3_result_text(pCtx, zOut, j, sqlite3_free);\n            }\n            break;\n        }\n      case 6:\n      case 7:\n        {\n            jsonReturnJson(pNode, pCtx, aReplace);\n            break;\n        }\n    }\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeMultiLoad",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int i;\n    char c;\n    for (i = 0; (c = zTypes[i]) != 0; i++) {\n        if (c == 's') {\n            const char *z;\n            sqlite3VdbeAddOp4(p, z == 0 ? 75 : 117, 0, iDest + i, 0, z, 0);\n        } else if (c == 'i') {\n        } else {\n            goto skip_op_resultrow;\n        }\n    }\n    sqlite3VdbeAddOp2(p, 84, iDest, i);\n  skip_op_resultrow:\n    ;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BitvecBuiltinTest",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Bitvec *pBitvec = 0;\n    unsigned char *pV = 0;\n    int rc = -1;\n    int i, nx, pc, op;\n    void *pTmpSpace;\n    pBitvec = sqlite3BitvecCreate(sz);\n    pV = sqlite3MallocZero((sz + 7) / 8 + 1);\n    pTmpSpace = sqlite3_malloc64(512);\n    if (pBitvec == 0 || pV == 0 || pTmpSpace == 0)\n        goto bitvec_end;\n    sqlite3BitvecSet(0, 1);\n    sqlite3BitvecClear(0, 1, pTmpSpace);\n    pc = i = 0;\n    while ((op = aOp[pc]) != 0)\n        {\n            switch (op) {\n              case 1:\n              case 2:\n              case 5:\n                {\n                    nx = 4;\n                    i = aOp[pc + 2] - 1;\n                    aOp[pc + 2] += aOp[pc + 3];\n                    break;\n                }\n              case 3:\n              case 4:\n              default:\n                {\n                    nx = 2;\n                    sqlite3_randomness(sizeof (i), &i);\n                    break;\n                }\n            }\n            if ((--aOp[pc + 1]) > 0)\n                nx = 0;\n            pc += nx;\n            i = (i & 2147483647) % sz;\n            if ((op & 1) != 0) {\n                pV[(i + 1) >> 3] |= (1 << ((i + 1) & 7));\n                if (op != 5) {\n                    if (sqlite3BitvecSet(pBitvec, i + 1))\n                        goto bitvec_end;\n                }\n            } else {\n                pV[(i + 1) >> 3] &= ~(1 << ((i + 1) & 7));\n                sqlite3BitvecClear(pBitvec, i + 1, pTmpSpace);\n            }\n        }\n    rc = sqlite3BitvecTest(0, 0) + sqlite3BitvecTest(pBitvec, sz + 1) + sqlite3BitvecTest(pBitvec, 0) + (sqlite3BitvecSize(pBitvec) - sz);\n    for (i = 1; i <= sz; i++) {\n        if (((pV[i >> 3] & (1 << (i & 7))) != 0) != sqlite3BitvecTest(pBitvec, i)) {\n            rc = i;\n            break;\n        }\n    }\n  bitvec_end:\n    sqlite3_free(pTmpSpace);\n    sqlite3_free(pV);\n    sqlite3BitvecDestroy(pBitvec);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeCopyFile",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int rc;\n    sqlite3_file *pFd;\n    sqlite3_backup b;\n    sqlite3BtreeEnter(pTo);\n    sqlite3BtreeEnter(pFrom);\n    assert(sqlite3BtreeTxnState(pTo) == 2);\n    pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));\n    if (pFd->pMethods) {\n        i64 nByte = sqlite3BtreeGetPageSize(pFrom) * (i64)sqlite3BtreeLastPage(pFrom);\n        rc = sqlite3OsFileControl(pFd, 11, &nByte);\n        if (rc == 12)\n            rc = 0;\n        if (rc)\n            goto copy_finished;\n    }\n    memset(&b, 0, sizeof (b));\n    b.pSrcDb = pFrom->db;\n    b.pSrc = pFrom;\n    b.pDest = pTo;\n    b.iNext = 1;\n    sqlite3_backup_step(&b, 2147483647);\n    assert(b.rc != 0);\n    rc = sqlite3_backup_finish(&b);\n    if (rc == 0) {\n        pTo->pBt->btsFlags &= ~2;\n    } else {\n        sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));\n    }\n    assert(sqlite3BtreeTxnState(pTo) != 2);\n  copy_finished:\n    sqlite3BtreeLeave(pFrom);\n    sqlite3BtreeLeave(pTo);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3VdbeMemTranslate",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    sqlite3_int64 len;\n    unsigned char *zOut;\n    unsigned char *zIn;\n    unsigned char *zTerm;\n    unsigned char *z;\n    unsigned int c;\n    assert(pMem->db == 0 || sqlite3_mutex_held(pMem->db->mutex));\n    assert(pMem->flags & 2);\n    assert(pMem->enc != desiredEnc);\n    assert(pMem->enc != 0);\n    assert(pMem->n >= 0);\n    if (pMem->enc != 1 && desiredEnc != 1) {\n        u8 temp;\n        int rc;\n        rc = sqlite3VdbeMemMakeWriteable(pMem);\n        if (rc != 0) {\n            assert(rc == 7);\n            return 7;\n        }\n        zIn = (u8 *)pMem->z;\n        zTerm = &zIn[pMem->n & ~1];\n        while (zIn < zTerm)\n            {\n                temp = *zIn;\n                *zIn = *(zIn + 1);\n                zIn++;\n                *zIn++ = temp;\n            }\n        pMem->enc = desiredEnc;\n        goto translate_out;\n    }\n    if (desiredEnc == 1) {\n        pMem->n &= ~1;\n        len = 2 * (sqlite3_int64)pMem->n + 1;\n    } else {\n        len = 2 * (sqlite3_int64)pMem->n + 2;\n    }\n    zIn = (u8 *)pMem->z;\n    zTerm = &zIn[pMem->n];\n    zOut = sqlite3DbMallocRaw(pMem->db, len);\n    if (!zOut) {\n        return 7;\n    }\n    z = zOut;\n    if (pMem->enc == 1) {\n        if (desiredEnc == 2) {\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    if (c >= 192) {\n                        c = sqlite3Utf8Trans1[c - 192];\n                        while (zIn != zTerm && (*zIn & 192) == 128)\n                            {\n                                c = (c << 6) + (63 & *(zIn++));\n                            }\n                        if (c < 128 || (c & 4294965248U) == 55296 || (c & 4294967294U) == 65534) {\n                            c = 65533;\n                        }\n                    }\n                    ;\n                    {\n                        if (c <= 65535) {\n                            *z++ = (u8)(c & 255);\n                            *z++ = (u8)((c >> 8) & 255);\n                        } else {\n                            *z++ = (u8)(((c >> 10) & 63) + (((c - 65536) >> 10) & 192));\n                            *z++ = (u8)(216 + (((c - 65536) >> 18) & 3));\n                            *z++ = (u8)(c & 255);\n                            *z++ = (u8)(220 + ((c >> 8) & 3));\n                        }\n                    }\n                    ;\n                }\n        } else {\n            assert(desiredEnc == 3);\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    if (c >= 192) {\n                        c = sqlite3Utf8Trans1[c - 192];\n                        while (zIn != zTerm && (*zIn & 192) == 128)\n                            {\n                                c = (c << 6) + (63 & *(zIn++));\n                            }\n                        if (c < 128 || (c & 4294965248U) == 55296 || (c & 4294967294U) == 65534) {\n                            c = 65533;\n                        }\n                    }\n                    ;\n                    {\n                        if (c <= 65535) {\n                            *z++ = (u8)((c >> 8) & 255);\n                            *z++ = (u8)(c & 255);\n                        } else {\n                            *z++ = (u8)(216 + (((c - 65536) >> 18) & 3));\n                            *z++ = (u8)(((c >> 10) & 63) + (((c - 65536) >> 10) & 192));\n                            *z++ = (u8)(220 + ((c >> 8) & 3));\n                            *z++ = (u8)(c & 255);\n                        }\n                    }\n                    ;\n                }\n        }\n        pMem->n = (int)(z - zOut);\n        *z++ = 0;\n    } else {\n        assert(desiredEnc == 1);\n        if (pMem->enc == 2) {\n            while (zIn < zTerm)\n                {\n                    c = *(zIn++);\n                    c += (*(zIn++)) << 8;\n                    if (c >= 55296 && c < 57344) {\n                        if (zIn < zTerm) {\n                            int c2 = (*zIn++);\n                            c2 += ((*zIn++) << 8);\n                            c = (c2 & 1023) + ((c & 63) << 10) + (((c & 960) + 64) << 10);\n                        }\n                    }\n                    {\n                        if (c < 128) {\n                            *z++ = (u8)(c & 255);\n                        } else if (c < 2048) {\n                            *z++ = 192 + (u8)((c >> 6) & 31);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else if (c < 65536) {\n                            *z++ = 224 + (u8)((c >> 12) & 15);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else {\n                            *z++ = 240 + (u8)((c >> 18) & 7);\n                            *z++ = 128 + (u8)((c >> 12) & 63);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        }\n                    }\n                    ;\n                }\n        } else {\n            while (zIn < zTerm)\n                {\n                    c = (*(zIn++)) << 8;\n                    c += *(zIn++);\n                    if (c >= 55296 && c < 57344) {\n                        if (zIn < zTerm) {\n                            int c2 = ((*zIn++) << 8);\n                            c2 += (*zIn++);\n                            c = (c2 & 1023) + ((c & 63) << 10) + (((c & 960) + 64) << 10);\n                        }\n                    }\n                    {\n                        if (c < 128) {\n                            *z++ = (u8)(c & 255);\n                        } else if (c < 2048) {\n                            *z++ = 192 + (u8)((c >> 6) & 31);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else if (c < 65536) {\n                            *z++ = 224 + (u8)((c >> 12) & 15);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        } else {\n                            *z++ = 240 + (u8)((c >> 18) & 7);\n                            *z++ = 128 + (u8)((c >> 12) & 63);\n                            *z++ = 128 + (u8)((c >> 6) & 63);\n                            *z++ = 128 + (u8)(c & 63);\n                        }\n                    }\n                    ;\n                }\n        }\n        pMem->n = (int)(z - zOut);\n    }\n    *z = 0;\n    assert((pMem->n + (desiredEnc == 1 ? 1 : 2)) <= len);\n    c = 2 | 512 | (pMem->flags & (63 | 2048));\n    sqlite3VdbeMemRelease(pMem);\n    pMem->flags = c;\n    pMem->enc = desiredEnc;\n    pMem->z = (char *)zOut;\n    pMem->zMalloc = pMem->z;\n    pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z);\n  translate_out:\n    return 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3WhereBegin",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    int nByteWInfo;\n    int nTabList;\n    WhereInfo *pWInfo;\n    Vdbe *v = pParse->pVdbe;\n    Bitmask notReady;\n    WhereLoopBuilder sWLB;\n    WhereMaskSet *pMaskSet;\n    WhereLevel *pLevel;\n    WhereLoop *pLoop;\n    int ii;\n    sqlite3 *db;\n    int rc;\n    u8 bFordelete = 0;\n    assert((wctrlFlags & 8) == 0 || ((wctrlFlags & 4) != 0 && (wctrlFlags & 32) == 0));\n    assert((wctrlFlags & 32) == 0 || (wctrlFlags & 16384) == 0);\n    db = pParse->db;\n    memset(&sWLB, 0, sizeof (sWLB));\n    ;\n    if (pOrderBy && pOrderBy->nExpr >= ((int)(sizeof(Bitmask) * 8)))\n        pOrderBy = 0;\n    ;\n    if (pTabList->nSrc > ((int)(sizeof(Bitmask) * 8))) {\n        sqlite3ErrorMsg(pParse, \"at most %d tables in a join\", ((int)(sizeof(Bitmask) * 8)));\n        return 0;\n    }\n    nTabList = (wctrlFlags & 32) ? 1 : pTabList->nSrc;\n    nByteWInfo = (sizeof(WhereInfo) + (nTabList - 1) * sizeof(WhereLevel));\n    pWInfo = sqlite3DbMallocRawNN(db, nByteWInfo + sizeof(WhereLoop));\n    if (db->mallocFailed) {\n        sqlite3DbFree(db, pWInfo);\n        pWInfo = 0;\n        goto whereBeginError;\n    }\n    pWInfo->pParse = pParse;\n    pWInfo->pTabList = pTabList;\n    pWInfo->pOrderBy = pOrderBy;\n    pWInfo->pResultSet = pResultSet;\n    pWInfo->aiCurOnePass[0] = pWInfo->aiCurOnePass[1] = -1;\n    pWInfo->nLevel = nTabList;\n    pWInfo->iBreak = pWInfo->iContinue = sqlite3VdbeMakeLabel(pParse);\n    pWInfo->wctrlFlags = wctrlFlags;\n    pWInfo->iLimit = iAuxArg;\n    pWInfo->savedNQueryLoop = pParse->nQueryLoop;\n    pWInfo->pSelect = pSelect;\n    memset(&pWInfo->nOBSat, 0, ((int)((char *)&((WhereInfo *)0)->sWC)) - ((int)((char *)&((WhereInfo *)0)->nOBSat)));\n    memset(&pWInfo->a[0], 0, sizeof(WhereLoop) + nTabList * sizeof(WhereLevel));\n    assert(pWInfo->eOnePass == 0);\n    pMaskSet = &pWInfo->sMaskSet;\n    pMaskSet->n = 0;\n    pMaskSet->ix[0] = -99;\n    sWLB.pWInfo = pWInfo;\n    sWLB.pWC = &pWInfo->sWC;\n    sWLB.pNew = (WhereLoop *)(((char *)pWInfo) + nByteWInfo);\n    assert(((((char *)(sWLB.pNew) - (char *)0) & 7) == 0));\n    whereLoopInit(sWLB.pNew);\n    sqlite3WhereClauseInit(&pWInfo->sWC, pWInfo);\n    sqlite3WhereSplit(&pWInfo->sWC, pWhere, 44);\n    if (nTabList == 0) {\n        if (pOrderBy)\n            pWInfo->nOBSat = pOrderBy->nExpr;\n        if ((wctrlFlags & 256) != 0 && (((db)->dbOptFlags & (16)) == 0)) {\n            pWInfo->eDistinct = 1;\n        }\n        sqlite3VdbeExplain(pParse, 0, \"SCAN CONSTANT ROW\");\n    } else {\n        ii = 0;\n        do {\n            createMask(pMaskSet, pTabList->a[ii].iCursor);\n            sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);\n        } while ((++ii) < pTabList->nSrc);\n    }\n    sqlite3WhereExprAnalyze(pTabList, &pWInfo->sWC);\n    if (pSelect && pSelect->pLimit) {\n        sqlite3WhereAddLimit(&pWInfo->sWC, pSelect);\n    }\n    if (pParse->nErr)\n        goto whereBeginError;\n    for (ii = 0; ii < sWLB.pWC->nBase; ii++) {\n        WhereTerm *pT = &sWLB.pWC->a[ii];\n        if (pT->wtFlags & 2)\n            continue;\n        if (pT->prereqAll == 0 && (nTabList == 0 || exprIsDeterministic(pT->pExpr))) {\n            sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, 16);\n            pT->wtFlags |= 4;\n        }\n    }\n    if (wctrlFlags & 256) {\n        if ((((db)->dbOptFlags & (16)) != 0)) {\n            wctrlFlags &= ~256;\n            pWInfo->wctrlFlags &= ~256;\n        } else if (isDistinctRedundant(pParse, pTabList, &pWInfo->sWC, pResultSet)) {\n            pWInfo->eDistinct = 1;\n        } else if (pOrderBy == 0) {\n            pWInfo->wctrlFlags |= 128;\n            pWInfo->pOrderBy = pResultSet;\n        }\n    }\n    if (nTabList != 1 || whereShortCut(&sWLB) == 0) {\n        rc = whereLoopAddAll(&sWLB);\n        if (rc)\n            goto whereBeginError;\n        ;\n        wherePathSolver(pWInfo, 0);\n        if (db->mallocFailed)\n            goto whereBeginError;\n        if (pWInfo->pOrderBy) {\n            wherePathSolver(pWInfo, pWInfo->nRowOut + 1);\n            if (db->mallocFailed)\n                goto whereBeginError;\n        }\n    }\n    if (pWInfo->pOrderBy == 0 && (db->flags & 4096) != 0) {\n        pWInfo->revMask = ((Bitmask)-1);\n    }\n    if (pParse->nErr) {\n        goto whereBeginError;\n    }\n    assert(db->mallocFailed == 0);\n    notReady = ~(Bitmask)0;\n    if (pWInfo->nLevel >= 2 && pResultSet != 0 && 0 == (wctrlFlags & 1024) && (((db)->dbOptFlags & (256)) == 0)) {\n        notReady = whereOmitNoopJoin(pWInfo, notReady);\n        nTabList = pWInfo->nLevel;\n        assert(nTabList > 0);\n    }\n    if (pWInfo->nLevel >= 2 && (((db)->dbOptFlags & (524288)) == 0)) {\n        whereCheckIfBloomFilterIsUseful(pWInfo);\n    }\n    pWInfo->pParse->nQueryLoop += pWInfo->nRowOut;\n    assert((wctrlFlags & 4) == 0 || pWInfo->nLevel == 1);\n    if ((wctrlFlags & 4) != 0) {\n        int wsFlags = pWInfo->a[0].pWLoop->wsFlags;\n        int bOnerow = (wsFlags & 4096) != 0;\n        assert(!(wsFlags & 1024) || ((pTabList->a[0].pTab)->eTabType == 1));\n        if (bOnerow || (0 != (wctrlFlags & 8) && !((pTabList->a[0].pTab)->eTabType == 1) && (0 == (wsFlags & 8192) || (wctrlFlags & 16)))) {\n            pWInfo->eOnePass = bOnerow ? 1 : 2;\n            if ((((pTabList->a[0].pTab)->tabFlags & 128) == 0) && (wsFlags & 64)) {\n                if (wctrlFlags & 8) {\n                    bFordelete = 8;\n                }\n                pWInfo->a[0].pWLoop->wsFlags = (wsFlags & ~64);\n            }\n        }\n    }\n    for (ii = 0 , pLevel = pWInfo->a; ii < nTabList; ii++ , pLevel++) {\n        Table *pTab;\n        int iDb;\n        SrcItem *pTabItem;\n        pTabItem = &pTabList->a[pLevel->iFrom];\n        pTab = pTabItem->pTab;\n        iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        pLoop = pLevel->pWLoop;\n        if ((pTab->tabFlags & 16384) != 0 || ((pTab)->eTabType == 2)) {\n        } else if ((pLoop->wsFlags & 1024) != 0) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            int iCur = pTabItem->iCursor;\n            sqlite3VdbeAddOp4(v, 173, iCur, 0, 0, pVTab, (-11));\n        } else if (((pTab)->eTabType == 1)) {\n        } else if (((pLoop->wsFlags & 64) == 0 && (wctrlFlags & 32) == 0) || (pTabItem->fg.jointype & (64 | 16)) != 0) {\n            int op = 112;\n            if (pWInfo->eOnePass != 0) {\n                op = 113;\n                pWInfo->aiCurOnePass[0] = pTabItem->iCursor;\n            }\n            ;\n            sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);\n            assert(pTabItem->iCursor == pLevel->iTabCur);\n            ;\n            ;\n            if (pWInfo->eOnePass == 0 && pTab->nCol < ((int)(sizeof(Bitmask) * 8)) && (pTab->tabFlags & (96 | 128)) == 0 && (pLoop->wsFlags & (16384 | 4194304)) == 0) {\n                Bitmask b = pTabItem->colUsed;\n                int n = 0;\n                for (; b; b = b >> 1 , n++) {\n                }\n                sqlite3VdbeChangeP4(v, -1, ((void *)(long)(n)), (-3));\n                assert(n <= pTab->nCol);\n            }\n            {\n                sqlite3VdbeChangeP5(v, bFordelete);\n            }\n        } else {\n            sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n        }\n        if (pLoop->wsFlags & 512) {\n            Index *pIx = pLoop->u.btree.pIndex;\n            int iIndexCur;\n            int op = 112;\n            assert(iAuxArg != 0 || (pWInfo->wctrlFlags & 4) == 0);\n            if (!(((pTab)->tabFlags & 128) == 0) && ((pIx)->idxType == 2) && (wctrlFlags & 32) != 0) {\n                iIndexCur = pLevel->iTabCur;\n                op = 0;\n            } else if (pWInfo->eOnePass != 0) {\n                Index *pJ = pTabItem->pTab->pIndex;\n                iIndexCur = iAuxArg;\n                assert(wctrlFlags & 4);\n                while ((pJ) && pJ != pIx)\n                    {\n                        iIndexCur++;\n                        pJ = pJ->pNext;\n                    }\n                op = 113;\n                pWInfo->aiCurOnePass[1] = iIndexCur;\n            } else if (iAuxArg && (wctrlFlags & 32) != 0) {\n                iIndexCur = iAuxArg;\n                op = 101;\n            } else {\n                iIndexCur = pParse->nTab++;\n                if (pIx->bHasExpr && (((db)->dbOptFlags & (16777216)) == 0)) {\n                    whereAddIndexedExpr(pParse, pIx, iIndexCur, pTabItem);\n                }\n            }\n            pLevel->iIdxCur = iIndexCur;\n            assert(pIx != 0);\n            assert(pIx->pSchema == pTab->pSchema);\n            assert(iIndexCur >= 0);\n            if (op) {\n                sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);\n                sqlite3VdbeSetP4KeyInfo(pParse, pIx);\n                if ((pLoop->wsFlags & 15) != 0 && (pLoop->wsFlags & (2 | 32768)) == 0 && (pLoop->wsFlags & 524288) == 0 && (pLoop->wsFlags & 1048576) == 0 && (pWInfo->wctrlFlags & 1) == 0 && pWInfo->eDistinct != 2) {\n                    sqlite3VdbeChangeP5(v, 2);\n                }\n                ;\n            }\n        }\n        if (iDb >= 0)\n            sqlite3CodeVerifySchema(pParse, iDb);\n        if ((pTabItem->fg.jointype & 16) != 0 && (pLevel->pRJ = sqlite3WhereMalloc(pWInfo, sizeof(WhereRightJoin))) != 0) {\n            WhereRightJoin *pRJ = pLevel->pRJ;\n            pRJ->iMatch = pParse->nTab++;\n            pRJ->regBloom = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 77, 65536, pRJ->regBloom);\n            pRJ->regReturn = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 75, 0, pRJ->regReturn);\n            assert(pTab == pTabItem->pTab);\n            if ((((pTab)->tabFlags & 128) == 0)) {\n                KeyInfo *pInfo;\n                sqlite3VdbeAddOp2(v, 118, pRJ->iMatch, 1);\n                pInfo = sqlite3KeyInfoAlloc(pParse->db, 1, 0);\n                if (pInfo) {\n                    pInfo->aColl[0] = 0;\n                    pInfo->aSortFlags[0] = 0;\n                    sqlite3VdbeAppendP4(v, pInfo, (-8));\n                }\n            } else {\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                sqlite3VdbeAddOp2(v, 118, pRJ->iMatch, pPk->nKeyCol);\n                sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n            }\n            pLoop->wsFlags &= ~64;\n            pWInfo->nOBSat = 0;\n            pWInfo->eDistinct = 3;\n        }\n    }\n    pWInfo->iTop = sqlite3VdbeCurrentAddr(v);\n    if (db->mallocFailed)\n        goto whereBeginError;\n    for (ii = 0; ii < nTabList; ii++) {\n        int addrExplain;\n        int wsFlags;\n        SrcItem *pSrc;\n        if (pParse->nErr)\n            goto whereBeginError;\n        pLevel = &pWInfo->a[ii];\n        wsFlags = pLevel->pWLoop->wsFlags;\n        pSrc = &pTabList->a[pLevel->iFrom];\n        if (pSrc->fg.isMaterialized) {\n            if (pSrc->fg.isCorrelated) {\n                sqlite3VdbeAddOp2(v, 10, pSrc->regReturn, pSrc->addrFillSub);\n            } else {\n                int iOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n                sqlite3VdbeAddOp2(v, 10, pSrc->regReturn, pSrc->addrFillSub);\n                sqlite3VdbeJumpHere(v, iOnce);\n            }\n        }\n        if ((wsFlags & (16384 | 4194304)) != 0) {\n            if ((wsFlags & 16384) != 0) {\n                constructAutomaticIndex(pParse, &pWInfo->sWC, &pTabList->a[pLevel->iFrom], notReady, pLevel);\n            } else {\n                sqlite3ConstructBloomFilter(pWInfo, ii, pLevel, notReady);\n            }\n            if (db->mallocFailed)\n                goto whereBeginError;\n        }\n        addrExplain = sqlite3WhereExplainOneScan(pParse, pTabList, pLevel, wctrlFlags);\n        pLevel->addrBody = sqlite3VdbeCurrentAddr(v);\n        notReady = sqlite3WhereCodeOneLoopStart(pParse, v, pWInfo, ii, pLevel, notReady);\n        pWInfo->iContinue = pLevel->addrCont;\n        if ((wsFlags & 8192) == 0 && (wctrlFlags & 32) == 0) {\n            ((void)addrExplain);\n        }\n    }\n    ;\n    pWInfo->iEndWhere = sqlite3VdbeCurrentAddr(v);\n    return pWInfo;\n  whereBeginError:\n    if (pWInfo) {\n        pParse->nQueryLoop = pWInfo->savedNQueryLoop;\n        whereInfoFree(db, pWInfo);\n    }\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#75933:1#balance_nonroot",
    "gotos": 15,
    "labels": 1,
    "body": "{\n    BtShared *pBt;\n    int nMaxCells = 0;\n    int nNew = 0;\n    int nOld;\n    int i, j, k;\n    int nxDiv;\n    int rc = 0;\n    u16 leafCorrection;\n    int leafData;\n    int usableSpace;\n    int pageFlags;\n    int iSpace1 = 0;\n    int iOvflSpace = 0;\n    int szScratch;\n    MemPage *apOld[3];\n    MemPage *apNew[5];\n    u8 *pRight;\n    u8 *apDiv[2];\n    int cntNew[5];\n    int cntOld[5];\n    int szNew[5];\n    u8 *aSpace1;\n    Pgno pgno;\n    u8 abDone[5];\n    Pgno aPgno[5];\n    CellArray b;\n    memset(abDone, 0, sizeof (abDone));\n    memset(&b, 0, sizeof (b));\n    pBt = pParent->pBt;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(sqlite3PagerIswriteable(pParent->pDbPage));\n    assert(pParent->nOverflow == 0 || pParent->nOverflow == 1);\n    assert(pParent->nOverflow == 0 || pParent->aiOvfl[0] == iParentIdx);\n    if (!aOvflSpace) {\n        return 7;\n    }\n    assert(pParent->nFree >= 0);\n    i = pParent->nOverflow + pParent->nCell;\n    if (i < 2) {\n        nxDiv = 0;\n    } else {\n        assert(bBulk == 0 || bBulk == 1);\n        if (iParentIdx == 0) {\n            nxDiv = 0;\n        } else if (iParentIdx == i) {\n            nxDiv = i - 2 + bBulk;\n        } else {\n            nxDiv = iParentIdx - 1;\n        }\n        i = 2 - bBulk;\n    }\n    nOld = i + 1;\n    if ((i + nxDiv - pParent->nOverflow) == pParent->nCell) {\n        pRight = &pParent->aData[pParent->hdrOffset + 8];\n    } else {\n        pRight = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[0] << 8 | (&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[1])));\n    }\n    pgno = sqlite3Get4byte(pRight);\n    while (1)\n        {\n            if (rc == 0) {\n                rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);\n            }\n            if (rc) {\n                memset(apOld, 0, (i + 1) * sizeof(MemPage *));\n                goto balance_cleanup;\n            }\n            if (apOld[i]->nFree < 0) {\n                rc = btreeComputeFreeSpace(apOld[i]);\n                if (rc) {\n                    memset(apOld, 0, (i) * sizeof(MemPage *));\n                    goto balance_cleanup;\n                }\n            }\n            nMaxCells += apOld[i]->nCell + ((int)(sizeof (pParent->apOvfl) / sizeof (pParent->apOvfl[0])));\n            if ((i--) == 0)\n                break;\n            if (pParent->nOverflow && i + nxDiv == pParent->aiOvfl[0]) {\n                apDiv[i] = pParent->apOvfl[0];\n                pgno = sqlite3Get4byte(apDiv[i]);\n                szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\n                pParent->nOverflow = 0;\n            } else {\n                apDiv[i] = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[0] << 8 | (&(pParent)->aCellIdx[2 * (i + nxDiv - pParent->nOverflow)])[1])));\n                pgno = sqlite3Get4byte(apDiv[i]);\n                szNew[i] = pParent->xCellSize(pParent, apDiv[i]);\n                if (pBt->btsFlags & 12) {\n                    int iOff;\n                    iOff = ((int)(long)(apDiv[i])) - ((int)(long)(pParent->aData));\n                    if ((iOff + szNew[i]) <= (int)pBt->usableSize) {\n                        memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);\n                        apDiv[i] = &aOvflSpace[apDiv[i] - pParent->aData];\n                    }\n                }\n                dropCell(pParent, i + nxDiv - pParent->nOverflow, szNew[i], &rc);\n            }\n        }\n    nMaxCells = (nMaxCells + 3) & ~3;\n    szScratch = nMaxCells * sizeof(u8 *) + nMaxCells * sizeof(u16) + pBt->pageSize;\n    assert(szScratch <= 7 * (int)pBt->pageSize);\n    b.apCell = sqlite3DbMallocRaw(0, szScratch);\n    if (b.apCell == 0) {\n        rc = 7;\n        goto balance_cleanup;\n    }\n    b.szCell = (u16 *)&b.apCell[nMaxCells];\n    aSpace1 = (u8 *)&b.szCell[nMaxCells];\n    assert(((((char *)(aSpace1) - (char *)0) & 7) == 0));\n    b.pRef = apOld[0];\n    leafCorrection = b.pRef->leaf * 4;\n    leafData = b.pRef->intKeyLeaf;\n    for (i = 0; i < nOld; i++) {\n        MemPage *pOld = apOld[i];\n        int limit = pOld->nCell;\n        u8 *aData = pOld->aData;\n        u16 maskPage = pOld->maskPage;\n        u8 *piCell = aData + pOld->cellOffset;\n        u8 *piEnd;\n        if (pOld->aData[0] != apOld[0]->aData[0]) {\n            rc = sqlite3CorruptError(76127);\n            goto balance_cleanup;\n        }\n        memset(&b.szCell[b.nCell], 0, sizeof (b.szCell[0]) * (limit + pOld->nOverflow));\n        if (pOld->nOverflow > 0) {\n            if ((limit < pOld->aiOvfl[0])) {\n                rc = sqlite3CorruptError(76151);\n                goto balance_cleanup;\n            }\n            limit = pOld->aiOvfl[0];\n            for (j = 0; j < limit; j++) {\n                b.apCell[b.nCell] = aData + (maskPage & ((piCell)[0] << 8 | (piCell)[1]));\n                piCell += 2;\n                b.nCell++;\n            }\n            for (k = 0; k < pOld->nOverflow; k++) {\n                assert(k == 0 || pOld->aiOvfl[k - 1] + 1 == pOld->aiOvfl[k]);\n                b.apCell[b.nCell] = pOld->apOvfl[k];\n                b.nCell++;\n            }\n        }\n        piEnd = aData + pOld->cellOffset + 2 * pOld->nCell;\n        while (piCell < piEnd)\n            {\n                assert(b.nCell < nMaxCells);\n                b.apCell[b.nCell] = aData + (maskPage & ((piCell)[0] << 8 | (piCell)[1]));\n                piCell += 2;\n                b.nCell++;\n            }\n        cntOld[i] = b.nCell;\n        if (i < nOld - 1 && !leafData) {\n            u16 sz = (u16)szNew[i];\n            u8 *pTemp;\n            assert(b.nCell < nMaxCells);\n            b.szCell[b.nCell] = sz;\n            pTemp = &aSpace1[iSpace1];\n            iSpace1 += sz;\n            assert(sz <= pBt->maxLocal + 23);\n            assert(iSpace1 <= (int)pBt->pageSize);\n            memcpy(pTemp, apDiv[i], sz);\n            b.apCell[b.nCell] = pTemp + leafCorrection;\n            assert(leafCorrection == 0 || leafCorrection == 4);\n            b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;\n            if (!pOld->leaf) {\n                assert(leafCorrection == 0);\n                assert(pOld->hdrOffset == 0 || (sqlite3Config.neverCorrupt == 0));\n                memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);\n            } else {\n                assert(leafCorrection == 4);\n                while (b.szCell[b.nCell] < 4)\n                    {\n                        assert(b.szCell[b.nCell] == 3 || (sqlite3Config.neverCorrupt == 0));\n                        assert(b.apCell[b.nCell] == &aSpace1[iSpace1 - 3] || (sqlite3Config.neverCorrupt == 0));\n                        aSpace1[iSpace1++] = 0;\n                        b.szCell[b.nCell]++;\n                    }\n            }\n            b.nCell++;\n        }\n    }\n    usableSpace = pBt->usableSize - 12 + leafCorrection;\n    for (i = k = 0; i < nOld; i++ , k++) {\n        MemPage *p = apOld[i];\n        b.apEnd[k] = p->aDataEnd;\n        b.ixNx[k] = cntOld[i];\n        if (k && b.ixNx[k] == b.ixNx[k - 1]) {\n            k--;\n        }\n        if (!leafData) {\n            k++;\n            b.apEnd[k] = pParent->aDataEnd;\n            b.ixNx[k] = cntOld[i] + 1;\n        }\n        assert(p->nFree >= 0);\n        szNew[i] = usableSpace - p->nFree;\n        for (j = 0; j < p->nOverflow; j++) {\n            szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);\n        }\n        cntNew[i] = cntOld[i];\n    }\n    k = nOld;\n    for (i = 0; i < k; i++) {\n        int sz;\n        while (szNew[i] > usableSpace)\n            {\n                if (i + 1 >= k) {\n                    k = i + 2;\n                    if (k > 3 + 2) {\n                        rc = sqlite3CorruptError(76252);\n                        goto balance_cleanup;\n                    }\n                    szNew[k - 1] = 0;\n                    cntNew[k - 1] = b.nCell;\n                }\n                sz = 2 + cachedCellSize(&b, cntNew[i] - 1);\n                szNew[i] -= sz;\n                if (!leafData) {\n                    if (cntNew[i] < b.nCell) {\n                        sz = 2 + cachedCellSize(&b, cntNew[i]);\n                    } else {\n                        sz = 0;\n                    }\n                }\n                szNew[i + 1] += sz;\n                cntNew[i]--;\n            }\n        while (cntNew[i] < b.nCell)\n            {\n                sz = 2 + cachedCellSize(&b, cntNew[i]);\n                if (szNew[i] + sz > usableSpace)\n                    break;\n                szNew[i] += sz;\n                cntNew[i]++;\n                if (!leafData) {\n                    if (cntNew[i] < b.nCell) {\n                        sz = 2 + cachedCellSize(&b, cntNew[i]);\n                    } else {\n                        sz = 0;\n                    }\n                }\n                szNew[i + 1] -= sz;\n            }\n        if (cntNew[i] >= b.nCell) {\n            k = i + 1;\n        } else if (cntNew[i] <= (i > 0 ? cntNew[i - 1] : 0)) {\n            rc = sqlite3CorruptError(76285);\n            goto balance_cleanup;\n        }\n    }\n    for (i = k - 1; i > 0; i--) {\n        int szRight = szNew[i];\n        int szLeft = szNew[i - 1];\n        int r;\n        int d;\n        r = cntNew[i - 1] - 1;\n        d = r + 1 - leafData;\n        (void)cachedCellSize(&b, d);\n        do {\n            assert(d < nMaxCells);\n            assert(r < nMaxCells);\n            (void)cachedCellSize(&b, r);\n            if (szRight != 0 && (bBulk || szRight + b.szCell[d] + 2 > szLeft - (b.szCell[r] + (i == k - 1 ? 0 : 2)))) {\n                break;\n            }\n            szRight += b.szCell[d] + 2;\n            szLeft -= b.szCell[r] + 2;\n            cntNew[i - 1] = r;\n            r--;\n            d--;\n        } while (r >= 0);\n        szNew[i] = szRight;\n        szNew[i - 1] = szLeft;\n        if (cntNew[i - 1] <= (i > 1 ? cntNew[i - 2] : 0)) {\n            rc = sqlite3CorruptError(76327);\n            goto balance_cleanup;\n        }\n    }\n    assert(cntNew[0] > 0 || (pParent->pgno == 1 && pParent->nCell == 0) || (sqlite3Config.neverCorrupt == 0));\n    ;\n    pageFlags = apOld[0]->aData[0];\n    for (i = 0; i < k; i++) {\n        MemPage *pNew;\n        if (i < nOld) {\n            pNew = apNew[i] = apOld[i];\n            apOld[i] = 0;\n            rc = sqlite3PagerWrite(pNew->pDbPage);\n            nNew++;\n            if (sqlite3PagerPageRefcount(pNew->pDbPage) != 1 + (i == (iParentIdx - nxDiv)) && rc == 0) {\n                rc = sqlite3CorruptError(76360);\n            }\n            if (rc)\n                goto balance_cleanup;\n        } else {\n            assert(i > 0);\n            rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);\n            if (rc)\n                goto balance_cleanup;\n            zeroPage(pNew, pageFlags);\n            apNew[i] = pNew;\n            nNew++;\n            cntOld[i] = b.nCell;\n            if ((pBt->autoVacuum)) {\n                ptrmapPut(pBt, pNew->pgno, 5, pParent->pgno, &rc);\n                if (rc != 0) {\n                    goto balance_cleanup;\n                }\n            }\n        }\n    }\n    for (i = 0; i < nNew; i++) {\n        aPgno[i] = apNew[i]->pgno;\n        assert(apNew[i]->pDbPage->flags & 4);\n        assert(apNew[i]->pDbPage->flags & 2);\n    }\n    for (i = 0; i < nNew - 1; i++) {\n        int iB = i;\n        for (j = i + 1; j < nNew; j++) {\n            if (apNew[j]->pgno < apNew[iB]->pgno)\n                iB = j;\n        }\n        if (iB != i) {\n            Pgno pgnoA = apNew[i]->pgno;\n            Pgno pgnoB = apNew[iB]->pgno;\n            Pgno pgnoTemp = (sqlite3PendingByte / pBt->pageSize) + 1;\n            u16 fgA = apNew[i]->pDbPage->flags;\n            u16 fgB = apNew[iB]->pDbPage->flags;\n            sqlite3PagerRekey(apNew[i]->pDbPage, pgnoTemp, fgB);\n            sqlite3PagerRekey(apNew[iB]->pDbPage, pgnoA, fgA);\n            sqlite3PagerRekey(apNew[i]->pDbPage, pgnoB, fgB);\n            apNew[i]->pgno = pgnoB;\n            apNew[iB]->pgno = pgnoA;\n        }\n    }\n    ;\n    assert(sqlite3PagerIswriteable(pParent->pDbPage));\n    assert(nNew >= 1 && nNew <= ((int)(sizeof (apNew) / sizeof (apNew[0]))));\n    assert(apNew[nNew - 1] != 0);\n    sqlite3Put4byte(pRight, apNew[nNew - 1]->pgno);\n    if ((pageFlags & 8) == 0 && nOld != nNew) {\n        MemPage *pOld = (nNew > nOld ? apNew : apOld)[nOld - 1];\n        memcpy(&apNew[nNew - 1]->aData[8], &pOld->aData[8], 4);\n    }\n    if ((pBt->autoVacuum)) {\n        MemPage *pOld;\n        MemPage *pNew = pOld = apNew[0];\n        int cntOldNext = pNew->nCell + pNew->nOverflow;\n        int iNew = 0;\n        int iOld = 0;\n        for (i = 0; i < b.nCell; i++) {\n            u8 *pCell = b.apCell[i];\n            while (i == cntOldNext)\n                {\n                    iOld++;\n                    assert(iOld < nNew || iOld < nOld);\n                    assert(iOld >= 0 && iOld < 3);\n                    pOld = iOld < nNew ? apNew[iOld] : apOld[iOld];\n                    cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;\n                }\n            if (i == cntNew[iNew]) {\n                pNew = apNew[++iNew];\n                if (!leafData)\n                    continue;\n            }\n            if (iOld >= nNew || pNew->pgno != aPgno[iOld] || !(((uptr)(pCell) >= (uptr)(pOld->aData)) && ((uptr)(pCell) < (uptr)(pOld->aDataEnd)))) {\n                if (!leafCorrection) {\n                    ptrmapPut(pBt, sqlite3Get4byte(pCell), 5, pNew->pgno, &rc);\n                }\n                if (cachedCellSize(&b, i) > pNew->minLocal) {\n                    ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);\n                }\n                if (rc)\n                    goto balance_cleanup;\n            }\n        }\n    }\n    for (i = 0; i < nNew - 1; i++) {\n        u8 *pCell;\n        u8 *pTemp;\n        int sz;\n        u8 *pSrcEnd;\n        MemPage *pNew = apNew[i];\n        j = cntNew[i];\n        assert(j < nMaxCells);\n        assert(b.apCell[j] != 0);\n        pCell = b.apCell[j];\n        sz = b.szCell[j] + leafCorrection;\n        pTemp = &aOvflSpace[iOvflSpace];\n        if (!pNew->leaf) {\n            memcpy(&pNew->aData[8], pCell, 4);\n        } else if (leafData) {\n            CellInfo info;\n            j--;\n            pNew->xParseCell(pNew, b.apCell[j], &info);\n            pCell = pTemp;\n            sz = 4 + sqlite3PutVarint(&pCell[4], info.nKey);\n            pTemp = 0;\n        } else {\n            pCell -= 4;\n            if (b.szCell[j] == 4) {\n                assert(leafCorrection == 4);\n                sz = pParent->xCellSize(pParent, pCell);\n            }\n        }\n        iOvflSpace += sz;\n        assert(sz <= pBt->maxLocal + 23);\n        assert(iOvflSpace <= (int)pBt->pageSize);\n        for (k = 0; b.ixNx[k] <= j && (k < 3 * 2); k++) {\n        }\n        pSrcEnd = b.apEnd[k];\n        if ((((uptr)(pSrcEnd) >= (uptr)(pCell)) && ((uptr)(pSrcEnd) < (uptr)(pCell + sz)))) {\n            rc = sqlite3CorruptError(76560);\n            goto balance_cleanup;\n        }\n        insertCell(pParent, nxDiv + i, pCell, sz, pTemp, pNew->pgno, &rc);\n        if (rc != 0)\n            goto balance_cleanup;\n        assert(sqlite3PagerIswriteable(pParent->pDbPage));\n    }\n    for (i = 1 - nNew; i < nNew; i++) {\n        int iPg = i < 0 ? -i : i;\n        assert(iPg >= 0 && iPg < nNew);\n        if (abDone[iPg])\n            continue;\n        if (i >= 0 || cntOld[iPg - 1] >= cntNew[iPg - 1]) {\n            int iNew;\n            int iOld;\n            int nNewCell;\n            assert(iPg == 0 || cntOld[iPg - 1] >= cntNew[iPg - 1] || abDone[iPg - 1]);\n            assert(cntNew[iPg] >= cntOld[iPg] || abDone[iPg + 1]);\n            if (iPg == 0) {\n                iNew = iOld = 0;\n                nNewCell = cntNew[0];\n            } else {\n                iOld = iPg < nOld ? (cntOld[iPg - 1] + !leafData) : b.nCell;\n                iNew = cntNew[iPg - 1] + !leafData;\n                nNewCell = cntNew[iPg] - iNew;\n            }\n            rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);\n            if (rc)\n                goto balance_cleanup;\n            abDone[iPg]++;\n            apNew[iPg]->nFree = usableSpace - szNew[iPg];\n            assert(apNew[iPg]->nOverflow == 0);\n            assert(apNew[iPg]->nCell == nNewCell);\n        }\n    }\n    assert(memcmp(abDone, \"\\001\\001\\001\\001\\001\", nNew) == 0);\n    assert(nOld > 0);\n    assert(nNew > 0);\n    if (isRoot && pParent->nCell == 0 && pParent->hdrOffset <= apNew[0]->nFree) {\n        assert(nNew == 1 || (sqlite3Config.neverCorrupt == 0));\n        rc = defragmentPage(apNew[0], -1);\n        ;\n        assert(apNew[0]->nFree == ((((((int)((&apNew[0]->aData[5])[0] << 8 | (&apNew[0]->aData[5])[1])) - 1) & 65535) + 1) - apNew[0]->cellOffset - apNew[0]->nCell * 2) || rc != 0);\n        copyNodeContent(apNew[0], pParent, &rc);\n        freePage(apNew[0], &rc);\n    } else if ((pBt->autoVacuum) && !leafCorrection) {\n        for (i = 0; i < nNew; i++) {\n            u32 key = sqlite3Get4byte(&apNew[i]->aData[8]);\n            ptrmapPut(pBt, key, 5, apNew[i]->pgno, &rc);\n        }\n    }\n    assert(pParent->isInit);\n    ;\n    for (i = nNew; i < nOld; i++) {\n        freePage(apOld[i], &rc);\n    }\n  balance_cleanup:\n    sqlite3DbFree(0, b.apCell);\n    for (i = 0; i < nOld; i++) {\n        releasePage(apOld[i]);\n    }\n    for (i = 0; i < nNew; i++) {\n        releasePage(apNew[i]);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#74635:1#freePage2",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    MemPage *pTrunk = 0;\n    Pgno iTrunk = 0;\n    MemPage *pPage1 = pBt->pPage1;\n    MemPage *pPage;\n    int rc;\n    u32 nFree;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert((sqlite3Config.neverCorrupt == 0) || iPage > 1);\n    assert(!pMemPage || pMemPage->pgno == iPage);\n    if (iPage < 2 || iPage > pBt->nPage) {\n        return sqlite3CorruptError(74648);\n    }\n    if (pMemPage) {\n        pPage = pMemPage;\n        sqlite3PagerRef(pPage->pDbPage);\n    } else {\n        pPage = btreePageLookup(pBt, iPage);\n    }\n    rc = sqlite3PagerWrite(pPage1->pDbPage);\n    if (rc)\n        goto freepage_out;\n    nFree = sqlite3Get4byte(&pPage1->aData[36]);\n    sqlite3Put4byte(&pPage1->aData[36], nFree + 1);\n    if (pBt->btsFlags & 4) {\n        if ((!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0)) != 0)) || ((rc = sqlite3PagerWrite(pPage->pDbPage)) != 0)) {\n            goto freepage_out;\n        }\n        memset(pPage->aData, 0, pPage->pBt->pageSize);\n    }\n    if ((pBt->autoVacuum)) {\n        ptrmapPut(pBt, iPage, 2, 0, &rc);\n        if (rc)\n            goto freepage_out;\n    }\n    if (nFree != 0) {\n        u32 nLeaf;\n        iTrunk = sqlite3Get4byte(&pPage1->aData[32]);\n        if (iTrunk > btreePagecount(pBt)) {\n            rc = sqlite3CorruptError(74695);\n            goto freepage_out;\n        }\n        rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);\n        if (rc != 0) {\n            goto freepage_out;\n        }\n        nLeaf = sqlite3Get4byte(&pTrunk->aData[4]);\n        assert(pBt->usableSize > 32);\n        if (nLeaf > (u32)pBt->usableSize / 4 - 2) {\n            rc = sqlite3CorruptError(74706);\n            goto freepage_out;\n        }\n        if (nLeaf < (u32)pBt->usableSize / 4 - 8) {\n            rc = sqlite3PagerWrite(pTrunk->pDbPage);\n            if (rc == 0) {\n                sqlite3Put4byte(&pTrunk->aData[4], nLeaf + 1);\n                sqlite3Put4byte(&pTrunk->aData[8 + nLeaf * 4], iPage);\n                if (pPage && (pBt->btsFlags & 4) == 0) {\n                    sqlite3PagerDontWrite(pPage->pDbPage);\n                }\n                rc = btreeSetHasContent(pBt, iPage);\n            }\n            ;\n            goto freepage_out;\n        }\n    }\n    if (pPage == 0 && 0 != (rc = btreeGetPage(pBt, iPage, &pPage, 0))) {\n        goto freepage_out;\n    }\n    rc = sqlite3PagerWrite(pPage->pDbPage);\n    if (rc != 0) {\n        goto freepage_out;\n    }\n    sqlite3Put4byte(pPage->aData, iTrunk);\n    sqlite3Put4byte(&pPage->aData[4], 0);\n    sqlite3Put4byte(&pPage1->aData[32], iPage);\n    ;\n  freepage_out:\n    if (pPage) {\n        pPage->isInit = 0;\n    }\n    releasePage(pPage);\n    releasePage(pTrunk);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#87902:1#sqlite3Step",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    sqlite3 *db;\n    int rc;\n    assert(p);\n    db = p->db;\n    if (p->eVdbeState != 2) {\n      restart_step:\n        if (p->eVdbeState == 1) {\n            if (p->expired) {\n                p->rc = 17;\n                rc = 1;\n                if ((p->prepFlags & 128) != 0) {\n                    rc = sqlite3VdbeTransferError(p);\n                }\n                goto end_of_step;\n            }\n            if (db->nVdbeActive == 0) {\n                __atomic_store_n((&db->u1.isInterrupted), (0), 0);\n            }\n            assert(db->nVdbeWrite > 0 || db->autoCommit == 0 || (db->nDeferredCons == 0 && db->nDeferredImmCons == 0));\n            if ((db->mTrace & (2 | 128)) != 0 && !db->init.busy && p->zSql) {\n                sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);\n            } else {\n                assert(p->startTime == 0);\n            }\n            db->nVdbeActive++;\n            if (p->readOnly == 0)\n                db->nVdbeWrite++;\n            if (p->bIsReader)\n                db->nVdbeRead++;\n            p->pc = 0;\n            p->eVdbeState = 2;\n        } else if ((p->eVdbeState == 3)) {\n            sqlite3_reset((sqlite3_stmt *)p);\n            assert(p->eVdbeState == 1);\n            goto restart_step;\n        }\n    }\n    if (p->explain) {\n        rc = sqlite3VdbeList(p);\n    } else {\n        db->nVdbeExec++;\n        rc = sqlite3VdbeExec(p);\n        db->nVdbeExec--;\n    }\n    if (rc == 100) {\n        assert(p->rc == 0);\n        assert(db->mallocFailed == 0);\n        db->errCode = 100;\n        return 100;\n    } else {\n        if (((p)->startTime) > 0) {\n            invokeProfileCallback(db, p);\n        }\n        ;\n        if (rc == 101 && db->autoCommit) {\n            assert(p->rc == 0);\n            p->rc = doWalCallbacks(db);\n            if (p->rc != 0) {\n                rc = 1;\n            }\n        } else if (rc != 101 && (p->prepFlags & 128) != 0) {\n            rc = sqlite3VdbeTransferError(p);\n        }\n    }\n    db->errCode = rc;\n    if (7 == sqlite3ApiExit(p->db, p->rc)) {\n        p->rc = 7;\n        if ((p->prepFlags & 128) != 0)\n            rc = p->rc;\n    }\n  end_of_step:\n    assert((p->prepFlags & 128) != 0 || rc == 100 || rc == 101 || rc == 1 || (rc & 255) == 5 || rc == 21);\n    return (rc & db->errMask);\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeIndexMoveto",
    "gotos": 6,
    "labels": 2,
    "body": "{\n    int rc;\n    RecordCompare xRecordCompare;\n    assert(cursorOwnsBtShared(pCur));\n    assert(sqlite3_mutex_held(pCur->pBtree->db->mutex));\n    assert(pRes);\n    assert(pCur->pKeyInfo != 0);\n    xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);\n    pIdxKey->errCode = 0;\n    assert(pIdxKey->default_rc == 1 || pIdxKey->default_rc == 0 || pIdxKey->default_rc == -1);\n    if (pCur->eState == 0 && pCur->pPage->leaf && cursorOnLastPage(pCur)) {\n        int c;\n        if (pCur->ix == pCur->pPage->nCell - 1 && (c = indexCellCompare(pCur, pCur->ix, pIdxKey, xRecordCompare)) <= 0 && pIdxKey->errCode == 0) {\n            *pRes = c;\n            return 0;\n        }\n        if (pCur->iPage > 0 && indexCellCompare(pCur, 0, pIdxKey, xRecordCompare) <= 0 && pIdxKey->errCode == 0) {\n            pCur->curFlags &= ~4;\n            if (!pCur->pPage->isInit) {\n                return sqlite3CorruptError(73922);\n            }\n            goto bypass_moveto_root;\n        }\n        pIdxKey->errCode = 0;\n    }\n    rc = moveToRoot(pCur);\n    if (rc) {\n        if (rc == 16) {\n            assert(pCur->pgnoRoot == 0 || pCur->pPage->nCell == 0);\n            *pRes = -1;\n            return 0;\n        }\n        return rc;\n    }\n  bypass_moveto_root:\n    assert(pCur->pPage);\n    assert(pCur->pPage->isInit);\n    assert(pCur->eState == 0);\n    assert(pCur->pPage->nCell > 0);\n    assert(pCur->curIntKey == 0);\n    assert(pIdxKey != 0);\n    for (;;) {\n        int lwr, upr, idx, c;\n        Pgno chldPg;\n        MemPage *pPage = pCur->pPage;\n        u8 *pCell;\n        assert(pPage->nCell > 0);\n        assert(pPage->intKey == 0);\n        lwr = 0;\n        upr = pPage->nCell - 1;\n        idx = upr >> 1;\n        for (;;) {\n            int nCell;\n            pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n            nCell = pCell[0];\n            if (nCell <= pPage->max1bytePayload) {\n                ;\n                c = xRecordCompare(nCell, (void *)&pCell[1], pIdxKey);\n            } else if (!(pCell[1] & 128) && (nCell = ((nCell & 127) << 7) + pCell[1]) <= pPage->maxLocal) {\n                ;\n                c = xRecordCompare(nCell, (void *)&pCell[2], pIdxKey);\n            } else {\n                void *pCellKey;\n                u8 *const pCellBody = pCell - pPage->childPtrSize;\n                const int nOverrun = 18;\n                pPage->xParseCell(pPage, pCellBody, &pCur->info);\n                nCell = (int)pCur->info.nKey;\n                ;\n                ;\n                ;\n                ;\n                if (nCell < 2 || nCell / pCur->pBt->usableSize > pCur->pBt->nPage) {\n                    rc = sqlite3CorruptError(74009);\n                    goto moveto_index_finish;\n                }\n                pCellKey = sqlite3Malloc(nCell + nOverrun);\n                if (pCellKey == 0) {\n                    rc = 7;\n                    goto moveto_index_finish;\n                }\n                pCur->ix = (u16)idx;\n                rc = accessPayload(pCur, 0, nCell, (unsigned char *)pCellKey, 0);\n                memset(((u8 *)pCellKey) + nCell, 0, nOverrun);\n                pCur->curFlags &= ~4;\n                if (rc) {\n                    sqlite3_free(pCellKey);\n                    goto moveto_index_finish;\n                }\n                c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);\n                sqlite3_free(pCellKey);\n            }\n            assert((pIdxKey->errCode != 11 || c == 0) && (pIdxKey->errCode != 7 || pCur->pBtree->db->mallocFailed));\n            if (c < 0) {\n                lwr = idx + 1;\n            } else if (c > 0) {\n                upr = idx - 1;\n            } else {\n                assert(c == 0);\n                *pRes = 0;\n                rc = 0;\n                pCur->ix = (u16)idx;\n                if (pIdxKey->errCode)\n                    rc = sqlite3CorruptError(74041);\n                goto moveto_index_finish;\n            }\n            if (lwr > upr)\n                break;\n            assert(lwr + upr >= 0);\n            idx = (lwr + upr) >> 1;\n        }\n        assert(lwr == upr + 1 || (pPage->intKey && !pPage->leaf));\n        assert(pPage->isInit);\n        if (pPage->leaf) {\n            assert(pCur->ix < pCur->pPage->nCell || (sqlite3Config.neverCorrupt == 0));\n            pCur->ix = (u16)idx;\n            *pRes = c;\n            rc = 0;\n            goto moveto_index_finish;\n        }\n        if (lwr >= pPage->nCell) {\n            chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset + 8]);\n        } else {\n            chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (lwr)])[0] << 8 | (&(pPage)->aCellIdx[2 * (lwr)])[1]))));\n        }\n        pCur->ix = (u16)lwr;\n        rc = moveToChild(pCur, chldPg);\n        if (rc)\n            break;\n    }\n  moveto_index_finish:\n    pCur->info.nSize = 0;\n    assert((pCur->curFlags & 4) == 0);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3PagerOpen",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    u8 *pPtr;\n    Pager *pPager = 0;\n    int rc = 0;\n    int tempFile = 0;\n    int memDb = 0;\n    int memJM = 0;\n    int readOnly = 0;\n    int journalFileSize;\n    char *zPathname = 0;\n    int nPathname = 0;\n    int useJournal = (flags & 1) == 0;\n    int pcacheSize = sqlite3PcacheSize();\n    u32 szPageDflt = 4096;\n    const char *zUri = 0;\n    int nUriByte = 1;\n    int nUri = 0;\n    journalFileSize = (((sqlite3JournalSize(pVfs)) + 7) & ~7);\n    *ppPager = 0;\n    if (flags & 2) {\n        memDb = 1;\n        if (zFilename && zFilename[0]) {\n            zPathname = sqlite3DbStrDup(0, zFilename);\n            if (zPathname == 0)\n                return 7;\n            nPathname = sqlite3Strlen30(zPathname);\n            zFilename = 0;\n        }\n    }\n    if (zFilename && zFilename[0]) {\n        const char *z;\n        nPathname = pVfs->mxPathname + 1;\n        zPathname = sqlite3DbMallocRaw(0, nPathname * 2);\n        if (zPathname == 0) {\n            return 7;\n        }\n        zPathname[0] = 0;\n        rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);\n        if (rc != 0) {\n            if (rc == (0 | (2 << 8))) {\n                if (vfsFlags & 16777216) {\n                    rc = (14 | (6 << 8));\n                } else {\n                    rc = 0;\n                }\n            }\n        }\n        nPathname = sqlite3Strlen30(zPathname);\n        z = zUri = &zFilename[sqlite3Strlen30(zFilename) + 1];\n        while (*z)\n            {\n                z += strlen(z) + 1;\n                z += strlen(z) + 1;\n                nUri++;\n            }\n        nUriByte = (int)(&z[1] - zUri);\n        assert(nUriByte >= 1);\n        if (rc == 0 && nPathname + 8 > pVfs->mxPathname) {\n            rc = sqlite3CantopenError(59883);\n        }\n        if (rc != 0) {\n            sqlite3DbFree(0, zPathname);\n            return rc;\n        }\n    }\n    pPtr = (u8 *)sqlite3MallocZero((((sizeof (*pPager)) + 7) & ~7) + (((pcacheSize) + 7) & ~7) + (((pVfs->szOsFile) + 7) & ~7) + journalFileSize * 2 + sizeof (pPager) + 4 + nPathname + 1 + nUriByte + nPathname + 8 + 1 + nPathname + 4 + 1 + 3);\n    assert(((((char *)(((void *)(long)(journalFileSize))) - (char *)0) & 7) == 0));\n    if (!pPtr) {\n        sqlite3DbFree(0, zPathname);\n        return 7;\n    }\n    pPager = (Pager *)pPtr;\n    pPtr += (((sizeof (*pPager)) + 7) & ~7);\n    pPager->pPCache = (PCache *)pPtr;\n    pPtr += (((pcacheSize) + 7) & ~7);\n    pPager->fd = (sqlite3_file *)pPtr;\n    pPtr += (((pVfs->szOsFile) + 7) & ~7);\n    pPager->sjfd = (sqlite3_file *)pPtr;\n    pPtr += journalFileSize;\n    pPager->jfd = (sqlite3_file *)pPtr;\n    pPtr += journalFileSize;\n    assert(((((char *)(pPager->jfd) - (char *)0) & 7) == 0));\n    memcpy(pPtr, &pPager, sizeof (pPager));\n    pPtr += sizeof (pPager);\n    pPtr += 4;\n    pPager->zFilename = (char *)pPtr;\n    if (nPathname > 0) {\n        memcpy(pPtr, zPathname, nPathname);\n        pPtr += nPathname + 1;\n        if (zUri) {\n            memcpy(pPtr, zUri, nUriByte);\n            pPtr += nUriByte;\n        } else {\n            pPtr++;\n        }\n    }\n    if (nPathname > 0) {\n        pPager->zJournal = (char *)pPtr;\n        memcpy(pPtr, zPathname, nPathname);\n        pPtr += nPathname;\n        memcpy(pPtr, \"-journal\", 8);\n        pPtr += 8 + 1;\n    } else {\n        pPager->zJournal = 0;\n    }\n    if (nPathname > 0) {\n        pPager->zWal = (char *)pPtr;\n        memcpy(pPtr, zPathname, nPathname);\n        pPtr += nPathname;\n        memcpy(pPtr, \"-wal\", 4);\n        pPtr += 4 + 1;\n    } else {\n        pPager->zWal = 0;\n    }\n    (void)pPtr;\n    if (nPathname)\n        sqlite3DbFree(0, zPathname);\n    pPager->pVfs = pVfs;\n    pPager->vfsFlags = vfsFlags;\n    if (zFilename && zFilename[0]) {\n        int fout = 0;\n        rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);\n        assert(!memDb);\n        pPager->memVfs = memJM = (fout & 128) != 0;\n        readOnly = (fout & 1) != 0;\n        if (rc == 0) {\n            int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);\n            if (!readOnly) {\n                setSectorSize(pPager);\n                assert(4096 <= 8192);\n                if (szPageDflt < pPager->sectorSize) {\n                    if (pPager->sectorSize > 8192) {\n                        szPageDflt = 8192;\n                    } else {\n                        szPageDflt = (u32)pPager->sectorSize;\n                    }\n                }\n            }\n            pPager->noLock = sqlite3_uri_boolean(pPager->zFilename, \"nolock\", 0);\n            if ((iDc & 8192) != 0 || sqlite3_uri_boolean(pPager->zFilename, \"immutable\", 0)) {\n                vfsFlags |= 1;\n                goto act_like_temp_file;\n            }\n        }\n    } else {\n      act_like_temp_file:\n        tempFile = 1;\n        pPager->eState = 1;\n        pPager->eLock = 4;\n        pPager->noLock = 1;\n        readOnly = (vfsFlags & 1);\n    }\n    if (rc == 0) {\n        assert(pPager->memDb == 0);\n        rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);\n        ;\n    }\n    if (rc == 0) {\n        nExtra = (((nExtra) + 7) & ~7);\n        assert(nExtra >= 8 && nExtra < 1000);\n        rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb, !memDb ? pagerStress : 0, (void *)pPager, pPager->pPCache);\n    }\n    if (rc != 0) {\n        sqlite3OsClose(pPager->fd);\n        sqlite3PageFree(pPager->pTmpSpace);\n        sqlite3_free(pPager);\n        return rc;\n    }\n    ;\n    pPager->useJournal = (u8)useJournal;\n    pPager->mxPgno = 1073741823;\n    pPager->tempFile = (u8)tempFile;\n    assert(tempFile == 0 || tempFile == 1);\n    assert(1 == 1);\n    pPager->exclusiveMode = (u8)tempFile;\n    pPager->changeCountDone = pPager->tempFile;\n    pPager->memDb = (u8)memDb;\n    pPager->readOnly = (u8)readOnly;\n    assert(useJournal || pPager->tempFile);\n    pPager->noSync = pPager->tempFile;\n    if (pPager->noSync) {\n        assert(pPager->fullSync == 0);\n        assert(pPager->extraSync == 0);\n        assert(pPager->syncFlags == 0);\n        assert(pPager->walSyncFlags == 0);\n    } else {\n        pPager->fullSync = 1;\n        pPager->extraSync = 0;\n        pPager->syncFlags = 2;\n        pPager->walSyncFlags = 2 | (2 << 2);\n    }\n    pPager->nExtra = (u16)nExtra;\n    pPager->journalSizeLimit = -1;\n    assert(((pPager->fd)->pMethods != 0) || tempFile);\n    setSectorSize(pPager);\n    if (!useJournal) {\n        pPager->journalMode = 2;\n    } else if (memDb || memJM) {\n        pPager->journalMode = 4;\n    }\n    pPager->xReiniter = xReinit;\n    setGetterMethod(pPager);\n    *ppPager = pPager;\n    return 0;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeTableMoveto",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    int rc;\n    assert(cursorOwnsBtShared(pCur));\n    assert(sqlite3_mutex_held(pCur->pBtree->db->mutex));\n    assert(pRes);\n    assert(pCur->pKeyInfo == 0);\n    assert(pCur->eState != 0 || pCur->curIntKey != 0);\n    if (pCur->eState == 0 && (pCur->curFlags & 2) != 0) {\n        if (pCur->info.nKey == intKey) {\n            *pRes = 0;\n            return 0;\n        }\n        if (pCur->info.nKey < intKey) {\n            if ((pCur->curFlags & 8) != 0) {\n                *pRes = -1;\n                return 0;\n            }\n            if (pCur->info.nKey + 1 == intKey) {\n                *pRes = 0;\n                rc = sqlite3BtreeNext(pCur, 0);\n                if (rc == 0) {\n                    getCellInfo(pCur);\n                    if (pCur->info.nKey == intKey) {\n                        return 0;\n                    }\n                } else if (rc != 101) {\n                    return rc;\n                }\n            }\n        }\n    }\n    rc = moveToRoot(pCur);\n    if (rc) {\n        if (rc == 16) {\n            assert(pCur->pgnoRoot == 0 || pCur->pPage->nCell == 0);\n            *pRes = -1;\n            return 0;\n        }\n        return rc;\n    }\n    assert(pCur->pPage);\n    assert(pCur->pPage->isInit);\n    assert(pCur->eState == 0);\n    assert(pCur->pPage->nCell > 0);\n    assert(pCur->iPage == 0 || pCur->apPage[0]->intKey == pCur->curIntKey);\n    assert(pCur->curIntKey);\n    for (;;) {\n        int lwr, upr, idx, c;\n        Pgno chldPg;\n        MemPage *pPage = pCur->pPage;\n        u8 *pCell;\n        assert(pPage->nCell > 0);\n        assert(pPage->intKey);\n        lwr = 0;\n        upr = pPage->nCell - 1;\n        assert(biasRight == 0 || biasRight == 1);\n        idx = upr >> (1 - biasRight);\n        for (;;) {\n            i64 nCellKey;\n            pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n            if (pPage->intKeyLeaf) {\n                while (128 <= *(pCell++))\n                    {\n                        if (pCell >= pPage->aDataEnd) {\n                            return sqlite3CorruptError(73726);\n                        }\n                    }\n            }\n            sqlite3GetVarint(pCell, (u64 *)&nCellKey);\n            if (nCellKey < intKey) {\n                lwr = idx + 1;\n                if (lwr > upr) {\n                    c = -1;\n                    break;\n                }\n            } else if (nCellKey > intKey) {\n                upr = idx - 1;\n                if (lwr > upr) {\n                    c = +1;\n                    break;\n                }\n            } else {\n                assert(nCellKey == intKey);\n                pCur->ix = (u16)idx;\n                if (!pPage->leaf) {\n                    lwr = idx;\n                    goto moveto_table_next_layer;\n                } else {\n                    pCur->curFlags |= 2;\n                    pCur->info.nKey = nCellKey;\n                    pCur->info.nSize = 0;\n                    *pRes = 0;\n                    return 0;\n                }\n            }\n            assert(lwr + upr >= 0);\n            idx = (lwr + upr) >> 1;\n        }\n        assert(lwr == upr + 1 || !pPage->leaf);\n        assert(pPage->isInit);\n        if (pPage->leaf) {\n            assert(pCur->ix < pCur->pPage->nCell);\n            pCur->ix = (u16)idx;\n            *pRes = c;\n            rc = 0;\n            goto moveto_table_finish;\n        }\n      moveto_table_next_layer:\n        if (lwr >= pPage->nCell) {\n            chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset + 8]);\n        } else {\n            chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (lwr)])[0] << 8 | (&(pPage)->aCellIdx[2 * (lwr)])[1]))));\n        }\n        pCur->ix = (u16)lwr;\n        rc = moveToChild(pCur, chldPg);\n        if (rc)\n            break;\n    }\n  moveto_table_finish:\n    pCur->info.nSize = 0;\n    assert((pCur->curFlags & 4) == 0);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#73416:1#moveToRoot",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    MemPage *pRoot;\n    int rc = 0;\n    assert(cursorOwnsBtShared(pCur));\n    assert(1 < 3);\n    assert(0 < 3);\n    assert(4 > 3);\n    assert(pCur->eState < 3 || pCur->iPage < 0);\n    assert(pCur->pgnoRoot > 0 || pCur->iPage < 0);\n    if (pCur->iPage >= 0) {\n        if (pCur->iPage) {\n            releasePageNotNull(pCur->pPage);\n            while (--pCur->iPage)\n                {\n                    releasePageNotNull(pCur->apPage[pCur->iPage]);\n                }\n            pRoot = pCur->pPage = pCur->apPage[0];\n            goto skip_init;\n        }\n    } else if (pCur->pgnoRoot == 0) {\n        pCur->eState = 1;\n        return 16;\n    } else {\n        assert(pCur->iPage == (-1));\n        if (pCur->eState >= 3) {\n            if (pCur->eState == 4) {\n                assert(pCur->skipNext != 0);\n                return pCur->skipNext;\n            }\n            sqlite3BtreeClearCursor(pCur);\n        }\n        rc = getAndInitPage(pCur->pBt, pCur->pgnoRoot, &pCur->pPage, 0, pCur->curPagerFlags);\n        if (rc != 0) {\n            pCur->eState = 1;\n            return rc;\n        }\n        pCur->iPage = 0;\n        pCur->curIntKey = pCur->pPage->intKey;\n    }\n    pRoot = pCur->pPage;\n    assert(pRoot->pgno == pCur->pgnoRoot || (sqlite3Config.neverCorrupt == 0));\n    assert(pRoot->intKey == 1 || pRoot->intKey == 0);\n    if (pRoot->isInit == 0 || (pCur->pKeyInfo == 0) != pRoot->intKey) {\n        return sqlite3CorruptError(73472);\n    }\n  skip_init:\n    pCur->ix = 0;\n    pCur->info.nSize = 0;\n    pCur->curFlags &= ~(8 | 2 | 4);\n    if (pRoot->nCell > 0) {\n        pCur->eState = 0;\n    } else if (!pRoot->leaf) {\n        Pgno subpage;\n        if (pRoot->pgno != 1)\n            return sqlite3CorruptError(73484);\n        subpage = sqlite3Get4byte(&pRoot->aData[pRoot->hdrOffset + 8]);\n        pCur->eState = 0;\n        rc = moveToChild(pCur, subpage);\n    } else {\n        pCur->eState = 1;\n        rc = 16;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#98611:12#sqlite3_blob_open",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    int nAttempt = 0;\n    int iCol;\n    int rc = 0;\n    char *zErr = 0;\n    Table *pTab;\n    Incrblob *pBlob = 0;\n    Parse sParse;\n    *ppBlob = 0;\n    wrFlag = !!wrFlag;\n    sqlite3_mutex_enter(db->mutex);\n    pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));\n    while (1)\n        {\n            sqlite3ParseObjectInit(&sParse, db);\n            if (!pBlob)\n                goto blob_open_out;\n            sqlite3DbFree(db, zErr);\n            zErr = 0;\n            sqlite3BtreeEnterAll(db);\n            pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);\n            if (pTab && ((pTab)->eTabType == 1)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open virtual table: %s\", zTable);\n            }\n            if (pTab && !(((pTab)->tabFlags & 128) == 0)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open table without rowid: %s\", zTable);\n            }\n            if (pTab && ((pTab)->eTabType == 2)) {\n                pTab = 0;\n                sqlite3ErrorMsg(&sParse, \"cannot open view: %s\", zTable);\n            }\n            if (!pTab) {\n                if (sParse.zErrMsg) {\n                    sqlite3DbFree(db, zErr);\n                    zErr = sParse.zErrMsg;\n                    sParse.zErrMsg = 0;\n                }\n                rc = 1;\n                sqlite3BtreeLeaveAll(db);\n                goto blob_open_out;\n            }\n            pBlob->pTab = pTab;\n            pBlob->zDb = db->aDb[sqlite3SchemaToIndex(db, pTab->pSchema)].zDbSName;\n            for (iCol = 0; iCol < pTab->nCol; iCol++) {\n                if (sqlite3StrICmp(pTab->aCol[iCol].zCnName, zColumn) == 0) {\n                    break;\n                }\n            }\n            if (iCol == pTab->nCol) {\n                sqlite3DbFree(db, zErr);\n                zErr = sqlite3MPrintf(db, \"no such column: \\\"%s\\\"\", zColumn);\n                rc = 1;\n                sqlite3BtreeLeaveAll(db);\n                goto blob_open_out;\n            }\n            if (wrFlag) {\n                const char *zFault = 0;\n                Index *pIdx;\n                if (db->flags & 16384) {\n                    FKey *pFKey;\n                    assert(((pTab)->eTabType == 0));\n                    for (pFKey = pTab->u.tab.pFKey; pFKey; pFKey = pFKey->pNextFrom) {\n                        int j;\n                        for (j = 0; j < pFKey->nCol; j++) {\n                            if (pFKey->aCol[j].iFrom == iCol) {\n                                zFault = \"foreign key\";\n                            }\n                        }\n                    }\n                }\n                for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                    int j;\n                    for (j = 0; j < pIdx->nKeyCol; j++) {\n                        if (pIdx->aiColumn[j] == iCol || pIdx->aiColumn[j] == (-2)) {\n                            zFault = \"indexed\";\n                        }\n                    }\n                }\n                if (zFault) {\n                    sqlite3DbFree(db, zErr);\n                    zErr = sqlite3MPrintf(db, \"cannot open %s column for writing\", zFault);\n                    rc = 1;\n                    sqlite3BtreeLeaveAll(db);\n                    goto blob_open_out;\n                }\n            }\n            pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);\n            assert(pBlob->pStmt || db->mallocFailed);\n            if (pBlob->pStmt) {\n                static const int iLn = 0;\n                static const VdbeOpList openBlob[] = {{169, 0, 0, 0}, {112, 0, 0, 0}, {31, 0, 5, 1}, {94, 0, 0, 1}, {84, 1, 0, 0}, {70, 0, 0, 0}};\n                Vdbe *v = (Vdbe *)pBlob->pStmt;\n                int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n                VdbeOp *aOp;\n                sqlite3VdbeAddOp4Int(v, 2, iDb, wrFlag, pTab->pSchema->schema_cookie, pTab->pSchema->iGeneration);\n                sqlite3VdbeChangeP5(v, 1);\n                assert(sqlite3VdbeCurrentAddr(v) == 2 || db->mallocFailed);\n                aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof (openBlob) / sizeof (openBlob[0]))), openBlob, iLn);\n                sqlite3VdbeUsesBtree(v, iDb);\n                if (db->mallocFailed == 0) {\n                    assert(aOp != 0);\n                    aOp[0].p1 = iDb;\n                    aOp[0].p2 = pTab->tnum;\n                    aOp[0].p3 = wrFlag;\n                    sqlite3VdbeChangeP4(v, 2, pTab->zName, 0);\n                }\n                if (db->mallocFailed == 0) {\n                    if (wrFlag)\n                        aOp[1].opcode = 113;\n                    aOp[1].p2 = pTab->tnum;\n                    aOp[1].p3 = iDb;\n                    aOp[1].p4type = (-3);\n                    aOp[1].p4.i = pTab->nCol + 1;\n                    aOp[3].p2 = pTab->nCol;\n                    sParse.nVar = 0;\n                    sParse.nMem = 1;\n                    sParse.nTab = 1;\n                    sqlite3VdbeMakeReady(v, &sParse);\n                }\n            }\n            pBlob->iCol = iCol;\n            pBlob->db = db;\n            sqlite3BtreeLeaveAll(db);\n            if (db->mallocFailed) {\n                goto blob_open_out;\n            }\n            rc = blobSeekToRow(pBlob, iRow, &zErr);\n            if ((++nAttempt) >= 50 || rc != 17)\n                break;\n            sqlite3ParseObjectReset(&sParse);\n        }\n  blob_open_out:\n    if (rc == 0 && db->mallocFailed == 0) {\n        *ppBlob = (sqlite3_blob *)pBlob;\n    } else {\n        if (pBlob && pBlob->pStmt)\n            sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);\n        sqlite3DbFree(db, pBlob);\n    }\n    sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : 0), zErr);\n    sqlite3DbFree(db, zErr);\n    sqlite3ParseObjectReset(&sParse);\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeOpen",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    BtShared *pBt = 0;\n    Btree *p;\n    sqlite3_mutex *mutexOpen = 0;\n    int rc = 0;\n    u8 nReserve;\n    unsigned char zDbHeader[100];\n    const int isTempDb = zFilename == 0 || zFilename[0] == 0;\n    const int isMemdb = (zFilename && strcmp(zFilename, \":memory:\") == 0) || (isTempDb && sqlite3TempInMemory(db)) || (vfsFlags & 128) != 0;\n    assert(db != 0);\n    assert(pVfs != 0);\n    assert(sqlite3_mutex_held(db->mutex));\n    assert((flags & 255) == flags);\n    assert((flags & 8) == 0 || (flags & 4) != 0);\n    assert((flags & 4) == 0 || isTempDb);\n    if (isMemdb) {\n        flags |= 2;\n    }\n    if ((vfsFlags & 256) != 0 && (isMemdb || isTempDb)) {\n        vfsFlags = (vfsFlags & ~256) | 512;\n    }\n    p = sqlite3MallocZero(sizeof(Btree));\n    if (!p) {\n        return 7;\n    }\n    p->inTrans = 0;\n    p->db = db;\n    p->lock.pBtree = p;\n    p->lock.iTable = 1;\n    if (isTempDb == 0 && (isMemdb == 0 || (vfsFlags & 64) != 0)) {\n        if (vfsFlags & 131072) {\n            int nFilename = sqlite3Strlen30(zFilename) + 1;\n            int nFullPathname = pVfs->mxPathname + 1;\n            char *zFullPathname = sqlite3Malloc(((nFullPathname) > (nFilename) ? (nFullPathname) : (nFilename)));\n            sqlite3_mutex *mutexShared;\n            p->sharable = 1;\n            if (!zFullPathname) {\n                sqlite3_free(p);\n                return 7;\n            }\n            if (isMemdb) {\n                memcpy(zFullPathname, zFilename, nFilename);\n            } else {\n                rc = sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname);\n                if (rc) {\n                    if (rc == (0 | (2 << 8))) {\n                        rc = 0;\n                    } else {\n                        sqlite3_free(zFullPathname);\n                        sqlite3_free(p);\n                        return rc;\n                    }\n                }\n            }\n            mutexOpen = sqlite3MutexAlloc(4);\n            sqlite3_mutex_enter(mutexOpen);\n            mutexShared = sqlite3MutexAlloc(2);\n            sqlite3_mutex_enter(mutexShared);\n            for (pBt = sqlite3SharedCacheList; pBt; pBt = pBt->pNext) {\n                assert(pBt->nRef > 0);\n                if (0 == strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0)) && sqlite3PagerVfs(pBt->pPager) == pVfs) {\n                    int iDb;\n                    for (iDb = db->nDb - 1; iDb >= 0; iDb--) {\n                        Btree *pExisting = db->aDb[iDb].pBt;\n                        if (pExisting && pExisting->pBt == pBt) {\n                            sqlite3_mutex_leave(mutexShared);\n                            sqlite3_mutex_leave(mutexOpen);\n                            sqlite3_free(zFullPathname);\n                            sqlite3_free(p);\n                            return 19;\n                        }\n                    }\n                    p->pBt = pBt;\n                    pBt->nRef++;\n                    break;\n                }\n            }\n            sqlite3_mutex_leave(mutexShared);\n            sqlite3_free(zFullPathname);\n        }\n    }\n    if (pBt == 0) {\n        assert(sizeof(i64) == 8);\n        assert(sizeof(u64) == 8);\n        assert(sizeof(u32) == 4);\n        assert(sizeof(u16) == 2);\n        assert(sizeof(Pgno) == 4);\n        pBt = sqlite3MallocZero(sizeof (*pBt));\n        if (pBt == 0) {\n            rc = 7;\n            goto btree_open_out;\n        }\n        rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename, sizeof(MemPage), flags, vfsFlags, pageReinit);\n        if (rc == 0) {\n            sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);\n            rc = sqlite3PagerReadFileheader(pBt->pPager, sizeof (zDbHeader), zDbHeader);\n        }\n        if (rc != 0) {\n            goto btree_open_out;\n        }\n        pBt->openFlags = (u8)flags;\n        pBt->db = db;\n        sqlite3PagerSetBusyHandler(pBt->pPager, btreeInvokeBusyHandler, pBt);\n        p->pBt = pBt;\n        pBt->pCursor = 0;\n        pBt->pPage1 = 0;\n        if (sqlite3PagerIsreadonly(pBt->pPager))\n            pBt->btsFlags |= 1;\n        pBt->pageSize = (zDbHeader[16] << 8) | (zDbHeader[17] << 16);\n        if (pBt->pageSize < 512 || pBt->pageSize > 65536 || ((pBt->pageSize - 1) & pBt->pageSize) != 0) {\n            pBt->pageSize = 0;\n            if (zFilename && !isMemdb) {\n                pBt->autoVacuum = (0 ? 1 : 0);\n                pBt->incrVacuum = (0 == 2 ? 1 : 0);\n            }\n            nReserve = 0;\n        } else {\n            nReserve = zDbHeader[20];\n            pBt->btsFlags |= 2;\n            pBt->autoVacuum = (sqlite3Get4byte(&zDbHeader[36 + 4 * 4]) ? 1 : 0);\n            pBt->incrVacuum = (sqlite3Get4byte(&zDbHeader[36 + 7 * 4]) ? 1 : 0);\n        }\n        rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);\n        if (rc)\n            goto btree_open_out;\n        pBt->usableSize = pBt->pageSize - nReserve;\n        assert((pBt->pageSize & 7) == 0);\n        pBt->nRef = 1;\n        if (p->sharable) {\n            sqlite3_mutex *mutexShared;\n            mutexShared = sqlite3MutexAlloc(2);\n            if (1 && sqlite3Config.bCoreMutex) {\n                pBt->mutex = sqlite3MutexAlloc(0);\n                if (pBt->mutex == 0) {\n                    rc = 7;\n                    goto btree_open_out;\n                }\n            }\n            sqlite3_mutex_enter(mutexShared);\n            pBt->pNext = sqlite3SharedCacheList;\n            sqlite3SharedCacheList = pBt;\n            sqlite3_mutex_leave(mutexShared);\n        }\n    }\n    if (p->sharable) {\n        int i;\n        Btree *pSib;\n        for (i = 0; i < db->nDb; i++) {\n            if ((pSib = db->aDb[i].pBt) != 0 && pSib->sharable) {\n                while (pSib->pPrev)\n                    {\n                        pSib = pSib->pPrev;\n                    }\n                if ((uptr)p->pBt < (uptr)pSib->pBt) {\n                    p->pNext = pSib;\n                    p->pPrev = 0;\n                    pSib->pPrev = p;\n                } else {\n                    while (pSib->pNext && (uptr)pSib->pNext->pBt < (uptr)p->pBt)\n                        {\n                            pSib = pSib->pNext;\n                        }\n                    p->pNext = pSib->pNext;\n                    p->pPrev = pSib;\n                    if (p->pNext) {\n                        p->pNext->pPrev = p;\n                    }\n                    pSib->pNext = p;\n                }\n                break;\n            }\n        }\n    }\n    *ppBtree = p;\n  btree_open_out:\n    if (rc != 0) {\n        if (pBt && pBt->pPager) {\n            sqlite3PagerClose(pBt->pPager, 0);\n        }\n        sqlite3_free(pBt);\n        sqlite3_free(p);\n        *ppBtree = 0;\n    } else {\n        sqlite3_file *pFile;\n        if (sqlite3BtreeSchema(p, 0, 0) == 0) {\n            sqlite3BtreeSetCacheSize(p, -2000);\n        }\n        pFile = sqlite3PagerFile(pBt->pPager);\n        if (pFile->pMethods) {\n            sqlite3OsFileControlHint(pFile, 30, (void *)&pBt->db);\n        }\n    }\n    if (mutexOpen) {\n        assert(sqlite3_mutex_held(mutexOpen));\n        sqlite3_mutex_leave(mutexOpen);\n    }\n    assert(rc != 0 || sqlite3BtreeConnectionCount(*ppBtree) > 0);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#70334:1#getAndInitPage",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    int rc;\n    DbPage *pDbPage;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(pCur == 0 || ppPage == &pCur->pPage);\n    assert(pCur == 0 || bReadOnly == pCur->curPagerFlags);\n    assert(pCur == 0 || pCur->iPage > 0);\n    if (pgno > btreePagecount(pBt)) {\n        rc = sqlite3CorruptError(70349);\n        goto getAndInitPage_error1;\n    }\n    rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage **)&pDbPage, bReadOnly);\n    if (rc) {\n        goto getAndInitPage_error1;\n    }\n    *ppPage = (MemPage *)sqlite3PagerGetExtra(pDbPage);\n    if ((*ppPage)->isInit == 0) {\n        btreePageFromDbPage(pDbPage, pgno, pBt);\n        rc = btreeInitPage(*ppPage);\n        if (rc != 0) {\n            goto getAndInitPage_error2;\n        }\n    }\n    assert((*ppPage)->pgno == pgno || (sqlite3Config.neverCorrupt == 0));\n    assert((*ppPage)->aData == sqlite3PagerGetData(pDbPage));\n    if (pCur && ((*ppPage)->nCell < 1 || (*ppPage)->intKey != pCur->curIntKey)) {\n        rc = sqlite3CorruptError(70370);\n        goto getAndInitPage_error2;\n    }\n    return 0;\n  getAndInitPage_error2:\n    releasePage(*ppPage);\n  getAndInitPage_error1:\n    if (pCur) {\n        pCur->iPage--;\n        pCur->pPage = pCur->apPage[pCur->iPage];\n    }\n    ;\n    assert(pgno != 0 || rc != 0);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#69569:1#defragmentPage",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int i;\n    int pc;\n    int hdr;\n    int size;\n    int usableSize;\n    int cellOffset;\n    int cbrk;\n    int nCell;\n    unsigned char *data;\n    unsigned char *temp;\n    unsigned char *src;\n    int iCellFirst;\n    int iCellLast;\n    int iCellStart;\n    assert(sqlite3PagerIswriteable(pPage->pDbPage));\n    assert(pPage->pBt != 0);\n    assert(pPage->pBt->usableSize <= 65536);\n    assert(pPage->nOverflow == 0);\n    assert(sqlite3_mutex_held(pPage->pBt->mutex));\n    data = pPage->aData;\n    hdr = pPage->hdrOffset;\n    cellOffset = pPage->cellOffset;\n    nCell = pPage->nCell;\n    assert(nCell == ((&data[hdr + 3])[0] << 8 | (&data[hdr + 3])[1]) || (sqlite3Config.neverCorrupt == 0));\n    iCellFirst = cellOffset + 2 * nCell;\n    usableSize = pPage->pBt->usableSize;\n    if ((int)data[hdr + 7] <= nMaxFrag) {\n        int iFree = ((&data[hdr + 1])[0] << 8 | (&data[hdr + 1])[1]);\n        if (iFree > usableSize - 4)\n            return sqlite3CorruptError(69605);\n        if (iFree) {\n            int iFree2 = ((&data[iFree])[0] << 8 | (&data[iFree])[1]);\n            if (iFree2 > usableSize - 4)\n                return sqlite3CorruptError(69608);\n            if (0 == iFree2 || (data[iFree2] == 0 && data[iFree2 + 1] == 0)) {\n                u8 *pEnd = &data[cellOffset + nCell * 2];\n                u8 *pAddr;\n                int sz2 = 0;\n                int sz = ((&data[iFree + 2])[0] << 8 | (&data[iFree + 2])[1]);\n                int top = ((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);\n                if (top >= iFree) {\n                    return sqlite3CorruptError(69616);\n                }\n                if (iFree2) {\n                    if (iFree + sz > iFree2)\n                        return sqlite3CorruptError(69619);\n                    sz2 = ((&data[iFree2 + 2])[0] << 8 | (&data[iFree2 + 2])[1]);\n                    if (iFree2 + sz2 > usableSize)\n                        return sqlite3CorruptError(69621);\n                    memmove(&data[iFree + sz + sz2], &data[iFree + sz], iFree2 - (iFree + sz));\n                    sz += sz2;\n                } else if (iFree + sz > usableSize) {\n                    return sqlite3CorruptError(69625);\n                }\n                cbrk = top + sz;\n                assert(cbrk + (iFree - top) <= usableSize);\n                memmove(&data[cbrk], &data[top], iFree - top);\n                for (pAddr = &data[cellOffset]; pAddr < pEnd; pAddr += 2) {\n                    pc = ((pAddr)[0] << 8 | (pAddr)[1]);\n                    if (pc < iFree) {\n                        ((pAddr)[0] = (u8)((pc + sz) >> 8) , (pAddr)[1] = (u8)(pc + sz));\n                    } else if (pc < iFree2) {\n                        ((pAddr)[0] = (u8)((pc + sz2) >> 8) , (pAddr)[1] = (u8)(pc + sz2));\n                    }\n                }\n                goto defragment_out;\n            }\n        }\n    }\n    cbrk = usableSize;\n    iCellLast = usableSize - 4;\n    iCellStart = ((&data[hdr + 5])[0] << 8 | (&data[hdr + 5])[1]);\n    if (nCell > 0) {\n        temp = sqlite3PagerTempSpace(pPage->pBt->pPager);\n        memcpy(&temp[iCellStart], &data[iCellStart], usableSize - iCellStart);\n        src = temp;\n        for (i = 0; i < nCell; i++) {\n            u8 *pAddr;\n            pAddr = &data[cellOffset + i * 2];\n            pc = ((pAddr)[0] << 8 | (pAddr)[1]);\n            ;\n            ;\n            if (pc < iCellStart || pc > iCellLast) {\n                return sqlite3CorruptError(69658);\n            }\n            assert(pc >= iCellStart && pc <= iCellLast);\n            size = pPage->xCellSize(pPage, &src[pc]);\n            cbrk -= size;\n            if (cbrk < iCellStart || pc + size > usableSize) {\n                return sqlite3CorruptError(69664);\n            }\n            assert(cbrk + size <= usableSize && cbrk >= iCellStart);\n            ;\n            ;\n            ((pAddr)[0] = (u8)((cbrk) >> 8) , (pAddr)[1] = (u8)(cbrk));\n            memcpy(&data[cbrk], &src[pc], size);\n        }\n    }\n    data[hdr + 7] = 0;\n  defragment_out:\n    assert(pPage->nFree >= 0);\n    if (data[hdr + 7] + cbrk - iCellFirst != pPage->nFree) {\n        return sqlite3CorruptError(69678);\n    }\n    assert(cbrk >= iCellFirst);\n    ((&data[hdr + 5])[0] = (u8)((cbrk) >> 8) , (&data[hdr + 5])[1] = (u8)(cbrk));\n    data[hdr + 1] = 0;\n    data[hdr + 2] = 0;\n    memset(&data[iCellFirst], 0, cbrk - iCellFirst);\n    assert(sqlite3PagerIswriteable(pPage->pDbPage));\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#69069:1#ptrmapPut",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    DbPage *pDbPage;\n    u8 *pPtrmap;\n    Pgno iPtrmap;\n    int offset;\n    int rc;\n    if (*pRC)\n        return;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(0 == (ptrmapPageno((pBt), (((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)))) == (((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)))));\n    assert(pBt->autoVacuum);\n    if (key == 0) {\n        *pRC = sqlite3CorruptError(69084);\n        return;\n    }\n    iPtrmap = ptrmapPageno(pBt, key);\n    rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);\n    if (rc != 0) {\n        *pRC = rc;\n        return;\n    }\n    if (((char *)sqlite3PagerGetExtra(pDbPage))[0] != 0) {\n        *pRC = sqlite3CorruptError(69097);\n        goto ptrmap_exit;\n    }\n    offset = (5 * (key - iPtrmap - 1));\n    if (offset < 0) {\n        *pRC = sqlite3CorruptError(69102);\n        goto ptrmap_exit;\n    }\n    assert(offset <= (int)pBt->usableSize - 5);\n    pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);\n    if (eType != pPtrmap[offset] || sqlite3Get4byte(&pPtrmap[offset + 1]) != parent) {\n        ;\n        *pRC = rc = sqlite3PagerWrite(pDbPage);\n        if (rc == 0) {\n            pPtrmap[offset] = eType;\n            sqlite3Put4byte(&pPtrmap[offset + 1], parent);\n        }\n    }\n  ptrmap_exit:\n    sqlite3PagerUnref(pDbPage);\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeBeginTrans",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    BtShared *pBt = p->pBt;\n    Pager *pPager = pBt->pPager;\n    int rc = 0;\n    sqlite3BtreeEnter(p);\n    assert(p->pBt->inTransaction != 0 || p->pBt->nTransaction == 0);\n    assert(p->pBt->inTransaction >= p->inTrans);\n    ;\n    if (p->inTrans == 2 || (p->inTrans == 1 && !wrflag)) {\n        goto trans_begun;\n    }\n    assert(pBt->inTransaction == 2 || (pBt->bDoTruncate) == 0);\n    if ((p->db->flags & 33554432) && sqlite3PagerIsreadonly(pPager) == 0) {\n        pBt->btsFlags &= ~1;\n    }\n    if ((pBt->btsFlags & 1) != 0 && wrflag) {\n        rc = 8;\n        goto trans_begun;\n    }\n    {\n        sqlite3 *pBlock = 0;\n        if ((wrflag && pBt->inTransaction == 2) || (pBt->btsFlags & 128) != 0) {\n            pBlock = pBt->pWriter->db;\n        } else if (wrflag > 1) {\n            BtLock *pIter;\n            for (pIter = pBt->pLock; pIter; pIter = pIter->pNext) {\n                if (pIter->pBtree != p) {\n                    pBlock = pIter->pBtree->db;\n                    break;\n                }\n            }\n        }\n        if (pBlock) {\n            ;\n            rc = (6 | (1 << 8));\n            goto trans_begun;\n        }\n    }\n    rc = querySharedCacheTableLock(p, 1, 1);\n    if (0 != rc)\n        goto trans_begun;\n    pBt->btsFlags &= ~16;\n    if (pBt->nPage == 0)\n        pBt->btsFlags |= 16;\n    do {\n        ;\n        while (pBt->pPage1 == 0 && 0 == (rc = lockBtree(pBt)))\n            ;\n        if (rc == 0 && wrflag) {\n            if ((pBt->btsFlags & 1) != 0) {\n                rc = 8;\n            } else {\n                rc = sqlite3PagerBegin(pPager, wrflag > 1, sqlite3TempInMemory(p->db));\n                if (rc == 0) {\n                    rc = newDatabase(pBt);\n                } else if (rc == (5 | (2 << 8)) && pBt->inTransaction == 0) {\n                    rc = 5;\n                }\n            }\n        }\n        if (rc != 0) {\n            (void)0;\n            unlockBtreeIfUnused(pBt);\n        }\n    } while ((rc & 255) == 5 && pBt->inTransaction == 0 && btreeInvokeBusyHandler(pBt));\n    ;\n    if (rc == 0) {\n        if (p->inTrans == 0) {\n            pBt->nTransaction++;\n            if (p->sharable) {\n                assert(p->lock.pBtree == p && p->lock.iTable == 1);\n                p->lock.eLock = 1;\n                p->lock.pNext = pBt->pLock;\n                pBt->pLock = &p->lock;\n            }\n        }\n        p->inTrans = (wrflag ? 2 : 1);\n        if (p->inTrans > pBt->inTransaction) {\n            pBt->inTransaction = p->inTrans;\n        }\n        if (wrflag) {\n            MemPage *pPage1 = pBt->pPage1;\n            assert(!pBt->pWriter);\n            pBt->pWriter = p;\n            pBt->btsFlags &= ~64;\n            if (wrflag > 1)\n                pBt->btsFlags |= 64;\n            if (pBt->nPage != sqlite3Get4byte(&pPage1->aData[28])) {\n                rc = sqlite3PagerWrite(pPage1->pDbPage);\n                if (rc == 0) {\n                    sqlite3Put4byte(&pPage1->aData[28], pBt->nPage);\n                }\n            }\n        }\n    }\n  trans_begun:\n    if (rc == 0) {\n        if (pSchemaVersion) {\n            *pSchemaVersion = sqlite3Get4byte(&pBt->pPage1->aData[40]);\n        }\n        if (wrflag) {\n            rc = sqlite3PagerOpenSavepoint(pPager, p->db->nSavepoint);\n        }\n    }\n    assert(p->pBt->inTransaction != 0 || p->pBt->nTransaction == 0);\n    assert(p->pBt->inTransaction >= p->inTrans);\n    ;\n    sqlite3BtreeLeave(p);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#174354:1#createFunctionApi",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int rc = 1;\n    FuncDestructor *pArg = 0;\n    sqlite3_mutex_enter(db->mutex);\n    if (xDestroy) {\n        pArg = (FuncDestructor *)sqlite3Malloc(sizeof(FuncDestructor));\n        if (!pArg) {\n            sqlite3OomFault(db);\n            xDestroy(p);\n            goto out;\n        }\n        pArg->nRef = 0;\n        pArg->xDestroy = xDestroy;\n        pArg->pUserData = p;\n    }\n    rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, xValue, xInverse, pArg);\n    if (pArg && pArg->nRef == 0) {\n        assert(rc != 0 || (xStep == 0 && xFinal == 0));\n        xDestroy(p);\n        sqlite3_free(pArg);\n    }\n  out:\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3PagerCommitPhaseOne",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    assert(pPager->eState == 2 || pPager->eState == 3 || pPager->eState == 4 || pPager->eState == 6);\n    assert(assert_pager_state(pPager));\n    if ((pPager->errCode))\n        return pPager->errCode;\n    if (sqlite3FaultSim(400))\n        return 10;\n    ;\n    if (pPager->eState < 3)\n        return 0;\n    assert(pPager->memDb == 0 || pPager->tempFile);\n    assert(((pPager->fd)->pMethods != 0) || pPager->tempFile);\n    if (0 == pagerFlushOnCommit(pPager, 1)) {\n        sqlite3BackupRestart(pPager->pBackup);\n    } else {\n        PgHdr *pList;\n        if (((pPager)->pWal != 0)) {\n            PgHdr *pPageOne = 0;\n            pList = sqlite3PcacheDirtyList(pPager->pPCache);\n            if (pList == 0) {\n                rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);\n                pList = pPageOne;\n                pList->pDirty = 0;\n            }\n            assert(rc == 0);\n            if ((pList)) {\n                rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);\n            }\n            sqlite3PagerUnref(pPageOne);\n            if (rc == 0) {\n                sqlite3PcacheCleanAll(pPager->pPCache);\n            }\n        } else {\n            rc = pager_incr_changecounter(pPager, 0);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            rc = writeSuperJournal(pPager, zSuper);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            rc = syncJournal(pPager, 0);\n            if (rc != 0)\n                goto commit_phase_one_exit;\n            pList = sqlite3PcacheDirtyList(pPager->pPCache);\n            if (0 == 0) {\n                rc = pager_write_pagelist(pPager, pList);\n            }\n            if (rc != 0) {\n                assert(rc != (10 | (11 << 8)));\n                goto commit_phase_one_exit;\n            }\n            sqlite3PcacheCleanAll(pPager->pPCache);\n            if (pPager->dbSize > pPager->dbFileSize) {\n                Pgno nNew = pPager->dbSize - (pPager->dbSize == ((pPager)->lckPgno));\n                assert(pPager->eState == 4);\n                rc = pager_truncate(pPager, nNew);\n                if (rc != 0)\n                    goto commit_phase_one_exit;\n            }\n            if (!noSync) {\n                rc = sqlite3PagerSync(pPager, zSuper);\n            }\n        }\n    }\n  commit_phase_one_exit:\n    if (rc == 0 && !((pPager)->pWal != 0)) {\n        pPager->eState = 5;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Select",
    "gotos": 12,
    "labels": 1,
    "body": "{\n    int i, j;\n    WhereInfo *pWInfo;\n    Vdbe *v;\n    int isAgg;\n    ExprList *pEList = 0;\n    SrcList *pTabList;\n    Expr *pWhere;\n    ExprList *pGroupBy;\n    Expr *pHaving;\n    AggInfo *pAggInfo = 0;\n    int rc = 1;\n    DistinctCtx sDistinct;\n    SortCtx sSort;\n    int iEnd;\n    sqlite3 *db;\n    ExprList *pMinMaxOrderBy = 0;\n    u8 minMaxFlag;\n    db = pParse->db;\n    assert(pParse == db->pParse);\n    v = sqlite3GetVdbe(pParse);\n    if (p == 0 || pParse->nErr) {\n        return 1;\n    }\n    assert(db->mallocFailed == 0);\n    if (sqlite3AuthCheck(pParse, 21, 0, 0, 0))\n        return 1;\n    assert(p->pOrderBy == 0 || pDest->eDest != 5);\n    assert(p->pOrderBy == 0 || pDest->eDest != 8);\n    assert(p->pOrderBy == 0 || pDest->eDest != 6);\n    assert(p->pOrderBy == 0 || pDest->eDest != 7);\n    if (((pDest->eDest) <= 6)) {\n        assert(pDest->eDest == 3 || pDest->eDest == 1 || pDest->eDest == 2 || pDest->eDest == 4 || pDest->eDest == 6 || pDest->eDest == 5);\n        if (p->pOrderBy) {\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3ExprListDelete, p->pOrderBy);\n            ;\n            p->pOrderBy = 0;\n        }\n        p->selFlags &= ~1;\n        p->selFlags |= 4194304;\n    }\n    sqlite3SelectPrep(pParse, p, 0);\n    if (pParse->nErr) {\n        goto select_end;\n    }\n    assert(db->mallocFailed == 0);\n    assert(p->pEList != 0);\n    if (p->selFlags & 8388608) {\n        SrcItem *p0 = &p->pSrc->a[0];\n        if (sameSrcAlias(p0, p->pSrc)) {\n            sqlite3ErrorMsg(pParse, \"target object/alias may not appear in FROM clause: %s\", p0->zAlias ? p0->zAlias : p0->pTab->zName);\n            goto select_end;\n        }\n        p->selFlags &= ~8388608;\n    }\n    if (pDest->eDest == 9) {\n        sqlite3GenerateColumnNames(pParse, p);\n    }\n    if (sqlite3WindowRewrite(pParse, p)) {\n        assert(pParse->nErr);\n        goto select_end;\n    }\n    pTabList = p->pSrc;\n    isAgg = (p->selFlags & 8) != 0;\n    memset(&sSort, 0, sizeof (sSort));\n    sSort.pOrderBy = p->pOrderBy;\n    for (i = 0; !p->pPrior && i < pTabList->nSrc; i++) {\n        SrcItem *pItem = &pTabList->a[i];\n        Select *pSub = pItem->pSelect;\n        Table *pTab = pItem->pTab;\n        assert(pTab != 0);\n        if ((pItem->fg.jointype & (8 | 16)) == 8 && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor) && (((db)->dbOptFlags & (8192)) == 0)) {\n            ;\n            pItem->fg.jointype &= ~(8 | 32);\n            assert(pItem->iCursor >= 0);\n            unsetJoinExpr(p->pWhere, pItem->iCursor, pTabList->a[0].fg.jointype & 64);\n        }\n        if (pSub == 0)\n            continue;\n        if (pTab->nCol != pSub->pEList->nExpr) {\n            sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\", pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n            goto select_end;\n        }\n        if ((pSub->selFlags & 8) != 0)\n            continue;\n        assert(pSub->pGroupBy == 0);\n        if (pSub->pOrderBy != 0 && (p->pOrderBy != 0 || pTabList->nSrc > 1) && pSub->pLimit == 0 && (pSub->selFlags & 134217728) == 0 && (p->selFlags & 134217728) == 0 && (((db)->dbOptFlags & (262144)) == 0)) {\n            ;\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))sqlite3ExprListDelete, pSub->pOrderBy);\n            pSub->pOrderBy = 0;\n        }\n        if (pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (32 | 2)) != 0)) {\n            continue;\n        }\n        if (flattenSubquery(pParse, p, i, isAgg)) {\n            if (pParse->nErr)\n                goto select_end;\n            i = -1;\n        }\n        pTabList = p->pSrc;\n        if (db->mallocFailed)\n            goto select_end;\n        if (!((pDest->eDest) <= 8)) {\n            sSort.pOrderBy = p->pOrderBy;\n        }\n    }\n    if (p->pPrior) {\n        rc = multiSelect(pParse, p, pDest);\n        if (p->pNext == 0)\n            sqlite3VdbeExplainPop(pParse);\n        return rc;\n    }\n    if (p->pWhere != 0 && p->pWhere->op == 44 && (((db)->dbOptFlags & (32768)) == 0) && propagateConstants(pParse, p)) {\n    } else {\n        ;\n    }\n    for (i = 0; i < pTabList->nSrc; i++) {\n        SrcItem *pItem = &pTabList->a[i];\n        SrcItem *pPrior;\n        SelectDest dest;\n        Select *pSub;\n        const char *zSavedAuthContext;\n        if (pItem->colUsed == 0 && pItem->zName != 0) {\n            sqlite3AuthCheck(pParse, 20, pItem->zName, \"\", pItem->zDatabase);\n        }\n        pSub = pItem->pSelect;\n        if (pSub == 0)\n            continue;\n        assert(pItem->addrFillSub == 0);\n        pParse->nHeight += sqlite3SelectExprHeight(p);\n        if ((((db)->dbOptFlags & (4096)) == 0) && (pItem->fg.isCte == 0 || (pItem->u2.pCteUse->eM10d != 0 && pItem->u2.pCteUse->nUse < 2)) && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem)) {\n            assert(pItem->pSelect && (pItem->pSelect->selFlags & 16777216) != 0);\n        } else {\n            ;\n        }\n        zSavedAuthContext = pParse->zAuthContext;\n        pParse->zAuthContext = pItem->zName;\n        if (i == 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (32 | 2)) != 0) && (pItem->fg.isCte == 0 || pItem->u2.pCteUse->eM10d != 0) && (pTabList->a[0].fg.jointype & 64) == 0) {\n            int addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n            pItem->regReturn = ++pParse->nMem;\n            sqlite3VdbeAddOp3(v, 11, pItem->regReturn, 0, addrTop);\n            ;\n            pItem->addrFillSub = addrTop;\n            sqlite3SelectDestInit(&dest, 13, pItem->regReturn);\n            sqlite3VdbeExplain(pParse, 1, \"CO-ROUTINE %!S\", pItem);\n            sqlite3Select(pParse, pSub, &dest);\n            pItem->pTab->nRowLogEst = pSub->nSelectRow;\n            pItem->fg.viaCoroutine = 1;\n            pItem->regResult = dest.iSdst;\n            sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n            sqlite3VdbeJumpHere(v, addrTop - 1);\n            sqlite3ClearTempRegCache(pParse);\n        } else if (pItem->fg.isCte && pItem->u2.pCteUse->addrM9e > 0) {\n            CteUse *pCteUse = pItem->u2.pCteUse;\n            sqlite3VdbeAddOp2(v, 10, pCteUse->regRtn, pCteUse->addrM9e);\n            if (pItem->iCursor != pCteUse->iCur) {\n                sqlite3VdbeAddOp2(v, 115, pItem->iCursor, pCteUse->iCur);\n                ;\n            }\n            pSub->nSelectRow = pCteUse->nRowEst;\n        } else if ((pPrior = isSelfJoinView(pTabList, pItem)) != 0) {\n            if (pPrior->addrFillSub) {\n                sqlite3VdbeAddOp2(v, 10, pPrior->regReturn, pPrior->addrFillSub);\n            }\n            sqlite3VdbeAddOp2(v, 115, pItem->iCursor, pPrior->iCursor);\n            pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n        } else {\n            int topAddr;\n            int onceAddr = 0;\n            pItem->regReturn = ++pParse->nMem;\n            topAddr = sqlite3VdbeAddOp0(v, 9);\n            pItem->addrFillSub = topAddr + 1;\n            pItem->fg.isMaterialized = 1;\n            if (pItem->fg.isCorrelated == 0) {\n                onceAddr = sqlite3VdbeAddOp0(v, 15);\n                ;\n                ;\n            } else {\n                ;\n            }\n            sqlite3SelectDestInit(&dest, 12, pItem->iCursor);\n            sqlite3VdbeExplain(pParse, 1, \"MATERIALIZE %!S\", pItem);\n            dest.zAffSdst = sqlite3TableAffinityStr(db, pItem->pTab);\n            sqlite3Select(pParse, pSub, &dest);\n            sqlite3DbFree(db, dest.zAffSdst);\n            dest.zAffSdst = 0;\n            pItem->pTab->nRowLogEst = pSub->nSelectRow;\n            if (onceAddr)\n                sqlite3VdbeJumpHere(v, onceAddr);\n            sqlite3VdbeAddOp2(v, 67, pItem->regReturn, topAddr + 1);\n            ;\n            sqlite3VdbeJumpHere(v, topAddr);\n            sqlite3ClearTempRegCache(pParse);\n            if (pItem->fg.isCte && pItem->fg.isCorrelated == 0) {\n                CteUse *pCteUse = pItem->u2.pCteUse;\n                pCteUse->addrM9e = pItem->addrFillSub;\n                pCteUse->regRtn = pItem->regReturn;\n                pCteUse->iCur = pItem->iCursor;\n                pCteUse->nRowEst = pSub->nSelectRow;\n            }\n        }\n        if (db->mallocFailed)\n            goto select_end;\n        pParse->nHeight -= sqlite3SelectExprHeight(p);\n        pParse->zAuthContext = zSavedAuthContext;\n    }\n    pEList = p->pEList;\n    pWhere = p->pWhere;\n    pGroupBy = p->pGroupBy;\n    pHaving = p->pHaving;\n    sDistinct.isTnct = (p->selFlags & 1) != 0;\n    if ((p->selFlags & (1 | 8)) == 1 && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1) == 0 && p->pWin == 0) {\n        p->selFlags &= ~1;\n        pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n        p->selFlags |= 8;\n        assert(sDistinct.isTnct);\n        sDistinct.isTnct = 2;\n    }\n    if (sSort.pOrderBy) {\n        KeyInfo *pKeyInfo;\n        pKeyInfo = sqlite3KeyInfoFromExprList(pParse, sSort.pOrderBy, 0, pEList->nExpr);\n        sSort.iECursor = pParse->nTab++;\n        sSort.addrSortIndex = sqlite3VdbeAddOp4(v, 118, sSort.iECursor, sSort.pOrderBy->nExpr + 1 + pEList->nExpr, 0, (char *)pKeyInfo, (-8));\n    } else {\n        sSort.addrSortIndex = -1;\n    }\n    if (pDest->eDest == 12) {\n        sqlite3VdbeAddOp2(v, 118, pDest->iSDParm, pEList->nExpr);\n        if (p->selFlags & 2048) {\n            int ii;\n            for (ii = pEList->nExpr - 1; ii > 0 && pEList->a[ii].fg.bUsed == 0; ii--) {\n                sqlite3ExprDelete(db, pEList->a[ii].pExpr);\n                sqlite3DbFree(db, pEList->a[ii].zEName);\n                pEList->nExpr--;\n            }\n            for (ii = 0; ii < pEList->nExpr; ii++) {\n                if (pEList->a[ii].fg.bUsed == 0)\n                    pEList->a[ii].pExpr->op = 121;\n            }\n        }\n    }\n    iEnd = sqlite3VdbeMakeLabel(pParse);\n    if ((p->selFlags & 16384) == 0) {\n        p->nSelectRow = 320;\n    }\n    if (p->pLimit)\n        computeLimitRegisters(pParse, p, iEnd);\n    if (p->iLimit == 0 && sSort.addrSortIndex >= 0) {\n        sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, 119);\n        sSort.sortFlags |= 1;\n    }\n    if (p->selFlags & 1) {\n        sDistinct.tabTnct = pParse->nTab++;\n        sDistinct.addrTnct = sqlite3VdbeAddOp4(v, 118, sDistinct.tabTnct, 0, 0, (char *)sqlite3KeyInfoFromExprList(pParse, p->pEList, 0, 0), (-8));\n        sqlite3VdbeChangeP5(v, 8);\n        sDistinct.eTnctType = 3;\n    } else {\n        sDistinct.eTnctType = 0;\n    }\n    if (!isAgg && pGroupBy == 0) {\n        u16 wctrlFlags = (sDistinct.isTnct ? 256 : 0) | (p->selFlags & 16384);\n        Window *pWin = p->pWin;\n        if (pWin) {\n            sqlite3WindowCodeInit(pParse, p);\n        }\n        assert(16384 == 16384);\n        ;\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy, p->pEList, p, wctrlFlags, p->nSelectRow);\n        if (pWInfo == 0)\n            goto select_end;\n        if (sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow) {\n            p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n        }\n        if (sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo)) {\n            sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n        }\n        if (sSort.pOrderBy) {\n            sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n            sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n            if (sSort.nOBSat == sSort.pOrderBy->nExpr) {\n                sSort.pOrderBy = 0;\n            }\n        }\n        ;\n        if (sSort.addrSortIndex >= 0 && sSort.pOrderBy == 0) {\n            sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n        }\n        assert(p->pEList == pEList);\n        if (pWin) {\n            int addrGosub = sqlite3VdbeMakeLabel(pParse);\n            int iCont = sqlite3VdbeMakeLabel(pParse);\n            int iBreak = sqlite3VdbeMakeLabel(pParse);\n            int regGosub = ++pParse->nMem;\n            sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n            sqlite3VdbeAddOp2(v, 9, 0, iBreak);\n            sqlite3VdbeResolveLabel(v, addrGosub);\n            ;\n            sSort.labelOBLopt = 0;\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n            sqlite3VdbeResolveLabel(v, iCont);\n            sqlite3VdbeAddOp1(v, 67, regGosub);\n            ;\n            sqlite3VdbeResolveLabel(v, iBreak);\n        } else {\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, sqlite3WhereContinueLabel(pWInfo), sqlite3WhereBreakLabel(pWInfo));\n            ;\n            sqlite3WhereEnd(pWInfo);\n        }\n    } else {\n        NameContext sNC;\n        int iAMem;\n        int iBMem;\n        int iUseFlag;\n        int iAbortFlag;\n        int groupBySort;\n        int addrEnd;\n        int sortPTab = 0;\n        int sortOut = 0;\n        int orderByGrp = 0;\n        if (pGroupBy) {\n            int k;\n            struct ExprList_item *pItem;\n            for (k = p->pEList->nExpr , pItem = p->pEList->a; k > 0; k-- , pItem++) {\n                pItem->u.x.iAlias = 0;\n            }\n            for (k = pGroupBy->nExpr , pItem = pGroupBy->a; k > 0; k-- , pItem++) {\n                pItem->u.x.iAlias = 0;\n            }\n            assert(66 == sqlite3LogEst(100));\n            if (p->nSelectRow > 66)\n                p->nSelectRow = 66;\n            if (sSort.pOrderBy && pGroupBy->nExpr == sSort.pOrderBy->nExpr) {\n                int ii;\n                for (ii = 0; ii < pGroupBy->nExpr; ii++) {\n                    u8 sortFlags;\n                    sortFlags = sSort.pOrderBy->a[ii].fg.sortFlags & 1;\n                    pGroupBy->a[ii].fg.sortFlags = sortFlags;\n                }\n                if (sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1) == 0) {\n                    orderByGrp = 1;\n                }\n            }\n        } else {\n            assert(0 == sqlite3LogEst(1));\n            p->nSelectRow = 0;\n        }\n        addrEnd = sqlite3VdbeMakeLabel(pParse);\n        pAggInfo = sqlite3DbMallocZero(db, sizeof (*pAggInfo));\n        if (pAggInfo) {\n            sqlite3ParserAddCleanup(pParse, (void (*)(sqlite3 *, void *))agginfoFree, pAggInfo);\n            ;\n        }\n        if (db->mallocFailed) {\n            goto select_end;\n        }\n        pAggInfo->selId = p->selId;\n        memset(&sNC, 0, sizeof (sNC));\n        sNC.pParse = pParse;\n        sNC.pSrcList = pTabList;\n        sNC.uNC.pAggInfo = pAggInfo;\n        pAggInfo->mnReg = pParse->nMem + 1;\n        pAggInfo->nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n        pAggInfo->pGroupBy = pGroupBy;\n        sqlite3ExprAnalyzeAggList(&sNC, pEList);\n        sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n        if (pHaving) {\n            if (pGroupBy) {\n                assert(pWhere == p->pWhere);\n                assert(pHaving == p->pHaving);\n                assert(pGroupBy == p->pGroupBy);\n                havingToWhere(pParse, p);\n                pWhere = p->pWhere;\n            }\n            sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n        }\n        pAggInfo->nAccumulator = pAggInfo->nColumn;\n        if (p->pGroupBy == 0 && p->pHaving == 0 && pAggInfo->nFunc == 1) {\n            minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pFExpr, &pMinMaxOrderBy);\n        } else {\n            minMaxFlag = 0;\n        }\n        for (i = 0; i < pAggInfo->nFunc; i++) {\n            Expr *pExpr = pAggInfo->aFunc[i].pFExpr;\n            assert((((pExpr)->flags & 4096) == 0));\n            sNC.ncFlags |= 131072;\n            sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n            assert(!(((((pExpr))->flags & (16777216)) != 0) && pExpr->y.pWin->eFrmType != 166));\n            if ((((pExpr)->flags & (16777216)) != 0)) {\n                sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n            }\n            sNC.ncFlags &= ~131072;\n        }\n        pAggInfo->mxReg = pParse->nMem;\n        if (db->mallocFailed)\n            goto select_end;\n        if (pGroupBy) {\n            KeyInfo *pKeyInfo;\n            int addr1;\n            int addrOutputRow;\n            int regOutputRow;\n            int addrSetAbort;\n            int addrTopOfLoop;\n            int addrSortingIdx;\n            int addrReset;\n            int regReset;\n            ExprList *pDistinct = 0;\n            u16 distFlag = 0;\n            int eDist = 0;\n            if (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0 && (pAggInfo->aFunc[0].pFExpr != 0) && ((((pAggInfo->aFunc[0].pFExpr)->flags & 4096) == 0)) && pAggInfo->aFunc[0].pFExpr->x.pList != 0) {\n                Expr *pExpr = pAggInfo->aFunc[0].pFExpr->x.pList->a[0].pExpr;\n                pExpr = sqlite3ExprDup(db, pExpr, 0);\n                pDistinct = sqlite3ExprListDup(db, pGroupBy, 0);\n                pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);\n                distFlag = pDistinct ? (256 | 1024) : 0;\n            }\n            pAggInfo->sortingIdx = pParse->nTab++;\n            pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy, 0, pAggInfo->nColumn);\n            addrSortingIdx = sqlite3VdbeAddOp4(v, 119, pAggInfo->sortingIdx, pAggInfo->nSortingColumn, 0, (char *)pKeyInfo, (-8));\n            iUseFlag = ++pParse->nMem;\n            iAbortFlag = ++pParse->nMem;\n            regOutputRow = ++pParse->nMem;\n            addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n            regReset = ++pParse->nMem;\n            addrReset = sqlite3VdbeMakeLabel(pParse);\n            iAMem = pParse->nMem + 1;\n            pParse->nMem += pGroupBy->nExpr;\n            iBMem = pParse->nMem + 1;\n            pParse->nMem += pGroupBy->nExpr;\n            sqlite3VdbeAddOp2(v, 71, 0, iAbortFlag);\n            ;\n            sqlite3VdbeAddOp3(v, 75, 0, iAMem, iAMem + pGroupBy->nExpr - 1);\n            sqlite3VdbeAddOp2(v, 10, regReset, addrReset);\n            ;\n            pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct, p, (sDistinct.isTnct == 2 ? 128 : 64) | (orderByGrp ? 512 : 0) | distFlag, 0);\n            if (pWInfo == 0) {\n                sqlite3ExprListDelete(db, pDistinct);\n                goto select_end;\n            }\n            eDist = sqlite3WhereIsDistinct(pWInfo);\n            ;\n            if (sqlite3WhereIsOrdered(pWInfo) == pGroupBy->nExpr) {\n                groupBySort = 0;\n            } else {\n                int regBase;\n                int regRecord;\n                int nCol;\n                int nGroupBy;\n                explainTempTable(pParse, (sDistinct.isTnct && (p->selFlags & 1) == 0) ? \"DISTINCT\" : \"GROUP BY\");\n                groupBySort = 1;\n                nGroupBy = pGroupBy->nExpr;\n                nCol = nGroupBy;\n                j = nGroupBy;\n                for (i = 0; i < pAggInfo->nColumn; i++) {\n                    if (pAggInfo->aCol[i].iSorterColumn >= j) {\n                        nCol++;\n                        j++;\n                    }\n                }\n                regBase = sqlite3GetTempRange(pParse, nCol);\n                sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n                j = nGroupBy;\n                pAggInfo->directMode = 1;\n                for (i = 0; i < pAggInfo->nColumn; i++) {\n                    struct AggInfo_col *pCol = &pAggInfo->aCol[i];\n                    if (pCol->iSorterColumn >= j) {\n                        sqlite3ExprCode(pParse, pCol->pCExpr, j + regBase);\n                        j++;\n                    }\n                }\n                pAggInfo->directMode = 0;\n                regRecord = sqlite3GetTempReg(pParse);\n                sqlite3VdbeAddOp3(v, 97, regBase, nCol, regRecord);\n                sqlite3VdbeAddOp2(v, 139, pAggInfo->sortingIdx, regRecord);\n                sqlite3ReleaseTempReg(pParse, regRecord);\n                sqlite3ReleaseTempRange(pParse, regBase, nCol);\n                ;\n                sqlite3WhereEnd(pWInfo);\n                pAggInfo->sortingIdxPTab = sortPTab = pParse->nTab++;\n                sortOut = sqlite3GetTempReg(pParse);\n                sqlite3VdbeAddOp3(v, 121, sortPTab, sortOut, nCol);\n                sqlite3VdbeAddOp2(v, 34, pAggInfo->sortingIdx, addrEnd);\n                ;\n                ;\n                pAggInfo->useSortingIdx = 1;\n            }\n            if (orderByGrp && (((db)->dbOptFlags & (4)) == 0) && (groupBySort || sqlite3WhereIsSorted(pWInfo))) {\n                sSort.pOrderBy = 0;\n                sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n            }\n            addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n            if (groupBySort) {\n                sqlite3VdbeAddOp3(v, 133, pAggInfo->sortingIdx, sortOut, sortPTab);\n            }\n            for (j = 0; j < pGroupBy->nExpr; j++) {\n                if (groupBySort) {\n                    sqlite3VdbeAddOp3(v, 94, sortPTab, j, iBMem + j);\n                } else {\n                    pAggInfo->directMode = 1;\n                    sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem + j);\n                }\n            }\n            sqlite3VdbeAddOp4(v, 90, iAMem, iBMem, pGroupBy->nExpr, (char *)sqlite3KeyInfoRef(pKeyInfo), (-8));\n            addr1 = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp3(v, 14, addr1 + 1, 0, addr1 + 1);\n            ;\n            sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n            sqlite3VdbeAddOp2(v, 10, regOutputRow, addrOutputRow);\n            ;\n            sqlite3VdbeAddOp2(v, 59, iAbortFlag, addrEnd);\n            ;\n            ;\n            sqlite3VdbeAddOp2(v, 10, regReset, addrReset);\n            ;\n            sqlite3VdbeJumpHere(v, addr1);\n            updateAccumulator(pParse, iUseFlag, pAggInfo, eDist);\n            sqlite3VdbeAddOp2(v, 71, 1, iUseFlag);\n            ;\n            if (groupBySort) {\n                sqlite3VdbeAddOp2(v, 37, pAggInfo->sortingIdx, addrTopOfLoop);\n                ;\n            } else {\n                ;\n                sqlite3WhereEnd(pWInfo);\n                sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n            }\n            sqlite3ExprListDelete(db, pDistinct);\n            sqlite3VdbeAddOp2(v, 10, regOutputRow, addrOutputRow);\n            ;\n            sqlite3VdbeGoto(v, addrEnd);\n            addrSetAbort = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp2(v, 71, 1, iAbortFlag);\n            ;\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            sqlite3VdbeResolveLabel(v, addrOutputRow);\n            addrOutputRow = sqlite3VdbeCurrentAddr(v);\n            sqlite3VdbeAddOp2(v, 59, iUseFlag, addrOutputRow + 2);\n            ;\n            ;\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            finalizeAggFunctions(pParse, pAggInfo);\n            sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow + 1, 16);\n            selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, addrOutputRow + 1, addrSetAbort);\n            sqlite3VdbeAddOp1(v, 67, regOutputRow);\n            ;\n            sqlite3VdbeResolveLabel(v, addrReset);\n            resetAccumulator(pParse, pAggInfo);\n            sqlite3VdbeAddOp2(v, 71, 0, iUseFlag);\n            ;\n            sqlite3VdbeAddOp1(v, 67, regReset);\n            if (distFlag != 0 && eDist != 0) {\n                struct AggInfo_func *pF = &pAggInfo->aFunc[0];\n                fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);\n            }\n        } else {\n            Table *pTab;\n            if ((pTab = isSimpleCount(p, pAggInfo)) != 0) {\n                const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n                const int iCsr = pParse->nTab++;\n                Index *pIdx;\n                KeyInfo *pKeyInfo = 0;\n                Index *pBest = 0;\n                Pgno iRoot = pTab->tnum;\n                sqlite3CodeVerifySchema(pParse, iDb);\n                sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n                if (!(((pTab)->tabFlags & 128) == 0))\n                    pBest = sqlite3PrimaryKeyIndex(pTab);\n                if (!p->pSrc->a[0].fg.notIndexed) {\n                    for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n                        if (pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && (!pBest || pIdx->szIdxRow < pBest->szIdxRow)) {\n                            pBest = pIdx;\n                        }\n                    }\n                }\n                if (pBest) {\n                    iRoot = pBest->tnum;\n                    pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n                }\n                sqlite3VdbeAddOp4Int(v, 112, iCsr, (int)iRoot, iDb, 1);\n                if (pKeyInfo) {\n                    sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, (-8));\n                }\n                sqlite3VdbeAddOp2(v, 98, iCsr, pAggInfo->aFunc[0].iMem);\n                sqlite3VdbeAddOp1(v, 122, iCsr);\n                explainSimpleCount(pParse, pTab, pBest);\n            } else {\n                int regAcc = 0;\n                ExprList *pDistinct = 0;\n                u16 distFlag = 0;\n                int eDist;\n                if (pAggInfo->nAccumulator) {\n                    for (i = 0; i < pAggInfo->nFunc; i++) {\n                        if ((((pAggInfo->aFunc[i].pFExpr)->flags & (16777216)) != 0)) {\n                            continue;\n                        }\n                        if (pAggInfo->aFunc[i].pFunc->funcFlags & 32) {\n                            break;\n                        }\n                    }\n                    if (i == pAggInfo->nFunc) {\n                        regAcc = ++pParse->nMem;\n                        sqlite3VdbeAddOp2(v, 71, 0, regAcc);\n                    }\n                } else if (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0) {\n                    assert((((pAggInfo->aFunc[0].pFExpr)->flags & 4096) == 0));\n                    pDistinct = pAggInfo->aFunc[0].pFExpr->x.pList;\n                    distFlag = pDistinct ? (256 | 1024) : 0;\n                }\n                assert(p->pGroupBy == 0);\n                resetAccumulator(pParse, pAggInfo);\n                assert(minMaxFlag == 0 || pMinMaxOrderBy != 0);\n                assert(pMinMaxOrderBy == 0 || pMinMaxOrderBy->nExpr == 1);\n                ;\n                pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy, pDistinct, p, minMaxFlag | distFlag, 0);\n                if (pWInfo == 0) {\n                    goto select_end;\n                }\n                ;\n                eDist = sqlite3WhereIsDistinct(pWInfo);\n                updateAccumulator(pParse, regAcc, pAggInfo, eDist);\n                if (eDist != 0) {\n                    struct AggInfo_func *pF = pAggInfo->aFunc;\n                    if (pF) {\n                        fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);\n                    }\n                }\n                if (regAcc)\n                    sqlite3VdbeAddOp2(v, 71, 1, regAcc);\n                if (minMaxFlag) {\n                    sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);\n                }\n                ;\n                sqlite3WhereEnd(pWInfo);\n                finalizeAggFunctions(pParse, pAggInfo);\n            }\n            sSort.pOrderBy = 0;\n            sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 16);\n            selectInnerLoop(pParse, p, -1, 0, 0, pDest, addrEnd, addrEnd);\n        }\n        sqlite3VdbeResolveLabel(v, addrEnd);\n    }\n    if (sDistinct.eTnctType == 3) {\n        explainTempTable(pParse, \"DISTINCT\");\n    }\n    if (sSort.pOrderBy) {\n        explainTempTable(pParse, sSort.nOBSat > 0 ? \"RIGHT PART OF ORDER BY\" : \"ORDER BY\");\n        assert(p->pEList == pEList);\n        generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n    }\n    sqlite3VdbeResolveLabel(v, iEnd);\n    rc = (pParse->nErr > 0);\n  select_end:\n    assert(db->mallocFailed == 0 || db->mallocFailed == 1);\n    assert(db->mallocFailed == 0 || pParse->nErr != 0);\n    sqlite3ExprListDelete(db, pMinMaxOrderBy);\n    sqlite3VdbeExplainPop(pParse);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3PagerSharedLock",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    assert(sqlite3PcacheRefCount(pPager->pPCache) == 0);\n    assert(assert_pager_state(pPager));\n    assert(pPager->eState == 0 || pPager->eState == 1);\n    assert(pPager->errCode == 0);\n    if (!((pPager)->pWal != 0) && pPager->eState == 0) {\n        int bHotJournal = 1;\n        assert(!pPager->memDb);\n        assert(pPager->tempFile == 0 || pPager->eLock == 4);\n        rc = pager_wait_on_lock(pPager, 1);\n        if (rc != 0) {\n            assert(pPager->eLock == 0 || pPager->eLock == (4 + 1));\n            goto failed;\n        }\n        if (pPager->eLock <= 1) {\n            rc = hasHotJournal(pPager, &bHotJournal);\n        }\n        if (rc != 0) {\n            goto failed;\n        }\n        if (bHotJournal) {\n            if (pPager->readOnly) {\n                rc = (8 | (3 << 8));\n                goto failed;\n            }\n            rc = pagerLockDb(pPager, 4);\n            if (rc != 0) {\n                goto failed;\n            }\n            if (!((pPager->jfd)->pMethods != 0) && pPager->journalMode != 2) {\n                sqlite3_vfs *const pVfs = pPager->pVfs;\n                int bExists;\n                rc = sqlite3OsAccess(pVfs, pPager->zJournal, 0, &bExists);\n                if (rc == 0 && bExists) {\n                    int fout = 0;\n                    int f = 2 | 2048;\n                    assert(!pPager->tempFile);\n                    rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);\n                    assert(rc != 0 || ((pPager->jfd)->pMethods != 0));\n                    if (rc == 0 && fout & 1) {\n                        rc = sqlite3CantopenError(60413);\n                        sqlite3OsClose(pPager->jfd);\n                    }\n                }\n            }\n            if (((pPager->jfd)->pMethods != 0)) {\n                assert(rc == 0);\n                rc = pagerSyncHotJournal(pPager);\n                if (rc == 0) {\n                    rc = pager_playback(pPager, !pPager->tempFile);\n                    pPager->eState = 0;\n                }\n            } else if (!pPager->exclusiveMode) {\n                pagerUnlockDb(pPager, 1);\n            }\n            if (rc != 0) {\n                pager_error(pPager, rc);\n                goto failed;\n            }\n            assert(pPager->eState == 0);\n            assert((pPager->eLock == 1) || (pPager->exclusiveMode && pPager->eLock > 1));\n        }\n        if (!pPager->tempFile && pPager->hasHeldSharedLock) {\n            char dbFileVers[16];\n            ;\n            rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof (dbFileVers), 24);\n            if (rc != 0) {\n                if (rc != (10 | (2 << 8))) {\n                    goto failed;\n                }\n                memset(dbFileVers, 0, sizeof (dbFileVers));\n            }\n            if (memcmp(pPager->dbFileVers, dbFileVers, sizeof (dbFileVers)) != 0) {\n                pager_reset(pPager);\n                if (((pPager)->bUseFetch)) {\n                    sqlite3OsUnfetch(pPager->fd, 0, 0);\n                }\n            }\n        }\n        rc = pagerOpenWalIfPresent(pPager);\n        assert(pPager->pWal == 0 || rc == 0);\n    }\n    if (((pPager)->pWal != 0)) {\n        assert(rc == 0);\n        rc = pagerBeginReadTransaction(pPager);\n    }\n    if (pPager->tempFile == 0 && pPager->eState == 0 && rc == 0) {\n        rc = pagerPagecount(pPager, &pPager->dbSize);\n    }\n  failed:\n    if (rc != 0) {\n        assert(!pPager->memDb);\n        pager_unlock(pPager);\n        assert(pPager->eState == 0);\n    } else {\n        pPager->eState = 1;\n        pPager->hasHeldSharedLock = 1;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#51749:12#sqlite3_deserialize",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    MemFile *p;\n    char *zSql;\n    sqlite3_stmt *pStmt = 0;\n    int rc;\n    int iDb;\n    sqlite3_mutex_enter(db->mutex);\n    if (zSchema == 0)\n        zSchema = db->aDb[0].zDbSName;\n    iDb = sqlite3FindDbName(db, zSchema);\n    ;\n    if (iDb < 2 && iDb != 0) {\n        rc = 1;\n        goto end_deserialize;\n    }\n    zSql = sqlite3_mprintf(\"ATTACH x AS %Q\", zSchema);\n    if (zSql == 0) {\n        rc = 7;\n    } else {\n        rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n    }\n    if (rc)\n        goto end_deserialize;\n    db->init.iDb = (u8)iDb;\n    db->init.reopenMemdb = 1;\n    rc = sqlite3_step(pStmt);\n    db->init.reopenMemdb = 0;\n    if (rc != 101) {\n        rc = 1;\n        goto end_deserialize;\n    }\n    p = memdbFromDbSchema(db, zSchema);\n    if (p == 0) {\n        rc = 1;\n    } else {\n        MemStore *pStore = p->pStore;\n        pStore->aData = pData;\n        pData = 0;\n        pStore->sz = szDb;\n        pStore->szAlloc = szBuf;\n        pStore->szMax = szBuf;\n        if (pStore->szMax < sqlite3Config.mxMemdbSize) {\n            pStore->szMax = sqlite3Config.mxMemdbSize;\n        }\n        pStore->mFlags = mFlags;\n        rc = 0;\n    }\n  end_deserialize:\n    sqlite3_finalize(pStmt);\n    if (pData && (mFlags & 1) != 0) {\n        sqlite3_free(pData);\n    }\n    sqlite3_mutex_leave(db->mutex);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#57876:1#pager_playback",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    sqlite3_vfs *pVfs = pPager->pVfs;\n    i64 szJ;\n    u32 nRec;\n    u32 u;\n    Pgno mxPg = 0;\n    int rc;\n    int res = 1;\n    char *zSuper = 0;\n    int needPagerReset;\n    int nPlayback = 0;\n    u32 savedPageSize = pPager->pageSize;\n    assert(((pPager->jfd)->pMethods != 0));\n    rc = sqlite3OsFileSize(pPager->jfd, &szJ);\n    if (rc != 0) {\n        goto end_playback;\n    }\n    zSuper = pPager->pTmpSpace;\n    rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname + 1);\n    if (rc == 0 && zSuper[0]) {\n        rc = sqlite3OsAccess(pVfs, zSuper, 0, &res);\n    }\n    zSuper = 0;\n    if (rc != 0 || !res) {\n        goto end_playback;\n    }\n    pPager->journalOff = 0;\n    needPagerReset = isHot;\n    while (1)\n        {\n            rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);\n            if (rc != 0) {\n                if (rc == 101) {\n                    rc = 0;\n                }\n                goto end_playback;\n            }\n            if (nRec == 4294967295U) {\n                assert(pPager->journalOff == (pPager->sectorSize));\n                nRec = (int)((szJ - (pPager->sectorSize)) / ((pPager->pageSize) + 8));\n            }\n            if (nRec == 0 && !isHot && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) {\n                nRec = (int)((szJ - pPager->journalOff) / ((pPager->pageSize) + 8));\n            }\n            if (pPager->journalOff == (pPager->sectorSize)) {\n                rc = pager_truncate(pPager, mxPg);\n                if (rc != 0) {\n                    goto end_playback;\n                }\n                pPager->dbSize = mxPg;\n                if (pPager->mxPgno < mxPg) {\n                    pPager->mxPgno = mxPg;\n                }\n            }\n            for (u = 0; u < nRec; u++) {\n                if (needPagerReset) {\n                    pager_reset(pPager);\n                    needPagerReset = 0;\n                }\n                rc = pager_playback_one_page(pPager, &pPager->journalOff, 0, 1, 0);\n                if (rc == 0) {\n                    nPlayback++;\n                } else {\n                    if (rc == 101) {\n                        pPager->journalOff = szJ;\n                        break;\n                    } else if (rc == (10 | (2 << 8))) {\n                        rc = 0;\n                        goto end_playback;\n                    } else {\n                        goto end_playback;\n                    }\n                }\n            }\n        }\n    assert(0);\n  end_playback:\n    if (rc == 0) {\n        rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);\n    }\n    pPager->changeCountDone = pPager->tempFile;\n    if (rc == 0) {\n        zSuper = &pPager->pTmpSpace[4];\n        rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname + 1);\n        ;\n    }\n    if (rc == 0 && (pPager->eState >= 4 || pPager->eState == 0)) {\n        rc = sqlite3PagerSync(pPager, 0);\n    }\n    if (rc == 0) {\n        rc = pager_end_transaction(pPager, zSuper[0] != '\\x00', 0);\n        ;\n    }\n    if (rc == 0 && zSuper[0] && res) {\n        assert(zSuper == &pPager->pTmpSpace[4]);\n        memset(&zSuper[-4], 0, 4);\n        rc = pager_delsuper(pPager, zSuper);\n        ;\n    }\n    if (isHot && nPlayback) {\n        sqlite3_log((27 | (2 << 8)), \"recovered %d pages from %s\", nPlayback, pPager->zJournal);\n    }\n    setSectorSize(pPager);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#65382:1#walBeginShmUnreliable",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    i64 szWal;\n    i64 iOffset;\n    u8 aBuf[32];\n    u8 *aFrame = 0;\n    int szFrame;\n    u8 *aData;\n    volatile void *pDummy;\n    int rc;\n    u32 aSaveCksum[2];\n    assert(pWal->bShmUnreliable);\n    assert(pWal->readOnly & 2);\n    assert(pWal->nWiData > 0 && pWal->apWiData[0]);\n    rc = walLockShared(pWal, (3 + (0)));\n    if (rc != 0) {\n        if (rc == 5)\n            rc = (-1);\n        goto begin_unreliable_shm_out;\n    }\n    pWal->readLock = 0;\n    rc = sqlite3OsShmMap(pWal->pDbFd, 0, (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)), 0, &pDummy);\n    assert(rc != 0);\n    if (rc != (8 | (5 << 8))) {\n        rc = (rc == 8 ? (-1) : rc);\n        goto begin_unreliable_shm_out;\n    }\n    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));\n    rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);\n    if (rc != 0) {\n        goto begin_unreliable_shm_out;\n    }\n    if (szWal < 32) {\n        *pChanged = 1;\n        rc = (pWal->hdr.mxFrame == 0 ? 0 : (-1));\n        goto begin_unreliable_shm_out;\n    }\n    rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);\n    if (rc != 0) {\n        goto begin_unreliable_shm_out;\n    }\n    if (memcmp(&pWal->hdr.aSalt, &aBuf[16], 8)) {\n        rc = (-1);\n        goto begin_unreliable_shm_out;\n    }\n    assert((pWal->szPage & (pWal->szPage - 1)) == 0);\n    assert(pWal->szPage >= 512 && pWal->szPage <= 65536);\n    szFrame = pWal->szPage + 24;\n    aFrame = (u8 *)sqlite3_malloc64(szFrame);\n    if (aFrame == 0) {\n        rc = 7;\n        goto begin_unreliable_shm_out;\n    }\n    aData = &aFrame[24];\n    aSaveCksum[0] = pWal->hdr.aFrameCksum[0];\n    aSaveCksum[1] = pWal->hdr.aFrameCksum[1];\n    for (iOffset = (32 + ((pWal->hdr.mxFrame + 1) - 1) * (i64)((pWal->szPage) + 24)); iOffset + szFrame <= szWal; iOffset += szFrame) {\n        u32 pgno;\n        u32 nTruncate;\n        rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n        if (rc != 0)\n            break;\n        if (!walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame))\n            break;\n        if (nTruncate) {\n            rc = (-1);\n            break;\n        }\n    }\n    pWal->hdr.aFrameCksum[0] = aSaveCksum[0];\n    pWal->hdr.aFrameCksum[1] = aSaveCksum[1];\n  begin_unreliable_shm_out:\n    sqlite3_free(aFrame);\n    if (rc != 0) {\n        int i;\n        for (i = 0; i < pWal->nWiData; i++) {\n            sqlite3_free((void *)pWal->apWiData[i]);\n            pWal->apWiData[i] = 0;\n        }\n        pWal->bShmUnreliable = 0;\n        sqlite3WalEndReadTransaction(pWal);\n        *pChanged = 1;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#75567:1#editPage",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    u8 *const aData = pPg->aData;\n    const int hdr = pPg->hdrOffset;\n    u8 *pBegin = &pPg->aCellIdx[nNew * 2];\n    int nCell = pPg->nCell;\n    u8 *pData;\n    u8 *pCellptr;\n    int i;\n    int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;\n    int iNewEnd = iNew + nNew;\n    assert(nCell >= 0);\n    if (iOld < iNew) {\n        int nShift = pageFreeArray(pPg, iOld, iNew - iOld, pCArray);\n        if ((nShift > nCell))\n            return sqlite3CorruptError(75593);\n        memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift * 2], nCell * 2);\n        nCell -= nShift;\n    }\n    if (iNewEnd < iOldEnd) {\n        int nTail = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);\n        assert(nCell >= nTail);\n        nCell -= nTail;\n    }\n    pData = &aData[(((((int)((&aData[hdr + 5])[0] << 8 | (&aData[hdr + 5])[1])) - 1) & 65535) + 1)];\n    if (pData < pBegin)\n        goto editpage_fail;\n    if (pData > pPg->aDataEnd)\n        goto editpage_fail;\n    if (iNew < iOld) {\n        int nAdd = ((nNew) < (iOld - iNew) ? (nNew) : (iOld - iNew));\n        assert((iOld - iNew) < nNew || nCell == 0 || (sqlite3Config.neverCorrupt == 0));\n        assert(nAdd >= 0);\n        pCellptr = pPg->aCellIdx;\n        memmove(&pCellptr[nAdd * 2], pCellptr, nCell * 2);\n        if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iNew, nAdd, pCArray))\n            goto editpage_fail;\n        nCell += nAdd;\n    }\n    for (i = 0; i < pPg->nOverflow; i++) {\n        int iCell = (iOld + pPg->aiOvfl[i]) - iNew;\n        if (iCell >= 0 && iCell < nNew) {\n            pCellptr = &pPg->aCellIdx[iCell * 2];\n            if (nCell > iCell) {\n                memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);\n            }\n            nCell++;\n            cachedCellSize(pCArray, iCell + iNew);\n            if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iCell + iNew, 1, pCArray))\n                goto editpage_fail;\n        }\n    }\n    assert(nCell >= 0);\n    pCellptr = &pPg->aCellIdx[nCell * 2];\n    if (pageInsertArray(pPg, pBegin, &pData, pCellptr, iNew + nCell, nNew - nCell, pCArray))\n        goto editpage_fail;\n    pPg->nCell = nNew;\n    pPg->nOverflow = 0;\n    ((&aData[hdr + 3])[0] = (u8)((pPg->nCell) >> 8) , (&aData[hdr + 3])[1] = (u8)(pPg->nCell));\n    ((&aData[hdr + 5])[0] = (u8)((pData - aData) >> 8) , (&aData[hdr + 5])[1] = (u8)(pData - aData));\n    return 0;\n  editpage_fail:\n    populateCellCache(pCArray, iNew, nNew);\n    return rebuildPage(pCArray, iNew, nNew, pPg);\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeInsert",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int rc;\n    int loc = seekResult;\n    int szNew = 0;\n    int idx;\n    MemPage *pPage;\n    Btree *p = pCur->pBtree;\n    BtShared *pBt = p->pBt;\n    unsigned char *oldCell;\n    unsigned char *newCell = 0;\n    assert((flags & (2 | 8 | 128)) == flags);\n    assert((flags & 128) == 0 || seekResult || pCur->pKeyInfo == 0);\n    if (pCur->curFlags & 32) {\n        rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);\n        if (rc)\n            return rc;\n        if (loc && pCur->iPage < 0) {\n            return sqlite3CorruptError(77101);\n        }\n    }\n    if (pCur->eState >= 3) {\n        ;\n        ;\n        rc = moveToRoot(pCur);\n        if (rc && rc != 16)\n            return rc;\n    }\n    assert(cursorOwnsBtShared(pCur));\n    assert((pCur->curFlags & 1) != 0 && pBt->inTransaction == 2 && (pBt->btsFlags & 1) == 0);\n    assert(hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo != 0, 2));\n    assert((flags & 128) || (pX->pKey == 0) == (pCur->pKeyInfo == 0));\n    if (pCur->pKeyInfo == 0) {\n        assert(pX->pKey == 0);\n        if (p->hasIncrblobCur) {\n            invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);\n        }\n        if ((pCur->curFlags & 2) != 0 && pX->nKey == pCur->info.nKey) {\n            assert(pX->nData >= 0 && pX->nZero >= 0);\n            if (pCur->info.nSize != 0 && pCur->info.nPayload == (u32)pX->nData + pX->nZero) {\n                return btreeOverwriteCell(pCur, pX);\n            }\n            assert(loc == 0);\n        } else if (loc == 0) {\n            rc = sqlite3BtreeTableMoveto(pCur, pX->nKey, (flags & 8) != 0, &loc);\n            if (rc)\n                return rc;\n        }\n    } else {\n        assert((flags & 2) == 0 || loc == 0);\n        if (loc == 0 && (flags & 2) == 0) {\n            if (pX->nMem) {\n                UnpackedRecord r;\n                r.pKeyInfo = pCur->pKeyInfo;\n                r.aMem = pX->aMem;\n                r.nField = pX->nMem;\n                r.default_rc = 0;\n                r.eqSeen = 0;\n                rc = sqlite3BtreeIndexMoveto(pCur, &r, &loc);\n            } else {\n                rc = btreeMoveto(pCur, pX->pKey, pX->nKey, (flags & 8) != 0, &loc);\n            }\n            if (rc)\n                return rc;\n        }\n        if (loc == 0) {\n            getCellInfo(pCur);\n            if (pCur->info.nKey == pX->nKey) {\n                BtreePayload x2;\n                x2.pData = pX->pKey;\n                x2.nData = pX->nKey;\n                x2.nZero = 0;\n                return btreeOverwriteCell(pCur, &x2);\n            }\n        }\n    }\n    assert(pCur->eState == 0 || (pCur->eState == 1 && loc));\n    pPage = pCur->pPage;\n    assert(pPage->intKey || pX->nKey >= 0 || (flags & 128));\n    assert(pPage->leaf || !pPage->intKey);\n    if (pPage->nFree < 0) {\n        if ((pCur->eState > 1)) {\n            rc = sqlite3CorruptError(77224);\n        } else {\n            rc = btreeComputeFreeSpace(pPage);\n        }\n        if (rc)\n            return rc;\n    }\n    ;\n    assert(pPage->isInit || (sqlite3Config.neverCorrupt == 0));\n    newCell = pBt->pTmpSpace;\n    assert(newCell != 0);\n    if (flags & 128) {\n        rc = 0;\n        szNew = pBt->nPreformatSize;\n        if (szNew < 4)\n            szNew = 4;\n        if ((pBt->autoVacuum) && szNew > pPage->maxLocal) {\n            CellInfo info;\n            pPage->xParseCell(pPage, newCell, &info);\n            if (info.nPayload != info.nLocal) {\n                Pgno ovfl = sqlite3Get4byte(&newCell[szNew - 4]);\n                ptrmapPut(pBt, ovfl, 3, pPage->pgno, &rc);\n            }\n        }\n    } else {\n        rc = fillInCell(pPage, newCell, pX, &szNew);\n    }\n    if (rc)\n        goto end_insert;\n    assert(szNew == pPage->xCellSize(pPage, newCell));\n    assert(szNew <= ((int)(pBt->pageSize - 8)));\n    idx = pCur->ix;\n    if (loc == 0) {\n        CellInfo info;\n        assert(idx >= 0);\n        if (idx >= pPage->nCell) {\n            return sqlite3CorruptError(77260);\n        }\n        rc = sqlite3PagerWrite(pPage->pDbPage);\n        if (rc) {\n            goto end_insert;\n        }\n        oldCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2 * (idx)])[0] << 8 | (&(pPage)->aCellIdx[2 * (idx)])[1])));\n        if (!pPage->leaf) {\n            memcpy(newCell, oldCell, 4);\n        }\n        pPage->xParseCell(pPage, oldCell, &info);\n        if (info.nLocal != info.nPayload) {\n            rc = clearCellOverflow(pPage, oldCell, &info);\n        } else {\n            rc = 0;\n        }\n        ;\n        ;\n        (pCur->curFlags &= ~4);\n        if (info.nSize == szNew && info.nLocal == info.nPayload && (!(pBt->autoVacuum) || szNew < pPage->minLocal)) {\n            assert(rc == 0);\n            if (oldCell < pPage->aData + pPage->hdrOffset + 10) {\n                return sqlite3CorruptError(77287);\n            }\n            if (oldCell + szNew > pPage->aDataEnd) {\n                return sqlite3CorruptError(77290);\n            }\n            memcpy(oldCell, newCell, szNew);\n            return 0;\n        }\n        dropCell(pPage, idx, info.nSize, &rc);\n        if (rc)\n            goto end_insert;\n    } else if (loc < 0 && pPage->nCell > 0) {\n        assert(pPage->leaf);\n        idx = ++pCur->ix;\n        pCur->curFlags &= ~2;\n    } else {\n        assert(pPage->leaf);\n    }\n    insertCell(pPage, idx, newCell, szNew, 0, 0, &rc);\n    assert(pPage->nOverflow == 0 || rc == 0);\n    assert(rc != 0 || pPage->nCell > 0 || pPage->nOverflow > 0);\n    pCur->info.nSize = 0;\n    if (pPage->nOverflow) {\n        assert(rc == 0);\n        pCur->curFlags &= ~(2);\n        rc = balance(pCur);\n        pCur->pPage->nOverflow = 0;\n        pCur->eState = 1;\n        if ((flags & 2) && rc == 0) {\n            btreeReleaseAllCursorPages(pCur);\n            if (pCur->pKeyInfo) {\n                assert(pCur->pKey == 0);\n                pCur->pKey = sqlite3Malloc(pX->nKey);\n                if (pCur->pKey == 0) {\n                    rc = 7;\n                } else {\n                    memcpy(pCur->pKey, pX->pKey, pX->nKey);\n                }\n            }\n            pCur->eState = 3;\n            pCur->nKey = pX->nKey;\n        }\n    }\n    assert(pCur->iPage < 0 || pCur->pPage->nOverflow == 0);\n  end_insert:\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3CreateView",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    Table *p;\n    int n;\n    const char *z;\n    Token sEnd;\n    DbFixer sFix;\n    Token *pName = 0;\n    int iDb;\n    sqlite3 *db = pParse->db;\n    if (pParse->nVar > 0) {\n        sqlite3ErrorMsg(pParse, \"parameters are not allowed in views\");\n        goto create_view_fail;\n    }\n    sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);\n    p = pParse->pNewTable;\n    if (p == 0 || pParse->nErr)\n        goto create_view_fail;\n    p->tabFlags |= 512;\n    sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    iDb = sqlite3SchemaToIndex(db, p->pSchema);\n    sqlite3FixInit(&sFix, pParse, iDb, \"view\", pName);\n    if (sqlite3FixSelect(&sFix, pSelect))\n        goto create_view_fail;\n    pSelect->selFlags |= 2097152;\n    if ((pParse->eParseMode >= 2)) {\n        p->u.view.pSelect = pSelect;\n        pSelect = 0;\n    } else {\n        p->u.view.pSelect = sqlite3SelectDup(db, pSelect, 1);\n    }\n    p->pCheck = sqlite3ExprListDup(db, pCNames, 1);\n    p->eTabType = 2;\n    if (db->mallocFailed)\n        goto create_view_fail;\n    sEnd = pParse->sLastToken;\n    assert(sEnd.z[0] != 0 || sEnd.n == 0);\n    if (sEnd.z[0] != ';') {\n        sEnd.z += sEnd.n;\n    }\n    sEnd.n = 0;\n    n = (int)(sEnd.z - pBegin->z);\n    assert(n > 0);\n    z = pBegin->z;\n    while ((sqlite3CtypeMap[(unsigned char)(z[n - 1])] & 1))\n        {\n            n--;\n        }\n    sEnd.z = &z[n - 1];\n    sEnd.n = 1;\n    sqlite3EndTable(pParse, 0, &sEnd, 0, 0);\n  create_view_fail:\n    sqlite3SelectDelete(db, pSelect);\n    if ((pParse->eParseMode >= 2)) {\n        sqlite3RenameExprlistUnmap(pParse, pCNames);\n    }\n    sqlite3ExprListDelete(db, pCNames);\n    return;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#43965:1#proxyTakeConch",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    if (pCtx->conchHeld != 0) {\n        return 0;\n    } else {\n        unixFile *conchFile = pCtx->conchFile;\n        int pError = 0;\n        char readBuf;\n        char lockPath;\n        char *tempLockPath;\n        int rc = 0;\n        int createConch = 0;\n        int hostIdMatch = 0;\n        int readLen = 0;\n        int tryOldLockPath = 0;\n        int forceNewLockPath = 0;\n        ;\n        if ((rc & 255) == 10) {\n            storeLastErrno(pFile, pError);\n            goto end_takeconch;\n        }\n        if (rc != 0) {\n            goto end_takeconch;\n        }\n        if (readLen < 0) {\n            storeLastErrno(pFile, conchFile->lastErrno);\n            rc = (10 | (1 << 8));\n            goto end_takeconch;\n        } else if (readLen <= (1 + 16) || <recovery-expr>()[0] != (char)2) {\n            createConch = 1;\n        }\n        do {\n            if (!createConch && !forceNewLockPath) {\n                if (!pCtx->lockProxyPath) {\n                    if (hostIdMatch) {\n                        if (<recovery-expr>()) {\n                        }\n                        tempLockPath = <recovery-expr>();\n                        tryOldLockPath = 1;\n                        goto end_takeconch;\n                    }\n                } else if (hostIdMatch && !strncmp(pCtx->lockProxyPath, &<recovery-expr>()[(1 + 16)], readLen - (1 + 16))) {\n                    goto end_takeconch;\n                }\n            }\n            if (<recovery-expr>()) {\n                rc = 5;\n                goto end_takeconch;\n            }\n            if (!pCtx->lockProxyPath) {\n                tempLockPath = <recovery-expr>();\n            }\n            if (hostIdMatch && !createConch) {\n                if (conchFile->pInode && conchFile->pInode->nShared > 1) {\n                    rc = 5;\n                } else {\n                }\n            } else {\n            }\n            if (rc == 0) {\n                char writeBuffer;\n                int writeSize = 0;\n                <recovery-expr>()[0] = (char)2;\n                if (<recovery-expr>()) {\n                } else {\n                }\n                writeSize = (1 + 16) + strlen(&<recovery-expr>()[(1 + 16)]);\n                robust_ftruncate(conchFile->h, writeSize);\n                rc = unixWrite((sqlite3_file *)conchFile, <recovery-expr>(), writeSize, 0);\n                full_fsync(conchFile->h, 0, 0);\n                if (rc == 0 && createConch) {\n                    struct stat buf;\n                    int err = ((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pFile->h, &<recovery-expr>());\n                    if (err == 0) {\n                    }\n                }\n            }\n            conchFile->pMethod->xUnlock((sqlite3_file *)conchFile, 1);\n          end_takeconch:\n            ;\n            if (rc == 0 && pFile->openFlags) {\n                int fd;\n                if (pFile->h >= 0) {\n                    robust_close(pFile, pFile->h, 44130);\n                }\n                pFile->h = -1;\n                fd = <recovery-expr>()(pCtx->dbPath, pFile->openFlags, 0);\n                ;\n                if (fd >= 0) {\n                    pFile->h = fd;\n                } else {\n                    rc = sqlite3CantopenError(44138);\n                }\n            }\n            if (rc == 0 && !pCtx->lockProxy) {\n                char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;\n                rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);\n                if (rc != 0 && rc != 7 && tryOldLockPath) {\n                    forceNewLockPath = 1;\n                    tryOldLockPath = 0;\n                    continue;\n                }\n            }\n            if (rc == 0) {\n                if (tempLockPath) {\n                    pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);\n                    if (!pCtx->lockProxyPath) {\n                        rc = 7;\n                    }\n                }\n            }\n            if (rc == 0) {\n                pCtx->conchHeld = 1;\n                if (pCtx->lockProxy->pMethod == &afpIoMethods) {\n                    afpLockingContext *afpCtx;\n                    afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;\n                    afpCtx->dbPath = pCtx->lockProxyPath;\n                }\n            } else {\n                conchFile->pMethod->xUnlock((sqlite3_file *)conchFile, 0);\n            }\n            ;\n            return rc;\n        } while (1);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#64904:1#walCheckpoint",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    int szPage;\n    WalIterator *pIter = 0;\n    u32 iDbpage = 0;\n    u32 iFrame = 0;\n    u32 mxSafeFrame;\n    u32 mxPage;\n    int i;\n    volatile WalCkptInfo *pInfo;\n    szPage = walPagesize(pWal);\n    ;\n    ;\n    pInfo = walCkptInfo(pWal);\n    if (pInfo->nBackfill < pWal->hdr.mxFrame) {\n        assert(eMode != 0 || xBusy == 0);\n        mxSafeFrame = pWal->hdr.mxFrame;\n        mxPage = pWal->hdr.nPage;\n        for (i = 1; i < (8 - 3); i++) {\n            u32 y = __atomic_load_n((pInfo->aReadMark + i), 0);\n            if (mxSafeFrame > y) {\n                assert(y <= pWal->hdr.mxFrame);\n                rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (i)), 1);\n                if (rc == 0) {\n                    u32 iMark = (i == 1 ? mxSafeFrame : 4294967295U);\n                    __atomic_store_n((pInfo->aReadMark + i), (iMark), 0);\n                    walUnlockExclusive(pWal, (3 + (i)), 1);\n                } else if (rc == 5) {\n                    mxSafeFrame = y;\n                    xBusy = 0;\n                } else {\n                    goto walcheckpoint_out;\n                }\n            }\n        }\n        if (pInfo->nBackfill < mxSafeFrame) {\n            rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);\n            assert(rc == 0 || pIter == 0);\n        }\n        if (pIter && (rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (0)), 1)) == 0) {\n            u32 nBackfill = pInfo->nBackfill;\n            pInfo->nBackfillAttempted = mxSafeFrame;\n            rc = sqlite3OsSync(pWal->pWalFd, (((sync_flags) >> 2) & 3));\n            if (rc == 0) {\n                i64 nReq = ((i64)mxPage * szPage);\n                i64 nSize;\n                sqlite3OsFileControl(pWal->pDbFd, 39, 0);\n                rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);\n                if (rc == 0 && nSize < nReq) {\n                    if ((nSize + 65536 + (i64)pWal->hdr.mxFrame * szPage) < nReq) {\n                        rc = sqlite3CorruptError(64988);\n                    } else {\n                        sqlite3OsFileControlHint(pWal->pDbFd, 5, &nReq);\n                    }\n                }\n            }\n            while (rc == 0 && 0 == walIteratorNext(pIter, &iDbpage, &iFrame))\n                {\n                    i64 iOffset;\n                    assert(walFramePgno(pWal, iFrame) == iDbpage);\n                    if (__atomic_load_n((&db->u1.isInterrupted), 0)) {\n                        rc = db->mallocFailed ? 7 : 9;\n                        break;\n                    }\n                    if (iFrame <= nBackfill || iFrame > mxSafeFrame || iDbpage > mxPage) {\n                        continue;\n                    }\n                    iOffset = (32 + ((iFrame) - 1) * (i64)((szPage) + 24)) + 24;\n                    rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);\n                    if (rc != 0)\n                        break;\n                    iOffset = (iDbpage - 1) * (i64)szPage;\n                    ;\n                    rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);\n                    if (rc != 0)\n                        break;\n                }\n            sqlite3OsFileControl(pWal->pDbFd, 37, 0);\n            if (rc == 0) {\n                if (mxSafeFrame == walIndexHdr(pWal)->mxFrame) {\n                    i64 szDb = pWal->hdr.nPage * (i64)szPage;\n                    ;\n                    rc = sqlite3OsTruncate(pWal->pDbFd, szDb);\n                    if (rc == 0) {\n                        rc = sqlite3OsSync(pWal->pDbFd, (((sync_flags) >> 2) & 3));\n                    }\n                }\n                if (rc == 0) {\n                    __atomic_store_n((&pInfo->nBackfill), (mxSafeFrame), 0);\n                }\n            }\n            walUnlockExclusive(pWal, (3 + (0)), 1);\n        }\n        if (rc == 5) {\n            rc = 0;\n        }\n    }\n    if (rc == 0 && eMode != 0) {\n        assert(pWal->writeLock);\n        if (pInfo->nBackfill < pWal->hdr.mxFrame) {\n            rc = 5;\n        } else if (eMode >= 2) {\n            u32 salt1;\n            sqlite3_randomness(4, &salt1);\n            assert(pInfo->nBackfill == pWal->hdr.mxFrame);\n            rc = walBusyLock(pWal, xBusy, pBusyArg, (3 + (1)), (8 - 3) - 1);\n            if (rc == 0) {\n                if (eMode == 3) {\n                    walRestartHdr(pWal, salt1);\n                    rc = sqlite3OsTruncate(pWal->pWalFd, 0);\n                }\n                walUnlockExclusive(pWal, (3 + (1)), (8 - 3) - 1);\n            }\n        }\n    }\n  walcheckpoint_out:\n    walIteratorFree(pIter);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3Vacuum",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    Vdbe *v = sqlite3GetVdbe(pParse);\n    int iDb = 0;\n    if (v == 0)\n        goto build_vacuum_end;\n    if (pParse->nErr)\n        goto build_vacuum_end;\n    if (pNm) {\n        iDb = sqlite3TwoPartName(pParse, pNm, pNm, &pNm);\n        if (iDb < 0)\n            goto build_vacuum_end;\n    }\n    if (iDb != 1) {\n        int iIntoReg = 0;\n        if (pInto && sqlite3ResolveSelfReference(pParse, 0, 0, pInto, 0) == 0) {\n            iIntoReg = ++pParse->nMem;\n            sqlite3ExprCode(pParse, pInto, iIntoReg);\n        }\n        sqlite3VdbeAddOp2(v, 5, iDb, iIntoReg);\n        sqlite3VdbeUsesBtree(v, iDb);\n    }\n  build_vacuum_end:\n    sqlite3ExprDelete(pParse->db, pInto);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3BitvecSet",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    u32 h;\n    if (p == 0)\n        return 0;\n    assert(i > 0);\n    assert(i <= p->iSize);\n    i--;\n    while ((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) && p->iDivisor)\n        {\n            u32 bin = i / p->iDivisor;\n            i = i % p->iDivisor;\n            if (p->u.apSub[bin] == 0) {\n                p->u.apSub[bin] = sqlite3BitvecCreate(p->iDivisor);\n                if (p->u.apSub[bin] == 0)\n                    return 7;\n            }\n            p = p->u.apSub[bin];\n        }\n    if (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) {\n        p->u.aBitmap[i / 8] |= 1 << (i & (8 - 1));\n        return 0;\n    }\n    h = (((i++) * 1) % ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)));\n    if (!p->u.aHash[h]) {\n        if (p->nSet < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)) {\n            goto bitvec_set_end;\n        } else {\n            goto bitvec_set_rehash;\n        }\n    }\n    do {\n        if (p->u.aHash[h] == i)\n            return 0;\n        h++;\n        if (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)))\n            h = 0;\n    } while (p->u.aHash[h]);\n  bitvec_set_rehash:\n    if (p->nSet >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)) {\n        unsigned int j;\n        int rc;\n        u32 *aiValues = sqlite3DbMallocRaw(0, sizeof (p->u.aHash));\n        if (aiValues == 0) {\n            return 7;\n        } else {\n            memcpy(aiValues, p->u.aHash, sizeof (p->u.aHash));\n            memset(p->u.apSub, 0, sizeof (p->u.apSub));\n            p->iDivisor = (p->iSize + ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *)) - 1) / ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *));\n            rc = sqlite3BitvecSet(p, i);\n            for (j = 0; j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)); j++) {\n                if (aiValues[j])\n                    rc |= sqlite3BitvecSet(p, aiValues[j]);\n            }\n            sqlite3DbFree(0, aiValues);\n            return rc;\n        }\n    }\n  bitvec_set_end:\n    p->nSet++;\n    p->u.aHash[h] = i;\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#43690:1#proxyCreateUnixFile",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int fd = -1;\n    unixFile *pNew;\n    int rc = 0;\n    int openFlags;\n    sqlite3_vfs dummyVfs;\n    int terrno = 0;\n    UnixUnusedFd *pUnused;\n    pUnused = findReusableFd(path, openFlags);\n    if (pUnused) {\n        fd = pUnused->fd;\n    } else {\n        pUnused = sqlite3_malloc64(sizeof (*pUnused));\n        if (!pUnused) {\n            return 7;\n        }\n    }\n    if (fd < 0) {\n        fd = <recovery-expr>()(path, openFlags, 0);\n        if (<recovery-expr>()) {\n            if (proxyCreateLockPath(path) == 0) {\n                fd = <recovery-expr>()(path, openFlags, 0);\n            }\n        }\n    }\n    if (fd < 0) {\n        fd = <recovery-expr>()(path, openFlags, 0);\n    }\n    if (fd < 0) {\n        if (islockfile) {\n            return 5;\n        }\n        switch (terrno) {\n            return 3;\n            return (10 | (15 << 8));\n          default:\n            return sqlite3CantopenError(43742);\n        }\n    }\n    pNew = (unixFile *)sqlite3_malloc64(sizeof (*pNew));\n    if (<recovery-expr>()) {\n        rc = 7;\n        goto end_create_proxy;\n    }\n    memset(pNew, 0, sizeof(unixFile));\n    pNew->openFlags = openFlags;\n    memset(&dummyVfs, 0, sizeof (dummyVfs));\n    dummyVfs.pAppData = (void *)&autolockIoFinder;\n    dummyVfs.zName = \"dummy\";\n    pUnused->fd = fd;\n    pUnused->flags = openFlags;\n    pNew->pPreallocatedUnused = pUnused;\n    rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file *)pNew, path, 0);\n    if (rc == 0) {\n        *ppFile = pNew;\n        return 0;\n    }\n  end_create_proxy:\n    robust_close(pNew, fd, 43766);\n    sqlite3_free(pNew);\n    sqlite3_free(pUnused);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#38559:1#posixUnlock",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode;\n    struct flock lock;\n    int rc = 0;\n    assert(pFile);\n    ;\n    assert(eFileLock <= 1);\n    if (pFile->eFileLock <= eFileLock) {\n        return 0;\n    }\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    assert(pInode->nShared != 0);\n    if (pFile->eFileLock > 1) {\n        assert(pInode->eFileLock == pFile->eFileLock);\n        if (eFileLock == 1) {\n            if (handleNFSUnlock) {\n                int tErrno;\n                <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n                if (unixFileLock(pFile, &<recovery-expr>()) == (-1)) {\n                    rc = (10 | (8 << 8));\n                    storeLastErrno(pFile, tErrno);\n                    goto end_unlock;\n                }\n                <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n                if (unixFileLock(pFile, &<recovery-expr>()) == (-1)) {\n                    rc = sqliteErrorFromPosixError(tErrno, (10 | (9 << 8)));\n                    if (((rc != 0) && (rc != 5))) {\n                        storeLastErrno(pFile, tErrno);\n                    }\n                    goto end_unlock;\n                }\n                if (unixFileLock(pFile, &<recovery-expr>()) == (-1)) {\n                    rc = (10 | (8 << 8));\n                    storeLastErrno(pFile, tErrno);\n                    goto end_unlock;\n                }\n            } else {\n                <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n                <recovery-expr>().l_len = 510;\n                if (unixFileLock(pFile, &<recovery-expr>())) {\n                    rc = (10 | (9 << 8));\n                    goto end_unlock;\n                }\n            }\n        }\n        <recovery-expr>().l_start = sqlite3PendingByte;\n        <recovery-expr>().l_len = 2L;\n        assert(sqlite3PendingByte + 1 == (sqlite3PendingByte + 1));\n        if (unixFileLock(pFile, &<recovery-expr>()) == 0) {\n            pInode->eFileLock = 1;\n        } else {\n            rc = (10 | (8 << 8));\n            goto end_unlock;\n        }\n    }\n    if (eFileLock == 0) {\n        pInode->nShared--;\n        if (pInode->nShared == 0) {\n            <recovery-expr>().l_start = <recovery-expr>().l_len = 0L;\n            if (unixFileLock(pFile, &<recovery-expr>()) == 0) {\n                pInode->eFileLock = 0;\n            } else {\n                rc = (10 | (8 << 8));\n                pInode->eFileLock = 0;\n                pFile->eFileLock = 0;\n            }\n        }\n        pInode->nLock--;\n        assert(pInode->nLock >= 0);\n        if (pInode->nLock == 0)\n            closePendingFds(pFile);\n    }\n  end_unlock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#38309:1#unixLock",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode;\n    struct flock lock;\n    int tErrno = 0;\n    assert(pFile);\n    ;\n    if (pFile->eFileLock >= eFileLock) {\n        ;\n        return 0;\n    }\n    assert(pFile->eFileLock != 0 || eFileLock == 1);\n    assert(eFileLock != 3);\n    assert(eFileLock != 2 || pFile->eFileLock == 1);\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    if ((pFile->eFileLock != pInode->eFileLock && (pInode->eFileLock >= 3 || eFileLock > 1))) {\n        rc = 5;\n        goto end_lock;\n    }\n    if (eFileLock == 1 && (pInode->eFileLock == 1 || pInode->eFileLock == 2)) {\n        assert(eFileLock == 1);\n        assert(pFile->eFileLock == 0);\n        assert(pInode->nShared > 0);\n        pFile->eFileLock = 1;\n        pInode->nShared++;\n        pInode->nLock++;\n        goto end_lock;\n    }\n    <recovery-expr>().l_len = 1L;\n    if (eFileLock == 1 || (eFileLock == 4 && pFile->eFileLock < 3)) {\n        <recovery-expr>().l_start = sqlite3PendingByte;\n        if (unixFileLock(pFile, &<recovery-expr>())) {\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n            goto end_lock;\n        }\n    }\n    if (eFileLock == 1) {\n        assert(pInode->nShared == 0);\n        assert(pInode->eFileLock == 0);\n        assert(rc == 0);\n        <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n        <recovery-expr>().l_len = 510;\n        if (unixFileLock(pFile, &<recovery-expr>())) {\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n        }\n        <recovery-expr>().l_start = sqlite3PendingByte;\n        <recovery-expr>().l_len = 1L;\n        if (unixFileLock(pFile, &<recovery-expr>()) && rc == 0) {\n            rc = (10 | (8 << 8));\n        }\n        if (rc) {\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n            goto end_lock;\n        } else {\n            pFile->eFileLock = 1;\n            pInode->nLock++;\n            pInode->nShared = 1;\n        }\n    } else if (eFileLock == 4 && pInode->nShared > 1) {\n        rc = 5;\n    } else {\n        assert(0 != pFile->eFileLock);\n        assert(eFileLock == 2 || eFileLock == 4);\n        if (eFileLock == 2) {\n            <recovery-expr>().l_start = (sqlite3PendingByte + 1);\n            <recovery-expr>().l_len = 1L;\n        } else {\n            <recovery-expr>().l_start = (sqlite3PendingByte + 2);\n            <recovery-expr>().l_len = 510;\n        }\n        if (unixFileLock(pFile, &<recovery-expr>())) {\n            rc = sqliteErrorFromPosixError(tErrno, (10 | (15 << 8)));\n            if (rc != 5) {\n                storeLastErrno(pFile, tErrno);\n            }\n        }\n    }\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n        pInode->eFileLock = eFileLock;\n    } else if (eFileLock == 4) {\n        pFile->eFileLock = 3;\n        pInode->eFileLock = 3;\n    }\n  end_lock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    ;\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#39569:1#afpLock",
    "gotos": 6,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    unixFile *pFile = (unixFile *)id;\n    unixInodeInfo *pInode = pFile->pInode;\n    afpLockingContext *context = (afpLockingContext *)pFile->lockingContext;\n    assert(pFile);\n    ;\n    if (pFile->eFileLock >= eFileLock) {\n        ;\n        return 0;\n    }\n    assert(pFile->eFileLock != 0 || eFileLock == 1);\n    assert(eFileLock != 3);\n    assert(eFileLock != 2 || pFile->eFileLock == 1);\n    pInode = pFile->pInode;\n    sqlite3_mutex_enter(pInode->pLockMutex);\n    if ((pFile->eFileLock != pInode->eFileLock && (pInode->eFileLock >= 3 || eFileLock > 1))) {\n        rc = 5;\n        goto afp_end_lock;\n    }\n    if (eFileLock == 1 && (pInode->eFileLock == 1 || pInode->eFileLock == 2)) {\n        assert(eFileLock == 1);\n        assert(pFile->eFileLock == 0);\n        assert(pInode->nShared > 0);\n        pFile->eFileLock = 1;\n        pInode->nShared++;\n        pInode->nLock++;\n        goto afp_end_lock;\n    }\n    if (eFileLock == 1 || (eFileLock == 4 && pFile->eFileLock < 3)) {\n        int failed;\n        failed = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 1);\n        if (failed) {\n            rc = failed;\n            goto afp_end_lock;\n        }\n    }\n    if (eFileLock == 1) {\n        int lrc1, lrc2, lrc1Errno = 0;\n        long lk, mask;\n        assert(pInode->nShared == 0);\n        assert(pInode->eFileLock == 0);\n        mask = (sizeof(long) == 8) ? (4294967295U | (((i64)2147483647) << 32)) : 2147483647;\n        lk = random();\n        pInode->sharedByte = (lk & mask) % (510 - 1);\n        lrc1 = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 1);\n        if (((lrc1 != 0) && (lrc1 != 5))) {\n            lrc1Errno = pFile->lastErrno;\n        }\n        lrc2 = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 0);\n        if (((lrc1 != 0) && (lrc1 != 5))) {\n            storeLastErrno(pFile, lrc1Errno);\n            rc = lrc1;\n            goto afp_end_lock;\n        } else if (((lrc2 != 0) && (lrc2 != 5))) {\n            rc = lrc2;\n            goto afp_end_lock;\n        } else if (lrc1 != 0) {\n            rc = lrc1;\n        } else {\n            pFile->eFileLock = 1;\n            pInode->nLock++;\n            pInode->nShared = 1;\n        }\n    } else if (eFileLock == 4 && pInode->nShared > 1) {\n        rc = 5;\n    } else {\n        int failed = 0;\n        assert(0 != pFile->eFileLock);\n        if (eFileLock >= 2 && pFile->eFileLock < 2) {\n            failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 1), 1, 1);\n            if (!failed) {\n                context->reserved = 1;\n            }\n        }\n        if (!failed && eFileLock == 4) {\n            if (!(failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 0))) {\n                int failed2 = 0;\n                failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2), 510, 1);\n                if (failed && (failed2 = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte + 2) + pInode->sharedByte, 1, 1))) {\n                    rc = ((failed & 255) == 10) ? failed2 : (10 | (15 << 8));\n                    goto afp_end_lock;\n                }\n            } else {\n                rc = failed;\n            }\n        }\n        if (failed) {\n            rc = failed;\n        }\n    }\n    if (rc == 0) {\n        pFile->eFileLock = eFileLock;\n        pInode->eFileLock = eFileLock;\n    } else if (eFileLock == 4) {\n        pFile->eFileLock = 3;\n        pInode->eFileLock = 3;\n    }\n  afp_end_lock:\n    sqlite3_mutex_leave(pInode->pLockMutex);\n    ;\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#74313:1#allocateBtreePage",
    "gotos": 11,
    "labels": 1,
    "body": "{\n    MemPage *pPage1;\n    int rc;\n    u32 n;\n    u32 k;\n    MemPage *pTrunk = 0;\n    MemPage *pPrevTrunk = 0;\n    Pgno mxPage;\n    assert(sqlite3_mutex_held(pBt->mutex));\n    assert(eMode == 0 || (nearby > 0 && (pBt->autoVacuum)));\n    pPage1 = pBt->pPage1;\n    mxPage = btreePagecount(pBt);\n    n = sqlite3Get4byte(&pPage1->aData[36]);\n    ;\n    if (n >= mxPage) {\n        return sqlite3CorruptError(74337);\n    }\n    if (n > 0) {\n        Pgno iTrunk;\n        u8 searchList = 0;\n        u32 nSearch = 0;\n        if (eMode == 1) {\n            if (nearby <= mxPage) {\n                u8 eType;\n                assert(nearby > 0);\n                assert(pBt->autoVacuum);\n                rc = ptrmapGet(pBt, nearby, &eType, 0);\n                if (rc)\n                    return rc;\n                if (eType == 2) {\n                    searchList = 1;\n                }\n            }\n        } else if (eMode == 2) {\n            searchList = 1;\n        }\n        rc = sqlite3PagerWrite(pPage1->pDbPage);\n        if (rc)\n            return rc;\n        sqlite3Put4byte(&pPage1->aData[36], n - 1);\n        do {\n            pPrevTrunk = pTrunk;\n            if (pPrevTrunk) {\n                iTrunk = sqlite3Get4byte(&pPrevTrunk->aData[0]);\n            } else {\n                iTrunk = sqlite3Get4byte(&pPage1->aData[32]);\n            }\n            ;\n            if (iTrunk > mxPage || nSearch++ > n) {\n                rc = sqlite3CorruptError(74393);\n            } else {\n                rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);\n            }\n            if (rc) {\n                pTrunk = 0;\n                goto end_allocate_page;\n            }\n            assert(pTrunk != 0);\n            assert(pTrunk->aData != 0);\n            k = sqlite3Get4byte(&pTrunk->aData[4]);\n            if (k == 0 && !searchList) {\n                assert(pPrevTrunk == 0);\n                rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                if (rc) {\n                    goto end_allocate_page;\n                }\n                *pPgno = iTrunk;\n                memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);\n                *ppPage = pTrunk;\n                pTrunk = 0;\n                ;\n            } else if (k > (u32)(pBt->usableSize / 4 - 2)) {\n                rc = sqlite3CorruptError(74422);\n                goto end_allocate_page;\n            } else if (searchList && (nearby == iTrunk || (iTrunk < nearby && eMode == 2))) {\n                *pPgno = iTrunk;\n                *ppPage = pTrunk;\n                searchList = 0;\n                rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                if (rc) {\n                    goto end_allocate_page;\n                }\n                if (k == 0) {\n                    if (!pPrevTrunk) {\n                        memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);\n                    } else {\n                        rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);\n                        if (rc != 0) {\n                            goto end_allocate_page;\n                        }\n                        memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);\n                    }\n                } else {\n                    MemPage *pNewTrunk;\n                    Pgno iNewTrunk = sqlite3Get4byte(&pTrunk->aData[8]);\n                    if (iNewTrunk > mxPage) {\n                        rc = sqlite3CorruptError(74456);\n                        goto end_allocate_page;\n                    }\n                    ;\n                    rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0);\n                    if (rc != 0) {\n                        goto end_allocate_page;\n                    }\n                    rc = sqlite3PagerWrite(pNewTrunk->pDbPage);\n                    if (rc != 0) {\n                        releasePage(pNewTrunk);\n                        goto end_allocate_page;\n                    }\n                    memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);\n                    sqlite3Put4byte(&pNewTrunk->aData[4], k - 1);\n                    memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k - 1) * 4);\n                    releasePage(pNewTrunk);\n                    if (!pPrevTrunk) {\n                        assert(sqlite3PagerIswriteable(pPage1->pDbPage));\n                        sqlite3Put4byte(&pPage1->aData[32], iNewTrunk);\n                    } else {\n                        rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);\n                        if (rc) {\n                            goto end_allocate_page;\n                        }\n                        sqlite3Put4byte(&pPrevTrunk->aData[0], iNewTrunk);\n                    }\n                }\n                pTrunk = 0;\n                ;\n            } else if (k > 0) {\n                u32 closest;\n                Pgno iPage;\n                unsigned char *aData = pTrunk->aData;\n                if (nearby > 0) {\n                    u32 i;\n                    closest = 0;\n                    if (eMode == 2) {\n                        for (i = 0; i < k; i++) {\n                            iPage = sqlite3Get4byte(&aData[8 + i * 4]);\n                            if (iPage <= nearby) {\n                                closest = i;\n                                break;\n                            }\n                        }\n                    } else {\n                        int dist;\n                        dist = sqlite3AbsInt32(sqlite3Get4byte(&aData[8]) - nearby);\n                        for (i = 1; i < k; i++) {\n                            int d2 = sqlite3AbsInt32(sqlite3Get4byte(&aData[8 + i * 4]) - nearby);\n                            if (d2 < dist) {\n                                closest = i;\n                                dist = d2;\n                            }\n                        }\n                    }\n                } else {\n                    closest = 0;\n                }\n                iPage = sqlite3Get4byte(&aData[8 + closest * 4]);\n                ;\n                if (iPage > mxPage || iPage < 2) {\n                    rc = sqlite3CorruptError(74521);\n                    goto end_allocate_page;\n                }\n                ;\n                if (!searchList || (iPage == nearby || (iPage < nearby && eMode == 2))) {\n                    int noContent;\n                    *pPgno = iPage;\n                    ;\n                    rc = sqlite3PagerWrite(pTrunk->pDbPage);\n                    if (rc)\n                        goto end_allocate_page;\n                    if (closest < k - 1) {\n                        memcpy(&aData[8 + closest * 4], &aData[4 + k * 4], 4);\n                    }\n                    sqlite3Put4byte(&aData[4], k - 1);\n                    noContent = !btreeGetHasContent(pBt, *pPgno) ? 1 : 0;\n                    rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);\n                    if (rc == 0) {\n                        rc = sqlite3PagerWrite((*ppPage)->pDbPage);\n                        if (rc != 0) {\n                            releasePage(*ppPage);\n                            *ppPage = 0;\n                        }\n                    }\n                    searchList = 0;\n                }\n            }\n            releasePage(pPrevTrunk);\n            pPrevTrunk = 0;\n        } while (searchList);\n    } else {\n        int bNoContent = (0 == (pBt->bDoTruncate)) ? 1 : 0;\n        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);\n        if (rc)\n            return rc;\n        pBt->nPage++;\n        if (pBt->nPage == ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)))\n            pBt->nPage++;\n        if (pBt->autoVacuum && (ptrmapPageno((pBt), (pBt->nPage)) == (pBt->nPage))) {\n            MemPage *pPg = 0;\n            ;\n            assert(pBt->nPage != ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)));\n            rc = btreeGetUnusedPage(pBt, pBt->nPage, &pPg, bNoContent);\n            if (rc == 0) {\n                rc = sqlite3PagerWrite(pPg->pDbPage);\n                releasePage(pPg);\n            }\n            if (rc)\n                return rc;\n            pBt->nPage++;\n            if (pBt->nPage == ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1))) {\n                pBt->nPage++;\n            }\n        }\n        sqlite3Put4byte(28 + (u8 *)pBt->pPage1->aData, pBt->nPage);\n        *pPgno = pBt->nPage;\n        assert(*pPgno != ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)));\n        rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);\n        if (rc)\n            return rc;\n        rc = sqlite3PagerWrite((*ppPage)->pDbPage);\n        if (rc != 0) {\n            releasePage(*ppPage);\n            *ppPage = 0;\n        }\n        ;\n    }\n    assert((sqlite3Config.neverCorrupt == 0) || *pPgno != ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1)));\n  end_allocate_page:\n    releasePage(pTrunk);\n    releasePage(pPrevTrunk);\n    assert(rc != 0 || sqlite3PagerPageRefcount((*ppPage)->pDbPage) <= 1);\n    assert(rc != 0 || (*ppPage)->isInit == 0);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#41382:1#unixShmMap",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    unixFile *pDbFd = (unixFile *)fd;\n    unixShm *p;\n    unixShmNode *pShmNode;\n    int rc = 0;\n    int nShmPerMap = unixShmRegionPerMap();\n    int nReqRegion;\n    if (pDbFd->pShm == 0) {\n        rc = unixOpenSharedMemory(pDbFd);\n        if (rc != 0)\n            return rc;\n    }\n    p = pDbFd->pShm;\n    pShmNode = p->pShmNode;\n    sqlite3_mutex_enter(pShmNode->pShmMutex);\n    if (pShmNode->isUnlocked) {\n        rc = unixLockSharedMemory(pDbFd, pShmNode);\n        if (rc != 0)\n            goto shmpage_out;\n        pShmNode->isUnlocked = 0;\n    }\n    assert(szRegion == pShmNode->szRegion || pShmNode->nRegion == 0);\n    assert(pShmNode->pInode == pDbFd->pInode);\n    assert(pShmNode->hShm >= 0 || pDbFd->pInode->bProcessLock == 1);\n    assert(pShmNode->hShm < 0 || pDbFd->pInode->bProcessLock == 0);\n    nReqRegion = ((iRegion + nShmPerMap) / nShmPerMap) * nShmPerMap;\n    if (pShmNode->nRegion < nReqRegion) {\n        char **apNew;\n        int nByte = nReqRegion * szRegion;\n        struct stat sStat;\n        pShmNode->szRegion = szRegion;\n        if (pShmNode->hShm >= 0) {\n            if (((int (*)(int, struct stat *))aSyscall[5].pCurrent)(pShmNode->hShm, &<recovery-expr>())) {\n                rc = (10 | (19 << 8));\n                goto shmpage_out;\n            }\n            if (<recovery-expr>().st_size < nByte) {\n                if (!bExtend) {\n                    goto shmpage_out;\n                } else {\n                    static const int pgsz = 4096;\n                    int iPg;\n                    assert((nByte % pgsz) == 0);\n                    for (iPg = (<recovery-expr>().st_size / pgsz); iPg < (nByte / pgsz); iPg++) {\n                        int x = 0;\n                        if (seekAndWriteFd(pShmNode->hShm, iPg * pgsz + pgsz - 1, \"\", 1, &x) != 1) {\n                            const char *zFile = pShmNode->zFilename;\n                            rc = unixLogErrorAtLine((10 | (19 << 8)), \"write\", zFile, 41460);\n                            goto shmpage_out;\n                        }\n                    }\n                }\n            }\n        }\n        apNew = (char **)sqlite3_realloc(pShmNode->apRegion, nReqRegion * sizeof(char *));\n        if (!apNew) {\n            rc = (10 | (12 << 8));\n            goto shmpage_out;\n        }\n        pShmNode->apRegion = apNew;\n        while (pShmNode->nRegion < nReqRegion)\n            {\n                int nMap = szRegion * nShmPerMap;\n                int i;\n                void *pMem;\n                if (pShmNode->hShm >= 0) {\n                    if (<recovery-expr>()) {\n                        rc = unixLogErrorAtLine((10 | (21 << 8)), \"mmap\", pShmNode->zFilename, 41487);\n                        goto shmpage_out;\n                    }\n                } else {\n                    pMem = sqlite3_malloc64(nMap);\n                    if (pMem == 0) {\n                        rc = 7;\n                        goto shmpage_out;\n                    }\n                    memset(pMem, 0, nMap);\n                }\n                for (i = 0; i < nShmPerMap; i++) {\n                    pShmNode->apRegion[pShmNode->nRegion + i] = &((char *)pMem)[szRegion * i];\n                }\n                pShmNode->nRegion += nShmPerMap;\n            }\n    }\n  shmpage_out:\n    if (pShmNode->nRegion > iRegion) {\n        *pp = pShmNode->apRegion[iRegion];\n    } else {\n        *pp = 0;\n    }\n    if (pShmNode->isReadonly && rc == 0)\n        rc = 8;\n    sqlite3_mutex_leave(pShmNode->pShmMutex);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#64091:1#walIndexRecover",
    "gotos": 7,
    "labels": 2,
    "body": "{\n    int rc;\n    i64 nSize;\n    u32 aFrameCksum[2] = {0, 0};\n    int iLock;\n    assert(pWal->ckptLock == 1 || pWal->ckptLock == 0);\n    assert(1 == 0 + 1);\n    assert(1 == 1);\n    assert(pWal->writeLock);\n    iLock = 1 + pWal->ckptLock;\n    rc = walLockExclusive(pWal, iLock, (3 + (0)) - iLock);\n    if (rc) {\n        return rc;\n    }\n    ;\n    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));\n    rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);\n    if (rc != 0) {\n        goto recovery_error;\n    }\n    if (nSize > 32) {\n        u8 aBuf[32];\n        u32 *aPrivate = 0;\n        u8 *aFrame = 0;\n        int szFrame;\n        u8 *aData;\n        int szPage;\n        u32 magic;\n        u32 version;\n        int isValid;\n        u32 iPg;\n        u32 iLastFrame;\n        rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);\n        if (rc != 0) {\n            goto recovery_error;\n        }\n        magic = sqlite3Get4byte(&aBuf[0]);\n        szPage = sqlite3Get4byte(&aBuf[8]);\n        if ((magic & 4294967294U) != 931071618 || szPage & (szPage - 1) || szPage > 65536 || szPage < 512) {\n            goto finished;\n        }\n        pWal->hdr.bigEndCksum = (u8)(magic & 1);\n        pWal->szPage = szPage;\n        pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);\n        memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);\n        walChecksumBytes(pWal->hdr.bigEndCksum == 0, aBuf, 32 - 2 * 4, 0, pWal->hdr.aFrameCksum);\n        if (pWal->hdr.aFrameCksum[0] != sqlite3Get4byte(&aBuf[24]) || pWal->hdr.aFrameCksum[1] != sqlite3Get4byte(&aBuf[28])) {\n            goto finished;\n        }\n        version = sqlite3Get4byte(&aBuf[4]);\n        if (version != 3007000) {\n            rc = sqlite3CantopenError(64174);\n            goto finished;\n        }\n        szFrame = szPage + 24;\n        aFrame = (u8 *)sqlite3_malloc64(szFrame + (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)));\n        if (!aFrame) {\n            rc = 7;\n            goto recovery_error;\n        }\n        aData = &aFrame[24];\n        aPrivate = (u32 *)&aData[szPage];\n        iLastFrame = (nSize - 32) / szFrame;\n        for (iPg = 0; iPg <= (u32)walFramePage(iLastFrame); iPg++) {\n            u32 *aShare;\n            u32 iFrame;\n            u32 iLast = ((iLastFrame) < ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + iPg * 4096) ? (iLastFrame) : ((4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + iPg * 4096));\n            u32 iFirst = 1 + (iPg == 0 ? 0 : (4096 - ((sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) / sizeof(u32))) + (iPg - 1) * 4096);\n            u32 nHdr, nHdr32;\n            rc = walIndexPage(pWal, iPg, (volatile u32 **)&aShare);\n            assert(aShare != 0 || rc != 0);\n            if (aShare == 0)\n                break;\n            pWal->apWiData[iPg] = aPrivate;\n            for (iFrame = iFirst; iFrame <= iLast; iFrame++) {\n                i64 iOffset = (32 + ((iFrame) - 1) * (i64)((szPage) + 24));\n                u32 pgno;\n                u32 nTruncate;\n                rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n                if (rc != 0)\n                    break;\n                isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);\n                if (!isValid)\n                    break;\n                rc = walIndexAppend(pWal, iFrame, pgno);\n                if ((rc != 0))\n                    break;\n                if (nTruncate) {\n                    pWal->hdr.mxFrame = iFrame;\n                    pWal->hdr.nPage = nTruncate;\n                    pWal->hdr.szPage = (u16)((szPage & 65280) | (szPage >> 16));\n                    ;\n                    ;\n                    aFrameCksum[0] = pWal->hdr.aFrameCksum[0];\n                    aFrameCksum[1] = pWal->hdr.aFrameCksum[1];\n                }\n            }\n            pWal->apWiData[iPg] = aShare;\n            nHdr = (iPg == 0 ? (sizeof(WalIndexHdr) * 2 + sizeof(WalCkptInfo)) : 0);\n            nHdr32 = nHdr / sizeof(u32);\n            memcpy(&aShare[nHdr32], &aPrivate[nHdr32], (sizeof(ht_slot) * (4096 * 2) + 4096 * sizeof(u32)) - nHdr);\n            if (iFrame <= iLast)\n                break;\n        }\n        sqlite3_free(aFrame);\n    }\n  finished:\n    if (rc == 0) {\n        volatile WalCkptInfo *pInfo;\n        int i;\n        pWal->hdr.aFrameCksum[0] = aFrameCksum[0];\n        pWal->hdr.aFrameCksum[1] = aFrameCksum[1];\n        walIndexWriteHdr(pWal);\n        pInfo = walCkptInfo(pWal);\n        pInfo->nBackfill = 0;\n        pInfo->nBackfillAttempted = pWal->hdr.mxFrame;\n        pInfo->aReadMark[0] = 0;\n        for (i = 1; i < (8 - 3); i++) {\n            rc = walLockExclusive(pWal, (3 + (i)), 1);\n            if (rc == 0) {\n                if (i == 1 && pWal->hdr.mxFrame) {\n                    pInfo->aReadMark[i] = pWal->hdr.mxFrame;\n                } else {\n                    pInfo->aReadMark[i] = 4294967295U;\n                }\n                walUnlockExclusive(pWal, (3 + (i)), 1);\n            } else if (rc != 5) {\n                goto recovery_error;\n            }\n        }\n        if (pWal->hdr.nPage) {\n            sqlite3_log((27 | (1 << 8)), \"recovered %d frames from WAL file %s\", pWal->hdr.mxFrame, pWal->zWalName);\n        }\n    }\n  recovery_error:\n    ;\n    walUnlockExclusive(pWal, iLock, (3 + (0)) - iLock);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#108460:1#sqlite3ExprCodeIN",
    "gotos": 4,
    "labels": 2,
    "body": "{\n    int rRhsHasNull = 0;\n    int eType;\n    int rLhs;\n    int rLhsOrig;\n    Vdbe *v;\n    int *aiMap = 0;\n    char *zAff = 0;\n    int nVector;\n    int iDummy;\n    Expr *pLeft;\n    int i;\n    int destStep2;\n    int destStep6 = 0;\n    int addrTruthOp;\n    int destNotNull;\n    int addrTop;\n    int iTab = 0;\n    u8 okConstFactor = pParse->okConstFactor;\n    assert(!0);\n    pLeft = pExpr->pLeft;\n    if (sqlite3ExprCheckIN(pParse, pExpr))\n        return;\n    zAff = exprINAffinity(pParse, pExpr);\n    nVector = sqlite3ExprVectorSize(pExpr->pLeft);\n    aiMap = (int *)sqlite3DbMallocZero(pParse->db, nVector * (sizeof(int) + sizeof(char)) + 1);\n    if (pParse->db->mallocFailed)\n        goto sqlite3ExprCodeIN_oom_error;\n    v = pParse->pVdbe;\n    assert(v != 0);\n    ;\n    eType = sqlite3FindInIndex(pParse, pExpr, 2 | 1, destIfFalse == destIfNull ? 0 : &rRhsHasNull, aiMap, &iTab);\n    assert(pParse->nErr || nVector == 1 || eType == 2 || eType == 3 || eType == 4);\n    assert(pParse->okConstFactor == okConstFactor);\n    pParse->okConstFactor = 0;\n    rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);\n    pParse->okConstFactor = okConstFactor;\n    for (i = 0; i < nVector && aiMap[i] == i; i++) {\n    }\n    if (i == nVector) {\n        rLhs = rLhsOrig;\n    } else {\n        rLhs = sqlite3GetTempRange(pParse, nVector);\n        for (i = 0; i < nVector; i++) {\n            sqlite3VdbeAddOp3(v, 80, rLhsOrig + i, rLhs + aiMap[i], 0);\n        }\n    }\n    if (eType == 5) {\n        ExprList *pList;\n        CollSeq *pColl;\n        int labelOk = sqlite3VdbeMakeLabel(pParse);\n        int r2, regToFree;\n        int regCkNull = 0;\n        int ii;\n        assert((((pExpr)->flags & 4096) == 0));\n        pList = pExpr->x.pList;\n        pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n        if (destIfNull != destIfFalse) {\n            regCkNull = sqlite3GetTempReg(pParse);\n            sqlite3VdbeAddOp3(v, 102, rLhs, rLhs, regCkNull);\n        }\n        for (ii = 0; ii < pList->nExpr; ii++) {\n            r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);\n            if (regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr)) {\n                sqlite3VdbeAddOp3(v, 102, regCkNull, r2, regCkNull);\n            }\n            sqlite3ReleaseTempReg(pParse, regToFree);\n            if (ii < pList->nExpr - 1 || destIfNull != destIfFalse) {\n                int op = rLhs != r2 ? 53 : 51;\n                sqlite3VdbeAddOp4(v, op, rLhs, labelOk, r2, (void *)pColl, (-2));\n                ;\n                ;\n                ;\n                ;\n                sqlite3VdbeChangeP5(v, zAff[0]);\n            } else {\n                int op = rLhs != r2 ? 52 : 50;\n                assert(destIfNull == destIfFalse);\n                sqlite3VdbeAddOp4(v, op, rLhs, destIfFalse, r2, (void *)pColl, (-2));\n                ;\n                ;\n                sqlite3VdbeChangeP5(v, zAff[0] | 16);\n            }\n        }\n        if (regCkNull) {\n            sqlite3VdbeAddOp2(v, 50, regCkNull, destIfNull);\n            ;\n            sqlite3VdbeGoto(v, destIfFalse);\n        }\n        sqlite3VdbeResolveLabel(v, labelOk);\n        sqlite3ReleaseTempReg(pParse, regCkNull);\n        goto sqlite3ExprCodeIN_finished;\n    }\n    if (destIfNull == destIfFalse) {\n        destStep2 = destIfFalse;\n    } else {\n        destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);\n    }\n    for (i = 0; i < nVector; i++) {\n        Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);\n        if (pParse->nErr)\n            goto sqlite3ExprCodeIN_oom_error;\n        if (sqlite3ExprCanBeNull(p)) {\n            sqlite3VdbeAddOp2(v, 50, rLhs + i, destStep2);\n            ;\n        }\n    }\n    if (eType == 1) {\n        sqlite3VdbeAddOp3(v, 30, iTab, destIfFalse, rLhs);\n        ;\n        addrTruthOp = sqlite3VdbeAddOp0(v, 9);\n    } else {\n        sqlite3VdbeAddOp4(v, 96, rLhs, nVector, 0, zAff, nVector);\n        if (destIfFalse == destIfNull) {\n            sqlite3VdbeAddOp4Int(v, 28, iTab, destIfFalse, rLhs, nVector);\n            ;\n            goto sqlite3ExprCodeIN_finished;\n        }\n        addrTruthOp = sqlite3VdbeAddOp4Int(v, 29, iTab, 0, rLhs, nVector);\n        ;\n    }\n    if (rRhsHasNull && nVector == 1) {\n        sqlite3VdbeAddOp2(v, 51, rRhsHasNull, destIfFalse);\n        ;\n    }\n    if (destIfFalse == destIfNull)\n        sqlite3VdbeGoto(v, destIfFalse);\n    if (destStep6)\n        sqlite3VdbeResolveLabel(v, destStep6);\n    addrTop = sqlite3VdbeAddOp2(v, 36, iTab, destIfFalse);\n    ;\n    if (nVector > 1) {\n        destNotNull = sqlite3VdbeMakeLabel(pParse);\n    } else {\n        destNotNull = destIfFalse;\n    }\n    for (i = 0; i < nVector; i++) {\n        Expr *p;\n        CollSeq *pColl;\n        int r3 = sqlite3GetTempReg(pParse);\n        p = sqlite3VectorFieldSubexpr(pLeft, i);\n        pColl = sqlite3ExprCollSeq(pParse, p);\n        sqlite3VdbeAddOp3(v, 94, iTab, i, r3);\n        sqlite3VdbeAddOp4(v, 52, rLhs + i, destNotNull, r3, (void *)pColl, (-2));\n        ;\n        sqlite3ReleaseTempReg(pParse, r3);\n    }\n    sqlite3VdbeAddOp2(v, 9, 0, destIfNull);\n    if (nVector > 1) {\n        sqlite3VdbeResolveLabel(v, destNotNull);\n        sqlite3VdbeAddOp2(v, 39, iTab, addrTop + 1);\n        ;\n        sqlite3VdbeAddOp2(v, 9, 0, destIfFalse);\n    }\n    sqlite3VdbeJumpHere(v, addrTruthOp);\n  sqlite3ExprCodeIN_finished:\n    if (rLhs != rLhsOrig)\n        sqlite3ReleaseTempReg(pParse, rLhs);\n    ;\n  sqlite3ExprCodeIN_oom_error:\n    sqlite3DbFree(pParse->db, aiMap);\n    sqlite3DbFree(pParse->db, zAff);\n}\n"
  },
  {
    "id": "#23:25#sqlite3BtreeIntegrityCheck",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    Pgno i;\n    IntegrityCk sCheck;\n    BtShared *pBt = p->pBt;\n    u64 savedDbFlags = pBt->db->flags;\n    char zErr[100];\n    int bPartial = 0;\n    int bCkFreelist = 1;\n    ;\n    assert(nRoot > 0);\n    if (aRoot[0] == 0) {\n        assert(nRoot > 1);\n        bPartial = 1;\n        if (aRoot[1] != 1)\n            bCkFreelist = 0;\n    }\n    sqlite3BtreeEnter(p);\n    assert(p->inTrans > 0 && pBt->inTransaction > 0);\n    ;\n    sCheck.db = db;\n    sCheck.pBt = pBt;\n    sCheck.pPager = pBt->pPager;\n    sCheck.nPage = btreePagecount(sCheck.pBt);\n    sCheck.mxErr = mxErr;\n    sCheck.nErr = 0;\n    sCheck.bOomFault = 0;\n    sCheck.zPfx = 0;\n    sCheck.v1 = 0;\n    sCheck.v2 = 0;\n    sCheck.aPgRef = 0;\n    sCheck.heap = 0;\n    sqlite3StrAccumInit(&sCheck.errMsg, 0, zErr, sizeof (zErr), 1000000000);\n    sCheck.errMsg.printfFlags = 1;\n    if (sCheck.nPage == 0) {\n        goto integrity_ck_cleanup;\n    }\n    sCheck.aPgRef = sqlite3MallocZero((sCheck.nPage / 8) + 1);\n    if (!sCheck.aPgRef) {\n        sCheck.bOomFault = 1;\n        goto integrity_ck_cleanup;\n    }\n    sCheck.heap = (u32 *)sqlite3PageMalloc(pBt->pageSize);\n    if (sCheck.heap == 0) {\n        sCheck.bOomFault = 1;\n        goto integrity_ck_cleanup;\n    }\n    i = ((Pgno)((sqlite3PendingByte / ((pBt)->pageSize)) + 1));\n    if (i <= sCheck.nPage)\n        setPageReferenced(&sCheck, i);\n    if (bCkFreelist) {\n        sCheck.zPfx = \"Main freelist: \";\n        checkList(&sCheck, 1, sqlite3Get4byte(&pBt->pPage1->aData[32]), sqlite3Get4byte(&pBt->pPage1->aData[36]));\n        sCheck.zPfx = 0;\n    }\n    if (!bPartial) {\n        if (pBt->autoVacuum) {\n            Pgno mx = 0;\n            Pgno mxInHdr;\n            for (i = 0; (int)i < nRoot; i++)\n                if (mx < aRoot[i])\n                    mx = aRoot[i];\n            mxInHdr = sqlite3Get4byte(&pBt->pPage1->aData[52]);\n            if (mx != mxInHdr) {\n                checkAppendMsg(&sCheck, \"max rootpage (%d) disagrees with header (%d)\", mx, mxInHdr);\n            }\n        } else if (sqlite3Get4byte(&pBt->pPage1->aData[64]) != 0) {\n            checkAppendMsg(&sCheck, \"incremental_vacuum enabled with a max rootpage of zero\");\n        }\n    }\n    ;\n    pBt->db->flags &= ~(u64)2097152;\n    for (i = 0; (int)i < nRoot && sCheck.mxErr; i++) {\n        i64 notUsed;\n        if (aRoot[i] == 0)\n            continue;\n        if (pBt->autoVacuum && aRoot[i] > 1 && !bPartial) {\n            checkPtrmap(&sCheck, aRoot[i], 1, 0);\n        }\n        checkTreePage(&sCheck, aRoot[i], &notUsed, (4294967295U | (((i64)2147483647) << 32)));\n    }\n    pBt->db->flags = savedDbFlags;\n    if (!bPartial) {\n        for (i = 1; i <= sCheck.nPage && sCheck.mxErr; i++) {\n            if (getPageReferenced(&sCheck, i) == 0 && (ptrmapPageno(pBt, i) != i || !pBt->autoVacuum)) {\n                checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n            }\n            if (getPageReferenced(&sCheck, i) != 0 && (ptrmapPageno(pBt, i) == i && pBt->autoVacuum)) {\n                checkAppendMsg(&sCheck, \"Pointer map page %d is referenced\", i);\n            }\n        }\n    }\n  integrity_ck_cleanup:\n    sqlite3PageFree(sCheck.heap);\n    sqlite3_free(sCheck.aPgRef);\n    if (sCheck.bOomFault) {\n        sqlite3_str_reset(&sCheck.errMsg);\n        sCheck.nErr++;\n    }\n    *pnErr = sCheck.nErr;\n    if (sCheck.nErr == 0)\n        sqlite3_str_reset(&sCheck.errMsg);\n    sqlite3BtreeLeave(p);\n    return sqlite3StrAccumFinish(&sCheck.errMsg);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#113618:1#dropColumnFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    int iSchema = sqlite3_value_int(argv[0]);\n    const char *zSql = (const char *)sqlite3_value_text(argv[1]);\n    int iCol = sqlite3_value_int(argv[2]);\n    const char *zDb = db->aDb[iSchema].zDbSName;\n    int rc;\n    Parse sParse;\n    RenameToken *pCol;\n    Table *pTab;\n    const char *zEnd;\n    char *zNew = 0;\n    sqlite3_xauth xAuth = db->xAuth;\n    db->xAuth = 0;\n    (void)(NotUsed);\n    rc = renameParseSql(&sParse, zDb, db, zSql, iSchema == 1);\n    if (rc != 0)\n        goto drop_column_done;\n    pTab = sParse.pNewTable;\n    if (pTab == 0 || pTab->nCol == 1 || iCol >= pTab->nCol) {\n        rc = sqlite3CorruptError(113646);\n        goto drop_column_done;\n    }\n    pCol = renameTokenFind(&sParse, 0, (void *)pTab->aCol[iCol].zCnName);\n    if (iCol < pTab->nCol - 1) {\n        RenameToken *pEnd;\n        pEnd = renameTokenFind(&sParse, 0, (void *)pTab->aCol[iCol + 1].zCnName);\n        zEnd = (const char *)pEnd->t.z;\n    } else {\n        assert(((pTab)->eTabType == 0));\n        zEnd = (const char *)&zSql[pTab->u.tab.addColOffset];\n        while ((pCol->t.z[0] != 0) && pCol->t.z[0] != ',')\n            pCol->t.z--;\n    }\n    zNew = sqlite3MPrintf(db, \"%.*s%s\", pCol->t.z - zSql, zSql, zEnd);\n    sqlite3_result_text(context, zNew, -1, ((sqlite3_destructor_type)-1));\n    sqlite3_free(zNew);\n  drop_column_done:\n    renameParseCleanup(&sParse);\n    db->xAuth = xAuth;\n    if (rc != 0) {\n        sqlite3_result_error_code(context, rc);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#43827:1#proxyBreakConchLock",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    unixFile *conchFile = pCtx->conchFile;\n    char tPath;\n    char buf;\n    char *cPath = pCtx->conchFilePath;\n    char errmsg[64] = \"\";\n    int fd = -1;\n    int rc = -1;\n    (void)(<recovery-expr>());\n    if (<recovery-expr>()) {\n        goto end_breaklock;\n    }\n    if (<recovery-expr>()) {\n        goto end_breaklock;\n    }\n    if (fd < 0) {\n        goto end_breaklock;\n    }\n    if (<recovery-expr>()) {\n        goto end_breaklock;\n    }\n    if (rename(<recovery-expr>(), cPath)) {\n        goto end_breaklock;\n    }\n    rc = 0;\n    robust_close(pFile, conchFile->h, 43869);\n    conchFile->h = fd;\n  end_breaklock:\n    if (rc) {\n        if (fd >= 0) {\n            ((int (*)(const char *))aSyscall[16].pCurrent)(<recovery-expr>());\n            robust_close(pFile, fd, 43877);\n        }\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#23498:1#getDigits",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    static const u16 aMx[] = {12, 14, 24, 31, 59, 9999};\n    int cnt = 0;\n    char nextC;\n    do {\n        char N = zFormat[0] - '0';\n        char min = zFormat[1] - '0';\n        int val = 0;\n        u16 max;\n        assert(zFormat[2] >= 'a' && zFormat[2] <= 'f');\n        max = aMx[zFormat[2] - 'a'];\n        nextC = zFormat[3];\n        val = 0;\n        while (N--)\n            {\n                if (!(sqlite3CtypeMap[(unsigned char)(*zDate)] & 4)) {\n                    goto end_getDigits;\n                }\n                val = val * 10 + *zDate - '0';\n                zDate++;\n            }\n        if (val < (int)min || val > (int)max || (nextC != 0 && nextC != *zDate)) {\n            goto end_getDigits;\n        }\n        zDate++;\n        cnt++;\n        zFormat += 4;\n    } while (nextC);\n  end_getDigits:\n    ;\n    return cnt;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#42734:1#unixOpen",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    unixFile *p = (unixFile *)pFile;\n    int fd = -1;\n    int openFlags = 0;\n    int eType = flags & 1048320;\n    int noLock;\n    int rc = 0;\n    int ctrlFlags = 0;\n    int isExclusive = (flags & 16);\n    int isDelete = (flags & 8);\n    int isCreate = (flags & 4);\n    int isReadonly = (flags & 1);\n    int isReadWrite = (flags & 2);\n    int isAutoProxy = (flags & 32);\n    struct statfs fsInfo;\n    int isNewJrnl = (isCreate && (eType == 16384 || eType == 2048 || eType == 524288));\n    char zTmpname[514];\n    const char *zName = zPath;\n    assert((isReadonly == 0 || isReadWrite == 0) && (isReadWrite || isReadonly));\n    assert(isCreate == 0 || isReadWrite);\n    assert(isExclusive == 0 || isCreate);\n    assert(isDelete == 0 || isCreate);\n    assert((!isDelete && zName) || eType != 256);\n    assert((!isDelete && zName) || eType != 2048);\n    assert((!isDelete && zName) || eType != 16384);\n    assert((!isDelete && zName) || eType != 524288);\n    assert(eType == 256 || eType == 512 || eType == 2048 || eType == 4096 || eType == 8192 || eType == 16384 || eType == 1024 || eType == 524288);\n    if (<recovery-expr>()) {\n        sqlite3_randomness(0, 0);\n    }\n    memset(p, 0, sizeof(unixFile));\n    if (eType == 256) {\n        UnixUnusedFd *pUnused;\n        pUnused = findReusableFd(zName, flags);\n        if (pUnused) {\n            fd = pUnused->fd;\n        } else {\n            pUnused = sqlite3_malloc64(sizeof (*pUnused));\n            if (!pUnused) {\n                return 7;\n            }\n        }\n        p->pPreallocatedUnused = pUnused;\n        assert((flags & 64) || zName[strlen(zName) + 1] == 0);\n    } else if (!zName) {\n        assert(isDelete && !isNewJrnl);\n        rc = unixGetTempname(pVfs->mxPathname, zTmpname);\n        if (rc != 0) {\n            return rc;\n        }\n        zName = zTmpname;\n        assert(zName[strlen(zName) + 1] == 0);\n    }\n    openFlags |= (0 | 0 | 0);\n    if (fd < 0) {\n        if (rc != 0) {\n            assert(!p->pPreallocatedUnused);\n            assert(eType == 524288 || eType == 2048);\n            return rc;\n        }\n        ;\n        if (fd < 0) {\n            if (<recovery-expr>()) {\n                rc = (8 | (6 << 8));\n            } else if (<recovery-expr>()) {\n                flags &= ~(2 | 4);\n                flags |= 1;\n                isReadonly = 1;\n            }\n        }\n        if (fd < 0) {\n            int rc2 = unixLogErrorAtLine(sqlite3CantopenError(42890), \"open\", zName, 42890);\n            if (rc == 0)\n                rc = rc2;\n            goto open_finished;\n        }\n        if (<recovery-expr>()) {\n        }\n    }\n    assert(fd >= 0);\n    if (pOutFlags) {\n        *pOutFlags = flags;\n    }\n    if (p->pPreallocatedUnused) {\n        p->pPreallocatedUnused->fd = fd;\n        p->pPreallocatedUnused->flags = flags & (1 | 2);\n    }\n    if (isDelete) {\n        ((int (*)(const char *))aSyscall[16].pCurrent)(zName);\n    } else {\n        p->openFlags = openFlags;\n    }\n    if (fstatfs(fd, &<recovery-expr>()) == -1) {\n        robust_close(p, fd, 42944);\n        return (10 | (13 << 8));\n    }\n    if (0 == strncmp(\"msdos\", <recovery-expr>().f_fstypename, 5)) {\n        ((unixFile *)pFile)->fsFlags |= 1;\n    }\n    if (0 == strncmp(\"exfat\", <recovery-expr>().f_fstypename, 5)) {\n        ((unixFile *)pFile)->fsFlags |= 1;\n    }\n    if (isDelete)\n        ctrlFlags |= 32;\n    if (isReadonly)\n        ctrlFlags |= 2;\n    noLock = eType != 256;\n    if (noLock)\n        ctrlFlags |= 128;\n    if (isNewJrnl)\n        ctrlFlags |= 8;\n    if (flags & 64)\n        ctrlFlags |= 64;\n    if (<recovery-expr>()) {\n        char *envforce = getenv(\"SQLITE_FORCE_PROXY_LOCKING\");\n        int useProxy = 0;\n        if (<recovery-expr>()) {\n            useProxy = atoi(envforce) > 0;\n        } else {\n        }\n        if (useProxy) {\n            rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);\n            if (rc == 0) {\n                rc = proxyTransformUnixFile((unixFile *)pFile, \":auto:\");\n                if (rc != 0) {\n                    unixClose(pFile);\n                    return rc;\n                }\n            }\n            goto open_finished;\n        }\n    }\n    assert(zPath == 0 || zPath[0] == '/' || eType == 16384 || eType == 2048);\n    rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);\n  open_finished:\n    if (rc != 0) {\n        sqlite3_free(p->pPreallocatedUnused);\n    }\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3ExprIfFalse",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    Vdbe *v = pParse->pVdbe;\n    int op = 0;\n    int regFree1 = 0;\n    int regFree2 = 0;\n    int r1, r2;\n    assert(jumpIfNull == 16 || jumpIfNull == 0);\n    if ((v == 0))\n        return;\n    if (pExpr == 0)\n        return;\n    assert(!0);\n    op = ((pExpr->op + (50 & 1)) ^ 1) - (50 & 1);\n    assert(pExpr->op != 50 || op == 51);\n    assert(pExpr->op != 51 || op == 50);\n    assert(pExpr->op != 52 || op == 53);\n    assert(pExpr->op != 53 || op == 52);\n    assert(pExpr->op != 56 || op == 57);\n    assert(pExpr->op != 55 || op == 54);\n    assert(pExpr->op != 54 || op == 55);\n    assert(pExpr->op != 57 || op == 56);\n    switch (pExpr->op) {\n      case 44:\n      case 43:\n        {\n            Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);\n            if (pAlt != pExpr) {\n                sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);\n            } else if (pExpr->op == 44) {\n                ;\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n            } else {\n                int d2 = sqlite3VdbeMakeLabel(pParse);\n                ;\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull ^ 16);\n                sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n                sqlite3VdbeResolveLabel(v, d2);\n            }\n            break;\n        }\n      case 19:\n        {\n            ;\n            sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n            break;\n        }\n      case 175:\n        {\n            int isNot;\n            int isTrue;\n            ;\n            isNot = pExpr->op2 == 171;\n            isTrue = sqlite3ExprTruthValue(pExpr->pRight);\n            ;\n            ;\n            if (isTrue ^ isNot) {\n                sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            } else {\n                sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, isNot ? 0 : 16);\n            }\n            break;\n        }\n      case 45:\n      case 171:\n        ;\n        ;\n        op = (pExpr->op == 45) ? 52 : 53;\n        jumpIfNull = 128;\n      case 56:\n      case 55:\n      case 54:\n      case 57:\n      case 52:\n      case 53:\n        {\n            if (sqlite3ExprIsVector(pExpr->pLeft))\n                goto default_expr;\n            ;\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n            codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op, r1, r2, dest, jumpIfNull, (((pExpr)->flags & (1024)) != 0));\n            assert(56 == 56);\n            ;\n            ;\n            assert(55 == 55);\n            ;\n            ;\n            assert(54 == 54);\n            ;\n            ;\n            assert(57 == 57);\n            ;\n            ;\n            assert(53 == 53);\n            ;\n            ;\n            ;\n            assert(52 == 52);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 50:\n      case 51:\n        {\n            r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n            sqlite3VdbeTypeofColumn(v, r1);\n            sqlite3VdbeAddOp2(v, op, r1, dest);\n            ;\n            ;\n            ;\n            ;\n            ;\n            break;\n        }\n      case 48:\n        {\n            ;\n            exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);\n            break;\n        }\n      case 49:\n        {\n            if (jumpIfNull) {\n                sqlite3ExprCodeIN(pParse, pExpr, dest, dest);\n            } else {\n                int destIfNull = sqlite3VdbeMakeLabel(pParse);\n                sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);\n                sqlite3VdbeResolveLabel(v, destIfNull);\n            }\n            break;\n        }\n      default:\n        {\n          default_expr:\n            if ((((pExpr)->flags & (1 | 536870912)) == 536870912)) {\n                sqlite3VdbeGoto(v, dest);\n            } else if ((((pExpr)->flags & (1 | 268435456)) == 268435456)) {\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n                sqlite3VdbeAddOp3(v, 17, r1, dest, jumpIfNull != 0);\n                ;\n                ;\n                ;\n            }\n            break;\n        }\n    }\n    sqlite3ReleaseTempReg(pParse, regFree1);\n    sqlite3ReleaseTempReg(pParse, regFree2);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#30033:12#sqlite3_str_vappendf",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    int c;\n    char *bufpt;\n    int precision;\n    int length;\n    int idx;\n    int width;\n    etByte flag_leftjustify;\n    etByte flag_prefix;\n    etByte flag_alternateform;\n    etByte flag_altform2;\n    etByte flag_zeropad;\n    etByte flag_long;\n    etByte done;\n    etByte cThousand;\n    etByte xtype = 17;\n    u8 bArgList;\n    char prefix;\n    sqlite_uint64 longvalue;\n    long double realvalue;\n    const et_info *infop;\n    char *zOut;\n    int nOut;\n    char *zExtra = 0;\n    int exp, e2;\n    int nsd;\n    double rounder;\n    etByte flag_dp;\n    etByte flag_rtz;\n    PrintfArguments *pArgList = 0;\n    char buf[70];\n    assert(pAccum->nChar > 0 || (pAccum->printfFlags & 4) == 0);\n    bufpt = 0;\n    if ((pAccum->printfFlags & 2) != 0) {\n        bArgList = 1;\n    } else {\n        bArgList = 0;\n    }\n    for (; (c = (*fmt)) != 0; ++fmt) {\n        if (c != '%') {\n            bufpt = (char *)fmt;\n            do {\n                fmt++;\n            } while (*fmt && *fmt != '%');\n            sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));\n            if (*fmt == 0)\n                break;\n        }\n        if ((c = (*++fmt)) == 0) {\n            sqlite3_str_append(pAccum, \"%\", 1);\n            break;\n        }\n        flag_leftjustify = flag_prefix = cThousand = flag_alternateform = flag_altform2 = flag_zeropad = 0;\n        done = 0;\n        width = 0;\n        flag_long = 0;\n        precision = -1;\n        do {\n            switch (c) {\n              case '-':\n                flag_leftjustify = 1;\n                break;\n              case '+':\n                flag_prefix = '+';\n                break;\n              case ' ':\n                flag_prefix = ' ';\n                break;\n              case '#':\n                flag_alternateform = 1;\n                break;\n              case '!':\n                flag_altform2 = 1;\n                break;\n              case '0':\n                flag_zeropad = 1;\n                break;\n              case ',':\n                cThousand = ',';\n                break;\n              default:\n                done = 1;\n                break;\n              case 'l':\n                {\n                    flag_long = 1;\n                    c = *++fmt;\n                    if (c == 'l') {\n                        c = *++fmt;\n                        flag_long = 2;\n                    }\n                    done = 1;\n                    break;\n                }\n              case '1':\n              case '2':\n              case '3':\n              case '4':\n              case '5':\n              case '6':\n              case '7':\n              case '8':\n              case '9':\n                {\n                    unsigned int wx = c - '0';\n                    while ((c = *++fmt) >= '0' && c <= '9')\n                        {\n                            wx = wx * 10 + c - '0';\n                        }\n                    ;\n                    width = wx & 2147483647;\n                    if (c != '.' && c != 'l') {\n                        done = 1;\n                    } else {\n                        fmt--;\n                    }\n                    break;\n                }\n              case '*':\n                {\n                    if (bArgList) {\n                        width = (int)getIntArg(pArgList);\n                    } else {\n                    }\n                    if (width < 0) {\n                        flag_leftjustify = 1;\n                        width = width >= -2147483647 ? -width : 0;\n                    }\n                    if ((c = fmt[1]) != '.' && c != 'l') {\n                        c = *++fmt;\n                        done = 1;\n                    }\n                    break;\n                }\n              case '.':\n                {\n                    c = *++fmt;\n                    if (c == '*') {\n                        if (bArgList) {\n                            precision = (int)getIntArg(pArgList);\n                        } else {\n                        }\n                        if (precision < 0) {\n                            precision = precision >= -2147483647 ? -precision : -1;\n                        }\n                        c = *++fmt;\n                    } else {\n                        unsigned int px = 0;\n                        while (c >= '0' && c <= '9')\n                            {\n                                px = px * 10 + c - '0';\n                                c = *++fmt;\n                            }\n                        ;\n                        precision = px & 2147483647;\n                    }\n                    if (c == 'l') {\n                        --fmt;\n                    } else {\n                        done = 1;\n                    }\n                    break;\n                }\n            }\n        } while (!done && (c = (*++fmt)) != 0);\n        infop = &fmtinfo[0];\n        xtype = 17;\n        for (idx = 0; idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0]))); idx++) {\n            if (c == fmtinfo[idx].fmttype) {\n                infop = &fmtinfo[idx];\n                xtype = infop->type;\n                break;\n            }\n        }\n        assert(width >= 0);\n        assert(precision >= (-1));\n        switch (xtype) {\n          case 13:\n            flag_long = sizeof(char *) == sizeof(i64) ? 2 : sizeof(char *) == sizeof(long) ? 1 : 0;\n          case 15:\n          case 0:\n            cThousand = 0;\n          case 16:\n            if (infop->flags & 1) {\n                i64 v;\n                if (bArgList) {\n                    v = getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        v = va_arg(<recovery-expr>(), <recovery-expr>());\n                    } else {\n                    }\n                } else {\n                }\n                if (v < 0) {\n                    ;\n                    ;\n                    longvalue = ~v;\n                    longvalue++;\n                    prefix = '-';\n                } else {\n                    longvalue = v;\n                    prefix = flag_prefix;\n                }\n            } else {\n                if (bArgList) {\n                    longvalue = (u64)getIntArg(pArgList);\n                } else if (flag_long) {\n                    if (flag_long == 2) {\n                        longvalue = va_arg(<recovery-expr>(), <recovery-expr>());\n                    } else {\n                    }\n                } else {\n                }\n                prefix = 0;\n            }\n            if (longvalue == 0)\n                flag_alternateform = 0;\n            if (flag_zeropad && precision < width - (prefix != 0)) {\n                precision = width - (prefix != 0);\n            }\n            if (precision < 70 - 10 - 70 / 3) {\n                nOut = 70;\n                zOut = buf;\n            } else {\n                u64 n;\n                n = (u64)precision + 10;\n                if (cThousand)\n                    n += precision / 3;\n                zOut = zExtra = printfTempBuf(pAccum, n);\n                if (zOut == 0)\n                    return;\n                nOut = (int)n;\n            }\n            bufpt = &zOut[nOut - 1];\n            if (xtype == 15) {\n                static const char zOrd[] = \"thstndrd\";\n                int x = (int)(longvalue % 10);\n                if (x >= 4 || (longvalue / 10) % 10 == 1) {\n                    x = 0;\n                }\n                *(--bufpt) = zOrd[x * 2 + 1];\n                *(--bufpt) = zOrd[x * 2];\n            }\n            {\n                const char *cset = &aDigits[infop->charset];\n                u8 base = infop->base;\n                do {\n                    *(--bufpt) = cset[longvalue % base];\n                    longvalue = longvalue / base;\n                } while (longvalue > 0);\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            while (precision > length)\n                {\n                    *(--bufpt) = '0';\n                    length++;\n                }\n            if (cThousand) {\n                int nn = (length - 1) / 3;\n                int ix = (length - 1) % 3 + 1;\n                bufpt -= nn;\n                for (idx = 0; nn > 0; idx++) {\n                    bufpt[idx] = bufpt[idx + nn];\n                    ix--;\n                    if (ix == 0) {\n                        bufpt[++idx] = cThousand;\n                        nn--;\n                        ix = 3;\n                    }\n                }\n            }\n            if (prefix)\n                *(--bufpt) = prefix;\n            if (flag_alternateform && infop->prefix) {\n                const char *pre;\n                char x;\n                pre = &aPrefix[infop->prefix];\n                for (; (x = (*pre)) != 0; pre++)\n                    *(--bufpt) = x;\n            }\n            length = (int)(&zOut[nOut - 1] - bufpt);\n            break;\n          case 1:\n          case 2:\n          case 3:\n            if (bArgList) {\n                realvalue = getDoubleArg(pArgList);\n            } else {\n            }\n            if (precision < 0)\n                precision = 6;\n            if (precision > 100000000) {\n                precision = 100000000;\n            }\n            if (realvalue < 0.) {\n                realvalue = -realvalue;\n                prefix = '-';\n            } else {\n                prefix = flag_prefix;\n            }\n            if (xtype == 3 && precision > 0)\n                precision--;\n            ;\n            idx = precision & 4095;\n            rounder = arRound[idx % 10];\n            while (idx >= 10)\n                {\n                    rounder *= 1.0E-10;\n                    idx -= 10;\n                }\n            if (xtype == 1) {\n                double rx = (double)realvalue;\n                sqlite3_uint64 u;\n                int ex;\n                memcpy(&u, &rx, sizeof (u));\n                ex = -1023 + (int)((u >> 52) & 2047);\n                if (precision + (ex / 3) < 15)\n                    rounder += realvalue * 2.9999999999999999E-16;\n                realvalue += rounder;\n            }\n            exp = 0;\n            if (sqlite3IsNaN((double)realvalue)) {\n                bufpt = \"NaN\";\n                length = 3;\n                break;\n            }\n            if (realvalue > 0.) {\n                long double scale = 1.;\n                while (realvalue >= 1.0E+100 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+100;\n                        exp += 100;\n                    }\n                while (realvalue >= 1.0E+10 * scale && exp <= 350)\n                    {\n                        scale *= 1.0E+10;\n                        exp += 10;\n                    }\n                while (realvalue >= 10. * scale && exp <= 350)\n                    {\n                        scale *= 10.;\n                        exp++;\n                    }\n                realvalue /= scale;\n                while (realvalue < 1.0E-8)\n                    {\n                        realvalue *= 1.0E+8;\n                        exp -= 8;\n                    }\n                while (realvalue < 1.)\n                    {\n                        realvalue *= 10.;\n                        exp--;\n                    }\n                if (exp > 350) {\n                    bufpt = buf;\n                    buf[0] = prefix;\n                    memcpy(buf + (prefix != 0), \"Inf\", 4);\n                    length = 3 + (prefix != 0);\n                    break;\n                }\n            }\n            bufpt = buf;\n            if (xtype != 1) {\n                realvalue += rounder;\n                if (realvalue >= 10.) {\n                    realvalue *= 0.10000000000000001;\n                    exp++;\n                }\n            }\n            if (xtype == 3) {\n                flag_rtz = !flag_alternateform;\n                if (exp < -4 || exp > precision) {\n                    xtype = 2;\n                } else {\n                    precision = precision - exp;\n                    xtype = 1;\n                }\n            } else {\n                flag_rtz = flag_altform2;\n            }\n            if (xtype == 2) {\n                e2 = 0;\n            } else {\n                e2 = exp;\n            }\n            {\n                i64 szBufNeeded;\n                szBufNeeded = ((e2) > (0) ? (e2) : (0)) + (i64)precision + (i64)width + 15;\n                if (szBufNeeded > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);\n                    if (bufpt == 0)\n                        return;\n                }\n            }\n            zOut = bufpt;\n            nsd = 16 + flag_altform2 * 10;\n            flag_dp = (precision > 0 ? 1 : 0) | flag_alternateform | flag_altform2;\n            if (prefix) {\n                *(bufpt++) = prefix;\n            }\n            if (e2 < 0) {\n                *(bufpt++) = '0';\n            } else {\n                for (; e2 >= 0; e2--) {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            }\n            if (flag_dp) {\n                *(bufpt++) = '.';\n            }\n            for (e2++; e2 < 0; precision-- , e2++) {\n                assert(precision > 0);\n                *(bufpt++) = '0';\n            }\n            while ((precision--) > 0)\n                {\n                    *(bufpt++) = et_getdigit(&realvalue, &nsd);\n                }\n            if (flag_rtz && flag_dp) {\n                while (bufpt[-1] == '0')\n                    *(--bufpt) = 0;\n                assert(bufpt > zOut);\n                if (bufpt[-1] == '.') {\n                    if (flag_altform2) {\n                        *(bufpt++) = '0';\n                    } else {\n                        *(--bufpt) = 0;\n                    }\n                }\n            }\n            if (xtype == 2) {\n                *(bufpt++) = aDigits[infop->charset];\n                if (exp < 0) {\n                    *(bufpt++) = '-';\n                    exp = -exp;\n                } else {\n                    *(bufpt++) = '+';\n                }\n                if (exp >= 100) {\n                    *(bufpt++) = (char)((exp / 100) + '0');\n                    exp %= 100;\n                }\n                *(bufpt++) = (char)(exp / 10 + '0');\n                *(bufpt++) = (char)(exp % 10 + '0');\n            }\n            *bufpt = 0;\n            length = (int)(bufpt - zOut);\n            bufpt = zOut;\n            if (flag_zeropad && !flag_leftjustify && length < width) {\n                int i;\n                int nPad = width - length;\n                for (i = width; i >= nPad; i--) {\n                    bufpt[i] = bufpt[i - nPad];\n                }\n                i = prefix != 0;\n                while (nPad--)\n                    bufpt[i++] = '0';\n                length = width;\n            }\n            break;\n          case 4:\n            if (!bArgList) {\n            }\n            length = width = 0;\n            break;\n          case 7:\n            buf[0] = '%';\n            bufpt = buf;\n            length = 1;\n            break;\n          case 8:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                length = 1;\n                if (bufpt) {\n                    buf[0] = c = *(bufpt++);\n                    if ((c & 192) == 192) {\n                        while (length < 4 && (bufpt[0] & 192) == 128)\n                            {\n                                buf[length++] = *(bufpt++);\n                            }\n                    }\n                } else {\n                    buf[0] = 0;\n                }\n            } else {\n                unsigned int ch;\n                if (ch < 128) {\n                    buf[0] = ch & 255;\n                    length = 1;\n                } else if (ch < 2048) {\n                    buf[0] = 192 + (u8)((ch >> 6) & 31);\n                    buf[1] = 128 + (u8)(ch & 63);\n                    length = 2;\n                } else if (ch < 65536) {\n                    buf[0] = 224 + (u8)((ch >> 12) & 15);\n                    buf[1] = 128 + (u8)((ch >> 6) & 63);\n                    buf[2] = 128 + (u8)(ch & 63);\n                    length = 3;\n                } else {\n                    buf[0] = 240 + (u8)((ch >> 18) & 7);\n                    buf[1] = 128 + (u8)((ch >> 12) & 63);\n                    buf[2] = 128 + (u8)((ch >> 6) & 63);\n                    buf[3] = 128 + (u8)(ch & 63);\n                    length = 4;\n                }\n            }\n            if (precision > 1) {\n                width -= precision - 1;\n                if (width > 1 && !flag_leftjustify) {\n                    sqlite3_str_appendchar(pAccum, width - 1, ' ');\n                    width = 0;\n                }\n                while (precision-- > 1)\n                    {\n                        sqlite3_str_append(pAccum, buf, length);\n                    }\n            }\n            bufpt = buf;\n            flag_altform2 = 1;\n            goto adjust_width_for_utf8;\n          case 5:\n          case 6:\n            if (bArgList) {\n                bufpt = getTextArg(pArgList);\n                xtype = 5;\n            } else {\n            }\n            if (bufpt == 0) {\n                bufpt = \"\";\n            } else if (xtype == 6) {\n                if (pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 && pAccum->accError == 0) {\n                    assert((pAccum->printfFlags & 4) == 0);\n                    pAccum->zText = bufpt;\n                    pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);\n                    pAccum->nChar = 2147483647 & (int)strlen(bufpt);\n                    pAccum->printfFlags |= 4;\n                    length = 0;\n                    break;\n                }\n                zExtra = bufpt;\n            }\n            if (precision >= 0) {\n                if (flag_altform2) {\n                    unsigned char *z = (unsigned char *)bufpt;\n                    while (precision-- > 0 && z[0])\n                        {\n                            {\n                                if ((*(z++)) >= 192) {\n                                    while ((*z & 192) == 128)\n                                        {\n                                            z++;\n                                        }\n                                }\n                            }\n                            ;\n                        }\n                    length = (int)(z - (unsigned char *)bufpt);\n                } else {\n                    for (length = 0; length < precision && bufpt[length]; length++) {\n                    }\n                }\n            } else {\n                length = 2147483647 & (int)strlen(bufpt);\n            }\n          adjust_width_for_utf8:\n            if (flag_altform2 && width > 0) {\n                int ii = length - 1;\n                while (ii >= 0)\n                    if ((bufpt[ii--] & 192) == 128)\n                        width++;\n            }\n            break;\n          case 9:\n          case 10:\n          case 14:\n            {\n                i64 i, j, k, n;\n                int needQuote, isnull;\n                char ch;\n                char q = ((xtype == 14) ? '\"' : '\\'');\n                char *escarg;\n                if (bArgList) {\n                    escarg = getTextArg(pArgList);\n                } else {\n                }\n                isnull = escarg == 0;\n                if (isnull)\n                    escarg = (xtype == 10 ? \"NULL\" : \"(NULL)\");\n                k = precision;\n                for (i = n = 0; k != 0 && (ch = escarg[i]) != 0; i++ , k--) {\n                    if (ch == q)\n                        n++;\n                    if (flag_altform2 && (ch & 192) == 192) {\n                        while ((escarg[i + 1] & 192) == 128)\n                            {\n                                i++;\n                            }\n                    }\n                }\n                needQuote = !isnull && xtype == 10;\n                n += i + 3;\n                if (n > 70) {\n                    bufpt = zExtra = printfTempBuf(pAccum, n);\n                    if (bufpt == 0)\n                        return;\n                } else {\n                    bufpt = buf;\n                }\n                j = 0;\n                if (needQuote)\n                    bufpt[j++] = q;\n                k = i;\n                for (i = 0; i < k; i++) {\n                    bufpt[j++] = ch = escarg[i];\n                    if (ch == q)\n                        bufpt[j++] = ch;\n                }\n                if (needQuote)\n                    bufpt[j++] = q;\n                bufpt[j] = 0;\n                length = j;\n                goto adjust_width_for_utf8;\n            }\n          case 11:\n            {\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                if (flag_alternateform) {\n                    Expr *pExpr;\n                    if ((pExpr) && (!(((pExpr)->flags & (2048)) != 0))) {\n                        sqlite3_str_appendall(pAccum, (const char *)pExpr->u.zToken);\n                        sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);\n                    }\n                } else {\n                    Token *pToken;\n                    assert(bArgList == 0);\n                    if (pToken && pToken->n) {\n                        sqlite3_str_append(pAccum, (const char *)pToken->z, pToken->n);\n                        sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          case 12:\n            {\n                SrcItem *pItem;\n                if ((pAccum->printfFlags & 1) == 0)\n                    return;\n                assert(bArgList == 0);\n                if (pItem->zAlias && !flag_altform2) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else if (pItem->zName) {\n                    if (pItem->zDatabase) {\n                        sqlite3_str_appendall(pAccum, pItem->zDatabase);\n                        sqlite3_str_append(pAccum, \".\", 1);\n                    }\n                    sqlite3_str_appendall(pAccum, pItem->zName);\n                } else if (pItem->zAlias) {\n                    sqlite3_str_appendall(pAccum, pItem->zAlias);\n                } else {\n                    Select *pSel = pItem->pSelect;\n                    assert(pSel != 0);\n                    if (pSel->selFlags & 2048) {\n                        sqlite3_str_appendf(pAccum, \"(join-%u)\", pSel->selId);\n                    } else {\n                        sqlite3_str_appendf(pAccum, \"(subquery-%u)\", pSel->selId);\n                    }\n                }\n                length = width = 0;\n                break;\n            }\n          default:\n            {\n                assert(xtype == 17);\n                return;\n            }\n        }\n        width -= length;\n        if (width > 0) {\n            if (!flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n            sqlite3_str_append(pAccum, bufpt, length);\n            if (flag_leftjustify)\n                sqlite3_str_appendchar(pAccum, width, ' ');\n        } else {\n            sqlite3_str_append(pAccum, bufpt, length);\n        }\n        if (zExtra) {\n            sqlite3DbFree(pAccum->db, zExtra);\n            zExtra = 0;\n        }\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/sqlite3.c#198948:1#jsonRemoveFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    JsonParse x;\n    JsonNode *pNode;\n    const char *zPath;\n    u32 i;\n    if (argc < 1)\n        return;\n    if (jsonParse(&x, ctx, (const char *)sqlite3_value_text(argv[0])))\n        return;\n    assert(x.nNode);\n    for (i = 1; i < (u32)argc; i++) {\n        zPath = (const char *)sqlite3_value_text(argv[i]);\n        if (zPath == 0)\n            goto remove_done;\n        pNode = jsonLookup(&x, zPath, 0, ctx);\n        if (x.nErr)\n            goto remove_done;\n        if (pNode)\n            pNode->jnFlags |= 4;\n    }\n    if ((x.aNode[0].jnFlags & 4) == 0) {\n        jsonReturnJson(x.aNode, ctx, 0);\n    }\n  remove_done:\n    jsonParseReset(&x);\n}\n"
  },
  {
    "id": "#23:25#sqlite3WhereCodeOneLoopStart",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int j, k;\n    int iCur;\n    int addrNxt;\n    int bRev;\n    WhereLoop *pLoop;\n    WhereClause *pWC;\n    WhereTerm *pTerm;\n    sqlite3 *db;\n    SrcItem *pTabItem;\n    int addrBrk;\n    int addrHalt;\n    int addrCont;\n    int iRowidReg = 0;\n    int iReleaseReg = 0;\n    Index *pIdx = 0;\n    int iLoop;\n    pWC = &pWInfo->sWC;\n    db = pParse->db;\n    pLoop = pLevel->pWLoop;\n    pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];\n    iCur = pTabItem->iCursor;\n    pLevel->notReady = notReady & ~sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);\n    bRev = (pWInfo->revMask >> iLevel) & 1;\n    ;\n    addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);\n    addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(pParse);\n    assert((pWInfo->wctrlFlags & (32 | 4096)) || pLevel->iFrom > 0 || (pTabItem[0].fg.jointype & 8) == 0);\n    if (pLevel->iFrom > 0 && (pTabItem[0].fg.jointype & 8) != 0) {\n        pLevel->iLeftJoin = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, pLevel->iLeftJoin);\n        ;\n    }\n    for (j = iLevel; j > 0; j--) {\n        if (pWInfo->a[j].iLeftJoin)\n            break;\n        if (pWInfo->a[j].pRJ)\n            break;\n    }\n    addrHalt = pWInfo->a[j].addrBrk;\n    if (pTabItem->fg.viaCoroutine) {\n        int regYield = pTabItem->regReturn;\n        sqlite3VdbeAddOp3(v, 11, regYield, 0, pTabItem->addrFillSub);\n        pLevel->p2 = sqlite3VdbeAddOp2(v, 12, regYield, addrBrk);\n        ;\n        ;\n        pLevel->op = 9;\n    } else if ((pLoop->wsFlags & 1024) != 0) {\n        int iReg;\n        int addrNotFound;\n        int nConstraint = pLoop->nLTerm;\n        iReg = sqlite3GetTempRange(pParse, nConstraint + 2);\n        addrNotFound = pLevel->addrBrk;\n        for (j = 0; j < nConstraint; j++) {\n            int iTarget = iReg + j + 2;\n            pTerm = pLoop->aLTerm[j];\n            if ((pTerm == 0))\n                continue;\n            if (pTerm->eOperator & 1) {\n                if (((j) <= 31 ? ((unsigned int)1) << (j) : 0) & pLoop->u.vtab.mHandleIn) {\n                    int iTab = pParse->nTab++;\n                    int iCache = ++pParse->nMem;\n                    sqlite3CodeRhsOfIN(pParse, pTerm->pExpr, iTab);\n                    sqlite3VdbeAddOp3(v, 174, iTab, iTarget, iCache);\n                } else {\n                    codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);\n                    addrNotFound = pLevel->addrNxt;\n                }\n            } else {\n                Expr *pRight = pTerm->pExpr->pRight;\n                codeExprOrVector(pParse, pRight, iTarget, 1);\n                if (pTerm->eMatchOp == 74 && pLoop->u.vtab.bOmitOffset) {\n                    assert(pTerm->eOperator == 64);\n                    assert(pWInfo->pSelect != 0);\n                    assert(pWInfo->pSelect->iOffset > 0);\n                    sqlite3VdbeAddOp2(v, 71, 0, pWInfo->pSelect->iOffset);\n                    ;\n                }\n            }\n        }\n        sqlite3VdbeAddOp2(v, 71, pLoop->u.vtab.idxNum, iReg);\n        sqlite3VdbeAddOp2(v, 71, nConstraint, iReg + 1);\n        sqlite3VdbeAddOp4(v, 6, iCur, addrNotFound, iReg, pLoop->u.vtab.idxStr, pLoop->u.vtab.needFree ? (-6) : (-1));\n        ;\n        pLoop->u.vtab.needFree = 0;\n        if (db->mallocFailed)\n            pLoop->u.vtab.idxStr = 0;\n        pLevel->p1 = iCur;\n        pLevel->op = pWInfo->eOnePass ? 184 : 63;\n        pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        assert((pLoop->wsFlags & 8192) == 0);\n        for (j = 0; j < nConstraint; j++) {\n            pTerm = pLoop->aLTerm[j];\n            if (j < 16 && (pLoop->u.vtab.omitMask >> j) & 1) {\n                disableTerm(pLevel, pTerm);\n                continue;\n            }\n            if ((pTerm->eOperator & 1) != 0 && (((j) <= 31 ? ((unsigned int)1) << (j) : 0) & pLoop->u.vtab.mHandleIn) == 0 && !db->mallocFailed) {\n                Expr *pCompare;\n                Expr *pRight;\n                VdbeOp *pOp;\n                int iIn;\n                for (iIn = 0; (iIn < pLevel->u.in.nIn); iIn++) {\n                    pOp = sqlite3VdbeGetOp(v, pLevel->u.in.aInLoop[iIn].addrInTop);\n                    if ((pOp->opcode == 94 && pOp->p3 == iReg + j + 2) || (pOp->opcode == 135 && pOp->p2 == iReg + j + 2)) {\n                        ;\n                        sqlite3VdbeAddOp3(v, pOp->opcode, pOp->p1, pOp->p2, pOp->p3);\n                        break;\n                    }\n                }\n                pCompare = sqlite3PExpr(pParse, 53, 0, 0);\n                if (!db->mallocFailed) {\n                    int iFld = pTerm->u.x.iField;\n                    Expr *pLeft = pTerm->pExpr->pLeft;\n                    assert(pLeft != 0);\n                    if (iFld > 0) {\n                        assert(pLeft->op == 177);\n                        assert((((pLeft)->flags & 4096) == 0));\n                        assert(iFld <= pLeft->x.pList->nExpr);\n                        pCompare->pLeft = pLeft->x.pList->a[iFld - 1].pExpr;\n                    } else {\n                        pCompare->pLeft = pLeft;\n                    }\n                    pCompare->pRight = pRight = sqlite3Expr(db, 176, 0);\n                    if (pRight) {\n                        pRight->iTable = iReg + j + 2;\n                        sqlite3ExprIfFalse(pParse, pCompare, pLevel->addrCont, 16);\n                    }\n                    pCompare->pLeft = 0;\n                }\n                sqlite3ExprDelete(db, pCompare);\n            }\n        }\n    } else if ((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & (4 | 1)) != 0) {\n        assert(pLoop->u.btree.nEq == 1);\n        pTerm = pLoop->aLTerm[0];\n        assert(pTerm != 0);\n        assert(pTerm->pExpr != 0);\n        ;\n        iReleaseReg = ++pParse->nMem;\n        iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);\n        if (iRowidReg != iReleaseReg)\n            sqlite3ReleaseTempReg(pParse, iReleaseReg);\n        addrNxt = pLevel->addrNxt;\n        if (pLevel->regFilter) {\n            sqlite3VdbeAddOp2(v, 13, iRowidReg, addrNxt);\n            ;\n            sqlite3VdbeAddOp4Int(v, 64, pLevel->regFilter, addrNxt, iRowidReg, 1);\n            ;\n            filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady);\n        }\n        sqlite3VdbeAddOp3(v, 30, iCur, addrNxt, iRowidReg);\n        ;\n        pLevel->op = 184;\n    } else if ((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & 2) != 0) {\n        int testOp = 184;\n        int start;\n        int memEndValue = 0;\n        WhereTerm *pStart, *pEnd;\n        j = 0;\n        pStart = pEnd = 0;\n        if (pLoop->wsFlags & 32)\n            pStart = pLoop->aLTerm[j++];\n        if (pLoop->wsFlags & 16)\n            pEnd = pLoop->aLTerm[j++];\n        assert(pStart != 0 || pEnd != 0);\n        if (bRev) {\n            pTerm = pStart;\n            pStart = pEnd;\n            pEnd = pTerm;\n        }\n        ;\n        if (pStart) {\n            Expr *pX;\n            int r1, rTemp;\n            int op;\n            const u8 aMoveOp[] = {24, 22, 21, 23};\n            assert(55 == 54 + 1);\n            assert(56 == 54 + 2);\n            assert(57 == 54 + 3);\n            assert((pStart->wtFlags & 128) == 0);\n            ;\n            pX = pStart->pExpr;\n            assert(pX != 0);\n            ;\n            if (sqlite3ExprIsVector(pX->pRight)) {\n                r1 = rTemp = sqlite3GetTempReg(pParse);\n                codeExprOrVector(pParse, pX->pRight, r1, 1);\n                ;\n                ;\n                ;\n                ;\n                op = aMoveOp[((pX->op - 54 - 1) & 3) | 1];\n                assert(pX->op != 54 || op == 23);\n                assert(pX->op != 57 || op == 23);\n                assert(pX->op != 56 || op == 22);\n                assert(pX->op != 55 || op == 22);\n            } else {\n                r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);\n                disableTerm(pLevel, pStart);\n                op = aMoveOp[(pX->op - 54)];\n            }\n            sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);\n            ;\n            ;\n            ;\n            ;\n            ;\n            sqlite3ReleaseTempReg(pParse, rTemp);\n        } else {\n            sqlite3VdbeAddOp2(v, bRev ? 32 : 36, iCur, addrHalt);\n            ;\n            ;\n        }\n        if (pEnd) {\n            Expr *pX;\n            pX = pEnd->pExpr;\n            assert(pX != 0);\n            assert((pEnd->wtFlags & 128) == 0);\n            ;\n            ;\n            memEndValue = ++pParse->nMem;\n            codeExprOrVector(pParse, pX->pRight, memEndValue, 1);\n            if (0 == sqlite3ExprIsVector(pX->pRight) && (pX->op == 56 || pX->op == 54)) {\n                testOp = bRev ? 55 : 57;\n            } else {\n                testOp = bRev ? 56 : 54;\n            }\n            if (0 == sqlite3ExprIsVector(pX->pRight)) {\n                disableTerm(pLevel, pEnd);\n            }\n        }\n        start = sqlite3VdbeCurrentAddr(v);\n        pLevel->op = bRev ? 38 : 39;\n        pLevel->p1 = iCur;\n        pLevel->p2 = start;\n        assert(pLevel->p5 == 0);\n        if (testOp != 184) {\n            iRowidReg = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 135, iCur, iRowidReg);\n            sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);\n            ;\n            ;\n            ;\n            ;\n            sqlite3VdbeChangeP5(v, 67 | 16);\n        }\n    } else if (pLoop->wsFlags & 512) {\n        static const u8 aStartOp[] = {0, 0, 36, 32, 24, 21, 23, 22};\n        static const u8 aEndOp[] = {45, 41, 40, 42};\n        u16 nEq = pLoop->u.btree.nEq;\n        u16 nBtm = pLoop->u.btree.nBtm;\n        u16 nTop = pLoop->u.btree.nTop;\n        int regBase;\n        WhereTerm *pRangeStart = 0;\n        WhereTerm *pRangeEnd = 0;\n        int startEq;\n        int endEq;\n        int start_constraints;\n        int nConstraint;\n        int iIdxCur;\n        int nExtraReg = 0;\n        int op;\n        char *zStartAff;\n        char *zEndAff = 0;\n        u8 bSeekPastNull = 0;\n        u8 bStopAtNull = 0;\n        int omitTable;\n        int regBignull = 0;\n        int addrSeekScan = 0;\n        pIdx = pLoop->u.btree.pIndex;\n        iIdxCur = pLevel->iIdxCur;\n        assert(nEq >= pLoop->nSkip);\n        j = nEq;\n        if (pLoop->wsFlags & 32) {\n            pRangeStart = pLoop->aLTerm[j++];\n            nExtraReg = ((nExtraReg) > (pLoop->u.btree.nBtm) ? (nExtraReg) : (pLoop->u.btree.nBtm));\n            assert((pRangeStart->wtFlags & 256) == 0 || (pLoop->wsFlags & 16) != 0);\n        }\n        if (pLoop->wsFlags & 16) {\n            pRangeEnd = pLoop->aLTerm[j++];\n            nExtraReg = ((nExtraReg) > (pLoop->u.btree.nTop) ? (nExtraReg) : (pLoop->u.btree.nTop));\n            if ((pRangeEnd->wtFlags & 256) != 0) {\n                assert(pRangeStart != 0);\n                assert(pRangeStart->wtFlags & 256);\n                pLevel->iLikeRepCntr = (u32)++pParse->nMem;\n                sqlite3VdbeAddOp2(v, 71, 1, (int)pLevel->iLikeRepCntr);\n                ;\n                pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);\n                ;\n                ;\n                assert((bRev & ~1) == 0);\n                pLevel->iLikeRepCntr <<= 1;\n                pLevel->iLikeRepCntr |= bRev ^ (pIdx->aSortOrder[nEq] == 1);\n            }\n            if (pRangeStart == 0) {\n                j = pIdx->aiColumn[nEq];\n                if ((j >= 0 && pIdx->pTable->aCol[j].notNull == 0) || j == (-2)) {\n                    bSeekPastNull = 1;\n                }\n            }\n        }\n        assert(pRangeEnd == 0 || (pRangeEnd->wtFlags & 128) == 0);\n        if ((pLoop->wsFlags & (16 | 32)) == 0 && (pLoop->wsFlags & 524288) != 0) {\n            assert(bSeekPastNull == 0 && nExtraReg == 0 && nBtm == 0 && nTop == 0);\n            assert(pRangeEnd == 0 && pRangeStart == 0);\n            ;\n            nExtraReg = 1;\n            bSeekPastNull = 1;\n            pLevel->regBignull = regBignull = ++pParse->nMem;\n            if (pLevel->iLeftJoin) {\n                sqlite3VdbeAddOp2(v, 71, 0, regBignull);\n            }\n            pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);\n        }\n        if ((nEq < pIdx->nColumn && bRev == (pIdx->aSortOrder[nEq] == 0))) {\n            {\n                WhereTerm *t = pRangeEnd;\n                pRangeEnd = pRangeStart;\n                pRangeStart = t;\n            }\n            ;\n            {\n                u8 t = bSeekPastNull;\n                bSeekPastNull = bStopAtNull;\n                bStopAtNull = t;\n            }\n            ;\n            {\n                u8 t = nBtm;\n                nBtm = nTop;\n                nTop = t;\n            }\n            ;\n        }\n        if (iLevel > 0 && (pLoop->wsFlags & 1048576) != 0) {\n            sqlite3VdbeAddOp1(v, 136, iIdxCur);\n        }\n        ;\n        regBase = codeAllEqualityTerms(pParse, pLevel, bRev, nExtraReg, &zStartAff);\n        assert(zStartAff == 0 || sqlite3Strlen30(zStartAff) >= nEq);\n        if (zStartAff && nTop) {\n            zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);\n        }\n        addrNxt = (regBignull ? pLevel->addrBignull : pLevel->addrNxt);\n        ;\n        ;\n        ;\n        ;\n        startEq = !pRangeStart || pRangeStart->eOperator & ((2 << (55 - 53)) | (2 << (57 - 53)));\n        endEq = !pRangeEnd || pRangeEnd->eOperator & ((2 << (55 - 53)) | (2 << (57 - 53)));\n        start_constraints = pRangeStart || nEq > 0;\n        nConstraint = nEq;\n        if (pRangeStart) {\n            Expr *pRight = pRangeStart->pExpr->pRight;\n            codeExprOrVector(pParse, pRight, regBase + nEq, nBtm);\n            whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);\n            if ((pRangeStart->wtFlags & 128) == 0 && sqlite3ExprCanBeNull(pRight)) {\n                sqlite3VdbeAddOp2(v, 50, regBase + nEq, addrNxt);\n                ;\n            }\n            if (zStartAff) {\n                updateRangeAffinityStr(pRight, nBtm, &zStartAff[nEq]);\n            }\n            nConstraint += nBtm;\n            ;\n            if (sqlite3ExprIsVector(pRight) == 0) {\n                disableTerm(pLevel, pRangeStart);\n            } else {\n                startEq = 1;\n            }\n            bSeekPastNull = 0;\n        } else if (bSeekPastNull) {\n            startEq = 0;\n            sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n            start_constraints = 1;\n            nConstraint++;\n        } else if (regBignull) {\n            sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n            start_constraints = 1;\n            nConstraint++;\n        }\n        codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);\n        if (pLoop->nSkip > 0 && nConstraint == pLoop->nSkip) {\n        } else {\n            if (regBignull) {\n                sqlite3VdbeAddOp2(v, 71, 1, regBignull);\n                ;\n            }\n            if (pLevel->regFilter) {\n                sqlite3VdbeAddOp4Int(v, 64, pLevel->regFilter, addrNxt, regBase, nEq);\n                ;\n                filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady);\n            }\n            op = aStartOp[(start_constraints << 2) + (startEq << 1) + bRev];\n            assert(op != 0);\n            if ((pLoop->wsFlags & 1048576) != 0 && op == 23) {\n                assert(regBignull == 0);\n                addrSeekScan = sqlite3VdbeAddOp1(v, 124, (pIdx->aiRowLogEst[0] + 9) / 10);\n                if (pRangeStart) {\n                    sqlite3VdbeChangeP5(v, 1);\n                    sqlite3VdbeChangeP2(v, addrSeekScan, sqlite3VdbeCurrentAddr(v) + 1);\n                    addrSeekScan = 0;\n                }\n                ;\n            }\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            assert(bSeekPastNull == 0 || bStopAtNull == 0);\n            if (regBignull) {\n                assert(bSeekPastNull == 1 || bStopAtNull == 1);\n                assert(bSeekPastNull == !bStopAtNull);\n                assert(bStopAtNull == startEq);\n                sqlite3VdbeAddOp2(v, 9, 0, sqlite3VdbeCurrentAddr(v) + 2);\n                op = aStartOp[(nConstraint > 1) * 4 + 2 + bRev];\n                sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint - startEq);\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                ;\n                assert(op == 36 || op == 32 || op == 23 || op == 22);\n            }\n        }\n        nConstraint = nEq;\n        assert(pLevel->p2 == 0);\n        if (pRangeEnd) {\n            Expr *pRight = pRangeEnd->pExpr->pRight;\n            if (addrSeekScan) {\n                pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n            }\n            codeExprOrVector(pParse, pRight, regBase + nEq, nTop);\n            whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);\n            if ((pRangeEnd->wtFlags & 128) == 0 && sqlite3ExprCanBeNull(pRight)) {\n                sqlite3VdbeAddOp2(v, 50, regBase + nEq, addrNxt);\n                ;\n            }\n            if (zEndAff) {\n                updateRangeAffinityStr(pRight, nTop, zEndAff);\n                codeApplyAffinity(pParse, regBase + nEq, nTop, zEndAff);\n            } else {\n                assert(pParse->db->mallocFailed);\n            }\n            nConstraint += nTop;\n            ;\n            if (sqlite3ExprIsVector(pRight) == 0) {\n                disableTerm(pLevel, pRangeEnd);\n            } else {\n                endEq = 1;\n            }\n        } else if (bStopAtNull) {\n            if (regBignull == 0) {\n                sqlite3VdbeAddOp2(v, 75, 0, regBase + nEq);\n                endEq = 0;\n            }\n            nConstraint++;\n        }\n        if (zStartAff)\n            sqlite3DbNNFreeNN(db, zStartAff);\n        if (zEndAff)\n            sqlite3DbNNFreeNN(db, zEndAff);\n        if (pLevel->p2 == 0)\n            pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        if (nConstraint) {\n            if (regBignull) {\n                sqlite3VdbeAddOp2(v, 17, regBignull, sqlite3VdbeCurrentAddr(v) + 3);\n                ;\n                ;\n            }\n            op = aEndOp[bRev * 2 + endEq];\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            if (addrSeekScan)\n                sqlite3VdbeJumpHere(v, addrSeekScan);\n        }\n        if (regBignull) {\n            assert(bSeekPastNull == !bStopAtNull);\n            assert(bSeekPastNull + bStopAtNull == 1);\n            assert(nConstraint + bSeekPastNull > 0);\n            sqlite3VdbeAddOp2(v, 16, regBignull, sqlite3VdbeCurrentAddr(v) + 2);\n            ;\n            ;\n            op = aEndOp[bRev * 2 + bSeekPastNull];\n            sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint + bSeekPastNull);\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n            ;\n        }\n        if ((pLoop->wsFlags & 262144) != 0) {\n            sqlite3VdbeAddOp3(v, 125, iIdxCur, nEq, nEq);\n        }\n        omitTable = (pLoop->wsFlags & 64) != 0 && (pWInfo->wctrlFlags & (32 | 4096)) == 0;\n        if (omitTable) {\n        } else if ((((pIdx->pTable)->tabFlags & 128) == 0)) {\n            codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);\n        } else if (iCur != iIdxCur) {\n            Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);\n            iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);\n            for (j = 0; j < pPk->nKeyCol; j++) {\n                k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);\n                sqlite3VdbeAddOp3(v, 94, iIdxCur, k, iRowidReg + j);\n            }\n            sqlite3VdbeAddOp4Int(v, 28, iCur, addrCont, iRowidReg, pPk->nKeyCol);\n            ;\n        }\n        if (pLevel->iLeftJoin == 0) {\n            if (pIdx->pPartIdxWhere) {\n                whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);\n            }\n        } else {\n            ;\n            assert((pWInfo->wctrlFlags & (32 | 4096)) == 0);\n        }\n        if (pLoop->wsFlags & 4096) {\n            pLevel->op = 184;\n        } else if (bRev) {\n            pLevel->op = 38;\n        } else {\n            pLevel->op = 39;\n        }\n        pLevel->p1 = iIdxCur;\n        pLevel->p3 = (pLoop->wsFlags & 65536) != 0 ? 1 : 0;\n        if ((pLoop->wsFlags & 15) == 0) {\n            pLevel->p5 = 1;\n        } else {\n            assert(pLevel->p5 == 0);\n        }\n        if (omitTable)\n            pIdx = 0;\n    } else if (pLoop->wsFlags & 8192) {\n        WhereClause *pOrWc;\n        SrcList *pOrTab;\n        Index *pCov = 0;\n        int iCovCur = pParse->nTab++;\n        int regReturn = ++pParse->nMem;\n        int regRowset = 0;\n        int regRowid = 0;\n        int iLoopBody = sqlite3VdbeMakeLabel(pParse);\n        int iRetInit;\n        int untestedTerms = 0;\n        int ii;\n        Expr *pAndExpr = 0;\n        Table *pTab = pTabItem->pTab;\n        pTerm = pLoop->aLTerm[0];\n        assert(pTerm != 0);\n        assert(pTerm->eOperator & 512);\n        assert((pTerm->wtFlags & 16) != 0);\n        pOrWc = &pTerm->u.pOrInfo->wc;\n        pLevel->op = 67;\n        pLevel->p1 = regReturn;\n        if (pWInfo->nLevel > 1) {\n            int nNotReady;\n            SrcItem *origSrc;\n            nNotReady = pWInfo->nLevel - iLevel - 1;\n            pOrTab = sqlite3DbMallocRawNN(db, sizeof (*pOrTab) + nNotReady * sizeof (pOrTab->a[0]));\n            if (pOrTab == 0)\n                return notReady;\n            pOrTab->nAlloc = (u8)(nNotReady + 1);\n            pOrTab->nSrc = pOrTab->nAlloc;\n            memcpy(pOrTab->a, pTabItem, sizeof (*pTabItem));\n            origSrc = pWInfo->pTabList->a;\n            for (k = 1; k <= nNotReady; k++) {\n                memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof (pOrTab->a[k]));\n            }\n        } else {\n            pOrTab = pWInfo->pTabList;\n        }\n        if ((pWInfo->wctrlFlags & 16) == 0) {\n            if ((((pTab)->tabFlags & 128) == 0)) {\n                regRowset = ++pParse->nMem;\n                sqlite3VdbeAddOp2(v, 75, 0, regRowset);\n            } else {\n                Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                regRowset = pParse->nTab++;\n                sqlite3VdbeAddOp2(v, 118, regRowset, pPk->nKeyCol);\n                sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n            }\n            regRowid = ++pParse->nMem;\n        }\n        iRetInit = sqlite3VdbeAddOp2(v, 71, 0, regReturn);\n        if (pWC->nTerm > 1) {\n            int iTerm;\n            for (iTerm = 0; iTerm < pWC->nTerm; iTerm++) {\n                Expr *pExpr = pWC->a[iTerm].pExpr;\n                if (&pWC->a[iTerm] == pTerm)\n                    continue;\n                ;\n                ;\n                ;\n                if ((pWC->a[iTerm].wtFlags & (2 | 4 | 32768)) != 0) {\n                    continue;\n                }\n                if ((pWC->a[iTerm].eOperator & 16383) == 0)\n                    continue;\n                if ((((pExpr)->flags & (4194304)) != 0))\n                    continue;\n                pExpr = sqlite3ExprDup(db, pExpr, 0);\n                pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);\n            }\n            if (pAndExpr) {\n                pAndExpr = sqlite3PExpr(pParse, 44 | 65536, 0, pAndExpr);\n            }\n        }\n        sqlite3VdbeExplain(pParse, 1, \"MULTI-INDEX OR\");\n        for (ii = 0; ii < pOrWc->nTerm; ii++) {\n            WhereTerm *pOrTerm = &pOrWc->a[ii];\n            if (pOrTerm->leftCursor == iCur || (pOrTerm->eOperator & 1024) != 0) {\n                WhereInfo *pSubWInfo;\n                Expr *pOrExpr = pOrTerm->pExpr;\n                Expr *pDelete;\n                int jmp1 = 0;\n                ;\n                pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, 0);\n                if (db->mallocFailed) {\n                    sqlite3ExprDelete(db, pDelete);\n                    continue;\n                }\n                if (pAndExpr) {\n                    pAndExpr->pLeft = pOrExpr;\n                    pOrExpr = pAndExpr;\n                }\n                sqlite3VdbeExplain(pParse, 1, \"INDEX %d\", ii + 1);\n                ;\n                pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0, 0, 32, iCovCur);\n                assert(pSubWInfo || pParse->nErr);\n                if (pSubWInfo) {\n                    WhereLoop *pSubLoop;\n                    int addrExplain = sqlite3WhereExplainOneScan(pParse, pOrTab, &pSubWInfo->a[0], 0);\n                    ((void)addrExplain);\n                    if ((pWInfo->wctrlFlags & 16) == 0) {\n                        int iSet = ((ii == pOrWc->nTerm - 1) ? -1 : ii);\n                        if ((((pTab)->tabFlags & 128) == 0)) {\n                            sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid);\n                            jmp1 = sqlite3VdbeAddOp4Int(v, 47, regRowset, 0, regRowid, iSet);\n                            ;\n                        } else {\n                            Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n                            int nPk = pPk->nKeyCol;\n                            int iPk;\n                            int r;\n                            r = sqlite3GetTempRange(pParse, nPk);\n                            for (iPk = 0; iPk < nPk; iPk++) {\n                                int iCol = pPk->aiColumn[iPk];\n                                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r + iPk);\n                            }\n                            if (iSet) {\n                                jmp1 = sqlite3VdbeAddOp4Int(v, 29, regRowset, 0, r, nPk);\n                                ;\n                            }\n                            if (iSet >= 0) {\n                                sqlite3VdbeAddOp3(v, 97, r, nPk, regRowid);\n                                sqlite3VdbeAddOp4Int(v, 138, regRowset, regRowid, r, nPk);\n                                if (iSet)\n                                    sqlite3VdbeChangeP5(v, 16);\n                            }\n                            sqlite3ReleaseTempRange(pParse, r, nPk);\n                        }\n                    }\n                    sqlite3VdbeAddOp2(v, 10, regReturn, iLoopBody);\n                    if (jmp1)\n                        sqlite3VdbeJumpHere(v, jmp1);\n                    if (pSubWInfo->untestedTerms)\n                        untestedTerms = 1;\n                    pSubLoop = pSubWInfo->a[0].pWLoop;\n                    assert((pSubLoop->wsFlags & 16384) == 0);\n                    if ((pSubLoop->wsFlags & 512) != 0 && (ii == 0 || pSubLoop->u.btree.pIndex == pCov) && ((((pTab)->tabFlags & 128) == 0) || !((pSubLoop->u.btree.pIndex)->idxType == 2))) {\n                        assert(pSubWInfo->a[0].iIdxCur == iCovCur);\n                        pCov = pSubLoop->u.btree.pIndex;\n                    } else {\n                        pCov = 0;\n                    }\n                    if (sqlite3WhereUsesDeferredSeek(pSubWInfo)) {\n                        pWInfo->bDeferredSeek = 1;\n                    }\n                    sqlite3WhereEnd(pSubWInfo);\n                    sqlite3VdbeExplainPop(pParse);\n                }\n                sqlite3ExprDelete(db, pDelete);\n            }\n        }\n        sqlite3VdbeExplainPop(pParse);\n        assert(pLevel->pWLoop == pLoop);\n        assert((pLoop->wsFlags & 8192) != 0);\n        assert((pLoop->wsFlags & 2048) == 0);\n        pLevel->u.pCoveringIdx = pCov;\n        if (pCov)\n            pLevel->iIdxCur = iCovCur;\n        if (pAndExpr) {\n            pAndExpr->pLeft = 0;\n            sqlite3ExprDelete(db, pAndExpr);\n        }\n        sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));\n        sqlite3VdbeGoto(v, pLevel->addrBrk);\n        sqlite3VdbeResolveLabel(v, iLoopBody);\n        assert(pLevel->op == 67);\n        pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n        if (pWInfo->nLevel > 1) {\n            sqlite3DbFreeNN(db, pOrTab);\n        }\n        if (!untestedTerms)\n            disableTerm(pLevel, pTerm);\n    } else {\n        static const u8 aStep[] = {39, 38};\n        static const u8 aStart[] = {36, 32};\n        assert(bRev == 0 || bRev == 1);\n        if (pTabItem->fg.isRecursive) {\n            pLevel->op = 184;\n        } else {\n            ;\n            pLevel->op = aStep[bRev];\n            pLevel->p1 = iCur;\n            pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrHalt);\n            ;\n            ;\n            pLevel->p5 = 1;\n        }\n    }\n    iLoop = (pIdx ? 1 : 2);\n    do {\n        int iNext = 0;\n        for (pTerm = pWC->a , j = pWC->nTerm; j > 0; j-- , pTerm++) {\n            Expr *pE;\n            int skipLikeAddr = 0;\n            ;\n            ;\n            if (pTerm->wtFlags & (2 | 4))\n                continue;\n            if ((pTerm->prereqAll & pLevel->notReady) != 0) {\n                ;\n                pWInfo->untestedTerms = 1;\n                continue;\n            }\n            pE = pTerm->pExpr;\n            assert(pE != 0);\n            if (pTabItem->fg.jointype & (8 | 64 | 16)) {\n                if (!(((pE)->flags & (1 | 2)) != 0)) {\n                    continue;\n                } else if ((pTabItem->fg.jointype & 8) == 8 && !(((pE)->flags & (1)) != 0)) {\n                    continue;\n                } else {\n                    Bitmask m = sqlite3WhereGetMask(&pWInfo->sMaskSet, pE->w.iJoin);\n                    if (m & pLevel->notReady) {\n                        continue;\n                    }\n                }\n            }\n            if (iLoop == 1 && !sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx)) {\n                iNext = 2;\n                continue;\n            }\n            if (iLoop < 3 && (pTerm->wtFlags & 4096)) {\n                if (iNext == 0)\n                    iNext = 3;\n                continue;\n            }\n            if ((pTerm->wtFlags & 512) != 0) {\n                u32 x = pLevel->iLikeRepCntr;\n                if (x > 0) {\n                    skipLikeAddr = sqlite3VdbeAddOp1(v, (x & 1) ? 17 : 16, (int)(x >> 1));\n                    ;\n                    ;\n                }\n            }\n            sqlite3ExprIfFalse(pParse, pE, addrCont, 16);\n            if (skipLikeAddr)\n                sqlite3VdbeJumpHere(v, skipLikeAddr);\n            pTerm->wtFlags |= 4;\n        }\n        iLoop = iNext;\n    } while (iLoop > 0);\n    for (pTerm = pWC->a , j = pWC->nBase; j > 0; j-- , pTerm++) {\n        Expr *pE, sEAlt;\n        WhereTerm *pAlt;\n        if (pTerm->wtFlags & (2 | 4))\n            continue;\n        if ((pTerm->eOperator & (2 | 128)) == 0)\n            continue;\n        if ((pTerm->eOperator & 2048) == 0)\n            continue;\n        if (pTerm->leftCursor != iCur)\n            continue;\n        if (pTabItem->fg.jointype & (8 | 64 | 16))\n            continue;\n        pE = pTerm->pExpr;\n        assert(!(((pE)->flags & (1)) != 0));\n        assert((pTerm->prereqRight & pLevel->notReady) != 0);\n        assert((pTerm->eOperator & (512 | 1024)) == 0);\n        pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.x.leftColumn, notReady, 2 | 1 | 128, 0);\n        if (pAlt == 0)\n            continue;\n        if (pAlt->wtFlags & (4))\n            continue;\n        if ((pAlt->eOperator & 1) && (((pAlt->pExpr)->flags & 4096) != 0) && (pAlt->pExpr->x.pSelect->pEList->nExpr > 1)) {\n            continue;\n        }\n        ;\n        ;\n        ;\n        ;\n        sEAlt = *pAlt->pExpr;\n        sEAlt.pLeft = pE->pLeft;\n        sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, 16);\n        pAlt->wtFlags |= 4;\n    }\n    if (pLevel->pRJ) {\n        Table *pTab;\n        int nPk;\n        int r;\n        int jmp1 = 0;\n        WhereRightJoin *pRJ = pLevel->pRJ;\n        pTab = pWInfo->pTabList->a[pLevel->iFrom].pTab;\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            r = sqlite3GetTempRange(pParse, 2);\n            sqlite3ExprCodeGetColumnOfTable(v, pTab, pLevel->iTabCur, -1, r + 1);\n            nPk = 1;\n        } else {\n            int iPk;\n            Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n            nPk = pPk->nKeyCol;\n            r = sqlite3GetTempRange(pParse, nPk + 1);\n            for (iPk = 0; iPk < nPk; iPk++) {\n                int iCol = pPk->aiColumn[iPk];\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r + 1 + iPk);\n            }\n        }\n        jmp1 = sqlite3VdbeAddOp4Int(v, 29, pRJ->iMatch, 0, r + 1, nPk);\n        ;\n        ;\n        sqlite3VdbeAddOp3(v, 97, r + 1, nPk, r);\n        sqlite3VdbeAddOp4Int(v, 138, pRJ->iMatch, r, r + 1, nPk);\n        sqlite3VdbeAddOp4Int(v, 180, pRJ->regBloom, 0, r + 1, nPk);\n        sqlite3VdbeChangeP5(v, 16);\n        sqlite3VdbeJumpHere(v, jmp1);\n        sqlite3ReleaseTempRange(pParse, r, nPk + 1);\n    }\n    if (pLevel->iLeftJoin) {\n        pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);\n        sqlite3VdbeAddOp2(v, 71, 1, pLevel->iLeftJoin);\n        ;\n        if (pLevel->pRJ == 0) {\n            goto code_outer_join_constraints;\n        }\n    }\n    if (pLevel->pRJ) {\n        WhereRightJoin *pRJ = pLevel->pRJ;\n        sqlite3VdbeAddOp2(v, 74, 0, pRJ->regReturn);\n        pRJ->addrSubrtn = sqlite3VdbeCurrentAddr(v);\n        assert(pParse->withinRJSubrtn < 255);\n        pParse->withinRJSubrtn++;\n      code_outer_join_constraints:\n        for (pTerm = pWC->a , j = 0; j < pWC->nBase; j++ , pTerm++) {\n            ;\n            ;\n            if (pTerm->wtFlags & (2 | 4))\n                continue;\n            if ((pTerm->prereqAll & pLevel->notReady) != 0) {\n                assert(pWInfo->untestedTerms);\n                continue;\n            }\n            if (pTabItem->fg.jointype & 64)\n                continue;\n            assert(pTerm->pExpr);\n            sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 16);\n            pTerm->wtFlags |= 4;\n        }\n    }\n    return pLevel->notReady;\n}\n"
  },
  {
    "id": "#23:25#sqlite3RunVacuum",
    "gotos": 12,
    "labels": 1,
    "body": "{\n    int rc = 0;\n    Btree *pMain;\n    Btree *pTemp;\n    u32 saved_mDbFlags;\n    u64 saved_flags;\n    i64 saved_nChange;\n    i64 saved_nTotalChange;\n    u32 saved_openFlags;\n    u8 saved_mTrace;\n    Db *pDb = 0;\n    int isMemDb;\n    int nRes;\n    int nDb;\n    const char *zDbMain;\n    const char *zOut;\n    u32 pgflags = 1;\n    if (!db->autoCommit) {\n        sqlite3SetString(pzErrMsg, db, \"cannot VACUUM from within a transaction\");\n        return 1;\n    }\n    if (db->nVdbeActive > 1) {\n        sqlite3SetString(pzErrMsg, db, \"cannot VACUUM - SQL statements in progress\");\n        return 1;\n    }\n    saved_openFlags = db->openFlags;\n    if (pOut) {\n        if (sqlite3_value_type(pOut) != 3) {\n            sqlite3SetString(pzErrMsg, db, \"non-text filename\");\n            return 1;\n        }\n        zOut = (const char *)sqlite3_value_text(pOut);\n        db->openFlags &= ~1;\n        db->openFlags |= 4 | 2;\n    } else {\n        zOut = \"\";\n    }\n    saved_flags = db->flags;\n    saved_mDbFlags = db->mDbFlags;\n    saved_nChange = db->nChange;\n    saved_nTotalChange = db->nTotalChange;\n    saved_mTrace = db->mTrace;\n    db->flags |= 1 | 512;\n    db->mDbFlags |= 2 | 4;\n    db->flags &= ~(u64)(16384 | 4096 | 268435456 | ((u64)(1) << 32));\n    db->mTrace = 0;\n    zDbMain = db->aDb[iDb].zDbSName;\n    pMain = db->aDb[iDb].pBt;\n    isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));\n    nDb = db->nDb;\n    rc = execSqlF(db, pzErrMsg, \"ATTACH %Q AS vacuum_db\", zOut);\n    db->openFlags = saved_openFlags;\n    if (rc != 0)\n        goto end_of_vacuum;\n    assert((db->nDb - 1) == nDb);\n    pDb = &db->aDb[nDb];\n    assert(strcmp(pDb->zDbSName, \"vacuum_db\") == 0);\n    pTemp = pDb->pBt;\n    if (pOut) {\n        sqlite3_file *id = sqlite3PagerFile(sqlite3BtreePager(pTemp));\n        i64 sz = 0;\n        if (id->pMethods != 0 && (sqlite3OsFileSize(id, &sz) != 0 || sz > 0)) {\n            rc = 1;\n            sqlite3SetString(pzErrMsg, db, \"output file already exists\");\n            goto end_of_vacuum;\n        }\n        db->mDbFlags |= 8;\n        pgflags = db->aDb[iDb].safety_level | (db->flags & 56);\n    }\n    nRes = sqlite3BtreeGetRequestedReserve(pMain);\n    sqlite3BtreeSetCacheSize(pTemp, db->aDb[iDb].pSchema->cache_size);\n    sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain, 0));\n    sqlite3BtreeSetPagerFlags(pTemp, pgflags | 32);\n    rc = execSql(db, pzErrMsg, \"BEGIN\");\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = sqlite3BtreeBeginTrans(pMain, pOut == 0 ? 2 : 0, 0);\n    if (rc != 0)\n        goto end_of_vacuum;\n    if (sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain)) == 5 && pOut == 0) {\n        db->nextPagesize = 0;\n    }\n    if (sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0) || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0)) || (db->mallocFailed)) {\n        rc = 7;\n        goto end_of_vacuum;\n    }\n    sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac >= 0 ? db->nextAutovac : sqlite3BtreeGetAutoVacuum(pMain));\n    db->init.iDb = nDb;\n    rc = execSqlF(db, pzErrMsg, \"SELECT sql FROM \\\"%w\\\".sqlite_schema WHERE type='table'AND name<>'sqlite_sequence' AND coalesce(rootpage,1)>0\", zDbMain);\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = execSqlF(db, pzErrMsg, \"SELECT sql FROM \\\"%w\\\".sqlite_schema WHERE type='index'\", zDbMain);\n    if (rc != 0)\n        goto end_of_vacuum;\n    db->init.iDb = 0;\n    rc = execSqlF(db, pzErrMsg, \"SELECT'INSERT INTO vacuum_db.'||quote(name)||' SELECT*FROM\\\"%w\\\".'||quote(name)FROM vacuum_db.sqlite_schema WHERE type='table'AND coalesce(rootpage,1)>0\", zDbMain);\n    assert((db->mDbFlags & 4) != 0);\n    db->mDbFlags &= ~4;\n    if (rc != 0)\n        goto end_of_vacuum;\n    rc = execSqlF(db, pzErrMsg, \"INSERT INTO vacuum_db.sqlite_schema SELECT*FROM \\\"%w\\\".sqlite_schema WHERE type IN('view','trigger') OR(type='table'AND rootpage=0)\", zDbMain);\n    if (rc)\n        goto end_of_vacuum;\n    {\n        u32 meta;\n        int i;\n        static const unsigned char aCopy[] = {1, 1, 3, 0, 5, 0, 6, 0, 8, 0};\n        assert(2 == sqlite3BtreeTxnState(pTemp));\n        assert(pOut != 0 || 2 == sqlite3BtreeTxnState(pMain));\n        for (i = 0; i < ((int)(sizeof (aCopy) / sizeof (aCopy[0]))); i += 2) {\n            sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);\n            rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta + aCopy[i + 1]);\n            if ((rc != 0))\n                goto end_of_vacuum;\n        }\n        if (pOut == 0) {\n            rc = sqlite3BtreeCopyFile(pMain, pTemp);\n        }\n        if (rc != 0)\n            goto end_of_vacuum;\n        rc = sqlite3BtreeCommit(pTemp);\n        if (rc != 0)\n            goto end_of_vacuum;\n        if (pOut == 0) {\n            sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));\n        }\n    }\n    assert(rc == 0);\n    if (pOut == 0) {\n        nRes = sqlite3BtreeGetRequestedReserve(pTemp);\n        rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes, 1);\n    }\n  end_of_vacuum:\n    db->init.iDb = 0;\n    db->mDbFlags = saved_mDbFlags;\n    db->flags = saved_flags;\n    db->nChange = saved_nChange;\n    db->nTotalChange = saved_nTotalChange;\n    db->mTrace = saved_mTrace;\n    sqlite3BtreeSetPageSize(pMain, -1, 0, 1);\n    db->autoCommit = 1;\n    if (pDb) {\n        sqlite3BtreeClose(pDb->pBt);\n        pDb->pBt = 0;\n        pDb->pSchema = 0;\n    }\n    sqlite3ResetAllSchemasOfConnection(db);\n    return rc;\n}\n"
  },
  {
    "id": "#23:25#sqlite3AtoF",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    int incr;\n    const char *zEnd;\n    int sign = 1;\n    i64 s = 0;\n    int d = 0;\n    int esign = 1;\n    int e = 0;\n    int eValid = 1;\n    double result;\n    int nDigit = 0;\n    int eType = 1;\n    assert(enc == 1 || enc == 2 || enc == 3);\n    *pResult = 0.;\n    if (length == 0)\n        return 0;\n    if (enc == 1) {\n        incr = 1;\n        zEnd = z + length;\n    } else {\n        int i;\n        incr = 2;\n        length &= ~1;\n        assert(2 == 2 && 3 == 3);\n        ;\n        ;\n        for (i = 3 - enc; i < length && z[i] == 0; i += 2) {\n        }\n        if (i < length)\n            eType = -100;\n        zEnd = &z[i ^ 1];\n        z += (enc & 1);\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1))\n        z += incr;\n    if (z >= zEnd)\n        return 0;\n    if (*z == '-') {\n        sign = -1;\n        z += incr;\n    } else if (*z == '+') {\n        z += incr;\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n        {\n            s = s * 10 + (*z - '0');\n            z += incr;\n            nDigit++;\n            if (s >= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) {\n                while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n                    {\n                        z += incr;\n                        d++;\n                    }\n            }\n        }\n    if (z >= zEnd)\n        goto do_atof_calc;\n    if (*z == '.') {\n        z += incr;\n        eType++;\n        while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n            {\n                if (s < (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) {\n                    s = s * 10 + (*z - '0');\n                    d--;\n                    nDigit++;\n                }\n                z += incr;\n            }\n    }\n    if (z >= zEnd)\n        goto do_atof_calc;\n    if (*z == 'e' || *z == 'E') {\n        z += incr;\n        eValid = 0;\n        eType++;\n        if (z >= zEnd)\n            goto do_atof_calc;\n        if (*z == '-') {\n            esign = -1;\n            z += incr;\n        } else if (*z == '+') {\n            z += incr;\n        }\n        while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4))\n            {\n                e = e < 10000 ? (e * 10 + (*z - '0')) : 10000;\n                z += incr;\n                eValid = 1;\n            }\n    }\n    while (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1))\n        z += incr;\n  do_atof_calc:\n    e = (e * esign) + d;\n    if (e < 0) {\n        esign = -1;\n        e *= -1;\n    } else {\n        esign = 1;\n    }\n    if (s == 0) {\n        result = sign < 0 ? -(double)0 : (double)0;\n    } else {\n        while (e > 0)\n            {\n                if (esign > 0) {\n                    if (s >= ((4294967295U | (((i64)2147483647) << 32)) / 10))\n                        break;\n                    s *= 10;\n                } else {\n                    if (s % 10 != 0)\n                        break;\n                    s /= 10;\n                }\n                e--;\n            }\n        s = sign < 0 ? -s : s;\n        if (e == 0) {\n            result = (double)s;\n        } else {\n            if (e > 307) {\n                if (e < 342) {\n                    long double scale = sqlite3Pow10(e - 308);\n                    if (esign < 0) {\n                        result = s / scale;\n                        result /= 1.0E+308;\n                    } else {\n                        result = s * scale;\n                        result *= 1.0E+308;\n                    }\n                } else {\n                    assert(e >= 342);\n                    if (esign < 0) {\n                        result = 0. * s;\n                    } else {\n                        result = 1.0E+308 * 1.0E+308 * s;\n                    }\n                }\n            } else {\n                long double scale = sqlite3Pow10(e);\n                if (esign < 0) {\n                    result = s / scale;\n                } else {\n                    result = s * scale;\n                }\n            }\n        }\n    }\n    *pResult = result;\n    if (z == zEnd && nDigit > 0 && eValid && eType > 0) {\n        return eType;\n    } else if (eType >= 2 && (eType == 3 || eValid) && nDigit > 0) {\n        return -1;\n    } else {\n        return 0;\n    }\n}\n"
  },
  {
    "id": "#23:25#sqlite3DeleteFrom",
    "gotos": 9,
    "labels": 1,
    "body": "{\n    Vdbe *v;\n    Table *pTab;\n    int i;\n    WhereInfo *pWInfo;\n    Index *pIdx;\n    int iTabCur;\n    int iDataCur = 0;\n    int iIdxCur = 0;\n    int nIdx;\n    sqlite3 *db;\n    AuthContext sContext;\n    NameContext sNC;\n    int iDb;\n    int memCnt = 0;\n    int rcauth;\n    int eOnePass;\n    int aiCurOnePass[2];\n    u8 *aToOpen = 0;\n    Index *pPk;\n    int iPk = 0;\n    i16 nPk = 1;\n    int iKey;\n    i16 nKey;\n    int iEphCur = 0;\n    int iRowSet = 0;\n    int addrBypass = 0;\n    int addrLoop = 0;\n    int addrEphOpen = 0;\n    int bComplex;\n    int isView;\n    Trigger *pTrigger;\n    memset(&sContext, 0, sizeof (sContext));\n    db = pParse->db;\n    assert(db->pParse == pParse);\n    if (pParse->nErr) {\n        goto delete_from_cleanup;\n    }\n    assert(db->mallocFailed == 0);\n    assert(pTabList->nSrc == 1);\n    pTab = sqlite3SrcListLookup(pParse, pTabList);\n    if (pTab == 0)\n        goto delete_from_cleanup;\n    pTrigger = sqlite3TriggersExist(pParse, pTab, 128, 0, 0);\n    isView = ((pTab)->eTabType == 2);\n    bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);\n    if (sqlite3ViewGetColumnNames(pParse, pTab)) {\n        goto delete_from_cleanup;\n    }\n    if (sqlite3IsReadOnly(pParse, pTab, (pTrigger ? 1 : 0))) {\n        goto delete_from_cleanup;\n    }\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert(iDb < db->nDb);\n    rcauth = sqlite3AuthCheck(pParse, 9, pTab->zName, 0, db->aDb[iDb].zDbSName);\n    assert(rcauth == 0 || rcauth == 1 || rcauth == 2);\n    if (rcauth == 1) {\n        goto delete_from_cleanup;\n    }\n    assert(!isView || pTrigger);\n    assert(pTabList->nSrc == 1);\n    iTabCur = pTabList->a[0].iCursor = pParse->nTab++;\n    for (nIdx = 0 , pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext , nIdx++) {\n        pParse->nTab++;\n    }\n    if (isView) {\n        sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n    }\n    v = sqlite3GetVdbe(pParse);\n    if (v == 0) {\n        goto delete_from_cleanup;\n    }\n    if (pParse->nested == 0)\n        sqlite3VdbeCountChanges(v);\n    sqlite3BeginWriteOperation(pParse, bComplex, iDb);\n    if (isView) {\n        sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iTabCur);\n        iDataCur = iIdxCur = iTabCur;\n        pOrderBy = 0;\n        pLimit = 0;\n    }\n    memset(&sNC, 0, sizeof (sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    if (sqlite3ResolveExprNames(&sNC, pWhere)) {\n        goto delete_from_cleanup;\n    }\n    if ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning) {\n        memCnt = ++pParse->nMem;\n        sqlite3VdbeAddOp2(v, 71, 0, memCnt);\n    }\n    if (rcauth == 0 && pWhere == 0 && !bComplex && !((pTab)->eTabType == 1)) {\n        assert(!isView);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            sqlite3VdbeAddOp4(v, 145, pTab->tnum, iDb, memCnt ? memCnt : -1, pTab->zName, (-1));\n        }\n        for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n            assert(pIdx->pSchema == pTab->pSchema);\n            if (((pIdx)->idxType == 2) && !(((pTab)->tabFlags & 128) == 0)) {\n                sqlite3VdbeAddOp3(v, 145, pIdx->tnum, iDb, memCnt ? memCnt : -1);\n            } else {\n                sqlite3VdbeAddOp2(v, 145, pIdx->tnum, iDb);\n            }\n        }\n    } else {\n        u16 wcf = 4 | 16;\n        if (sNC.ncFlags & 64)\n            bComplex = 1;\n        wcf |= (bComplex ? 0 : 8);\n        if ((((pTab)->tabFlags & 128) == 0)) {\n            pPk = 0;\n            nPk = 1;\n            iRowSet = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, 75, 0, iRowSet);\n        } else {\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n            assert(pPk != 0);\n            nPk = pPk->nKeyCol;\n            iPk = pParse->nMem + 1;\n            pParse->nMem += nPk;\n            iEphCur = pParse->nTab++;\n            addrEphOpen = sqlite3VdbeAddOp2(v, 118, iEphCur, nPk);\n            sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n        }\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 0, wcf, iTabCur + 1);\n        if (pWInfo == 0)\n            goto delete_from_cleanup;\n        eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n        assert(((pTab)->eTabType == 1) == 0 || eOnePass != 2);\n        assert(((pTab)->eTabType == 1) || bComplex || eOnePass != 0);\n        if (eOnePass != 1)\n            sqlite3MultiWrite(pParse);\n        if (sqlite3WhereUsesDeferredSeek(pWInfo)) {\n            sqlite3VdbeAddOp1(v, 143, iTabCur);\n        }\n        if (memCnt) {\n            sqlite3VdbeAddOp2(v, 86, memCnt, 1);\n        }\n        if (pPk) {\n            for (i = 0; i < nPk; i++) {\n                assert(pPk->aiColumn[i] >= 0);\n                sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, pPk->aiColumn[i], iPk + i);\n            }\n            iKey = iPk;\n        } else {\n            iKey = ++pParse->nMem;\n            sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);\n        }\n        if (eOnePass != 0) {\n            nKey = nPk;\n            aToOpen = sqlite3DbMallocRawNN(db, nIdx + 2);\n            if (aToOpen == 0) {\n                sqlite3WhereEnd(pWInfo);\n                goto delete_from_cleanup;\n            }\n            memset(aToOpen, 1, nIdx + 1);\n            aToOpen[nIdx + 1] = 0;\n            if (aiCurOnePass[0] >= 0)\n                aToOpen[aiCurOnePass[0] - iTabCur] = 0;\n            if (aiCurOnePass[1] >= 0)\n                aToOpen[aiCurOnePass[1] - iTabCur] = 0;\n            if (addrEphOpen)\n                sqlite3VdbeChangeToNoop(v, addrEphOpen);\n            addrBypass = sqlite3VdbeMakeLabel(pParse);\n        } else {\n            if (pPk) {\n                iKey = ++pParse->nMem;\n                nKey = 0;\n                sqlite3VdbeAddOp4(v, 97, iPk, nPk, iKey, sqlite3IndexAffinityStr(pParse->db, pPk), nPk);\n                sqlite3VdbeAddOp4Int(v, 138, iEphCur, iKey, iPk, nPk);\n            } else {\n                nKey = 1;\n                sqlite3VdbeAddOp2(v, 156, iRowSet, iKey);\n            }\n            sqlite3WhereEnd(pWInfo);\n        }\n        if (!isView) {\n            int iAddrOnce = 0;\n            if (eOnePass == 2) {\n                iAddrOnce = sqlite3VdbeAddOp0(v, 15);\n                ;\n            }\n            ;\n            sqlite3OpenTableAndIndices(pParse, pTab, 113, 8, iTabCur, aToOpen, &iDataCur, &iIdxCur);\n            assert(pPk || ((pTab)->eTabType == 1) || iDataCur == iTabCur);\n            assert(pPk || ((pTab)->eTabType == 1) || iIdxCur == iDataCur + 1);\n            if (eOnePass == 2) {\n                sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce);\n            }\n        }\n        if (eOnePass != 0) {\n            assert(nKey == nPk);\n            if (!((pTab)->eTabType == 1) && aToOpen[iDataCur - iTabCur]) {\n                assert(pPk != 0 || ((pTab)->eTabType == 2));\n                sqlite3VdbeAddOp4Int(v, 28, iDataCur, addrBypass, iKey, nKey);\n                ;\n            }\n        } else if (pPk) {\n            addrLoop = sqlite3VdbeAddOp1(v, 36, iEphCur);\n            ;\n            if (((pTab)->eTabType == 1)) {\n                sqlite3VdbeAddOp3(v, 94, iEphCur, 0, iKey);\n            } else {\n                sqlite3VdbeAddOp2(v, 134, iEphCur, iKey);\n            }\n            assert(nKey == 0);\n        } else {\n            addrLoop = sqlite3VdbeAddOp3(v, 46, iRowSet, 0, iKey);\n            ;\n            assert(nKey == 1);\n        }\n        if (((pTab)->eTabType == 1)) {\n            const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n            sqlite3VtabMakeWritable(pParse, pTab);\n            assert(eOnePass == 0 || eOnePass == 1);\n            sqlite3MayAbort(pParse);\n            if (eOnePass == 1) {\n                sqlite3VdbeAddOp1(v, 122, iTabCur);\n                if (((pParse)->pToplevel == 0)) {\n                    pParse->isMultiWrite = 0;\n                }\n            }\n            sqlite3VdbeAddOp4(v, 7, 0, 1, iKey, pVTab, (-11));\n            sqlite3VdbeChangeP5(v, 2);\n        } else {\n            int count = (pParse->nested == 0);\n            sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, iKey, nKey, count, 11, eOnePass, aiCurOnePass[1]);\n        }\n        if (eOnePass != 0) {\n            sqlite3VdbeResolveLabel(v, addrBypass);\n            sqlite3WhereEnd(pWInfo);\n        } else if (pPk) {\n            sqlite3VdbeAddOp2(v, 39, iEphCur, addrLoop + 1);\n            ;\n            sqlite3VdbeJumpHere(v, addrLoop);\n        } else {\n            sqlite3VdbeGoto(v, addrLoop);\n            sqlite3VdbeJumpHere(v, addrLoop);\n        }\n    }\n    if (pParse->nested == 0 && pParse->pTriggerTab == 0) {\n        sqlite3AutoincrementEnd(pParse);\n    }\n    if (memCnt) {\n        sqlite3CodeChangeCount(v, memCnt, \"rows deleted\");\n    }\n  delete_from_cleanup:\n    sqlite3AuthContextPop(&sContext);\n    sqlite3SrcListDelete(db, pTabList);\n    sqlite3ExprDelete(db, pWhere);\n    if (aToOpen)\n        sqlite3DbNNFreeNN(db, aToOpen);\n    return;\n}\n"
  },
  {
    "id": "#23:25#sqlite3CreateIndex",
    "gotos": 28,
    "labels": 1,
    "body": "{\n    Table *pTab = 0;\n    Index *pIndex = 0;\n    char *zName = 0;\n    int nName;\n    int i, j;\n    DbFixer sFix;\n    int sortOrderMask;\n    sqlite3 *db = pParse->db;\n    Db *pDb;\n    int iDb;\n    Token *pName = 0;\n    struct ExprList_item *pListItem;\n    int nExtra = 0;\n    int nExtraCol;\n    char *zExtra = 0;\n    Index *pPk = 0;\n    assert(db->pParse == pParse);\n    if (pParse->nErr) {\n        goto exit_create_index;\n    }\n    assert(db->mallocFailed == 0);\n    if ((pParse->eParseMode == 1) && idxType != 2) {\n        goto exit_create_index;\n    }\n    if (0 != sqlite3ReadSchema(pParse)) {\n        goto exit_create_index;\n    }\n    if (sqlite3HasExplicitNulls(pParse, pList)) {\n        goto exit_create_index;\n    }\n    if (pTblName != 0) {\n        assert(pName1 && pName2);\n        iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n        if (iDb < 0)\n            goto exit_create_index;\n        assert(pName && pName->z);\n        if (!db->init.busy) {\n            pTab = sqlite3SrcListLookup(pParse, pTblName);\n            if (pName2->n == 0 && pTab && pTab->pSchema == db->aDb[1].pSchema) {\n                iDb = 1;\n            }\n        }\n        sqlite3FixInit(&sFix, pParse, iDb, \"index\", pName);\n        if (sqlite3FixSrcList(&sFix, pTblName)) {\n            assert(0);\n        }\n        pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);\n        assert(db->mallocFailed == 0 || pTab == 0);\n        if (pTab == 0)\n            goto exit_create_index;\n        if (iDb == 1 && db->aDb[iDb].pSchema != pTab->pSchema) {\n            sqlite3ErrorMsg(pParse, \"cannot create a TEMP index on non-TEMP table \\\"%s\\\"\", pTab->zName);\n            goto exit_create_index;\n        }\n        if (!(((pTab)->tabFlags & 128) == 0))\n            pPk = sqlite3PrimaryKeyIndex(pTab);\n    } else {\n        assert(pName == 0);\n        assert(pStart == 0);\n        pTab = pParse->pNewTable;\n        if (!pTab)\n            goto exit_create_index;\n        iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    }\n    pDb = &db->aDb[iDb];\n    assert(pTab != 0);\n    if (sqlite3_strnicmp(pTab->zName, \"sqlite_\", 7) == 0 && db->init.busy == 0 && pTblName != 0) {\n        sqlite3ErrorMsg(pParse, \"table %s may not be indexed\", pTab->zName);\n        goto exit_create_index;\n    }\n    if (((pTab)->eTabType == 2)) {\n        sqlite3ErrorMsg(pParse, \"views may not be indexed\");\n        goto exit_create_index;\n    }\n    if (((pTab)->eTabType == 1)) {\n        sqlite3ErrorMsg(pParse, \"virtual tables may not be indexed\");\n        goto exit_create_index;\n    }\n    if (pName) {\n        zName = sqlite3NameFromToken(db, pName);\n        if (zName == 0)\n            goto exit_create_index;\n        assert(pName->z != 0);\n        if (0 != sqlite3CheckObjectName(pParse, zName, \"index\", pTab->zName)) {\n            goto exit_create_index;\n        }\n        if (!(pParse->eParseMode >= 2)) {\n            if (!db->init.busy) {\n                if (sqlite3FindTable(db, zName, pDb->zDbSName) != 0) {\n                    sqlite3ErrorMsg(pParse, \"there is already a table named %s\", zName);\n                    goto exit_create_index;\n                }\n            }\n            if (sqlite3FindIndex(db, zName, pDb->zDbSName) != 0) {\n                if (!ifNotExist) {\n                    sqlite3ErrorMsg(pParse, \"index %s already exists\", zName);\n                } else {\n                    assert(!db->init.busy);\n                    sqlite3CodeVerifySchema(pParse, iDb);\n                    sqlite3ForceNotReadOnly(pParse);\n                }\n                goto exit_create_index;\n            }\n        }\n    } else {\n        int n;\n        Index *pLoop;\n        for (pLoop = pTab->pIndex , n = 1; pLoop; pLoop = pLoop->pNext , n++) {\n        }\n        zName = sqlite3MPrintf(db, \"sqlite_autoindex_%s_%d\", pTab->zName, n);\n        if (zName == 0) {\n            goto exit_create_index;\n        }\n        if ((pParse->eParseMode != 0))\n            zName[7]++;\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        const char *zDb = pDb->zDbSName;\n        if (sqlite3AuthCheck(pParse, 18, ((!0) && (iDb == 1) ? \"sqlite_temp_master\" : \"sqlite_master\"), 0, zDb)) {\n            goto exit_create_index;\n        }\n        i = 1;\n        if (!0 && iDb == 1)\n            i = 3;\n        if (sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb)) {\n            goto exit_create_index;\n        }\n    }\n    if (pList == 0) {\n        Token prevCol;\n        Column *pCol = &pTab->aCol[pTab->nCol - 1];\n        pCol->colFlags |= 8;\n        sqlite3TokenInit(&prevCol, pCol->zCnName);\n        pList = sqlite3ExprListAppend(pParse, 0, sqlite3ExprAlloc(db, 59, &prevCol, 0));\n        if (pList == 0)\n            goto exit_create_index;\n        assert(pList->nExpr == 1);\n        sqlite3ExprListSetSortOrder(pList, sortOrder, -1);\n    } else {\n        sqlite3ExprListCheckLength(pParse, pList, \"index\");\n        if (pParse->nErr)\n            goto exit_create_index;\n    }\n    for (i = 0; i < pList->nExpr; i++) {\n        Expr *pExpr = pList->a[i].pExpr;\n        assert(pExpr != 0);\n        if (pExpr->op == 113) {\n            assert(!(((pExpr)->flags & (2048)) != 0));\n            nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));\n        }\n    }\n    nName = sqlite3Strlen30(zName);\n    nExtraCol = pPk ? pPk->nKeyCol : 1;\n    assert(pList->nExpr + nExtraCol <= 32767);\n    pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol, nName + nExtra + 1, &zExtra);\n    if (db->mallocFailed) {\n        goto exit_create_index;\n    }\n    assert(((((char *)(pIndex->aiRowLogEst) - (char *)0) & 7) == 0));\n    assert(((((char *)(pIndex->azColl) - (char *)0) & 7) == 0));\n    pIndex->zName = zExtra;\n    zExtra += nName + 1;\n    memcpy(pIndex->zName, zName, nName + 1);\n    pIndex->pTable = pTab;\n    pIndex->onError = (u8)onError;\n    pIndex->uniqNotNull = onError != 0;\n    pIndex->idxType = idxType;\n    pIndex->pSchema = db->aDb[iDb].pSchema;\n    pIndex->nKeyCol = pList->nExpr;\n    if (pPIWhere) {\n        sqlite3ResolveSelfReference(pParse, pTab, 2, pPIWhere, 0);\n        pIndex->pPartIdxWhere = pPIWhere;\n        pPIWhere = 0;\n    }\n    assert(sqlite3SchemaMutexHeld(db, iDb, 0));\n    if (pDb->pSchema->file_format >= 4) {\n        sortOrderMask = -1;\n    } else {\n        sortOrderMask = 0;\n    }\n    pListItem = pList->a;\n    if ((pParse->eParseMode >= 2)) {\n        pIndex->aColExpr = pList;\n        pList = 0;\n    }\n    for (i = 0; i < pIndex->nKeyCol; i++ , pListItem++) {\n        Expr *pCExpr;\n        int requestedSortOrder;\n        const char *zColl;\n        sqlite3StringToId(pListItem->pExpr);\n        sqlite3ResolveSelfReference(pParse, pTab, 32, pListItem->pExpr, 0);\n        if (pParse->nErr)\n            goto exit_create_index;\n        pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);\n        if (pCExpr->op != 167) {\n            if (pTab == pParse->pNewTable) {\n                sqlite3ErrorMsg(pParse, \"expressions prohibited in PRIMARY KEY and UNIQUE constraints\");\n                goto exit_create_index;\n            }\n            if (pIndex->aColExpr == 0) {\n                pIndex->aColExpr = pList;\n                pList = 0;\n            }\n            j = (-2);\n            pIndex->aiColumn[i] = (-2);\n            pIndex->uniqNotNull = 0;\n            pIndex->bHasExpr = 1;\n        } else {\n            j = pCExpr->iColumn;\n            assert(j <= 32767);\n            if (j < 0) {\n                j = pTab->iPKey;\n            } else {\n                if (pTab->aCol[j].notNull == 0) {\n                    pIndex->uniqNotNull = 0;\n                }\n                if (pTab->aCol[j].colFlags & 32) {\n                    pIndex->bHasVCol = 1;\n                    pIndex->bHasExpr = 1;\n                }\n            }\n            pIndex->aiColumn[i] = (i16)j;\n        }\n        zColl = 0;\n        if (pListItem->pExpr->op == 113) {\n            int nColl;\n            assert(!(((pListItem->pExpr)->flags & (2048)) != 0));\n            zColl = pListItem->pExpr->u.zToken;\n            nColl = sqlite3Strlen30(zColl) + 1;\n            assert(nExtra >= nColl);\n            memcpy(zExtra, zColl, nColl);\n            zColl = zExtra;\n            zExtra += nColl;\n            nExtra -= nColl;\n        } else if (j >= 0) {\n            zColl = sqlite3ColumnColl(&pTab->aCol[j]);\n        }\n        if (!zColl)\n            zColl = sqlite3StrBINARY;\n        if (!db->init.busy && !sqlite3LocateCollSeq(pParse, zColl)) {\n            goto exit_create_index;\n        }\n        pIndex->azColl[i] = zColl;\n        requestedSortOrder = pListItem->fg.sortFlags & sortOrderMask;\n        pIndex->aSortOrder[i] = (u8)requestedSortOrder;\n    }\n    if (pPk) {\n        for (j = 0; j < pPk->nKeyCol; j++) {\n            int x = pPk->aiColumn[j];\n            assert(x >= 0);\n            if (isDupColumn(pIndex, pIndex->nKeyCol, pPk, j)) {\n                pIndex->nColumn--;\n            } else {\n                ;\n                pIndex->aiColumn[i] = x;\n                pIndex->azColl[i] = pPk->azColl[j];\n                pIndex->aSortOrder[i] = pPk->aSortOrder[j];\n                i++;\n            }\n        }\n        assert(i == pIndex->nColumn);\n    } else {\n        pIndex->aiColumn[i] = (-1);\n        pIndex->azColl[i] = sqlite3StrBINARY;\n    }\n    sqlite3DefaultRowEst(pIndex);\n    if (pParse->pNewTable == 0)\n        estimateIndexWidth(pIndex);\n    assert((((pTab)->tabFlags & 128) == 0) || pTab->iPKey < 0 || sqlite3TableColumnToIndex(pIndex, pTab->iPKey) >= 0);\n    recomputeColumnsNotIndexed(pIndex);\n    if (pTblName != 0 && pIndex->nColumn >= pTab->nCol) {\n        pIndex->isCovering = 1;\n        for (j = 0; j < pTab->nCol; j++) {\n            if (j == pTab->iPKey)\n                continue;\n            if (sqlite3TableColumnToIndex(pIndex, j) >= 0)\n                continue;\n            pIndex->isCovering = 0;\n            break;\n        }\n    }\n    if (pTab == pParse->pNewTable) {\n        Index *pIdx;\n        for (pIdx = pTab->pIndex; pIdx; pIdx = pIdx->pNext) {\n            int k;\n            assert(((pIdx)->onError != 0));\n            assert(pIdx->idxType != 0);\n            assert(((pIndex)->onError != 0));\n            if (pIdx->nKeyCol != pIndex->nKeyCol)\n                continue;\n            for (k = 0; k < pIdx->nKeyCol; k++) {\n                const char *z1;\n                const char *z2;\n                assert(pIdx->aiColumn[k] >= 0);\n                if (pIdx->aiColumn[k] != pIndex->aiColumn[k])\n                    break;\n                z1 = pIdx->azColl[k];\n                z2 = pIndex->azColl[k];\n                if (sqlite3StrICmp(z1, z2))\n                    break;\n            }\n            if (k == pIdx->nKeyCol) {\n                if (pIdx->onError != pIndex->onError) {\n                    if (!(pIdx->onError == 11 || pIndex->onError == 11)) {\n                        sqlite3ErrorMsg(pParse, \"conflicting ON CONFLICT clauses specified\", 0);\n                    }\n                    if (pIdx->onError == 11) {\n                        pIdx->onError = pIndex->onError;\n                    }\n                }\n                if (idxType == 2)\n                    pIdx->idxType = idxType;\n                if ((pParse->eParseMode >= 2)) {\n                    pIndex->pNext = pParse->pNewIndex;\n                    pParse->pNewIndex = pIndex;\n                    pIndex = 0;\n                }\n                goto exit_create_index;\n            }\n        }\n    }\n    if (!(pParse->eParseMode >= 2)) {\n        assert(pParse->nErr == 0);\n        if (db->init.busy) {\n            Index *p;\n            assert(!(pParse->eParseMode != 0));\n            assert(sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema));\n            if (pTblName != 0) {\n                pIndex->tnum = db->init.newTnum;\n                if (sqlite3IndexHasDuplicateRootPage(pIndex)) {\n                    sqlite3ErrorMsg(pParse, \"invalid rootpage\");\n                    pParse->rc = sqlite3CorruptError(121012);\n                    goto exit_create_index;\n                }\n            }\n            p = sqlite3HashInsert(&pIndex->pSchema->idxHash, pIndex->zName, pIndex);\n            if (p) {\n                assert(p == pIndex);\n                sqlite3OomFault(db);\n                goto exit_create_index;\n            }\n            db->mDbFlags |= 1;\n        } else if ((((pTab)->tabFlags & 128) == 0) || pTblName != 0) {\n            Vdbe *v;\n            char *zStmt;\n            int iMem = ++pParse->nMem;\n            v = sqlite3GetVdbe(pParse);\n            if (v == 0)\n                goto exit_create_index;\n            sqlite3BeginWriteOperation(pParse, 1, iDb);\n            pIndex->tnum = (Pgno)sqlite3VdbeAddOp0(v, 184);\n            sqlite3VdbeAddOp3(v, 147, iDb, iMem, 2);\n            assert(pName != 0 || pStart == 0);\n            if (pStart) {\n                int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;\n                if (pName->z[n - 1] == ';')\n                    n--;\n                zStmt = sqlite3MPrintf(db, \"CREATE%s INDEX %.*s\", onError == 0 ? \"\" : \" UNIQUE\", n, pName->z);\n            } else {\n                zStmt = 0;\n            }\n            sqlite3NestedParse(pParse, \"INSERT INTO %Q.sqlite_master VALUES('index',%Q,%Q,#%d,%Q);\", db->aDb[iDb].zDbSName, pIndex->zName, pTab->zName, iMem, zStmt);\n            sqlite3DbFree(db, zStmt);\n            if (pTblName) {\n                sqlite3RefillIndex(pParse, pIndex, iMem);\n                sqlite3ChangeCookie(pParse, iDb);\n                sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, \"name='%q' AND type='index'\", pIndex->zName), 0);\n                sqlite3VdbeAddOp2(v, 166, 0, 1);\n            }\n            sqlite3VdbeJumpHere(v, (int)pIndex->tnum);\n        }\n    }\n    if (db->init.busy || pTblName == 0) {\n        pIndex->pNext = pTab->pIndex;\n        pTab->pIndex = pIndex;\n        pIndex = 0;\n    } else if ((pParse->eParseMode >= 2)) {\n        assert(pParse->pNewIndex == 0);\n        pParse->pNewIndex = pIndex;\n        pIndex = 0;\n    }\n  exit_create_index:\n    if (pIndex)\n        sqlite3FreeIndex(db, pIndex);\n    if (pTab) {\n        Index **ppFrom;\n        Index *pThis;\n        for (ppFrom = &pTab->pIndex; (pThis = *ppFrom) != 0; ppFrom = &pThis->pNext) {\n            Index *pNext;\n            if (pThis->onError != 5)\n                continue;\n            while ((pNext = pThis->pNext) != 0 && pNext->onError != 5)\n                {\n                    *ppFrom = pNext;\n                    pThis->pNext = pNext->pNext;\n                    pNext->pNext = pThis;\n                    ppFrom = &pNext->pNext;\n                }\n            break;\n        }\n    }\n    sqlite3ExprDelete(db, pPIWhere);\n    sqlite3ExprListDelete(db, pList);\n    sqlite3SrcListDelete(db, pTblName);\n    sqlite3DbFree(db, zName);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#25275:1#quickscan",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    char cin;\n    char cWait = (char)qss;\n    if (cWait == 0) {\n      PlainScan:\n        assert(cWait == 0);\n        while ((cin = *zLine++) != 0)\n            {\n                if (isspace((unsigned char)cin))\n                    continue;\n                switch (cin) {\n                  case '-':\n                    if (*zLine != '-')\n                        break;\n                    while ((cin = *++zLine) != 0)\n                        if (cin == '\\n')\n                            goto PlainScan;\n                    return qss;\n                  case ';':\n                    qss |= QSS_EndingSemi;\n                    continue;\n                  case '/':\n                    if (*zLine == '*') {\n                        ++zLine;\n                        cWait = '*';\n                        qss = ((cWait) | ((qss) & QSS_ScanMask));\n                        goto TermScan;\n                    }\n                    break;\n                  case '[':\n                    cin = ']';\n                  case '`':\n                  case '\\'':\n                  case '\"':\n                    cWait = cin;\n                    qss = QSS_HasDark | cWait;\n                    goto TermScan;\n                  default:\n                    break;\n                }\n                qss = (qss & ~QSS_EndingSemi) | QSS_HasDark;\n            }\n    } else {\n      TermScan:\n        while ((cin = *zLine++) != 0)\n            {\n                if (cin == cWait) {\n                    switch (cWait) {\n                      case '*':\n                        if (*zLine != '/')\n                            continue;\n                        ++zLine;\n                        cWait = 0;\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      case '`':\n                      case '\\'':\n                      case '\"':\n                        if (*zLine == cWait) {\n                            ++zLine;\n                            continue;\n                        }\n                      case ']':\n                        cWait = 0;\n                        qss = ((0) | ((qss) & QSS_ScanMask));\n                        goto PlainScan;\n                      default:\n                        assert(0);\n                    }\n                }\n            }\n    }\n    return qss;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#20038:1#tryToCloneData",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    sqlite3_stmt *pQuery = 0;\n    sqlite3_stmt *pInsert = 0;\n    char *zQuery = 0;\n    char *zInsert = 0;\n    int rc;\n    int i, j, n;\n    int nTable = strlen30(zTable);\n    int k = 0;\n    int cnt = 0;\n    const int spinRate = 10000;\n    zQuery = sqlite3_mprintf(\"SELECT * FROM \\\"%w\\\"\", zTable);\n    shell_check_oom(zQuery);\n    rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n    if (rc) {\n        goto end_data_xfer;\n    }\n    n = sqlite3_column_count(pQuery);\n    zInsert = sqlite3_malloc64(200 + nTable + n * 3);\n    shell_check_oom(zInsert);\n    sqlite3_snprintf(200 + nTable, zInsert, \"INSERT OR IGNORE INTO \\\"%s\\\" VALUES(?\", zTable);\n    i = strlen30(zInsert);\n    for (j = 1; j < n; j++) {\n        memcpy(zInsert + i, \",?\", 2);\n        i += 2;\n    }\n    memcpy(zInsert + i, \");\", 3);\n    rc = sqlite3_prepare_v2(newDb, zInsert, -1, &pInsert, 0);\n    if (rc) {\n        goto end_data_xfer;\n    }\n    for (k = 0; k < 2; k++) {\n        while ((rc = sqlite3_step(pQuery)) == 100)\n            {\n                for (i = 0; i < n; i++) {\n                    switch (sqlite3_column_type(pQuery, i)) {\n                      case 5:\n                        {\n                            sqlite3_bind_null(pInsert, i + 1);\n                            break;\n                        }\n                      case 1:\n                        {\n                            sqlite3_bind_int64(pInsert, i + 1, sqlite3_column_int64(pQuery, i));\n                            break;\n                        }\n                      case 2:\n                        {\n                            sqlite3_bind_double(pInsert, i + 1, sqlite3_column_double(pQuery, i));\n                            break;\n                        }\n                      case 3:\n                        {\n                            sqlite3_bind_text(pInsert, i + 1, (const char *)sqlite3_column_text(pQuery, i), -1, ((sqlite3_destructor_type)0));\n                            break;\n                        }\n                      case 4:\n                        {\n                            sqlite3_bind_blob(pInsert, i + 1, sqlite3_column_blob(pQuery, i), sqlite3_column_bytes(pQuery, i), ((sqlite3_destructor_type)0));\n                            break;\n                        }\n                    }\n                }\n                rc = sqlite3_step(pInsert);\n                if (rc != 0 && rc != 100 && rc != 101) {\n                }\n                sqlite3_reset(pInsert);\n                cnt++;\n                if ((cnt % spinRate) == 0) {\n                    printf(\"%c\\b\", \"|/-\\\\\"[(cnt / spinRate) % 4]);\n                }\n            }\n        if (rc == 101)\n            break;\n        sqlite3_finalize(pQuery);\n        sqlite3_free(zQuery);\n        zQuery = sqlite3_mprintf(\"SELECT * FROM \\\"%w\\\" ORDER BY rowid DESC;\", zTable);\n        shell_check_oom(zQuery);\n        rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n        if (rc) {\n            break;\n        }\n    }\n  end_data_xfer:\n    sqlite3_finalize(pQuery);\n    sqlite3_finalize(pInsert);\n    sqlite3_free(zQuery);\n    sqlite3_free(zInsert);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#19218:1#readHexDb",
    "gotos": 5,
    "labels": 1,
    "body": "{\n    unsigned char *a = 0;\n    int nLine;\n    int n = 0;\n    int pgsz = 0;\n    int iOffset = 0;\n    int j, k;\n    int rc;\n    const char *zDbFilename = p->pAuxDb->zDbFilename;\n    unsigned int x[16];\n    char zLine[1000];\n    if (zDbFilename) {\n        if (<recovery-expr>()) {\n            return 0;\n        }\n        nLine = 0;\n    } else {\n        nLine = p->lineno;\n    }\n    *pnData = 0;\n    nLine++;\n    if (<recovery-expr>())\n        goto readHexDb_error;\n    rc = sscanf(zLine, \"| size %d pagesize %d\", &n, &pgsz);\n    if (rc != 2)\n        goto readHexDb_error;\n    if (n < 0)\n        goto readHexDb_error;\n    if (pgsz < 512 || pgsz > 65536 || (pgsz & (pgsz - 1)) != 0)\n        goto readHexDb_error;\n    n = (n + pgsz - 1) & ~(pgsz - 1);\n    a = sqlite3_malloc(n ? n : 1);\n    shell_check_oom(a);\n    memset(a, 0, n);\n    if (pgsz < 512 || pgsz > 65536 || (pgsz & (pgsz - 1)) != 0) {\n        goto readHexDb_error;\n    }\n    *pnData = n;\n    if (<recovery-expr>()) {\n    } else {\n        p->lineno = nLine;\n    }\n    return a;\n  readHexDb_error:\n    if (<recovery-expr>()) {\n    } else {\n        while (fgets(zLine, sizeof (zLine), <recovery-expr>(p)) != 0)\n            {\n                nLine++;\n                if (<recovery-expr>()(zLine, \"| end \", 6) == 0)\n                    break;\n            }\n        p->lineno = nLine;\n    }\n    sqlite3_free(a);\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#15787:1#editFunc",
    "gotos": 7,
    "labels": 1,
    "body": "{\n    const char *zEditor;\n    char *zTempFile = 0;\n    sqlite3 *db;\n    char *zCmd = 0;\n    int bBin;\n    int rc;\n    int hasCRNL = 0;\n    sqlite3_int64 sz;\n    sqlite3_int64 x;\n    unsigned char *p = 0;\n    if (argc == 2) {\n        zEditor = (const char *)sqlite3_value_text(argv[1]);\n    } else {\n        zEditor = getenv(\"VISUAL\");\n    }\n    if (zEditor == 0) {\n        sqlite3_result_error(context, \"no editor for edit()\", -1);\n        return;\n    }\n    if (sqlite3_value_type(argv[0]) == 5) {\n        sqlite3_result_error(context, \"NULL input to edit()\", -1);\n        return;\n    }\n    db = sqlite3_context_db_handle(context);\n    zTempFile = 0;\n    sqlite3_file_control(db, 0, 16, &zTempFile);\n    if (zTempFile == 0) {\n        sqlite3_uint64 r = 0;\n        sqlite3_randomness(sizeof (r), &r);\n        zTempFile = sqlite3_mprintf(\"temp%llx\", r);\n        if (zTempFile == 0) {\n            sqlite3_result_error_nomem(context);\n            return;\n        }\n    }\n    bBin = sqlite3_value_type(argv[0]) == 4;\n    if (<recovery-expr>()) {\n        sqlite3_result_error(context, \"edit() cannot open temp file\", -1);\n        goto edit_func_end;\n    }\n    sz = sqlite3_value_bytes(argv[0]);\n    if (bBin) {\n    } else {\n        const char *z = (const char *)sqlite3_value_text(argv[0]);\n        if (z && strstr(z, \"\\r\\n\") != 0)\n            hasCRNL = 1;\n    }\n    if (x != sz) {\n        sqlite3_result_error(context, \"edit() could not write the whole file\", -1);\n        goto edit_func_end;\n    }\n    zCmd = sqlite3_mprintf(\"%s \\\"%s\\\"\", zEditor, zTempFile);\n    if (zCmd == 0) {\n        sqlite3_result_error_nomem(context);\n        goto edit_func_end;\n    }\n    rc = system(zCmd);\n    sqlite3_free(zCmd);\n    if (rc) {\n        sqlite3_result_error(context, \"EDITOR returned non-zero\", -1);\n        goto edit_func_end;\n    }\n    if (<recovery-expr>()) {\n        sqlite3_result_error(context, \"edit() cannot reopen temp file after edit\", -1);\n        goto edit_func_end;\n    }\n    p = sqlite3_malloc64(sz + 1);\n    if (p == 0) {\n        sqlite3_result_error_nomem(context);\n        goto edit_func_end;\n    }\n    if (x != sz) {\n        sqlite3_result_error(context, \"could not read back the whole file\", -1);\n        goto edit_func_end;\n    }\n    if (bBin) {\n        sqlite3_result_blob64(context, p, sz, sqlite3_free);\n    } else {\n        sqlite3_int64 i, j;\n        if (hasCRNL) {\n        } else {\n            for (i = j = 0; i < sz; i++) {\n                if (p[i] == '\\r' && p[i + 1] == '\\n')\n                    i++;\n                p[j++] = p[i];\n            }\n            sz = j;\n            p[sz] = 0;\n        }\n        sqlite3_result_text64(context, (const char *)p, sz, sqlite3_free, 1);\n    }\n    p = 0;\n  edit_func_end:\n    ;\n    unlink(zTempFile);\n    sqlite3_free(zTempFile);\n    sqlite3_free(p);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#20150:1#tryToCloneSchema",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    sqlite3_stmt *pQuery = 0;\n    char *zQuery = 0;\n    int rc;\n    const unsigned char *zName;\n    const unsigned char *zSql;\n    char *zErrMsg = 0;\n    zQuery = sqlite3_mprintf(\"SELECT name, sql FROM sqlite_schema WHERE %s\", zWhere);\n    shell_check_oom(zQuery);\n    rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n    if (rc) {\n        goto end_schema_xfer;\n    }\n    while ((rc = sqlite3_step(pQuery)) == 100)\n        {\n            zName = sqlite3_column_text(pQuery, 0);\n            zSql = sqlite3_column_text(pQuery, 1);\n            if (zName == 0 || zSql == 0)\n                continue;\n            printf(\"%s... \", zName);\n            sqlite3_exec(newDb, (const char *)zSql, 0, 0, &zErrMsg);\n            if (zErrMsg) {\n                sqlite3_free(zErrMsg);\n                zErrMsg = 0;\n            }\n            if (xForEach) {\n                xForEach(p, newDb, (const char *)zName);\n            }\n            printf(\"done\\n\");\n        }\n    if (rc != 101) {\n        sqlite3_finalize(pQuery);\n        sqlite3_free(zQuery);\n        zQuery = sqlite3_mprintf(\"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid DESC\", zWhere);\n        shell_check_oom(zQuery);\n        rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\n        if (rc) {\n            goto end_schema_xfer;\n        }\n        while (sqlite3_step(pQuery) == 100)\n            {\n                zName = sqlite3_column_text(pQuery, 0);\n                zSql = sqlite3_column_text(pQuery, 1);\n                if (zName == 0 || zSql == 0)\n                    continue;\n                printf(\"%s... \", zName);\n                sqlite3_exec(newDb, (const char *)zSql, 0, 0, &zErrMsg);\n                if (zErrMsg) {\n                    sqlite3_free(zErrMsg);\n                    zErrMsg = 0;\n                }\n                if (xForEach) {\n                    xForEach(p, newDb, (const char *)zName);\n                }\n                printf(\"done\\n\");\n            }\n    }\n  end_schema_xfer:\n    sqlite3_finalize(pQuery);\n    sqlite3_free(zQuery);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#10543:1#idxFindIndexes",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    IdxStatement *pStmt;\n    sqlite3 *dbm = p->dbm;\n    int rc = 0;\n    IdxHash hIdx;\n    idxHashInit(&hIdx);\n    for (pStmt = p->pStatement; rc == 0 && pStmt; pStmt = pStmt->pNext) {\n        IdxHashEntry *pEntry;\n        sqlite3_stmt *pExplain = 0;\n        idxHashClear(&hIdx);\n        rc = idxPrintfPrepareStmt(dbm, &pExplain, pzErr, \"EXPLAIN QUERY PLAN %s\", pStmt->zSql);\n        while (rc == 0 && sqlite3_step(pExplain) == 100)\n            {\n                const char *zDetail = (const char *)sqlite3_column_text(pExplain, 3);\n                int nDetail;\n                int i;\n                if (!zDetail)\n                    continue;\n                nDetail = (int)strlen(zDetail);\n                for (i = 0; i < nDetail; i++) {\n                    const char *zIdx = 0;\n                    if (i + 13 < nDetail && memcmp(&zDetail[i], \" USING INDEX \", 13) == 0) {\n                        zIdx = &zDetail[i + 13];\n                    } else if (i + 22 < nDetail && memcmp(&zDetail[i], \" USING COVERING INDEX \", 22) == 0) {\n                        zIdx = &zDetail[i + 22];\n                    }\n                    if (zIdx) {\n                        const char *zSql;\n                        int nIdx = 0;\n                        while (zIdx[nIdx] != '\\x00' && (zIdx[nIdx] != ' ' || zIdx[nIdx + 1] != '('))\n                            {\n                                nIdx++;\n                            }\n                        zSql = idxHashSearch(&p->hIdx, zIdx, nIdx);\n                        if (zSql) {\n                            idxHashAdd(&rc, &hIdx, zSql, 0);\n                            if (rc)\n                                goto find_indexes_out;\n                        }\n                        break;\n                    }\n                }\n                if (zDetail[0] != '-') {\n                    pStmt->zEQP = idxAppendText(&rc, pStmt->zEQP, \"%s\\n\", zDetail);\n                }\n            }\n        for (pEntry = hIdx.pFirst; pEntry; pEntry = pEntry->pNext) {\n            pStmt->zIdx = idxAppendText(&rc, pStmt->zIdx, \"%s;\\n\", pEntry->zKey);\n        }\n        idxFinalize(&rc, pExplain);\n    }\n  find_indexes_out:\n    idxHashClear(&hIdx);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#3970:1#sqlite3re_match",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    ReStateSet aStateSet[2], *pThis, *pNext;\n    ReStateNumber aSpace[100];\n    ReStateNumber *pToFree;\n    unsigned int i = 0;\n    unsigned int iSwap = 0;\n    int c = 268435455;\n    int cPrev = 0;\n    int rc = 0;\n    ReInput in;\n    in.z = zIn;\n    in.i = 0;\n    in.mx = nIn >= 0 ? nIn : (int)strlen((const char *)zIn);\n    if (pRe->nInit) {\n        unsigned char x = pRe->zInit[0];\n        while (in.i + pRe->nInit <= in.mx && (zIn[in.i] != x || strncmp((const char *)zIn + in.i, (const char *)pRe->zInit, pRe->nInit) != 0))\n            {\n                in.i++;\n            }\n        if (in.i + pRe->nInit > in.mx)\n            return 0;\n        c = 268435455 - 1;\n    }\n    if (pRe->nState <= (sizeof (aSpace) / (sizeof (aSpace[0]) * 2))) {\n        pToFree = 0;\n        aStateSet[0].aState = aSpace;\n    } else {\n        pToFree = sqlite3_malloc64(sizeof(ReStateNumber) * 2 * pRe->nState);\n        if (pToFree == 0)\n            return -1;\n        aStateSet[0].aState = pToFree;\n    }\n    aStateSet[1].aState = &aStateSet[0].aState[pRe->nState];\n    pNext = &aStateSet[1];\n    pNext->nState = 0;\n    re_add_state(pNext, 0);\n    while (c != 0 && pNext->nState > 0)\n        {\n            cPrev = c;\n            c = pRe->xNextChar(&in);\n            pThis = pNext;\n            pNext = &aStateSet[iSwap];\n            iSwap = 1 - iSwap;\n            pNext->nState = 0;\n            for (i = 0; i < pThis->nState; i++) {\n                int x = pThis->aState[i];\n                switch (pRe->aOp[x]) {\n                  case 1:\n                    {\n                        if (pRe->aArg[x] == c)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 18:\n                    {\n                        if (cPrev == 268435455)\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 2:\n                    {\n                        if (c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 11:\n                    {\n                        if (re_word_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 12:\n                    {\n                        if (!re_word_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 13:\n                    {\n                        if (re_digit_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 14:\n                    {\n                        if (!re_digit_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 15:\n                    {\n                        if (re_space_char(c))\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 16:\n                    {\n                        if (!re_space_char(c) && c != 0)\n                            re_add_state(pNext, x + 1);\n                        break;\n                    }\n                  case 17:\n                    {\n                        if (re_word_char(c) != re_word_char(cPrev))\n                            re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 3:\n                    {\n                        re_add_state(pNext, x);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 4:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        re_add_state(pThis, x + 1);\n                        break;\n                    }\n                  case 5:\n                    {\n                        re_add_state(pThis, x + pRe->aArg[x]);\n                        break;\n                    }\n                  case 6:\n                    {\n                        rc = 1;\n                        goto re_match_end;\n                    }\n                  case 8:\n                    {\n                        if (c == 0)\n                            break;\n                        goto re_op_cc_inc;\n                    }\n                  case 7:\n                  re_op_cc_inc:\n                    {\n                        int j = 1;\n                        int n = pRe->aArg[x];\n                        int hit = 0;\n                        for (j = 1; j > 0 && j < n; j++) {\n                            if (pRe->aOp[x + j] == 9) {\n                                if (pRe->aArg[x + j] == c) {\n                                    hit = 1;\n                                    j = -1;\n                                }\n                            } else {\n                                if (pRe->aArg[x + j] <= c && pRe->aArg[x + j + 1] >= c) {\n                                    hit = 1;\n                                    j = -1;\n                                } else {\n                                    j++;\n                                }\n                            }\n                        }\n                        if (pRe->aOp[x] == 8)\n                            hit = !hit;\n                        if (hit)\n                            re_add_state(pNext, x + n);\n                        break;\n                    }\n                }\n            }\n        }\n    for (i = 0; i < pNext->nState; i++) {\n        int x = pNext->aState[i];\n        while (pRe->aOp[x] == 5)\n            x += pRe->aArg[x];\n        if (pRe->aOp[x] == 6) {\n            rc = 1;\n            break;\n        }\n    }\n  re_match_end:\n    sqlite3_free(pToFree);\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#17826:1#exec_prepared_stmt_columnar",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    sqlite3_int64 nRow = 0;\n    int nColumn = 0;\n    char **azData = 0;\n    sqlite3_int64 nAlloc = 0;\n    char *abRowDiv = 0;\n    const unsigned char *uz;\n    const char *z;\n    char **azQuoted = 0;\n    int rc;\n    sqlite3_int64 i, nData;\n    int j, nTotal, w, n;\n    const char *colSep = 0;\n    const char *rowSep = 0;\n    const unsigned char **azNextLine = 0;\n    int bNextLine = 0;\n    int bMultiLineRowExists = 0;\n    int bw = p->cmOpts.bWordWrap;\n    const char *zEmpty = \"\";\n    const char *zShowNull = p->nullValue;\n    rc = sqlite3_step(pStmt);\n    if (rc != 100)\n        return;\n    nColumn = sqlite3_column_count(pStmt);\n    nAlloc = nColumn * 4;\n    if (nAlloc <= 0)\n        nAlloc = 1;\n    azData = sqlite3_malloc64(nAlloc * sizeof(char *));\n    shell_check_oom(azData);\n    azNextLine = sqlite3_malloc64(nColumn * sizeof(char *));\n    shell_check_oom((void *)azNextLine);\n    memset((void *)azNextLine, 0, nColumn * sizeof(char *));\n    if (p->cmOpts.bQuote) {\n        azQuoted = sqlite3_malloc64(nColumn * sizeof(char *));\n        shell_check_oom(azQuoted);\n        memset(azQuoted, 0, nColumn * sizeof(char *));\n    }\n    abRowDiv = sqlite3_malloc64(nAlloc / nColumn);\n    shell_check_oom(abRowDiv);\n    if (nColumn > p->nWidth) {\n        p->colWidth = realloc(p->colWidth, (nColumn + 1) * 2 * sizeof(int));\n        shell_check_oom(p->colWidth);\n        for (i = p->nWidth; i < nColumn; i++)\n            p->colWidth[i] = 0;\n        p->nWidth = nColumn;\n        p->actualWidth = &p->colWidth[nColumn];\n    }\n    memset(p->actualWidth, 0, nColumn * sizeof(int));\n    for (i = 0; i < nColumn; i++) {\n        w = p->colWidth[i];\n        if (w < 0)\n            w = -w;\n        p->actualWidth[i] = w;\n    }\n    for (i = 0; i < nColumn; i++) {\n        const unsigned char *zNotUsed;\n        int wx = p->colWidth[i];\n        if (wx == 0) {\n            wx = p->cmOpts.iWrap;\n        }\n        if (wx < 0)\n            wx = -wx;\n        uz = (const unsigned char *)sqlite3_column_name(pStmt, i);\n        azData[i] = translateForDisplayAndDup(uz, &zNotUsed, wx, bw);\n    }\n    do {\n        int useNextLine = bNextLine;\n        bNextLine = 0;\n        if ((nRow + 2) * nColumn >= nAlloc) {\n            nAlloc *= 2;\n            azData = sqlite3_realloc64(azData, nAlloc * sizeof(char *));\n            shell_check_oom(azData);\n            abRowDiv = sqlite3_realloc64(abRowDiv, nAlloc / nColumn);\n            shell_check_oom(abRowDiv);\n        }\n        abRowDiv[nRow] = 1;\n        nRow++;\n        for (i = 0; i < nColumn; i++) {\n            int wx = p->colWidth[i];\n            if (wx == 0) {\n                wx = p->cmOpts.iWrap;\n            }\n            if (wx < 0)\n                wx = -wx;\n            if (useNextLine) {\n                uz = azNextLine[i];\n                if (uz == 0)\n                    uz = (u8 *)zEmpty;\n            } else if (p->cmOpts.bQuote) {\n                sqlite3_free(azQuoted[i]);\n                azQuoted[i] = quoted_column(pStmt, i);\n                uz = (const unsigned char *)azQuoted[i];\n            } else {\n                uz = (const unsigned char *)sqlite3_column_text(pStmt, i);\n                if (uz == 0)\n                    uz = (u8 *)zShowNull;\n            }\n            azData[nRow * nColumn + i] = translateForDisplayAndDup(uz, &azNextLine[i], wx, bw);\n            if (azNextLine[i]) {\n                bNextLine = 1;\n                abRowDiv[nRow - 1] = 0;\n                bMultiLineRowExists = 1;\n            }\n        }\n    } while (bNextLine || sqlite3_step(pStmt) == 100);\n    nTotal = nColumn * (nRow + 1);\n    for (i = 0; i < nTotal; i++) {\n        z = azData[i];\n        if (z == 0)\n            z = (char *)zEmpty;\n        n = strlenChar(z);\n        j = i % nColumn;\n        if (n > p->actualWidth[j])\n            p->actualWidth[j] = n;\n    }\n    if (seenInterrupt)\n        goto columnar_end;\n    if (nColumn == 0)\n        goto columnar_end;\n    switch (p->cMode) {\n      case 1:\n        {\n            colSep = \"  \";\n            rowSep = \"\\n\";\n            if (p->showHeader) {\n                for (i = 0; i < nColumn; i++) {\n                    w = p->actualWidth[i];\n                    if (p->colWidth[i] < 0)\n                        w = -w;\n                    <recovery-expr>()(<recovery-expr>(p), w, azData[i]);\n                    fputs(i == nColumn - 1 ? \"\\n\" : \"  \", <recovery-expr>(p));\n                }\n                for (i = 0; i < nColumn; i++) {\n                    <recovery-expr>()(<recovery-expr>(p), p->actualWidth[i]);\n                    fputs(i == nColumn - 1 ? \"\\n\" : \"  \", <recovery-expr>(p));\n                }\n            }\n            break;\n        }\n      case 15:\n        {\n            colSep = \" | \";\n            rowSep = \" |\\n\";\n            print_row_separator(p, nColumn, \"+\");\n            fputs(\"| \", <recovery-expr>(p));\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(<recovery-expr>(p), \"%*s%s%*s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\");\n                fputs(i == nColumn - 1 ? \" |\\n\" : \" | \", <recovery-expr>(p));\n            }\n            print_row_separator(p, nColumn, \"+\");\n            break;\n        }\n      case 14:\n        {\n            colSep = \" | \";\n            rowSep = \" |\\n\";\n            fputs(\"| \", <recovery-expr>(p));\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(<recovery-expr>(p), \"%*s%s%*s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\");\n                fputs(i == nColumn - 1 ? \" |\\n\" : \" | \", <recovery-expr>(p));\n            }\n            print_row_separator(p, nColumn, \"|\");\n            break;\n        }\n      case 16:\n        {\n            colSep = \" \\342\\224\\202 \";\n            rowSep = \" \\342\\224\\202\\n\";\n            print_box_row_separator(p, nColumn, \"\\342\\224\\214\", \"\\342\\224\\254\", \"\\342\\224\\220\");\n            fprintf(<recovery-expr>(p), \"\\342\\224\\202 \");\n            for (i = 0; i < nColumn; i++) {\n                w = p->actualWidth[i];\n                n = strlenChar(azData[i]);\n                fprintf(<recovery-expr>(p), \"%*s%s%*s%s\", (w - n) / 2, \"\", azData[i], (w - n + 1) / 2, \"\", i == nColumn - 1 ? \" \\342\\224\\202\\n\" : \" \\342\\224\\202 \");\n            }\n            print_box_row_separator(p, nColumn, \"\\342\\224\\234\", \"\\342\\224\\274\", \"\\342\\224\\244\");\n            break;\n        }\n    }\n    for (i = nColumn , j = 0; i < nTotal; i++ , j++) {\n        if (j == 0 && p->cMode != 1) {\n            fprintf(<recovery-expr>(p), \"%s\", p->cMode == 16 ? \"\\342\\224\\202 \" : \"| \");\n        }\n        z = azData[i];\n        if (z == 0)\n            z = p->nullValue;\n        w = p->actualWidth[j];\n        if (p->colWidth[j] < 0)\n            w = -w;\n        <recovery-expr>()(<recovery-expr>(p), w, z);\n        if (j == nColumn - 1) {\n            fprintf(<recovery-expr>(p), \"%s\", rowSep);\n            if (bMultiLineRowExists && abRowDiv[i / nColumn - 1] && i + 1 < nTotal) {\n                if (p->cMode == 15) {\n                    print_row_separator(p, nColumn, \"+\");\n                } else if (p->cMode == 16) {\n                    print_box_row_separator(p, nColumn, \"\\342\\224\\234\", \"\\342\\224\\274\", \"\\342\\224\\244\");\n                } else if (p->cMode == 1) {\n                    fprintf(<recovery-expr>(p), \"\\n\");\n                }\n            }\n            j = -1;\n            if (seenInterrupt)\n                goto columnar_end;\n        } else {\n            fprintf(<recovery-expr>(p), \"%s\", colSep);\n        }\n    }\n    if (p->cMode == 15) {\n        print_row_separator(p, nColumn, \"+\");\n    } else if (p->cMode == 16) {\n        print_box_row_separator(p, nColumn, \"\\342\\224\\224\", \"\\342\\224\\264\", \"\\342\\224\\230\");\n    }\n  columnar_end:\n    if (seenInterrupt) {\n        fprintf(<recovery-expr>(p), \"Interrupt\\n\");\n    }\n    nData = (nRow + 1) * nColumn;\n    for (i = 0; i < nData; i++) {\n        z = azData[i];\n        if (z != zEmpty && z != zShowNull)\n            free(azData[i]);\n    }\n    sqlite3_free(azData);\n    sqlite3_free((void *)azNextLine);\n    sqlite3_free(abRowDiv);\n    if (azQuoted) {\n        for (i = 0; i < nColumn; i++)\n            sqlite3_free(azQuoted[i]);\n        sqlite3_free(azQuoted);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#2889:1#decimalMulFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Decimal *pA = decimal_new(context, argv[0], 0, 0);\n    Decimal *pB = decimal_new(context, argv[1], 0, 0);\n    signed char *acc = 0;\n    int i, j, k;\n    int minFrac;\n    (void)(argc);\n    if (pA == 0 || pA->oom || pA->isNull || pB == 0 || pB->oom || pB->isNull) {\n        goto mul_end;\n    }\n    acc = sqlite3_malloc64(pA->nDigit + pB->nDigit + 2);\n    if (acc == 0) {\n        sqlite3_result_error_nomem(context);\n        goto mul_end;\n    }\n    memset(acc, 0, pA->nDigit + pB->nDigit + 2);\n    minFrac = pA->nFrac;\n    if (pB->nFrac < minFrac)\n        minFrac = pB->nFrac;\n    for (i = pA->nDigit - 1; i >= 0; i--) {\n        signed char f = pA->a[i];\n        int carry = 0, x;\n        for (j = pB->nDigit - 1 , k = i + j + 3; j >= 0; j-- , k--) {\n            x = acc[k] + f * pB->a[j] + carry;\n            acc[k] = x % 10;\n            carry = x / 10;\n        }\n        x = acc[k] + carry;\n        acc[k] = x % 10;\n        acc[k - 1] += x / 10;\n    }\n    sqlite3_free(pA->a);\n    pA->a = acc;\n    acc = 0;\n    pA->nDigit += pB->nDigit + 2;\n    pA->nFrac += pB->nFrac;\n    pA->sign ^= pB->sign;\n    while (pA->nFrac > minFrac && pA->a[pA->nDigit - 1] == 0)\n        {\n            pA->nFrac--;\n            pA->nDigit--;\n        }\n    decimal_result(context, pA);\n  mul_end:\n    sqlite3_free(acc);\n    decimal_free(pA);\n    decimal_free(pB);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#21990:1#do_meta_command",
    "gotos": 48,
    "labels": 3,
    "body": "{\n    int h = 1;\n    int nArg = 0;\n    int n, c;\n    int rc = 0;\n    char *azArg[52];\n    if (p->expert.pExpert) {\n        expertFinish(p, 1, 0);\n    }\n    while (zLine[h] && nArg < (int)(sizeof (azArg) / sizeof (azArg[0])) - 1)\n        {\n            while (isspace((unsigned char)zLine[h]))\n                {\n                    h++;\n                }\n            if (zLine[h] == 0)\n                break;\n            if (zLine[h] == '\\'' || zLine[h] == '\"') {\n                int delim = zLine[h++];\n                azArg[nArg++] = &zLine[h];\n                while (zLine[h] && zLine[h] != delim)\n                    {\n                        if (zLine[h] == '\\\\' && delim == '\"' && zLine[h + 1] != 0)\n                            h++;\n                        h++;\n                    }\n                if (zLine[h] == delim) {\n                    zLine[h++] = 0;\n                }\n                if (delim == '\"')\n                    resolve_backslashes(azArg[nArg - 1]);\n            } else {\n                azArg[nArg++] = &zLine[h];\n                while (zLine[h] && !isspace((unsigned char)zLine[h]))\n                    {\n                        h++;\n                    }\n                if (zLine[h])\n                    zLine[h++] = 0;\n                resolve_backslashes(azArg[nArg - 1]);\n            }\n        }\n    azArg[nArg] = 0;\n    if (nArg == 0)\n        return 0;\n    n = strlen30(azArg[0]);\n    c = azArg[0][0];\n    clearTempFile(p);\n    if (c == 'a' && <recovery-expr>()(azArg[0], \"auth\", n) == 0) {\n        if (nArg != 2) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        if (booleanValue(azArg[1])) {\n            sqlite3_set_authorizer(p->db, shellAuth, p);\n        } else if (p->bSafeModePersist) {\n            sqlite3_set_authorizer(p->db, safeModeAuth, p);\n        } else {\n            sqlite3_set_authorizer(p->db, 0, 0);\n        }\n    } else if ((c == 'b' && n >= 3 && <recovery-expr>()(azArg[0], \"backup\", n) == 0) || (c == 's' && n >= 3 && <recovery-expr>()(azArg[0], \"save\", n) == 0)) {\n        const char *zDestFile = 0;\n        const char *zDb = 0;\n        sqlite3 *pDest;\n        sqlite3_backup *pBackup;\n        int j;\n        int bAsync = 0;\n        const char *zVfs = 0;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        for (j = 1; j < nArg; j++) {\n            const char *z = azArg[j];\n            if (z[0] == '-') {\n                if (z[1] == '-')\n                    z++;\n                if (cli_strcmp(z, \"-append\") == 0) {\n                    zVfs = \"apndvfs\";\n                } else if (cli_strcmp(z, \"-async\") == 0) {\n                    bAsync = 1;\n                } else {\n                    return 1;\n                }\n            } else if (zDestFile == 0) {\n                zDestFile = azArg[j];\n            } else if (zDb == 0) {\n                zDb = zDestFile;\n                zDestFile = azArg[j];\n            } else {\n                return 1;\n            }\n        }\n        if (zDestFile == 0) {\n            return 1;\n        }\n        if (zDb == 0)\n            zDb = \"main\";\n        rc = sqlite3_open_v2(zDestFile, &pDest, 2 | 4, zVfs);\n        if (rc != 0) {\n            close_db(pDest);\n            return 1;\n        }\n        if (bAsync) {\n            sqlite3_exec(pDest, \"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;\", 0, 0, 0);\n        }\n        open_db(p, 0);\n        pBackup = sqlite3_backup_init(pDest, \"main\", p->db, zDb);\n        if (pBackup == 0) {\n            close_db(pDest);\n            return 1;\n        }\n        while ((rc = sqlite3_backup_step(pBackup, 100)) == 0)\n            {\n            }\n        sqlite3_backup_finish(pBackup);\n        if (rc == 101) {\n            rc = 0;\n        } else {\n            rc = 1;\n        }\n        close_db(pDest);\n    } else if (c == 'b' && n >= 3 && <recovery-expr>()(azArg[0], \"bail\", n) == 0) {\n        if (nArg == 2) {\n            bail_on_error = booleanValue(azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'b' && n >= 3 && <recovery-expr>()(azArg[0], \"binary\", n) == 0) {\n        if (nArg == 2) {\n            if (booleanValue(azArg[1])) {\n                ;\n            } else {\n                ;\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'b' && n >= 3 && <recovery-expr>()(azArg[0], \"breakpoint\", n) == 0) {\n        test_breakpoint();\n    } else if (c == 'c' && cli_strcmp(azArg[0], \"cd\") == 0) {\n        failIfSafeMode(p, \"cannot run .cd in safe mode\");\n        if (nArg == 2) {\n            rc = chdir(azArg[1]);\n            if (rc) {\n                rc = 1;\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'c' && n >= 3 && <recovery-expr>()(azArg[0], \"changes\", n) == 0) {\n        if (nArg == 2) {\n            setOrClearFlag(p, 32, azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'c' && n >= 3 && <recovery-expr>()(azArg[0], \"check\", n) == 0) {\n        char *zRes = 0;\n        output_reset(p);\n        if (nArg != 2) {\n            rc = 2;\n        } else if ((zRes = readFile(\"testcase-out.txt\", 0)) == 0) {\n            rc = 2;\n        } else if (testcase_glob(azArg[1], zRes) == 0) {\n            rc = 1;\n        } else {\n            p->nCheck++;\n        }\n        sqlite3_free(zRes);\n    } else if (c == 'c' && <recovery-expr>()(azArg[0], \"clone\", n) == 0) {\n        failIfSafeMode(p, \"cannot run .clone in safe mode\");\n        if (nArg == 2) {\n            tryToClone(p, azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'c' && <recovery-expr>()(azArg[0], \"connection\", n) == 0) {\n        if (nArg == 1) {\n            int i;\n            for (i = 0; i < (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0])); i++) {\n                const char *zFile = p->aAuxDb[i].zDbFilename;\n                if (p->aAuxDb[i].db == 0 && p->pAuxDb != &p->aAuxDb[i]) {\n                    zFile = \"(not open)\";\n                } else if (zFile == 0) {\n                    zFile = \"(memory)\";\n                } else if (zFile[0] == 0) {\n                    zFile = \"(temporary-file)\";\n                }\n                if (p->pAuxDb == &p->aAuxDb[i]) {\n                } else if (p->aAuxDb[i].db != 0) {\n                }\n            }\n        } else if (nArg == 2 && isdigit((unsigned char)azArg[1][0]) && azArg[1][1] == 0) {\n            int i = azArg[1][0] - '0';\n            if (p->pAuxDb != &p->aAuxDb[i] && i >= 0 && i < (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0]))) {\n                p->pAuxDb->db = p->db;\n                p->pAuxDb = &p->aAuxDb[i];\n                globalDb = p->db = p->pAuxDb->db;\n                p->pAuxDb->db = 0;\n            }\n        } else if (nArg == 3 && cli_strcmp(azArg[1], \"close\") == 0 && isdigit((unsigned char)azArg[2][0]) && azArg[2][1] == 0) {\n            int i = azArg[2][0] - '0';\n            if (i < 0 || i >= (int)(sizeof (p->aAuxDb) / sizeof (p->aAuxDb[0]))) {\n            } else if (p->pAuxDb == &p->aAuxDb[i]) {\n                rc = 1;\n            } else if (p->aAuxDb[i].db) {\n                ;\n                close_db(p->aAuxDb[i].db);\n                p->aAuxDb[i].db = 0;\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'd' && n > 1 && <recovery-expr>()(azArg[0], \"databases\", n) == 0) {\n        char **azName = 0;\n        int nName = 0;\n        sqlite3_stmt *pStmt;\n        int i;\n        open_db(p, 0);\n        rc = sqlite3_prepare_v2(p->db, \"PRAGMA database_list\", -1, &pStmt, 0);\n        if (rc) {\n            rc = 1;\n        } else {\n            while (sqlite3_step(pStmt) == 100)\n                {\n                    const char *zSchema = (const char *)sqlite3_column_text(pStmt, 1);\n                    const char *zFile = (const char *)sqlite3_column_text(pStmt, 2);\n                    if (zSchema == 0 || zFile == 0)\n                        continue;\n                    azName = sqlite3_realloc(azName, (nName + 1) * 2 * sizeof(char *));\n                    shell_check_oom(azName);\n                    azName[nName * 2] = strdup(zSchema);\n                    azName[nName * 2 + 1] = strdup(zFile);\n                    nName++;\n                }\n        }\n        sqlite3_finalize(pStmt);\n        for (i = 0; i < nName; i++) {\n            int eTxn = sqlite3_txn_state(p->db, azName[i * 2]);\n            int bRdonly = sqlite3_db_readonly(p->db, azName[i * 2]);\n            const char *z = azName[i * 2 + 1];\n            fprintf(<recovery-expr>(p), \"%s: %s %s%s\\n\", azName[i * 2], z && z[0] ? z : \"\\\"\\\"\", bRdonly ? \"r/o\" : \"r/w\", eTxn == 0 ? \"\" : eTxn == 1 ? \" read-txn\" : \" write-txn\");\n            free(azName[i * 2]);\n            free(azName[i * 2 + 1]);\n        }\n        sqlite3_free(azName);\n    } else if (c == 'd' && n >= 3 && <recovery-expr>()(azArg[0], \"dbconfig\", n) == 0) {\n        static const struct DbConfigChoices {\n            const char *zName;\n            int op;\n        } aDbConfig[] = {{\"defensive\", 1010}, {\"dqs_ddl\", 1014}, {\"dqs_dml\", 1013}, {\"enable_fkey\", 1002}, {\"enable_qpsg\", 1007}, {\"enable_trigger\", 1003}, {\"enable_view\", 1015}, {\"fts3_tokenizer\", 1004}, {\"legacy_alter_table\", 1012}, {\"legacy_file_format\", 1016}, {\"load_extension\", 1005}, {\"no_ckpt_on_close\", 1006}, {\"reset_database\", 1009}, {\"trigger_eqp\", 1008}, {\"trusted_schema\", 1017}, {\"writable_schema\", 1011}};\n        int ii, v;\n        open_db(p, 0);\n        for (ii = 0; ii < (int)(sizeof (aDbConfig) / sizeof (aDbConfig[0])); ii++) {\n            if (nArg > 1 && cli_strcmp(azArg[1], aDbConfig[ii].zName) != 0)\n                continue;\n            if (nArg >= 3) {\n                sqlite3_db_config(p->db, aDbConfig[ii].op, booleanValue(azArg[2]), 0);\n            }\n            sqlite3_db_config(p->db, aDbConfig[ii].op, -1, &v);\n            fprintf(<recovery-expr>(p), \"%19s %s\\n\", aDbConfig[ii].zName, v ? \"on\" : \"off\");\n            if (nArg > 1)\n                break;\n        }\n        if (nArg > 1 && ii == (int)(sizeof (aDbConfig) / sizeof (aDbConfig[0]))) {\n        }\n    } else if (c == 'd' && <recovery-expr>()(azArg[0], \"dump\", n) == 0) {\n        char *zLike = 0;\n        char *zSql;\n        int i;\n        int savedShowHeader = p->showHeader;\n        int savedShellFlags = p->shellFlgs;\n        ((p)->shellFlgs &= (~(8 | 16 | 64 | 256 | 512)));\n        for (i = 1; i < nArg; i++) {\n            if (azArg[i][0] == '-') {\n                const char *z = azArg[i] + 1;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"preserve-rowids\") == 0) {\n                    ((p)->shellFlgs |= (8));\n                } else if (cli_strcmp(z, \"newlines\") == 0) {\n                    ((p)->shellFlgs |= (16));\n                } else if (cli_strcmp(z, \"data-only\") == 0) {\n                    ((p)->shellFlgs |= (256));\n                } else if (cli_strcmp(z, \"nosys\") == 0) {\n                    ((p)->shellFlgs |= (512));\n                } else {\n                    rc = 1;\n                    sqlite3_free(zLike);\n                    goto meta_command_exit;\n                }\n            } else {\n                char *zExpr = sqlite3_mprintf(\"name LIKE %Q ESCAPE '\\\\' OR EXISTS (  SELECT 1 FROM sqlite_schema WHERE     name LIKE %Q ESCAPE '\\\\' AND    sql LIKE 'CREATE VIRTUAL TABLE%%' AND    substr(o.name, 1, length(name)+1) == (name||'_'))\", azArg[i], azArg[i]);\n                if (zLike) {\n                    zLike = sqlite3_mprintf(\"%z OR %z\", zLike, zExpr);\n                } else {\n                    zLike = zExpr;\n                }\n            }\n        }\n        open_db(p, 0);\n        if ((p->shellFlgs & 256) == 0) {\n            fprintf(<recovery-expr>(p), \"PRAGMA foreign_keys=OFF;\\n\");\n            fprintf(<recovery-expr>(p), \"BEGIN TRANSACTION;\\n\");\n        }\n        p->writableSchema = 0;\n        p->showHeader = 0;\n        sqlite3_exec(p->db, \"SAVEPOINT dump; PRAGMA writable_schema=ON\", 0, 0, 0);\n        p->nErr = 0;\n        if (zLike == 0)\n            zLike = sqlite3_mprintf(\"true\");\n        zSql = sqlite3_mprintf(\"SELECT name, type, sql FROM sqlite_schema AS o WHERE (%s) AND type=='table'  AND sql NOT NULL ORDER BY tbl_name='sqlite_sequence', rowid\", zLike);\n        run_schema_dump_query(p, zSql);\n        sqlite3_free(zSql);\n        if ((p->shellFlgs & 256) == 0) {\n            zSql = sqlite3_mprintf(\"SELECT sql FROM sqlite_schema AS o WHERE (%s) AND sql NOT NULL  AND type IN ('index','trigger','view')\", zLike);\n            run_table_dump_query(p, zSql);\n            sqlite3_free(zSql);\n        }\n        sqlite3_free(zLike);\n        if (p->writableSchema) {\n            fprintf(<recovery-expr>(p), \"PRAGMA writable_schema=OFF;\\n\");\n            p->writableSchema = 0;\n        }\n        sqlite3_exec(p->db, \"PRAGMA writable_schema=OFF;\", 0, 0, 0);\n        sqlite3_exec(p->db, \"RELEASE dump;\", 0, 0, 0);\n        if ((p->shellFlgs & 256) == 0) {\n            fprintf(<recovery-expr>(p), p->nErr ? \"ROLLBACK; -- due to errors\\n\" : \"COMMIT;\\n\");\n        }\n        p->showHeader = savedShowHeader;\n        p->shellFlgs = savedShellFlags;\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"echo\", n) == 0) {\n        if (nArg == 2) {\n            setOrClearFlag(p, 64, azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"eqp\", n) == 0) {\n        if (nArg == 2) {\n            p->autoEQPtest = 0;\n            if (p->autoEQPtrace) {\n                if (p->db)\n                    sqlite3_exec(p->db, \"PRAGMA vdbe_trace=OFF;\", 0, 0, 0);\n                p->autoEQPtrace = 0;\n            }\n            if (cli_strcmp(azArg[1], \"full\") == 0) {\n                p->autoEQP = 3;\n            } else if (cli_strcmp(azArg[1], \"trigger\") == 0) {\n                p->autoEQP = 2;\n            } else {\n                p->autoEQP = (u8)booleanValue(azArg[1]);\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"exit\", n) == 0) {\n        if (nArg > 1 && (rc = (int)integerValue(azArg[1])) != 0)\n            exit(rc);\n        rc = 2;\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"explain\", n) == 0) {\n        int val = 1;\n        if (nArg >= 2) {\n            if (cli_strcmp(azArg[1], \"auto\") == 0) {\n                val = 99;\n            } else {\n                val = booleanValue(azArg[1]);\n            }\n        }\n        if (val == 1 && p->mode != 9) {\n            p->normalMode = p->mode;\n            p->mode = 9;\n            p->autoExplain = 0;\n        } else if (val == 0) {\n            if (p->mode == 9)\n                p->mode = p->normalMode;\n            p->autoExplain = 0;\n        } else if (val == 99) {\n            if (p->mode == 9)\n                p->mode = p->normalMode;\n            p->autoExplain = 1;\n        }\n    } else if (c == 'e' && <recovery-expr>()(azArg[0], \"expert\", n) == 0) {\n        if (p->bSafeMode) {\n            rc = 1;\n        } else {\n            open_db(p, 0);\n            expertDotCommand(p, azArg, nArg);\n        }\n    } else if (c == 'f' && <recovery-expr>()(azArg[0], \"filectrl\", n) == 0) {\n        static const struct {\n            const char *zCtrlName;\n            int ctrlCode;\n            const char *zUsage;\n        } aCtrl[] = {{\"chunk_size\", 6, \"SIZE\"}, {\"data_version\", 35, \"\"}, {\"has_moved\", 20, \"\"}, {\"lock_timeout\", 34, \"MILLISEC\"}, {\"persist_wal\", 10, \"[BOOLEAN]\"}, {\"psow\", 13, \"[BOOLEAN]\"}, {\"reserve_bytes\", 38, \"[N]\"}, {\"size_limit\", 36, \"[LIMIT]\"}, {\"tempfilename\", 16, \"\"}};\n        int filectrl = -1;\n        int iCtrl = -1;\n        sqlite3_int64 iRes = 0;\n        int isOk = 0;\n        int n2, i;\n        const char *zCmd = 0;\n        const char *zSchema = 0;\n        open_db(p, 0);\n        zCmd = nArg >= 2 ? azArg[1] : \"help\";\n        if (zCmd[0] == '-' && (cli_strcmp(zCmd, \"--schema\") == 0 || cli_strcmp(zCmd, \"-schema\") == 0) && nArg >= 4) {\n            zSchema = azArg[2];\n            for (i = 3; i < nArg; i++)\n                azArg[i - 2] = azArg[i];\n            nArg -= 2;\n            zCmd = azArg[1];\n        }\n        if (zCmd[0] == '-' && zCmd[1]) {\n            zCmd++;\n            if (zCmd[0] == '-' && zCmd[1])\n                zCmd++;\n        }\n        if (cli_strcmp(zCmd, \"help\") == 0) {\n            fprintf(<recovery-expr>(p), \"Available file-controls:\\n\");\n            for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n                fprintf(<recovery-expr>(p), \"  .filectrl %s %s\\n\", aCtrl[i].zCtrlName, aCtrl[i].zUsage);\n            }\n            rc = 1;\n            goto meta_command_exit;\n        }\n        n2 = strlen30(zCmd);\n        for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n            if (<recovery-expr>()(zCmd, aCtrl[i].zCtrlName, n2) == 0) {\n                if (filectrl < 0) {\n                    filectrl = aCtrl[i].ctrlCode;\n                    iCtrl = i;\n                } else {\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            }\n        }\n        if (filectrl < 0) {\n        } else {\n            switch (filectrl) {\n              case 36:\n                {\n                    if (nArg != 2 && nArg != 3)\n                        break;\n                    iRes = nArg == 3 ? integerValue(azArg[2]) : -1;\n                    sqlite3_file_control(p->db, zSchema, 36, &iRes);\n                    isOk = 1;\n                    break;\n                }\n              case 34:\n              case 6:\n                {\n                    int x;\n                    if (nArg != 3)\n                        break;\n                    x = (int)integerValue(azArg[2]);\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    isOk = 2;\n                    break;\n                }\n              case 10:\n              case 13:\n                {\n                    int x;\n                    if (nArg != 2 && nArg != 3)\n                        break;\n                    x = nArg == 3 ? booleanValue(azArg[2]) : -1;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    iRes = x;\n                    isOk = 1;\n                    break;\n                }\n              case 35:\n              case 20:\n                {\n                    int x;\n                    if (nArg != 2)\n                        break;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    iRes = x;\n                    isOk = 1;\n                    break;\n                }\n              case 16:\n                {\n                    char *z = 0;\n                    if (nArg != 2)\n                        break;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &z);\n                    if (z) {\n                        fprintf(<recovery-expr>(p), \"%s\\n\", z);\n                        sqlite3_free(z);\n                    }\n                    isOk = 2;\n                    break;\n                }\n              case 38:\n                {\n                    int x;\n                    if (nArg >= 3) {\n                        x = atoi(azArg[2]);\n                        sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    }\n                    x = -1;\n                    sqlite3_file_control(p->db, zSchema, filectrl, &x);\n                    fprintf(<recovery-expr>(p), \"%d\\n\", x);\n                    isOk = 2;\n                    break;\n                }\n            }\n        }\n        if (isOk == 0 && iCtrl >= 0) {\n            fprintf(<recovery-expr>(p), \"Usage: .filectrl %s %s\\n\", zCmd, aCtrl[iCtrl].zUsage);\n            rc = 1;\n        } else if (isOk == 1) {\n            char zBuf[100];\n            sqlite3_snprintf(sizeof (zBuf), zBuf, \"%lld\", iRes);\n            fprintf(<recovery-expr>(p), \"%s\\n\", zBuf);\n        }\n    } else if (c == 'f' && <recovery-expr>()(azArg[0], \"fullschema\", n) == 0) {\n        ShellState data;\n        int doStats = 0;\n        memcpy(&data, p, sizeof (data));\n        data.showHeader = 0;\n        data.cMode = data.mode = 3;\n        if (nArg == 2 && optionMatch(azArg[1], \"indent\")) {\n            data.cMode = data.mode = 11;\n            nArg = 1;\n        }\n        if (nArg != 1) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        rc = sqlite3_exec(p->db, \"SELECT sql FROM  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x     FROM sqlite_schema UNION ALL   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' ORDER BY x\", callback, &data, 0);\n        if (rc == 0) {\n            sqlite3_stmt *pStmt;\n            rc = sqlite3_prepare_v2(p->db, \"SELECT rowid FROM sqlite_schema WHERE name GLOB 'sqlite_stat[134]'\", -1, &pStmt, 0);\n            doStats = sqlite3_step(pStmt) == 100;\n            sqlite3_finalize(pStmt);\n        }\n        if (doStats == 0) {\n            fprintf(<recovery-expr>(p), \"/* No STAT tables available */\\n\");\n        } else {\n            fprintf(<recovery-expr>(p), \"ANALYZE sqlite_schema;\\n\");\n            data.cMode = data.mode = 5;\n            data.zDestTable = \"sqlite_stat1\";\n            shell_exec(&data, \"SELECT * FROM sqlite_stat1\", 0);\n            data.zDestTable = \"sqlite_stat4\";\n            shell_exec(&data, \"SELECT * FROM sqlite_stat4\", 0);\n            fprintf(<recovery-expr>(p), \"ANALYZE sqlite_schema;\\n\");\n        }\n    } else if (c == 'h' && <recovery-expr>()(azArg[0], \"headers\", n) == 0) {\n        if (nArg == 2) {\n            p->showHeader = booleanValue(azArg[1]);\n            p->shellFlgs |= 128;\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'h' && <recovery-expr>()(azArg[0], \"help\", n) == 0) {\n        if (nArg >= 2) {\n            n = <recovery-expr>()(<recovery-expr>(p), azArg[1]);\n            if (n == 0) {\n                fprintf(<recovery-expr>(p), \"Nothing matches '%s'\\n\", azArg[1]);\n            }\n        } else {\n            <recovery-expr>()(<recovery-expr>(p), 0);\n        }\n    } else if (c == 'i' && <recovery-expr>()(azArg[0], \"import\", n) == 0) {\n        char *zTable = 0;\n        char *zSchema = 0;\n        char *zFile = 0;\n        sqlite3_stmt *pStmt;\n        int nCol;\n        int nByte;\n        int i, j;\n        int needCommit;\n        int nSep;\n        char *zSql;\n        char *zFullTabName;\n        ImportCtx sCtx;\n        char *(*xRead)(ImportCtx *);\n        int eVerbose = 0;\n        int nSkip = 0;\n        int useOutputMode = 1;\n        char *zCreate = 0;\n        failIfSafeMode(p, \"cannot run .import in safe mode\");\n        memset(&sCtx, 0, sizeof (sCtx));\n        if (p->mode == 10) {\n            xRead = ascii_read_one_field;\n        } else {\n            xRead = csv_read_one_field;\n        }\n        rc = 1;\n        for (i = 1; i < nArg; i++) {\n            char *z = azArg[i];\n            if (z[0] == '-' && z[1] == '-')\n                z++;\n            if (z[0] != '-') {\n                if (zFile == 0) {\n                    zFile = z;\n                } else if (zTable == 0) {\n                    zTable = z;\n                } else {\n                    fprintf(<recovery-expr>(p), \"ERROR: extra argument: \\\"%s\\\".  Usage:\\n\", z);\n                    <recovery-expr>()(<recovery-expr>(p), \"import\");\n                    goto meta_command_exit;\n                }\n            } else if (cli_strcmp(z, \"-v\") == 0) {\n                eVerbose++;\n            } else if (cli_strcmp(z, \"-schema\") == 0 && i < nArg - 1) {\n                zSchema = azArg[++i];\n            } else if (cli_strcmp(z, \"-skip\") == 0 && i < nArg - 1) {\n                nSkip = integerValue(azArg[++i]);\n            } else if (cli_strcmp(z, \"-ascii\") == 0) {\n                sCtx.cColSep = \"\\037\"[0];\n                sCtx.cRowSep = \"\\036\"[0];\n                xRead = ascii_read_one_field;\n                useOutputMode = 0;\n            } else if (cli_strcmp(z, \"-csv\") == 0) {\n                sCtx.cColSep = ',';\n                sCtx.cRowSep = '\\n';\n                xRead = csv_read_one_field;\n                useOutputMode = 0;\n            } else {\n                fprintf(<recovery-expr>(p), \"ERROR: unknown option: \\\"%s\\\".  Usage:\\n\", z);\n                <recovery-expr>()(<recovery-expr>(p), \"import\");\n                goto meta_command_exit;\n            }\n        }\n        if (zTable == 0) {\n            fprintf(<recovery-expr>(p), \"ERROR: missing %s argument. Usage:\\n\", zFile == 0 ? \"FILE\" : \"TABLE\");\n            <recovery-expr>()(<recovery-expr>(p), \"import\");\n            goto meta_command_exit;\n        }\n        seenInterrupt = 0;\n        open_db(p, 0);\n        if (useOutputMode) {\n            nSep = strlen30(p->colSeparator);\n            if (nSep == 0) {\n                goto meta_command_exit;\n            }\n            if (nSep > 1) {\n                goto meta_command_exit;\n            }\n            nSep = strlen30(p->rowSeparator);\n            if (nSep == 0) {\n                goto meta_command_exit;\n            }\n            if (nSep == 2 && p->mode == 8 && cli_strcmp(p->rowSeparator, \"\\r\\n\") == 0) {\n                sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n                nSep = strlen30(p->rowSeparator);\n            }\n            if (nSep > 1) {\n                goto meta_command_exit;\n            }\n            sCtx.cColSep = p->colSeparator[0];\n            sCtx.cRowSep = p->rowSeparator[0];\n        }\n        sCtx.zFile = zFile;\n        sCtx.nLine = 1;\n        if (sCtx.zFile[0] == '|') {\n            <recovery-expr>(sCtx) = <recovery-expr>()(sCtx.zFile + 1, \"r\");\n            sCtx.zFile = \"<pipe>\";\n            sCtx.xCloser = <recovery-expr>();\n        } else {\n            <recovery-expr>(sCtx) = fopen(sCtx.zFile, \"rb\");\n        }\n        if (<recovery-expr>(sCtx) == 0) {\n            goto meta_command_exit;\n        }\n        if (eVerbose >= 2 || (eVerbose >= 1 && useOutputMode)) {\n            char zSep[2];\n            zSep[1] = 0;\n            zSep[0] = sCtx.cColSep;\n            fprintf(<recovery-expr>(p), \"Column separator \");\n            <recovery-expr>()(<recovery-expr>(p), zSep);\n            fprintf(<recovery-expr>(p), \", row separator \");\n            zSep[0] = sCtx.cRowSep;\n            <recovery-expr>()(<recovery-expr>(p), zSep);\n            fprintf(<recovery-expr>(p), \"\\n\");\n        }\n        sCtx.z = sqlite3_malloc64(120);\n        if (sCtx.z == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        while ((nSkip--) > 0)\n            {\n                while (xRead(&sCtx) && sCtx.cTerm == sCtx.cColSep)\n                    {\n                    }\n            }\n        if (zSchema != 0) {\n            zFullTabName = sqlite3_mprintf(\"\\\"%w\\\".\\\"%w\\\"\", zSchema, zTable);\n        } else {\n            zFullTabName = sqlite3_mprintf(\"\\\"%w\\\"\", zTable);\n        }\n        zSql = sqlite3_mprintf(\"SELECT * FROM %s\", zFullTabName);\n        if (zSql == 0 || zFullTabName == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        nByte = strlen30(zSql);\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        import_append_char(&sCtx, 0);\n        if (rc && sqlite3_strglob(\"no such table: *\", sqlite3_errmsg(p->db)) == 0) {\n            sqlite3 *dbCols = 0;\n            char *zRenames = 0;\n            char *zColDefs;\n            zCreate = sqlite3_mprintf(\"CREATE TABLE %s\", zFullTabName);\n            while (xRead(&sCtx))\n                {\n                    zAutoColumn(sCtx.z, &dbCols, 0);\n                    if (sCtx.cTerm != sCtx.cColSep)\n                        break;\n                }\n            zColDefs = zAutoColumn(0, &dbCols, &zRenames);\n            if (zRenames != 0) {\n                sqlite3_free(zRenames);\n            }\n            assert(dbCols == 0);\n            if (zColDefs == 0) {\n              import_fail:\n                sqlite3_free(zCreate);\n                sqlite3_free(zSql);\n                sqlite3_free(zFullTabName);\n                import_cleanup(&sCtx);\n                rc = 1;\n                goto meta_command_exit;\n            }\n            zCreate = sqlite3_mprintf(\"%z%z\\n\", zCreate, zColDefs);\n            if (eVerbose >= 1) {\n                fprintf(<recovery-expr>(p), \"%s\\n\", zCreate);\n            }\n            rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);\n            if (rc) {\n                goto import_fail;\n            }\n            sqlite3_free(zCreate);\n            zCreate = 0;\n            rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        }\n        if (rc) {\n            if (pStmt)\n                sqlite3_finalize(pStmt);\n            goto import_fail;\n        }\n        sqlite3_free(zSql);\n        nCol = sqlite3_column_count(pStmt);\n        sqlite3_finalize(pStmt);\n        pStmt = 0;\n        if (nCol == 0)\n            return 0;\n        zSql = sqlite3_malloc64(nByte * 2 + 20 + nCol * 2);\n        if (zSql == 0) {\n            import_cleanup(&sCtx);\n            shell_out_of_memory();\n        }\n        sqlite3_snprintf(nByte + 20, zSql, \"INSERT INTO %s VALUES(?\", zFullTabName);\n        j = strlen30(zSql);\n        for (i = 1; i < nCol; i++) {\n            zSql[j++] = ',';\n            zSql[j++] = '?';\n        }\n        zSql[j++] = ')';\n        zSql[j] = 0;\n        if (eVerbose >= 2) {\n            fprintf(<recovery-expr>(p), \"Insert using: %s\\n\", zSql);\n        }\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        if (rc) {\n            if (pStmt)\n                sqlite3_finalize(pStmt);\n            goto import_fail;\n        }\n        sqlite3_free(zSql);\n        sqlite3_free(zFullTabName);\n        needCommit = sqlite3_get_autocommit(p->db);\n        if (needCommit)\n            sqlite3_exec(p->db, \"BEGIN\", 0, 0, 0);\n        do {\n            int startLine = sCtx.nLine;\n            for (i = 0; i < nCol; i++) {\n                char *z = xRead(&sCtx);\n                if (z == 0 && i == 0)\n                    break;\n                if (p->mode == 10 && (z == 0 || z[0] == 0) && i == 0)\n                    break;\n                sqlite3_bind_text(pStmt, i + 1, z, -1, ((sqlite3_destructor_type)-1));\n                if (i < nCol - 1 && sCtx.cTerm != sCtx.cColSep) {\n                    i += 2;\n                    while (i <= nCol)\n                        {\n                            sqlite3_bind_null(pStmt, i);\n                            i++;\n                        }\n                }\n            }\n            if (sCtx.cTerm == sCtx.cColSep) {\n                do {\n                    xRead(&sCtx);\n                    i++;\n                } while (sCtx.cTerm == sCtx.cColSep);\n            }\n            if (i >= nCol) {\n                sqlite3_step(pStmt);\n                rc = sqlite3_reset(pStmt);\n                if (rc != 0) {\n                    sCtx.nErr++;\n                } else {\n                    sCtx.nRow++;\n                }\n            }\n        } while (<recovery-expr>());\n        import_cleanup(&sCtx);\n        sqlite3_finalize(pStmt);\n        if (needCommit)\n            sqlite3_exec(p->db, \"COMMIT\", 0, 0, 0);\n        if (eVerbose > 0) {\n            fprintf(<recovery-expr>(p), \"Added %d rows with %d errors using %d lines of input\\n\", sCtx.nRow, sCtx.nErr, sCtx.nLine - 1);\n        }\n    } else if (c == 'i' && <recovery-expr>()(azArg[0], \"imposter\", n) == 0) {\n        char *zSql;\n        char *zCollist = 0;\n        sqlite3_stmt *pStmt;\n        int tnum = 0;\n        int isWO = 0;\n        int lenPK = 0;\n        int i;\n        if (!(nArg == 3 || (nArg == 2 && sqlite3_stricmp(azArg[1], \"off\") == 0))) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        open_db(p, 0);\n        if (nArg == 2) {\n            sqlite3_test_control(25, p->db, \"main\", 0, 1);\n            goto meta_command_exit;\n        }\n        zSql = sqlite3_mprintf(\"SELECT rootpage, 0 FROM sqlite_schema WHERE name='%q' AND type='index'UNION ALL SELECT rootpage, 1 FROM sqlite_schema WHERE name='%q' AND type='table'   AND sql LIKE '%%without%%rowid%%'\", azArg[1], azArg[1]);\n        sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n        if (sqlite3_step(pStmt) == 100) {\n            tnum = sqlite3_column_int(pStmt, 0);\n            isWO = sqlite3_column_int(pStmt, 1);\n        }\n        sqlite3_finalize(pStmt);\n        zSql = sqlite3_mprintf(\"PRAGMA index_xinfo='%q'\", azArg[1]);\n        rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        sqlite3_free(zSql);\n        i = 0;\n        while (rc == 0 && sqlite3_step(pStmt) == 100)\n            {\n                char zLabel[20];\n                const char *zCol = (const char *)sqlite3_column_text(pStmt, 2);\n                i++;\n                if (zCol == 0) {\n                    if (sqlite3_column_int(pStmt, 1) == -1) {\n                        zCol = \"_ROWID_\";\n                    } else {\n                        sqlite3_snprintf(sizeof (zLabel), zLabel, \"expr%d\", i);\n                        zCol = zLabel;\n                    }\n                }\n                if (isWO && lenPK == 0 && sqlite3_column_int(pStmt, 5) == 0 && zCollist) {\n                    lenPK = (int)strlen(zCollist);\n                }\n                if (zCollist == 0) {\n                    zCollist = sqlite3_mprintf(\"\\\"%w\\\"\", zCol);\n                } else {\n                    zCollist = sqlite3_mprintf(\"%z,\\\"%w\\\"\", zCollist, zCol);\n                }\n            }\n        sqlite3_finalize(pStmt);\n        if (i == 0 || tnum == 0) {\n            rc = 1;\n            sqlite3_free(zCollist);\n            goto meta_command_exit;\n        }\n        if (lenPK == 0)\n            lenPK = 100000;\n        zSql = sqlite3_mprintf(\"CREATE TABLE \\\"%w\\\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID\", azArg[2], zCollist, lenPK, zCollist);\n        sqlite3_free(zCollist);\n        rc = sqlite3_test_control(25, p->db, \"main\", 1, tnum);\n        if (rc == 0) {\n            rc = sqlite3_exec(p->db, zSql, 0, 0, 0);\n            sqlite3_test_control(25, p->db, \"main\", 0, 0);\n            if (rc) {\n            } else {\n            }\n        } else {\n            rc = 1;\n        }\n        sqlite3_free(zSql);\n    } else if (c == 'l' && n >= 5 && <recovery-expr>()(azArg[0], \"limits\", n) == 0) {\n        static const struct {\n            const char *zLimitName;\n            int limitCode;\n        } aLimit[] = {{\"length\", 0}, {\"sql_length\", 1}, {\"column\", 2}, {\"expr_depth\", 3}, {\"compound_select\", 4}, {\"vdbe_op\", 5}, {\"function_arg\", 6}, {\"attached\", 7}, {\"like_pattern_length\", 8}, {\"variable_number\", 9}, {\"trigger_depth\", 10}, {\"worker_threads\", 11}};\n        int i, n2;\n        open_db(p, 0);\n        if (nArg == 1) {\n            for (i = 0; i < (int)(sizeof (aLimit) / sizeof (aLimit[0])); i++) {\n                printf(\"%20s %d\\n\", aLimit[i].zLimitName, sqlite3_limit(p->db, aLimit[i].limitCode, -1));\n            }\n        } else if (nArg > 3) {\n            rc = 1;\n            goto meta_command_exit;\n        } else {\n            int iLimit = -1;\n            n2 = strlen30(azArg[1]);\n            for (i = 0; i < (int)(sizeof (aLimit) / sizeof (aLimit[0])); i++) {\n                if (sqlite3_strnicmp(aLimit[i].zLimitName, azArg[1], n2) == 0) {\n                    if (iLimit < 0) {\n                        iLimit = i;\n                    } else {\n                        rc = 1;\n                        goto meta_command_exit;\n                    }\n                }\n            }\n            if (iLimit < 0) {\n                rc = 1;\n                goto meta_command_exit;\n            }\n            if (nArg == 3) {\n                sqlite3_limit(p->db, aLimit[iLimit].limitCode, (int)integerValue(azArg[2]));\n            }\n            printf(\"%20s %d\\n\", aLimit[iLimit].zLimitName, sqlite3_limit(p->db, aLimit[iLimit].limitCode, -1));\n        }\n    } else if (c == 'l' && n > 2 && <recovery-expr>()(azArg[0], \"lint\", n) == 0) {\n        open_db(p, 0);\n        lintDotCommand(p, azArg, nArg);\n    } else if (c == 'l' && <recovery-expr>()(azArg[0], \"load\", n) == 0) {\n        const char *zFile, *zProc;\n        char *zErrMsg = 0;\n        failIfSafeMode(p, \"cannot run .load in safe mode\");\n        if (nArg < 2) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        zFile = azArg[1];\n        zProc = nArg >= 3 ? azArg[2] : 0;\n        open_db(p, 0);\n        rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);\n        if (rc != 0) {\n            sqlite3_free(zErrMsg);\n            rc = 1;\n        }\n    } else if (c == 'l' && <recovery-expr>()(azArg[0], \"log\", n) == 0) {\n        failIfSafeMode(p, \"cannot run .log in safe mode\");\n        if (nArg != 2) {\n            rc = 1;\n        } else {\n            const char *zFile = azArg[1];\n            <recovery-expr>()(<recovery-expr>(p));\n            <recovery-expr>(p) = <recovery-expr>()(zFile, 0);\n        }\n    } else if (c == 'm' && <recovery-expr>()(azArg[0], \"mode\", n) == 0) {\n        const char *zMode = 0;\n        const char *zTabname = 0;\n        int i, n2;\n        ColModeOpts cmOpts = {60, 0, 0};\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (optionMatch(z, \"wrap\") && i + 1 < nArg) {\n                cmOpts.iWrap = integerValue(azArg[++i]);\n            } else if (optionMatch(z, \"ww\")) {\n                cmOpts.bWordWrap = 1;\n            } else if (optionMatch(z, \"wordwrap\") && i + 1 < nArg) {\n                cmOpts.bWordWrap = (u8)booleanValue(azArg[++i]);\n            } else if (optionMatch(z, \"quote\")) {\n                cmOpts.bQuote = 1;\n            } else if (optionMatch(z, \"noquote\")) {\n                cmOpts.bQuote = 0;\n            } else if (zMode == 0) {\n                zMode = z;\n                if (cli_strcmp(z, \"qbox\") == 0) {\n                    ColModeOpts cmo = {60, 1, 0};\n                    zMode = \"box\";\n                    cmOpts = cmo;\n                }\n            } else if (zTabname == 0) {\n                zTabname = z;\n            } else if (z[0] == '-') {\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (zMode == 0) {\n            if (p->mode == 1 || (p->mode >= 14 && p->mode <= 16)) {\n                fprintf(<recovery-expr>(p), \"current output mode: %s --wrap %d --wordwrap %s --%squote\\n\", modeDescr[p->mode], p->cmOpts.iWrap, p->cmOpts.bWordWrap ? \"on\" : \"off\", p->cmOpts.bQuote ? \"\" : \"no\");\n            } else {\n                fprintf(<recovery-expr>(p), \"current output mode: %s\\n\", modeDescr[p->mode]);\n            }\n            zMode = modeDescr[p->mode];\n        }\n        n2 = strlen30(zMode);\n        if (<recovery-expr>()(zMode, \"lines\", n2) == 0) {\n            p->mode = 0;\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (<recovery-expr>()(zMode, \"columns\", n2) == 0) {\n            p->mode = 1;\n            if ((p->shellFlgs & 128) == 0) {\n                p->showHeader = 1;\n            }\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n            p->cmOpts = cmOpts;\n        } else if (<recovery-expr>()(zMode, \"list\", n2) == 0) {\n            p->mode = 2;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"|\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (<recovery-expr>()(zMode, \"html\", n2) == 0) {\n            p->mode = 4;\n        } else if (<recovery-expr>()(zMode, \"tcl\", n2) == 0) {\n            p->mode = 7;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \" \");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (<recovery-expr>()(zMode, \"csv\", n2) == 0) {\n            p->mode = 8;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\r\\n\");\n        } else if (<recovery-expr>()(zMode, \"tabs\", n2) == 0) {\n            p->mode = 2;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"\\t\");\n        } else if (<recovery-expr>()(zMode, \"insert\", n2) == 0) {\n            p->mode = 5;\n            set_table_name(p, zTabname ? zTabname : \"table\");\n        } else if (<recovery-expr>()(zMode, \"quote\", n2) == 0) {\n            p->mode = 6;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\n\");\n        } else if (<recovery-expr>()(zMode, \"ascii\", n2) == 0) {\n            p->mode = 10;\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"\\037\");\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\036\");\n        } else if (<recovery-expr>()(zMode, \"markdown\", n2) == 0) {\n            p->mode = 14;\n            p->cmOpts = cmOpts;\n        } else if (<recovery-expr>()(zMode, \"table\", n2) == 0) {\n            p->mode = 15;\n            p->cmOpts = cmOpts;\n        } else if (<recovery-expr>()(zMode, \"box\", n2) == 0) {\n            p->mode = 16;\n            p->cmOpts = cmOpts;\n        } else if (<recovery-expr>()(zMode, \"count\", n2) == 0) {\n            p->mode = 17;\n        } else if (<recovery-expr>()(zMode, \"off\", n2) == 0) {\n            p->mode = 18;\n        } else if (<recovery-expr>()(zMode, \"json\", n2) == 0) {\n            p->mode = 13;\n        } else {\n            rc = 1;\n        }\n        p->cMode = p->mode;\n    } else if (c == 'n' && cli_strcmp(azArg[0], \"nonce\") == 0) {\n        if (nArg != 2) {\n            rc = 1;\n        } else if (p->zNonce == 0 || cli_strcmp(azArg[1], p->zNonce) != 0) {\n            exit(1);\n        } else {\n            p->bSafeMode = 0;\n            return 0;\n        }\n    } else if (c == 'n' && <recovery-expr>()(azArg[0], \"nullvalue\", n) == 0) {\n        if (nArg == 2) {\n            sqlite3_snprintf(sizeof (p->nullValue), p->nullValue, \"%.*s\", (int)(int)(sizeof (p->nullValue) / sizeof (p->nullValue[0])) - 1, azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 'o' && <recovery-expr>()(azArg[0], \"open\", n) == 0 && n >= 2) {\n        const char *zFN = 0;\n        char *zNewFilename = 0;\n        int iName = 1;\n        int newFlag = 0;\n        int openMode = 0;\n        for (iName = 1; iName < nArg; iName++) {\n            const char *z = azArg[iName];\n            if (optionMatch(z, \"new\")) {\n                newFlag = 1;\n            } else if (optionMatch(z, \"append\")) {\n                openMode = 2;\n            } else if (optionMatch(z, \"readonly\")) {\n                openMode = 4;\n            } else if (optionMatch(z, \"nofollow\")) {\n                p->openFlags |= 16777216;\n            } else if (optionMatch(z, \"deserialize\")) {\n                openMode = 5;\n            } else if (optionMatch(z, \"hexdb\")) {\n                openMode = 6;\n            } else if (optionMatch(z, \"maxsize\") && iName + 1 < nArg) {\n                p->szMax = integerValue(azArg[++iName]);\n            } else if (z[0] == '-') {\n                rc = 1;\n                goto meta_command_exit;\n            } else if (zFN) {\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                zFN = z;\n            }\n        }\n        ;\n        close_db(p->db);\n        p->db = 0;\n        p->pAuxDb->zDbFilename = 0;\n        sqlite3_free(p->pAuxDb->zFreeOnClose);\n        p->pAuxDb->zFreeOnClose = 0;\n        p->openMode = openMode;\n        p->openFlags = 0;\n        p->szMax = 0;\n        if (zFN || p->openMode == 6) {\n            if (newFlag && zFN && !p->bSafeMode)\n                shellDeleteFile(zFN);\n            if (p->bSafeMode && p->openMode != 6 && zFN && cli_strcmp(zFN, \":memory:\") != 0) {\n                failIfSafeMode(p, \"cannot open disk-based database files in safe mode\");\n            }\n            if (zFN) {\n                zNewFilename = sqlite3_mprintf(\"%s\", zFN);\n                shell_check_oom(zNewFilename);\n            } else {\n                zNewFilename = 0;\n            }\n            p->pAuxDb->zDbFilename = zNewFilename;\n            open_db(p, 1);\n            if (p->db == 0) {\n                sqlite3_free(zNewFilename);\n            } else {\n                p->pAuxDb->zFreeOnClose = zNewFilename;\n            }\n        }\n        if (p->db == 0) {\n            p->pAuxDb->zDbFilename = 0;\n            open_db(p, 0);\n        }\n    } else if ((c == 'o' && (<recovery-expr>()(azArg[0], \"output\", n) == 0 || <recovery-expr>()(azArg[0], \"once\", n) == 0)) || (c == 'e' && n == 5 && cli_strcmp(azArg[0], \"excel\") == 0)) {\n        char *zFile = 0;\n        int bTxtMode = 0;\n        int i;\n        int eMode = 0;\n        int bOnce = 0;\n        unsigned char zBOM[4];\n        zBOM[0] = 0;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        if (c == 'e') {\n            eMode = 'x';\n            bOnce = 2;\n        } else if (<recovery-expr>()(azArg[0], \"once\", n) == 0) {\n            bOnce = 1;\n        }\n        for (i = 1; i < nArg; i++) {\n            char *z = azArg[i];\n            if (z[0] == '-') {\n                if (z[1] == '-')\n                    z++;\n                if (cli_strcmp(z, \"-bom\") == 0) {\n                    zBOM[0] = 239;\n                    zBOM[1] = 187;\n                    zBOM[2] = 191;\n                    zBOM[3] = 0;\n                } else if (c != 'e' && cli_strcmp(z, \"-x\") == 0) {\n                    eMode = 'x';\n                } else if (c != 'e' && cli_strcmp(z, \"-e\") == 0) {\n                    eMode = 'e';\n                } else {\n                    fprintf(<recovery-expr>(p), \"ERROR: unknown option: \\\"%s\\\".  Usage:\\n\", azArg[i]);\n                    <recovery-expr>()(<recovery-expr>(p), azArg[0]);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else if (zFile == 0 && eMode != 'e' && eMode != 'x') {\n                zFile = sqlite3_mprintf(\"%s\", z);\n                if (zFile && zFile[0] == '|') {\n                    while (i + 1 < nArg)\n                        zFile = sqlite3_mprintf(\"%z %s\", zFile, azArg[++i]);\n                    break;\n                }\n            } else {\n                fprintf(<recovery-expr>(p), \"ERROR: extra parameter: \\\"%s\\\".  Usage:\\n\", azArg[i]);\n                <recovery-expr>()(<recovery-expr>(p), azArg[0]);\n                rc = 1;\n                sqlite3_free(zFile);\n                goto meta_command_exit;\n            }\n        }\n        if (zFile == 0) {\n            zFile = sqlite3_mprintf(\"stdout\");\n        }\n        if (bOnce) {\n            p->outCount = 2;\n        } else {\n            p->outCount = 0;\n        }\n        output_reset(p);\n        if (eMode == 'e' || eMode == 'x') {\n            p->doXdgOpen = 1;\n            outputModePush(p);\n            if (eMode == 'x') {\n                newTempFile(p, \"csv\");\n                ((p)->shellFlgs &= (~(64)));\n                p->mode = 8;\n                sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \",\");\n                sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"\\r\\n\");\n            } else {\n                newTempFile(p, \"txt\");\n                bTxtMode = 1;\n            }\n            sqlite3_free(zFile);\n            zFile = sqlite3_mprintf(\"%s\", p->zTempFile);\n        }\n        shell_check_oom(zFile);\n        if (zFile[0] == '|') {\n            <recovery-expr>(p) = <recovery-expr>()(zFile + 1, \"w\");\n            if (<recovery-expr>(p) == 0) {\n                rc = 1;\n            } else {\n                if (zBOM[0])\n                    fwrite(zBOM, 1, 3, <recovery-expr>(p));\n                sqlite3_snprintf(sizeof (<recovery-expr>(p)), <recovery-expr>(p), \"%s\", zFile);\n            }\n        } else {\n            <recovery-expr>(p) = <recovery-expr>()(zFile, bTxtMode);\n            if (<recovery-expr>(p) == 0) {\n                if (cli_strcmp(zFile, \"off\") != 0) {\n                }\n                rc = 1;\n            } else {\n                if (zBOM[0])\n                    fwrite(zBOM, 1, 3, <recovery-expr>(p));\n                sqlite3_snprintf(sizeof (<recovery-expr>(p)), <recovery-expr>(p), \"%s\", zFile);\n            }\n        }\n        sqlite3_free(zFile);\n    } else if (c == 'p' && n >= 3 && <recovery-expr>()(azArg[0], \"parameter\", n) == 0) {\n        open_db(p, 0);\n        if (nArg <= 1)\n            goto parameter_syntax_error;\n        if (nArg == 2 && cli_strcmp(azArg[1], \"clear\") == 0) {\n            sqlite3_exec(p->db, \"DROP TABLE IF EXISTS temp.sqlite_parameters;\", 0, 0, 0);\n        } else if (nArg == 2 && cli_strcmp(azArg[1], \"list\") == 0) {\n            sqlite3_stmt *pStmt = 0;\n            int rx;\n            int len = 0;\n            rx = sqlite3_prepare_v2(p->db, \"SELECT max(length(key)) FROM temp.sqlite_parameters;\", -1, &pStmt, 0);\n            if (rx == 0 && sqlite3_step(pStmt) == 100) {\n                len = sqlite3_column_int(pStmt, 0);\n                if (len > 40)\n                    len = 40;\n            }\n            sqlite3_finalize(pStmt);\n            pStmt = 0;\n            if (len) {\n                rx = sqlite3_prepare_v2(p->db, \"SELECT key, quote(value) FROM temp.sqlite_parameters;\", -1, &pStmt, 0);\n                while (rx == 0 && sqlite3_step(pStmt) == 100)\n                    {\n                        fprintf(<recovery-expr>(p), \"%-*s %s\\n\", len, sqlite3_column_text(pStmt, 0), sqlite3_column_text(pStmt, 1));\n                    }\n                sqlite3_finalize(pStmt);\n            }\n        } else if (nArg == 2 && cli_strcmp(azArg[1], \"init\") == 0) {\n            bind_table_init(p);\n        } else if (nArg == 4 && cli_strcmp(azArg[1], \"set\") == 0) {\n            int rx;\n            char *zSql;\n            sqlite3_stmt *pStmt;\n            const char *zKey = azArg[2];\n            const char *zValue = azArg[3];\n            bind_table_init(p);\n            zSql = sqlite3_mprintf(\"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%s);\", zKey, zValue);\n            shell_check_oom(zSql);\n            pStmt = 0;\n            rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n            sqlite3_free(zSql);\n            if (rx != 0) {\n                sqlite3_finalize(pStmt);\n                pStmt = 0;\n                zSql = sqlite3_mprintf(\"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%Q);\", zKey, zValue);\n                shell_check_oom(zSql);\n                rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n                sqlite3_free(zSql);\n                if (rx != 0) {\n                    fprintf(<recovery-expr>(p), \"Error: %s\\n\", sqlite3_errmsg(p->db));\n                    sqlite3_finalize(pStmt);\n                    pStmt = 0;\n                    rc = 1;\n                }\n            }\n            sqlite3_step(pStmt);\n            sqlite3_finalize(pStmt);\n        } else if (nArg == 3 && cli_strcmp(azArg[1], \"unset\") == 0) {\n            char *zSql = sqlite3_mprintf(\"DELETE FROM temp.sqlite_parameters WHERE key=%Q\", azArg[2]);\n            shell_check_oom(zSql);\n            sqlite3_exec(p->db, zSql, 0, 0, 0);\n            sqlite3_free(zSql);\n        } else\n          parameter_syntax_error:\n            <recovery-expr>()(<recovery-expr>(p), \"parameter\");\n    } else if (c == 'p' && n >= 3 && <recovery-expr>()(azArg[0], \"print\", n) == 0) {\n        int i;\n        for (i = 1; i < nArg; i++) {\n            if (i > 1)\n                fprintf(<recovery-expr>(p), \" \");\n            fprintf(<recovery-expr>(p), \"%s\", azArg[i]);\n        }\n        fprintf(<recovery-expr>(p), \"\\n\");\n    } else if (c == 'p' && n >= 3 && <recovery-expr>()(azArg[0], \"progress\", n) == 0) {\n        int i;\n        int nn = 0;\n        p->flgProgress = 0;\n        p->mxProgress = 0;\n        p->nProgress = 0;\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-') {\n                z++;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"quiet\") == 0 || cli_strcmp(z, \"q\") == 0) {\n                    p->flgProgress |= 1;\n                    continue;\n                }\n                if (cli_strcmp(z, \"reset\") == 0) {\n                    p->flgProgress |= 2;\n                    continue;\n                }\n                if (cli_strcmp(z, \"once\") == 0) {\n                    p->flgProgress |= 4;\n                    continue;\n                }\n                if (cli_strcmp(z, \"limit\") == 0) {\n                    if (i + 1 >= nArg) {\n                        rc = 1;\n                        goto meta_command_exit;\n                    } else {\n                        p->mxProgress = (int)integerValue(azArg[++i]);\n                    }\n                    continue;\n                }\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                nn = (int)integerValue(z);\n            }\n        }\n        open_db(p, 0);\n        sqlite3_progress_handler(p->db, nn, progress_handler, p);\n    } else if (c == 'p' && <recovery-expr>()(azArg[0], \"prompt\", n) == 0) {\n        if (nArg >= 2) {\n            strncpy(mainPrompt, azArg[1], (int)(int)(sizeof (mainPrompt) / sizeof (mainPrompt[0])) - 1);\n        }\n        if (nArg >= 3) {\n            strncpy(continuePrompt, azArg[2], (int)(int)(sizeof (continuePrompt) / sizeof (continuePrompt[0])) - 1);\n        }\n    } else if (c == 'q' && <recovery-expr>()(azArg[0], \"quit\", n) == 0) {\n        rc = 2;\n    } else if (c == 'r' && n >= 3 && <recovery-expr>()(azArg[0], \"read\", n) == 0) {\n        int savedLineno = p->lineno;\n        failIfSafeMode(p, \"cannot run .read in safe mode\");\n        if (nArg != 2) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        if (azArg[1][0] == '|') {\n            <recovery-expr>(p) = <recovery-expr>()(azArg[1] + 1, \"r\");\n            if (<recovery-expr>(p) == 0) {\n                rc = 1;\n            } else {\n                rc = process_input(p);\n                <recovery-expr>()(<recovery-expr>(p));\n            }\n        } else if ((<recovery-expr>(p) = <recovery-expr>()(azArg[1])) == 0) {\n            rc = 1;\n        } else {\n            rc = process_input(p);\n            fclose(<recovery-expr>(p));\n        }\n        p->lineno = savedLineno;\n    } else if (c == 'r' && n >= 3 && <recovery-expr>()(azArg[0], \"restore\", n) == 0) {\n        const char *zSrcFile;\n        const char *zDb;\n        sqlite3 *pSrc;\n        sqlite3_backup *pBackup;\n        int nTimeout = 0;\n        failIfSafeMode(p, \"cannot run .restore in safe mode\");\n        if (nArg == 2) {\n            zSrcFile = azArg[1];\n            zDb = \"main\";\n        } else if (nArg == 3) {\n            zSrcFile = azArg[2];\n            zDb = azArg[1];\n        } else {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        rc = sqlite3_open(zSrcFile, &pSrc);\n        if (rc != 0) {\n            close_db(pSrc);\n            return 1;\n        }\n        open_db(p, 0);\n        pBackup = sqlite3_backup_init(p->db, zDb, pSrc, \"main\");\n        if (pBackup == 0) {\n            close_db(pSrc);\n            return 1;\n        }\n        while ((rc = sqlite3_backup_step(pBackup, 100)) == 0 || rc == 5)\n            {\n                if (rc == 5) {\n                    if (nTimeout++ >= 3)\n                        break;\n                    sqlite3_sleep(100);\n                }\n            }\n        sqlite3_backup_finish(pBackup);\n        if (rc == 101) {\n            rc = 0;\n        } else if (rc == 5 || rc == 6) {\n            rc = 1;\n        } else {\n            rc = 1;\n        }\n        close_db(pSrc);\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"scanstats\", n) == 0) {\n        if (nArg == 2) {\n            p->scanstatsOn = (u8)booleanValue(azArg[1]);\n        } else {\n            rc = 1;\n        }\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"schema\", n) == 0) {\n        ShellText sSelect;\n        ShellState data;\n        char *zErrMsg = 0;\n        const char *zDiv = \"(\";\n        const char *zName = 0;\n        int iSchema = 0;\n        int bDebug = 0;\n        int bNoSystemTabs = 0;\n        int ii;\n        open_db(p, 0);\n        memcpy(&data, p, sizeof (data));\n        data.showHeader = 0;\n        data.cMode = data.mode = 3;\n        initText(&sSelect);\n        for (ii = 1; ii < nArg; ii++) {\n            if (optionMatch(azArg[ii], \"indent\")) {\n                data.cMode = data.mode = 11;\n            } else if (optionMatch(azArg[ii], \"debug\")) {\n                bDebug = 1;\n            } else if (optionMatch(azArg[ii], \"nosys\")) {\n                bNoSystemTabs = 1;\n            } else if (azArg[ii][0] == '-') {\n                rc = 1;\n                goto meta_command_exit;\n            } else if (zName == 0) {\n                zName = azArg[ii];\n            } else {\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (zName != 0) {\n            int isSchema = sqlite3_strlike(zName, \"sqlite_master\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_schema\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_temp_master\", '\\\\') == 0 || sqlite3_strlike(zName, \"sqlite_temp_schema\", '\\\\') == 0;\n            if (isSchema) {\n                char *new_argv[2], *new_colv[2];\n                new_argv[0] = sqlite3_mprintf(\"CREATE TABLE %s (\\n  type text,\\n  name text,\\n  tbl_name text,\\n  rootpage integer,\\n  sql text\\n)\", zName);\n                shell_check_oom(new_argv[0]);\n                new_argv[1] = 0;\n                new_colv[0] = \"sql\";\n                new_colv[1] = 0;\n                callback(&data, 1, new_argv, new_colv);\n                sqlite3_free(new_argv[0]);\n            }\n        }\n        if (zDiv) {\n            sqlite3_stmt *pStmt = 0;\n            rc = sqlite3_prepare_v2(p->db, \"SELECT name FROM pragma_database_list\", -1, &pStmt, 0);\n            if (rc) {\n                sqlite3_finalize(pStmt);\n                rc = 1;\n                goto meta_command_exit;\n            }\n            appendText(&sSelect, \"SELECT sql FROM\", 0);\n            iSchema = 0;\n            while (sqlite3_step(pStmt) == 100)\n                {\n                    const char *zDb = (const char *)sqlite3_column_text(pStmt, 0);\n                    char zScNum[30];\n                    sqlite3_snprintf(sizeof (zScNum), zScNum, \"%d\", ++iSchema);\n                    appendText(&sSelect, zDiv, 0);\n                    zDiv = \" UNION ALL \";\n                    appendText(&sSelect, \"SELECT shell_add_schema(sql,\", 0);\n                    if (sqlite3_stricmp(zDb, \"main\") != 0) {\n                        appendText(&sSelect, zDb, '\\'');\n                    } else {\n                        appendText(&sSelect, \"NULL\", 0);\n                    }\n                    appendText(&sSelect, \",name) AS sql, type, tbl_name, name, rowid,\", 0);\n                    appendText(&sSelect, zScNum, 0);\n                    appendText(&sSelect, \" AS snum, \", 0);\n                    appendText(&sSelect, zDb, '\\'');\n                    appendText(&sSelect, \" AS sname FROM \", 0);\n                    appendText(&sSelect, zDb, quoteChar(zDb));\n                    appendText(&sSelect, \".sqlite_schema\", 0);\n                }\n            sqlite3_finalize(pStmt);\n            if (zName) {\n                appendText(&sSelect, \" UNION ALL SELECT shell_module_schema(name), 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list\", 0);\n            }\n            appendText(&sSelect, \") WHERE \", 0);\n            if (zName) {\n                char *zQarg = sqlite3_mprintf(\"%Q\", zName);\n                int bGlob;\n                shell_check_oom(zQarg);\n                bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 || strchr(zName, '[') != 0;\n                if (strchr(zName, '.')) {\n                    appendText(&sSelect, \"lower(printf('%s.%s',sname,tbl_name))\", 0);\n                } else {\n                    appendText(&sSelect, \"lower(tbl_name)\", 0);\n                }\n                appendText(&sSelect, bGlob ? \" GLOB \" : \" LIKE \", 0);\n                appendText(&sSelect, zQarg, 0);\n                if (!bGlob) {\n                    appendText(&sSelect, \" ESCAPE '\\\\' \", 0);\n                }\n                appendText(&sSelect, \" AND \", 0);\n                sqlite3_free(zQarg);\n            }\n            if (bNoSystemTabs) {\n                appendText(&sSelect, \"name NOT LIKE 'sqlite_%%' AND \", 0);\n            }\n            appendText(&sSelect, \"sql IS NOT NULL ORDER BY snum, rowid\", 0);\n            if (bDebug) {\n                fprintf(<recovery-expr>(p), \"SQL: %s;\\n\", sSelect.z);\n            } else {\n                rc = sqlite3_exec(p->db, sSelect.z, callback, &data, &zErrMsg);\n            }\n            freeText(&sSelect);\n        }\n        if (zErrMsg) {\n            sqlite3_free(zErrMsg);\n            rc = 1;\n        } else if (rc != 0) {\n            rc = 1;\n        } else {\n            rc = 0;\n        }\n    } else if ((c == 's' && n == 11 && <recovery-expr>()(azArg[0], \"selecttrace\", n) == 0) || (c == 't' && n == 9 && <recovery-expr>()(azArg[0], \"treetrace\", n) == 0)) {\n        unsigned int x = nArg >= 2 ? (unsigned int)integerValue(azArg[1]) : 4294967295U;\n        sqlite3_test_control(31, 1, &x);\n    } else if (c == 's' && n >= 4 && <recovery-expr>()(azArg[0], \"selftest\", n) == 0) {\n        int bIsInit = 0;\n        int bVerbose = 0;\n        int bSelftestExists;\n        int i, k;\n        int nTest = 0;\n        int nErr = 0;\n        ShellText str;\n        sqlite3_stmt *pStmt = 0;\n        open_db(p, 0);\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-' && z[1] == '-')\n                z++;\n            if (cli_strcmp(z, \"-init\") == 0) {\n                bIsInit = 1;\n            } else if (cli_strcmp(z, \"-v\") == 0) {\n                bVerbose++;\n            } else {\n                rc = 1;\n                goto meta_command_exit;\n            }\n        }\n        if (sqlite3_table_column_metadata(p->db, \"main\", \"selftest\", 0, 0, 0, 0, 0, 0) != 0) {\n            bSelftestExists = 0;\n        } else {\n            bSelftestExists = 1;\n        }\n        if (bIsInit) {\n            createSelftestTable(p);\n            bSelftestExists = 1;\n        }\n        initText(&str);\n        appendText(&str, \"x\", 0);\n        for (k = bSelftestExists; k >= 0; k--) {\n            if (k == 1) {\n                rc = sqlite3_prepare_v2(p->db, \"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno\", -1, &pStmt, 0);\n            } else {\n                rc = sqlite3_prepare_v2(p->db, \"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),      (1,'run','PRAGMA integrity_check','ok')\", -1, &pStmt, 0);\n            }\n            if (rc) {\n                rc = 1;\n                sqlite3_finalize(pStmt);\n                goto meta_command_exit;\n            }\n            for (i = 1; sqlite3_step(pStmt) == 100; i++) {\n                int tno = sqlite3_column_int(pStmt, 0);\n                const char *zOp = (const char *)sqlite3_column_text(pStmt, 1);\n                const char *zSql = (const char *)sqlite3_column_text(pStmt, 2);\n                const char *zAns = (const char *)sqlite3_column_text(pStmt, 3);\n                if (zOp == 0)\n                    continue;\n                if (zSql == 0)\n                    continue;\n                if (zAns == 0)\n                    continue;\n                k = 0;\n                if (bVerbose > 0) {\n                    printf(\"%d: %s %s\\n\", tno, zOp, zSql);\n                }\n                if (cli_strcmp(zOp, \"memo\") == 0) {\n                    fprintf(<recovery-expr>(p), \"%s\\n\", zSql);\n                } else if (cli_strcmp(zOp, \"run\") == 0) {\n                    char *zErrMsg = 0;\n                    str.n = 0;\n                    str.z[0] = 0;\n                    rc = sqlite3_exec(p->db, zSql, captureOutputCallback, &str, &zErrMsg);\n                    nTest++;\n                    if (bVerbose) {\n                        fprintf(<recovery-expr>(p), \"Result: %s\\n\", str.z);\n                    }\n                    if (rc || zErrMsg) {\n                        nErr++;\n                        rc = 1;\n                        fprintf(<recovery-expr>(p), \"%d: error-code-%d: %s\\n\", tno, rc, zErrMsg);\n                        sqlite3_free(zErrMsg);\n                    } else if (cli_strcmp(zAns, str.z) != 0) {\n                        nErr++;\n                        rc = 1;\n                        fprintf(<recovery-expr>(p), \"%d: Expected: [%s]\\n\", tno, zAns);\n                        fprintf(<recovery-expr>(p), \"%d:      Got: [%s]\\n\", tno, str.z);\n                    }\n                } else {\n                    rc = 1;\n                    break;\n                }\n            }\n            sqlite3_finalize(pStmt);\n        }\n        freeText(&str);\n        fprintf(<recovery-expr>(p), \"%d errors out of %d tests\\n\", nErr, nTest);\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"separator\", n) == 0) {\n        if (nArg < 2 || nArg > 3) {\n            rc = 1;\n        }\n        if (nArg >= 2) {\n            sqlite3_snprintf(sizeof (p->colSeparator), p->colSeparator, \"%.*s\", (int)(int)(sizeof (p->colSeparator) / sizeof (p->colSeparator[0])) - 1, azArg[1]);\n        }\n        if (nArg >= 3) {\n            sqlite3_snprintf(sizeof (p->rowSeparator), p->rowSeparator, \"%.*s\", (int)(int)(sizeof (p->rowSeparator) / sizeof (p->rowSeparator[0])) - 1, azArg[2]);\n        }\n    } else if (c == 's' && n >= 4 && <recovery-expr>()(azArg[0], \"sha3sum\", n) == 0) {\n        const char *zLike = 0;\n        int i;\n        int bSchema = 0;\n        int bSeparate = 0;\n        int iSize = 224;\n        int bDebug = 0;\n        sqlite3_stmt *pStmt;\n        char *zSql;\n        char *zSep;\n        ShellText sSql;\n        ShellText sQuery;\n        open_db(p, 0);\n        for (i = 1; i < nArg; i++) {\n            const char *z = azArg[i];\n            if (z[0] == '-') {\n                z++;\n                if (z[0] == '-')\n                    z++;\n                if (cli_strcmp(z, \"schema\") == 0) {\n                    bSchema = 1;\n                } else if (cli_strcmp(z, \"sha3-224\") == 0 || cli_strcmp(z, \"sha3-256\") == 0 || cli_strcmp(z, \"sha3-384\") == 0 || cli_strcmp(z, \"sha3-512\") == 0) {\n                    iSize = atoi(&z[5]);\n                } else if (cli_strcmp(z, \"debug\") == 0) {\n                    bDebug = 1;\n                } else {\n                    <recovery-expr>()(<recovery-expr>(p), azArg[0]);\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else if (zLike) {\n                rc = 1;\n                goto meta_command_exit;\n            } else {\n                zLike = z;\n                bSeparate = 1;\n                if (sqlite3_strlike(\"sqlite\\\\_%\", zLike, '\\\\') == 0)\n                    bSchema = 1;\n            }\n        }\n        if (bSchema) {\n            zSql = \"SELECT lower(name) FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 UNION ALL SELECT 'sqlite_schema' ORDER BY 1 collate nocase\";\n        } else {\n            zSql = \"SELECT lower(name) FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 AND name NOT LIKE 'sqlite_%' ORDER BY 1 collate nocase\";\n        }\n        sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\n        initText(&sQuery);\n        initText(&sSql);\n        appendText(&sSql, \"WITH [sha3sum$query](a,b) AS(\", 0);\n        zSep = \"VALUES(\";\n        while (100 == sqlite3_step(pStmt))\n            {\n                const char *zTab = (const char *)sqlite3_column_text(pStmt, 0);\n                if (zTab == 0)\n                    continue;\n                if (zLike && sqlite3_strlike(zLike, zTab, 0) != 0)\n                    continue;\n                if (<recovery-expr>()(zTab, \"sqlite_\", 7) != 0) {\n                    appendText(&sQuery, \"SELECT * FROM \", 0);\n                    appendText(&sQuery, zTab, '\"');\n                    appendText(&sQuery, \" NOT INDEXED;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_schema\") == 0) {\n                    appendText(&sQuery, \"SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY name;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_sequence\") == 0) {\n                    appendText(&sQuery, \"SELECT name,seq FROM sqlite_sequence ORDER BY name;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_stat1\") == 0) {\n                    appendText(&sQuery, \"SELECT tbl,idx,stat FROM sqlite_stat1 ORDER BY tbl,idx;\", 0);\n                } else if (cli_strcmp(zTab, \"sqlite_stat4\") == 0) {\n                    appendText(&sQuery, \"SELECT * FROM \", 0);\n                    appendText(&sQuery, zTab, 0);\n                    appendText(&sQuery, \" ORDER BY tbl, idx, rowid;\\n\", 0);\n                }\n                appendText(&sSql, zSep, 0);\n                appendText(&sSql, sQuery.z, '\\'');\n                sQuery.n = 0;\n                appendText(&sSql, \",\", 0);\n                appendText(&sSql, zTab, '\\'');\n                zSep = \"),(\";\n            }\n        sqlite3_finalize(pStmt);\n        if (bSeparate) {\n            zSql = sqlite3_mprintf(\"%s)) SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label   FROM [sha3sum$query]\", sSql.z, iSize);\n        } else {\n            zSql = sqlite3_mprintf(\"%s)) SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash   FROM [sha3sum$query]\", sSql.z, iSize);\n        }\n        shell_check_oom(zSql);\n        freeText(&sQuery);\n        freeText(&sSql);\n        if (bDebug) {\n            fprintf(<recovery-expr>(p), \"%s\\n\", zSql);\n        } else {\n            shell_exec(p, zSql, 0);\n        }\n        sqlite3_free(zSql);\n    } else if (c == 's' && (<recovery-expr>()(azArg[0], \"shell\", n) == 0 || <recovery-expr>()(azArg[0], \"system\", n) == 0)) {\n        char *zCmd;\n        int i, x;\n        failIfSafeMode(p, \"cannot run .%s in safe mode\", azArg[0]);\n        if (nArg < 2) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        zCmd = sqlite3_mprintf(strchr(azArg[1], ' ') == 0 ? \"%s\" : \"\\\"%s\\\"\", azArg[1]);\n        for (i = 2; i < nArg && zCmd != 0; i++) {\n            zCmd = sqlite3_mprintf(strchr(azArg[i], ' ') == 0 ? \"%z %s\" : \"%z \\\"%s\\\"\", zCmd, azArg[i]);\n        }\n        x = zCmd != 0 ? system(zCmd) : 1;\n        sqlite3_free(zCmd);\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"show\", n) == 0) {\n        static const char *azBool[] = {\"off\", \"on\", \"trigger\", \"full\"};\n        const char *zOut;\n        int i;\n        if (nArg != 1) {\n            rc = 1;\n            goto meta_command_exit;\n        }\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"echo\", azBool[(((p)->shellFlgs & (64)) != 0)]);\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"eqp\", azBool[p->autoEQP & 3]);\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"explain\", p->mode == 9 ? \"on\" : p->autoExplain ? \"auto\" : \"off\");\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"headers\", azBool[p->showHeader != 0]);\n        if (p->mode == 1 || (p->mode >= 14 && p->mode <= 16)) {\n            fprintf(<recovery-expr>(p), \"%12.12s: %s --wrap %d --wordwrap %s --%squote\\n\", \"mode\", modeDescr[p->mode], p->cmOpts.iWrap, p->cmOpts.bWordWrap ? \"on\" : \"off\", p->cmOpts.bQuote ? \"\" : \"no\");\n        } else {\n            fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"mode\", modeDescr[p->mode]);\n        }\n        fprintf(<recovery-expr>(p), \"%12.12s: \", \"nullvalue\");\n        <recovery-expr>()(<recovery-expr>(p), p->nullValue);\n        fprintf(<recovery-expr>(p), \"\\n\");\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"output\", strlen30(<recovery-expr>(p)) ? <recovery-expr>(p) : \"stdout\");\n        fprintf(<recovery-expr>(p), \"%12.12s: \", \"colseparator\");\n        <recovery-expr>()(<recovery-expr>(p), p->colSeparator);\n        fprintf(<recovery-expr>(p), \"\\n\");\n        fprintf(<recovery-expr>(p), \"%12.12s: \", \"rowseparator\");\n        <recovery-expr>()(<recovery-expr>(p), p->rowSeparator);\n        fprintf(<recovery-expr>(p), \"\\n\");\n        switch (p->statsOn) {\n          case 0:\n            zOut = \"off\";\n            break;\n          default:\n            zOut = \"on\";\n            break;\n          case 2:\n            zOut = \"stmt\";\n            break;\n          case 3:\n            zOut = \"vmstep\";\n            break;\n        }\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"stats\", zOut);\n        fprintf(<recovery-expr>(p), \"%12.12s: \", \"width\");\n        for (i = 0; i < p->nWidth; i++) {\n            fprintf(<recovery-expr>(p), \"%d \", p->colWidth[i]);\n        }\n        fprintf(<recovery-expr>(p), \"\\n\");\n        fprintf(<recovery-expr>(p), \"%12.12s: %s\\n\", \"filename\", p->pAuxDb->zDbFilename ? p->pAuxDb->zDbFilename : \"\");\n    } else if (c == 's' && <recovery-expr>()(azArg[0], \"stats\", n) == 0) {\n        if (nArg == 2) {\n            if (cli_strcmp(azArg[1], \"stmt\") == 0) {\n                p->statsOn = 2;\n            } else if (cli_strcmp(azArg[1], \"vmstep\") == 0) {\n                p->statsOn = 3;\n            } else {\n                p->statsOn = (u8)booleanValue(azArg[1]);\n            }\n        } else if (nArg == 1) {\n            display_stats(p->db, p, 0);\n        } else {\n            rc = 1;\n        }\n    } else if ((c == 't' && n > 1 && <recovery-expr>()(azArg[0], \"tables\", n) == 0) || (c == 'i' && (<recovery-expr>()(azArg[0], \"indices\", n) == 0 || <recovery-expr>()(azArg[0], \"indexes\", n) == 0))) {\n        sqlite3_stmt *pStmt;\n        char **azResult;\n        int nRow, nAlloc;\n        int ii;\n        ShellText s;\n        initText(&s);\n        open_db(p, 0);\n        rc = sqlite3_prepare_v2(p->db, \"PRAGMA database_list\", -1, &pStmt, 0);\n        if (rc) {\n            sqlite3_finalize(pStmt);\n            return shellDatabaseError(p->db);\n        }\n        if (nArg > 2 && c == 'i') {\n            rc = 1;\n            sqlite3_finalize(pStmt);\n            goto meta_command_exit;\n        }\n        for (ii = 0; sqlite3_step(pStmt) == 100; ii++) {\n            const char *zDbName = (const char *)sqlite3_column_text(pStmt, 1);\n            if (zDbName == 0)\n                continue;\n            if (s.z && s.z[0])\n                appendText(&s, \" UNION ALL \", 0);\n            if (sqlite3_stricmp(zDbName, \"main\") == 0) {\n                appendText(&s, \"SELECT name FROM \", 0);\n            } else {\n                appendText(&s, \"SELECT \", 0);\n                appendText(&s, zDbName, '\\'');\n                appendText(&s, \"||'.'||name FROM \", 0);\n            }\n            appendText(&s, zDbName, '\"');\n            appendText(&s, \".sqlite_schema \", 0);\n            if (c == 't') {\n                appendText(&s, \" WHERE type IN ('table','view')   AND name NOT LIKE 'sqlite_%'   AND name LIKE ?1\", 0);\n            } else {\n                appendText(&s, \" WHERE type='index'   AND tbl_name LIKE ?1\", 0);\n            }\n        }\n        rc = sqlite3_finalize(pStmt);\n        if (rc == 0) {\n            appendText(&s, \" ORDER BY 1\", 0);\n            rc = sqlite3_prepare_v2(p->db, s.z, -1, &pStmt, 0);\n        }\n        freeText(&s);\n        if (rc)\n            return shellDatabaseError(p->db);\n        nRow = nAlloc = 0;\n        azResult = 0;\n        if (nArg > 1) {\n            sqlite3_bind_text(pStmt, 1, azArg[1], -1, ((sqlite3_destructor_type)-1));\n        } else {\n            sqlite3_bind_text(pStmt, 1, \"%\", -1, ((sqlite3_destructor_type)0));\n        }\n        while (sqlite3_step(pStmt) == 100)\n            {\n                if (nRow >= nAlloc) {\n                    char **azNew;\n                    int n2 = nAlloc * 2 + 10;\n                    azNew = sqlite3_realloc64(azResult, sizeof (azResult[0]) * n2);\n                    shell_check_oom(azNew);\n                    nAlloc = n2;\n                    azResult = azNew;\n                }\n                azResult[nRow] = sqlite3_mprintf(\"%s\", sqlite3_column_text(pStmt, 0));\n                shell_check_oom(azResult[nRow]);\n                nRow++;\n            }\n        if (sqlite3_finalize(pStmt) != 0) {\n            rc = shellDatabaseError(p->db);\n        }\n        if (rc == 0 && nRow > 0) {\n            int len, maxlen = 0;\n            int i, j;\n            int nPrintCol, nPrintRow;\n            for (i = 0; i < nRow; i++) {\n                len = strlen30(azResult[i]);\n                if (len > maxlen)\n                    maxlen = len;\n            }\n            nPrintCol = 80 / (maxlen + 2);\n            if (nPrintCol < 1)\n                nPrintCol = 1;\n            nPrintRow = (nRow + nPrintCol - 1) / nPrintCol;\n            for (i = 0; i < nPrintRow; i++) {\n                for (j = i; j < nRow; j += nPrintRow) {\n                    char *zSp = j < nPrintRow ? \"\" : \"  \";\n                    fprintf(<recovery-expr>(p), \"%s%-*s\", zSp, maxlen, azResult[j] ? azResult[j] : \"\");\n                }\n                fprintf(<recovery-expr>(p), \"\\n\");\n            }\n        }\n        for (ii = 0; ii < nRow; ii++)\n            sqlite3_free(azResult[ii]);\n        sqlite3_free(azResult);\n    } else if (c == 't' && cli_strcmp(azArg[0], \"testcase\") == 0) {\n        output_reset(p);\n        <recovery-expr>(p) = <recovery-expr>()(\"testcase-out.txt\", 0);\n        if (<recovery-expr>(p) == 0) {\n        }\n        if (nArg >= 2) {\n            sqlite3_snprintf(sizeof (p->zTestcase), p->zTestcase, \"%s\", azArg[1]);\n        } else {\n            sqlite3_snprintf(sizeof (p->zTestcase), p->zTestcase, \"?\");\n        }\n    } else if (c == 't' && n >= 8 && <recovery-expr>()(azArg[0], \"testctrl\", n) == 0) {\n        static const struct {\n            const char *zCtrlName;\n            int ctrlCode;\n            int unSafe;\n            const char *zUsage;\n        } aCtrl[] = {{\"always\", 13, 1, \"BOOLEAN\"}, {\"assert\", 12, 1, \"BOOLEAN\"}, {\"byteorder\", 22, 0, \"\"}, {\"extra_schema_checks\", 29, 0, \"BOOLEAN\"}, {\"imposter\", 25, 1, \"SCHEMA ON/OFF ROOTPAGE\"}, {\"internal_functions\", 17, 0, \"\"}, {\"localtime_fault\", 18, 0, \"BOOLEAN\"}, {\"never_corrupt\", 20, 1, \"BOOLEAN\"}, {\"optimizations\", 15, 0, \"DISABLE-MASK\"}, {\"pending_byte\", 11, 0, \"OFFSET  \"}, {\"prng_restore\", 6, 0, \"\"}, {\"prng_save\", 5, 0, \"\"}, {\"prng_seed\", 28, 0, \"SEED ?db?\"}, {\"seek_count\", 30, 0, \"\"}, {\"sorter_mmap\", 24, 0, \"NMAX\"}, {\"tune\", 32, 1, \"ID VALUE\"}};\n        int testctrl = -1;\n        int iCtrl = -1;\n        int rc2 = 0;\n        int isOk = 0;\n        int i, n2;\n        const char *zCmd = 0;\n        open_db(p, 0);\n        zCmd = nArg >= 2 ? azArg[1] : \"help\";\n        if (zCmd[0] == '-' && zCmd[1]) {\n            zCmd++;\n            if (zCmd[0] == '-' && zCmd[1])\n                zCmd++;\n        }\n        if (cli_strcmp(zCmd, \"help\") == 0) {\n            fprintf(<recovery-expr>(p), \"Available test-controls:\\n\");\n            for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n                fprintf(<recovery-expr>(p), \"  .testctrl %s %s\\n\", aCtrl[i].zCtrlName, aCtrl[i].zUsage);\n            }\n            rc = 1;\n            goto meta_command_exit;\n        }\n        n2 = strlen30(zCmd);\n        for (i = 0; i < (int)(sizeof (aCtrl) / sizeof (aCtrl[0])); i++) {\n            if (<recovery-expr>()(zCmd, aCtrl[i].zCtrlName, n2) == 0) {\n                if (testctrl < 0) {\n                    testctrl = aCtrl[i].ctrlCode;\n                    iCtrl = i;\n                } else {\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            }\n        }\n        if (testctrl < 0) {\n        } else if (aCtrl[iCtrl].unSafe && p->bSafeMode) {\n            exit(1);\n        } else {\n            switch (testctrl) {\n              case 15:\n                if (nArg == 3) {\n                    unsigned int opt = (unsigned int)strtol(azArg[2], 0, 0);\n                    rc2 = sqlite3_test_control(testctrl, p->db, opt);\n                    isOk = 3;\n                }\n                break;\n              case 5:\n              case 6:\n              case 22:\n                if (nArg == 2) {\n                    rc2 = sqlite3_test_control(testctrl);\n                    isOk = testctrl == 22 ? 1 : 3;\n                }\n                break;\n              case 11:\n                if (nArg == 3) {\n                    unsigned int opt = (unsigned int)integerValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 3;\n                }\n                break;\n              case 28:\n                if (nArg == 3 || nArg == 4) {\n                    int ii = (int)integerValue(azArg[2]);\n                    sqlite3 *db;\n                    if (ii == 0 && cli_strcmp(azArg[2], \"random\") == 0) {\n                        sqlite3_randomness(sizeof (ii), &ii);\n                        printf(\"-- random seed: %d\\n\", ii);\n                    }\n                    if (nArg == 3) {\n                        db = 0;\n                    } else {\n                        db = p->db;\n                        sqlite3_table_column_metadata(db, 0, \"x\", 0, 0, 0, 0, 0, 0);\n                    }\n                    rc2 = sqlite3_test_control(testctrl, ii, db);\n                    isOk = 3;\n                }\n                break;\n              case 12:\n              case 13:\n                if (nArg == 3) {\n                    int opt = booleanValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 1;\n                }\n                break;\n              case 18:\n              case 20:\n                if (nArg == 3) {\n                    int opt = booleanValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, opt);\n                    isOk = 3;\n                }\n                break;\n              case 17:\n                rc2 = sqlite3_test_control(testctrl, p->db);\n                isOk = 3;\n                break;\n              case 25:\n                if (nArg == 5) {\n                    rc2 = sqlite3_test_control(testctrl, p->db, azArg[2], integerValue(azArg[3]), integerValue(azArg[4]));\n                    isOk = 3;\n                }\n                break;\n              case 30:\n                {\n                    u64 x = 0;\n                    rc2 = sqlite3_test_control(testctrl, p->db, &x);\n                    fprintf(<recovery-expr>(p), \"%llu\\n\", x);\n                    isOk = 3;\n                    break;\n                }\n              case 24:\n                if (nArg == 3) {\n                    int opt = (unsigned int)integerValue(azArg[2]);\n                    rc2 = sqlite3_test_control(testctrl, p->db, opt);\n                    isOk = 3;\n                }\n                break;\n            }\n        }\n        if (isOk == 0 && iCtrl >= 0) {\n            fprintf(<recovery-expr>(p), \"Usage: .testctrl %s %s\\n\", zCmd, aCtrl[iCtrl].zUsage);\n            rc = 1;\n        } else if (isOk == 1) {\n            fprintf(<recovery-expr>(p), \"%d\\n\", rc2);\n        } else if (isOk == 2) {\n            fprintf(<recovery-expr>(p), \"0x%08x\\n\", rc2);\n        }\n    } else if (c == 't' && n > 4 && <recovery-expr>()(azArg[0], \"timeout\", n) == 0) {\n        open_db(p, 0);\n        sqlite3_busy_timeout(p->db, nArg >= 2 ? (int)integerValue(azArg[1]) : 0);\n    } else if (c == 't' && n >= 5 && <recovery-expr>()(azArg[0], \"timer\", n) == 0) {\n        if (nArg == 2) {\n            enableTimer = booleanValue(azArg[1]);\n            if (enableTimer && !1) {\n                enableTimer = 0;\n            }\n        } else {\n            rc = 1;\n        }\n    } else if (c == 't' && <recovery-expr>()(azArg[0], \"trace\", n) == 0) {\n        int mType = 0;\n        int jj;\n        open_db(p, 0);\n        for (jj = 1; jj < nArg; jj++) {\n            const char *z = azArg[jj];\n            if (z[0] == '-') {\n                if (optionMatch(z, \"expanded\")) {\n                    p->eTraceType = 1;\n                } else if (optionMatch(z, \"plain\")) {\n                    p->eTraceType = 0;\n                } else if (optionMatch(z, \"profile\")) {\n                    mType |= 2;\n                } else if (optionMatch(z, \"row\")) {\n                    mType |= 4;\n                } else if (optionMatch(z, \"stmt\")) {\n                    mType |= 1;\n                } else if (optionMatch(z, \"close\")) {\n                    mType |= 8;\n                } else {\n                    rc = 1;\n                    goto meta_command_exit;\n                }\n            } else {\n                <recovery-expr>()(<recovery-expr>(p));\n                <recovery-expr>(p) = <recovery-expr>()(azArg[1], 0);\n            }\n        }\n        if (<recovery-expr>(p) == 0) {\n            sqlite3_trace_v2(p->db, 0, 0, 0);\n        } else {\n            if (mType == 0)\n                mType = 1;\n            sqlite3_trace_v2(p->db, mType, sql_trace_callback, p);\n        }\n    } else if (c == 'v' && <recovery-expr>()(azArg[0], \"version\", n) == 0) {\n        fprintf(<recovery-expr>(p), \"SQLite %s %s\\n\", sqlite3_libversion(), sqlite3_sourceid());\n        fprintf(<recovery-expr>(p), \"clang-16.0.0\\n\");\n    } else if (c == 'v' && <recovery-expr>()(azArg[0], \"vfsinfo\", n) == 0) {\n        const char *zDbName = nArg == 2 ? azArg[1] : \"main\";\n        sqlite3_vfs *pVfs = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, zDbName, 27, &pVfs);\n            if (pVfs) {\n                fprintf(<recovery-expr>(p), \"vfs.zName      = \\\"%s\\\"\\n\", pVfs->zName);\n                fprintf(<recovery-expr>(p), \"vfs.iVersion   = %d\\n\", pVfs->iVersion);\n                fprintf(<recovery-expr>(p), \"vfs.szOsFile   = %d\\n\", pVfs->szOsFile);\n                fprintf(<recovery-expr>(p), \"vfs.mxPathname = %d\\n\", pVfs->mxPathname);\n            }\n        }\n    } else if (c == 'v' && <recovery-expr>()(azArg[0], \"vfslist\", n) == 0) {\n        sqlite3_vfs *pVfs;\n        sqlite3_vfs *pCurrent = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, \"main\", 27, &pCurrent);\n        }\n        for (pVfs = sqlite3_vfs_find(0); pVfs; pVfs = pVfs->pNext) {\n            fprintf(<recovery-expr>(p), \"vfs.zName      = \\\"%s\\\"%s\\n\", pVfs->zName, pVfs == pCurrent ? \"  <--- CURRENT\" : \"\");\n            fprintf(<recovery-expr>(p), \"vfs.iVersion   = %d\\n\", pVfs->iVersion);\n            fprintf(<recovery-expr>(p), \"vfs.szOsFile   = %d\\n\", pVfs->szOsFile);\n            fprintf(<recovery-expr>(p), \"vfs.mxPathname = %d\\n\", pVfs->mxPathname);\n            if (pVfs->pNext) {\n                fprintf(<recovery-expr>(p), \"-----------------------------------\\n\");\n            }\n        }\n    } else if (c == 'v' && <recovery-expr>()(azArg[0], \"vfsname\", n) == 0) {\n        const char *zDbName = nArg == 2 ? azArg[1] : \"main\";\n        char *zVfsName = 0;\n        if (p->db) {\n            sqlite3_file_control(p->db, zDbName, 12, &zVfsName);\n            if (zVfsName) {\n                fprintf(<recovery-expr>(p), \"%s\\n\", zVfsName);\n                sqlite3_free(zVfsName);\n            }\n        }\n    } else if (c == 'w' && <recovery-expr>()(azArg[0], \"wheretrace\", n) == 0) {\n        unsigned int x = nArg >= 2 ? (unsigned int)integerValue(azArg[1]) : 4294967295U;\n        sqlite3_test_control(31, 3, &x);\n    } else if (c == 'w' && <recovery-expr>()(azArg[0], \"width\", n) == 0) {\n        int j;\n        assert(nArg <= (int)(sizeof (azArg) / sizeof (azArg[0])));\n        p->nWidth = nArg - 1;\n        p->colWidth = realloc(p->colWidth, (p->nWidth + 1) * sizeof(int) * 2);\n        if (p->colWidth == 0 && p->nWidth > 0)\n            shell_out_of_memory();\n        if (p->nWidth)\n            p->actualWidth = &p->colWidth[p->nWidth];\n        for (j = 1; j < nArg; j++) {\n            p->colWidth[j - 1] = (int)integerValue(azArg[j]);\n        }\n    } else {\n        rc = 1;\n    }\n  meta_command_exit:\n    if (p->outCount) {\n        p->outCount--;\n        if (p->outCount == 0)\n            output_reset(p);\n    }\n    p->bSafeMode = p->bSafeModePersist;\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#2639:1#decimalCmpFunc",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Decimal *pA = 0, *pB = 0;\n    int rc;\n    (void)(argc);\n    pA = decimal_new(context, argv[0], 0, 0);\n    if (pA == 0 || pA->isNull)\n        goto cmp_done;\n    pB = decimal_new(context, argv[1], 0, 0);\n    if (pB == 0 || pB->isNull)\n        goto cmp_done;\n    rc = decimal_cmp(pA, pB);\n    if (rc < 0)\n        rc = -1;\n    else if (rc > 0)\n        rc = +1;\n    sqlite3_result_int(context, rc);\n  cmp_done:\n    decimal_free(pA);\n    decimal_free(pB);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#2413:1#decimal_new",
    "gotos": 4,
    "labels": 1,
    "body": "{\n    Decimal *p;\n    int n, i;\n    const unsigned char *zIn;\n    int iExp = 0;\n    p = sqlite3_malloc(sizeof (*p));\n    if (p == 0)\n        goto new_no_mem;\n    p->sign = 0;\n    p->oom = 0;\n    p->isInit = 1;\n    p->isNull = 0;\n    p->nDigit = 0;\n    p->nFrac = 0;\n    if (zAlt) {\n        n = nAlt , zIn = zAlt;\n    } else {\n        if (sqlite3_value_type(pIn) == 5) {\n            p->a = 0;\n            p->isNull = 1;\n            return p;\n        }\n        n = sqlite3_value_bytes(pIn);\n        zIn = sqlite3_value_text(pIn);\n    }\n    p->a = sqlite3_malloc64(n + 1);\n    if (p->a == 0)\n        goto new_no_mem;\n    for (i = 0; isspace(zIn[i]); i++) {\n    }\n    if (zIn[i] == '-') {\n        p->sign = 1;\n        i++;\n    } else if (zIn[i] == '+') {\n        i++;\n    }\n    while (i < n && zIn[i] == '0')\n        i++;\n    while (i < n)\n        {\n            char c = zIn[i];\n            if (c >= '0' && c <= '9') {\n                p->a[p->nDigit++] = c - '0';\n            } else if (c == '.') {\n                p->nFrac = p->nDigit + 1;\n            } else if (c == 'e' || c == 'E') {\n                int j = i + 1;\n                int neg = 0;\n                if (j >= n)\n                    break;\n                if (zIn[j] == '-') {\n                    neg = 1;\n                    j++;\n                } else if (zIn[j] == '+') {\n                    j++;\n                }\n                while (j < n && iExp < 1000000)\n                    {\n                        if (zIn[j] >= '0' && zIn[j] <= '9') {\n                            iExp = iExp * 10 + zIn[j] - '0';\n                        }\n                        j++;\n                    }\n                if (neg)\n                    iExp = -iExp;\n                break;\n            }\n            i++;\n        }\n    if (p->nFrac) {\n        p->nFrac = p->nDigit - (p->nFrac - 1);\n    }\n    if (iExp > 0) {\n        if (p->nFrac > 0) {\n            if (iExp <= p->nFrac) {\n                p->nFrac -= iExp;\n                iExp = 0;\n            } else {\n                iExp -= p->nFrac;\n                p->nFrac = 0;\n            }\n        }\n        if (iExp > 0) {\n            p->a = sqlite3_realloc64(p->a, p->nDigit + iExp + 1);\n            if (p->a == 0)\n                goto new_no_mem;\n            memset(p->a + p->nDigit, 0, iExp);\n            p->nDigit += iExp;\n        }\n    } else if (iExp < 0) {\n        int nExtra;\n        iExp = -iExp;\n        nExtra = p->nDigit - p->nFrac - 1;\n        if (nExtra) {\n            if (nExtra >= iExp) {\n                p->nFrac += iExp;\n                iExp = 0;\n            } else {\n                iExp -= nExtra;\n                p->nFrac = p->nDigit - 1;\n            }\n        }\n        if (iExp > 0) {\n            p->a = sqlite3_realloc64(p->a, p->nDigit + iExp + 1);\n            if (p->a == 0)\n                goto new_no_mem;\n            memmove(p->a + iExp, p->a, p->nDigit);\n            memset(p->a, 0, iExp);\n            p->nDigit += iExp;\n            p->nFrac += iExp;\n        }\n    }\n    return p;\n  new_no_mem:\n    if (pCtx)\n        sqlite3_result_error_nomem(pCtx);\n    sqlite3_free(p);\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/shell.c#20828:1#lintDotCommand",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    int n;\n    n = (nArg >= 2 ? strlen30(azArg[1]) : 0);\n    if (n < 1 || sqlite3_strnicmp(azArg[1], \"fkey-indexes\", n))\n        goto usage;\n    return lintFkeyIndexes(pState, azArg, nArg);\n  usage:\n    ;\n    return 1;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/sqlite/build/../src/tclsqlite.c#1931:1#DbObjCmd",
    "gotos": 3,
    "labels": 1,
    "body": "{\n    SqliteDb *pDb = (SqliteDb *)cd;\n    int choice;\n    int rc;\n    static const char *DB_strs[] = {\"authorizer\", \"backup\", \"bind_fallback\", \"busy\", \"cache\", \"changes\", \"close\", \"collate\", \"collation_needed\", \"commit_hook\", \"complete\", \"config\", \"copy\", \"deserialize\", \"enable_load_extension\", \"errorcode\", \"erroroffset\", \"eval\", \"exists\", \"function\", \"incrblob\", \"interrupt\", \"last_insert_rowid\", \"nullvalue\", \"onecolumn\", \"preupdate\", \"profile\", \"progress\", \"rekey\", \"restore\", \"rollback_hook\", \"serialize\", \"status\", \"timeout\", \"total_changes\", \"trace\", \"trace_v2\", \"transaction\", \"unlock_notify\", \"update_hook\", \"version\", \"wal_hook\", 0};\n    enum DB_enum {\n        DB_AUTHORIZER,\n        DB_BACKUP,\n        DB_BIND_FALLBACK,\n        DB_BUSY,\n        DB_CACHE,\n        DB_CHANGES,\n        DB_CLOSE,\n        DB_COLLATE,\n        DB_COLLATION_NEEDED,\n        DB_COMMIT_HOOK,\n        DB_COMPLETE,\n        DB_CONFIG,\n        DB_COPY,\n        DB_DESERIALIZE,\n        DB_ENABLE_LOAD_EXTENSION,\n        DB_ERRORCODE,\n        DB_ERROROFFSET,\n        DB_EVAL,\n        DB_EXISTS,\n        DB_FUNCTION,\n        DB_INCRBLOB,\n        DB_INTERRUPT,\n        DB_LAST_INSERT_ROWID,\n        DB_NULLVALUE,\n        DB_ONECOLUMN,\n        DB_PREUPDATE,\n        DB_PROFILE,\n        DB_PROGRESS,\n        DB_REKEY,\n        DB_RESTORE,\n        DB_ROLLBACK_HOOK,\n        DB_SERIALIZE,\n        DB_STATUS,\n        DB_TIMEOUT,\n        DB_TOTAL_CHANGES,\n        DB_TRACE,\n        DB_TRACE_V2,\n        DB_TRANSACTION,\n        DB_UNLOCK_NOTIFY,\n        DB_UPDATE_HOOK,\n        DB_VERSION,\n        DB_WAL_HOOK\n    };\n    if (objc < 2) {\n        Tcl_WrongNumArgs(<recovery-expr>(), 1, <recovery-expr>(), \"SUBCOMMAND ...\");\n    }\n    if (Tcl_GetIndexFromObj(<recovery-expr>(), <recovery-expr>()[1], DB_strs, \"option\", 0, &choice)) {\n    }\n    switch ((enum DB_enum)choice) {\n      case DB_AUTHORIZER:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zAuth) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zAuth, (char *)0);\n                }\n            } else {\n                char *zAuth;\n                int len;\n                if (pDb->zAuth) {\n                    Tcl_Free(pDb->zAuth);\n                }\n                zAuth = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zAuth && len > 0) {\n                    pDb->zAuth = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zAuth, zAuth, len + 1);\n                } else {\n                    pDb->zAuth = 0;\n                }\n                if (pDb->zAuth) {\n                    typedef int (*sqlite3_auth_cb)(void *, int, const char *, const char *, const char *, const char *);\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_set_authorizer(<recovery-expr>(pDb), (sqlite3_auth_cb)auth_callback, pDb);\n                } else {\n                    sqlite3_set_authorizer(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_BACKUP:\n        {\n            const char *zDestFile;\n            const char *zSrcDb;\n            if (objc == 3) {\n                zSrcDb = \"main\";\n                zDestFile = Tcl_GetString(<recovery-expr>()[2]);\n            } else if (objc == 4) {\n                zSrcDb = Tcl_GetString(<recovery-expr>()[2]);\n                zDestFile = Tcl_GetString(<recovery-expr>()[3]);\n            } else {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?DATABASE? FILENAME\");\n            }\n            if (<recovery-expr>()) {\n            }\n            if (<recovery-expr>()) {\n            }\n            while (<recovery-expr>())\n                {\n                }\n            if (<recovery-expr>()) {\n            } else {\n            }\n            break;\n        }\n      case DB_BIND_FALLBACK:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zBindFallback) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zBindFallback, (char *)0);\n                }\n            } else {\n                char *zCallback;\n                int len;\n                if (pDb->zBindFallback) {\n                    Tcl_Free(pDb->zBindFallback);\n                }\n                zCallback = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zCallback && len > 0) {\n                    pDb->zBindFallback = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zBindFallback, zCallback, len + 1);\n                } else {\n                    pDb->zBindFallback = 0;\n                }\n            }\n            break;\n        }\n      case DB_BUSY:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"CALLBACK\");\n            } else if (objc == 2) {\n                if (pDb->zBusy) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zBusy, (char *)0);\n                }\n            } else {\n                char *zBusy;\n                int len;\n                if (pDb->zBusy) {\n                    Tcl_Free(pDb->zBusy);\n                }\n                zBusy = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zBusy && len > 0) {\n                    pDb->zBusy = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zBusy, zBusy, len + 1);\n                } else {\n                    pDb->zBusy = 0;\n                }\n                if (pDb->zBusy) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_busy_handler(<recovery-expr>(pDb), DbBusyHandler, pDb);\n                } else {\n                    sqlite3_busy_handler(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_CACHE:\n        {\n            char *subCmd;\n            int n;\n            if (objc <= 2) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 1, <recovery-expr>(), \"cache option ?arg?\");\n            }\n            subCmd = Tcl_GetStringFromObj(<recovery-expr>()[2], 0);\n            if (*subCmd == 'f' && strcmp(subCmd, \"flush\") == 0) {\n                if (objc != 3) {\n                    Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"flush\");\n                } else {\n                    flushStmtCache(pDb);\n                }\n            } else if (*subCmd == 's' && strcmp(subCmd, \"size\") == 0) {\n                if (objc != 4) {\n                    Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"size n\");\n                } else {\n                    if (<recovery-expr>()) {\n                        Tcl_AppendResult(<recovery-expr>(), \"cannot convert \\\"\", Tcl_GetStringFromObj(<recovery-expr>()[3], 0), \"\\\" to integer\", (char *)0);\n                    } else {\n                        if (n < 0) {\n                            flushStmtCache(pDb);\n                            n = 0;\n                        } else if (n > 100) {\n                            n = 100;\n                        }\n                        pDb->maxStmt = n;\n                    }\n                }\n            } else {\n                Tcl_AppendResult(<recovery-expr>(), \"bad option \\\"\", Tcl_GetStringFromObj(<recovery-expr>()[2], 0), \"\\\": must be flush or size\", (char *)0);\n            }\n            break;\n        }\n      case DB_CHANGES:\n        {\n            if (objc != 2) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"\");\n            }\n            break;\n        }\n      case DB_CLOSE:\n        {\n            Tcl_DeleteCommand(<recovery-expr>(), Tcl_GetStringFromObj(<recovery-expr>()[0], 0));\n            break;\n        }\n      case DB_COLLATE:\n        {\n            SqlCollate *pCollate;\n            char *zName;\n            char *zScript;\n            int nScript;\n            if (objc != 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"NAME SCRIPT\");\n            }\n            zName = Tcl_GetStringFromObj(<recovery-expr>()[2], 0);\n            zScript = Tcl_GetStringFromObj(<recovery-expr>()[3], &nScript);\n            pCollate = (SqlCollate *)Tcl_Alloc(sizeof (*pCollate) + nScript + 1);\n            <recovery-expr>(pCollate) = <recovery-expr>();\n            pCollate->pNext = pDb->pCollate;\n            pCollate->zScript = (char *)&pCollate[1];\n            pDb->pCollate = pCollate;\n            memcpy(pCollate->zScript, zScript, nScript + 1);\n            if (<recovery-expr>()) {\n            }\n            break;\n        }\n      case DB_COLLATION_NEEDED:\n        {\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"SCRIPT\");\n            }\n            if (<recovery-expr>(pDb)) {\n                Tcl_DecrRefCount(<recovery-expr>(pDb));\n            }\n            <recovery-expr>(pDb) = Tcl_DuplicateObj(<recovery-expr>()[2]);\n            Tcl_IncrRefCount(<recovery-expr>(pDb));\n            sqlite3_collation_needed(<recovery-expr>(pDb), pDb, <recovery-expr>());\n            break;\n        }\n      case DB_COMMIT_HOOK:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zCommit) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zCommit, (char *)0);\n                }\n            } else {\n                const char *zCommit;\n                int len;\n                if (pDb->zCommit) {\n                    Tcl_Free(pDb->zCommit);\n                }\n                zCommit = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zCommit && len > 0) {\n                    pDb->zCommit = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zCommit, zCommit, len + 1);\n                } else {\n                    pDb->zCommit = 0;\n                }\n                if (pDb->zCommit) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_commit_hook(<recovery-expr>(pDb), DbCommitHandler, pDb);\n                } else {\n                    sqlite3_commit_hook(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_COMPLETE:\n        {\n            int isComplete;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"SQL\");\n            }\n            isComplete = sqlite3_complete(Tcl_GetStringFromObj(<recovery-expr>()[2], 0));\n            break;\n        }\n      case DB_CONFIG:\n        {\n            static const struct DbConfigChoices {\n                const char *zName;\n                int op;\n            } aDbConfig[];\n            int ii;\n            if (objc > 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?OPTION? ?BOOLEAN?\");\n            }\n            if (objc == 2) {\n            } else {\n                const char *zOpt = Tcl_GetString(<recovery-expr>()[2]);\n                int onoff = -1;\n                int v = 0;\n                if (zOpt[0] == '-')\n                    zOpt++;\n                if (<recovery-expr>()) {\n                    Tcl_AppendResult(<recovery-expr>(), \"unknown config option: \\\"\", zOpt, \"\\\"\", (void *)0);\n                }\n                if (objc == 4) {\n                    if (Tcl_GetBooleanFromObj(<recovery-expr>(), <recovery-expr>()[3], &onoff)) {\n                    }\n                }\n                sqlite3_db_config(<recovery-expr>(pDb), aDbConfig[ii].op, onoff, &v);\n            }\n            break;\n        }\n      case DB_COPY:\n        {\n            char *zTable;\n            char *zFile;\n            char *zConflict;\n            int nCol;\n            int nByte;\n            int i, j;\n            int nSep;\n            int nNull;\n            char *zSql;\n            char *zLine;\n            char **azCol;\n            const char *zCommit;\n            int lineno = 0;\n            char zLineNum[80];\n            const char *zSep;\n            const char *zNull;\n            if (objc < 5 || objc > 7) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\");\n            }\n            if (objc >= 6) {\n                zSep = Tcl_GetStringFromObj(<recovery-expr>()[5], 0);\n            } else {\n                zSep = \"\\t\";\n            }\n            if (objc >= 7) {\n                zNull = Tcl_GetStringFromObj(<recovery-expr>()[6], 0);\n            } else {\n                zNull = \"\";\n            }\n            zConflict = Tcl_GetStringFromObj(<recovery-expr>()[2], 0);\n            zTable = Tcl_GetStringFromObj(<recovery-expr>()[3], 0);\n            zFile = Tcl_GetStringFromObj(<recovery-expr>()[4], 0);\n            nSep = strlen30(zSep);\n            nNull = strlen30(zNull);\n            if (nSep == 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: non-null separator required for copy\", (char *)0);\n            }\n            if (strcmp(zConflict, \"rollback\") != 0 && strcmp(zConflict, \"abort\") != 0 && strcmp(zConflict, \"fail\") != 0 && strcmp(zConflict, \"ignore\") != 0 && strcmp(zConflict, \"replace\") != 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: \\\"\", zConflict, \"\\\", conflict-algorithm must be one of: rollback, abort, fail, ignore, or replace\", (char *)0);\n            }\n            zSql = sqlite3_mprintf(\"SELECT * FROM '%q'\", zTable);\n            if (zSql == 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: no such table: \", zTable, (char *)0);\n            }\n            nByte = strlen30(zSql);\n            sqlite3_free(zSql);\n            if (rc) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n                nCol = 0;\n            } else {\n            }\n            if (nCol == 0) {\n            }\n            zSql = malloc(nByte + 50 + nCol * 2);\n            if (zSql == 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: can't malloc()\", (char *)0);\n            }\n            sqlite3_snprintf(nByte + 50, zSql, \"INSERT OR %q INTO '%q' VALUES(?\", zConflict, zTable);\n            j = strlen30(zSql);\n            for (i = 1; i < nCol; i++) {\n                zSql[j++] = ',';\n                zSql[j++] = '?';\n            }\n            zSql[j++] = ')';\n            zSql[j] = 0;\n            free(zSql);\n            if (rc) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n            }\n            if (<recovery-expr>()) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: cannot open file: \", zFile, (char *)0);\n            }\n            azCol = malloc(sizeof (azCol[0]) * (nCol + 1));\n            if (azCol == 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"Error: can't malloc()\", (char *)0);\n            }\n            (void)sqlite3_exec(<recovery-expr>(pDb), \"BEGIN\", 0, 0, 0);\n            zCommit = \"COMMIT\";\n            while (<recovery-expr>())\n                {\n                    char *z;\n                    lineno++;\n                    azCol[0] = zLine;\n                    for (i = 0 , z = zLine; *z; z++) {\n                        if (*z == zSep[0] && strncmp(z, zSep, nSep) == 0) {\n                            *z = 0;\n                            i++;\n                            if (i < nCol) {\n                                azCol[i] = &z[nSep];\n                                z += nSep - 1;\n                            }\n                        }\n                    }\n                    if (i + 1 != nCol) {\n                        char *zErr;\n                        int nErr = strlen30(zFile) + 200;\n                        zErr = malloc(nErr);\n                        if (zErr) {\n                            sqlite3_snprintf(nErr, zErr, \"Error: %s line %d: expected %d columns of data but found %d\", zFile, lineno, nCol, i + 1);\n                            Tcl_AppendResult(<recovery-expr>(), zErr, (char *)0);\n                            free(zErr);\n                        }\n                        zCommit = \"ROLLBACK\";\n                        break;\n                    }\n                    for (i = 0; i < nCol; i++) {\n                        if ((nNull > 0 && strcmp(azCol[i], zNull) == 0) || strlen30(azCol[i]) == 0) {\n                        } else {\n                        }\n                    }\n                    free(zLine);\n                    if (<recovery-expr>()) {\n                        Tcl_AppendResult(<recovery-expr>(), \"Error: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n                        zCommit = \"ROLLBACK\";\n                        break;\n                    }\n                }\n            free(azCol);\n            (void)sqlite3_exec(<recovery-expr>(pDb), zCommit, 0, 0, 0);\n            if (zCommit[0] == 'C') {\n            } else {\n                sqlite3_snprintf(sizeof (zLineNum), zLineNum, \"%d\", lineno);\n                Tcl_AppendResult(<recovery-expr>(), \", failed while processing line: \", zLineNum, (char *)0);\n            }\n            break;\n        }\n      case DB_DESERIALIZE:\n        {\n            const char *zSchema = 0;\n            unsigned char *pBA;\n            unsigned char *pData;\n            int len, xrc;\n            int i;\n            int isReadonly = 0;\n            if (objc < 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?DATABASE? VALUE\");\n                break;\n            }\n            for (i = 2; i < objc - 1; i++) {\n                const char *z = Tcl_GetString(<recovery-expr>()[i]);\n                if (strcmp(z, \"-maxsize\") == 0 && i < objc - 2) {\n                    if (rc)\n                        goto deserialize_error;\n                    continue;\n                }\n                if (strcmp(z, \"-readonly\") == 0 && i < objc - 2) {\n                    rc = Tcl_GetBooleanFromObj(<recovery-expr>(), <recovery-expr>()[++i], &isReadonly);\n                    if (rc)\n                        goto deserialize_error;\n                    continue;\n                }\n                if (zSchema == 0 && i == objc - 2 && z[0] != '-') {\n                    zSchema = z;\n                    continue;\n                }\n                Tcl_AppendResult(<recovery-expr>(), \"unknown option: \", z, (char *)0);\n                goto deserialize_error;\n            }\n            pData = sqlite3_malloc64(len);\n            if (pData == 0 && len > 0) {\n                Tcl_AppendResult(<recovery-expr>(), \"out of memory\", (char *)0);\n            } else {\n                int flags;\n                if (len > 0)\n                    memcpy(pData, pBA, len);\n                if (isReadonly) {\n                } else {\n                }\n                xrc = sqlite3_deserialize(<recovery-expr>(pDb), zSchema, pData, len, len, flags);\n                if (xrc) {\n                    Tcl_AppendResult(<recovery-expr>(), \"unable to set MEMDB content\", (char *)0);\n                }\n                if (<recovery-expr>()) {\n                }\n            }\n          deserialize_error:\n            break;\n        }\n      case DB_ENABLE_LOAD_EXTENSION:\n        {\n            int onoff;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"BOOLEAN\");\n            }\n            if (Tcl_GetBooleanFromObj(<recovery-expr>(), <recovery-expr>()[2], &onoff)) {\n            }\n            sqlite3_enable_load_extension(<recovery-expr>(pDb), onoff);\n            break;\n        }\n      case DB_ERRORCODE:\n        {\n            Tcl_SetObjResult(<recovery-expr>(), Tcl_NewIntObj(sqlite3_errcode(<recovery-expr>(pDb))));\n            break;\n        }\n      case DB_ERROROFFSET:\n        {\n            Tcl_SetObjResult(<recovery-expr>(), Tcl_NewIntObj(sqlite3_error_offset(<recovery-expr>(pDb))));\n            break;\n        }\n      case DB_EXISTS:\n      case DB_ONECOLUMN:\n        {\n            DbEvalContext sEval;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"SQL\");\n            }\n            <recovery-expr>()(&sEval, pDb, <recovery-expr>()[2], 0, 0);\n            rc = dbEvalStep(&sEval);\n            if (choice == DB_ONECOLUMN) {\n                if (<recovery-expr>()) {\n                } else if (<recovery-expr>()) {\n                    Tcl_ResetResult(<recovery-expr>());\n                }\n            } else if (<recovery-expr>()) {\n            }\n            dbEvalFinalize(&sEval);\n            if (<recovery-expr>()) {\n            }\n            break;\n        }\n      case DB_EVAL:\n        {\n            int evalFlags = 0;\n            const char *zOpt;\n            while (objc > 3 && (zOpt = Tcl_GetString(<recovery-expr>()[2])) != 0 && zOpt[0] == '-')\n                {\n                    if (strcmp(zOpt, \"-withoutnulls\") == 0) {\n                        evalFlags |= 1;\n                    } else {\n                        Tcl_AppendResult(<recovery-expr>(), \"unknown option: \\\"\", zOpt, \"\\\"\", (void *)0);\n                    }\n                    objc--;\n                    <recovery-expr>()++;\n                }\n            if (objc < 3 || objc > 5) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?\");\n            }\n            if (objc == 3) {\n                DbEvalContext sEval;\n                <recovery-expr>()(&sEval, pDb, <recovery-expr>()[2], 0, 0);\n                while (<recovery-expr>())\n                    {\n                        int i;\n                        int nCol;\n                        <recovery-expr>()(&sEval, &nCol, 0);\n                        for (i = 0; i < nCol; i++) {\n                        }\n                    }\n                dbEvalFinalize(&sEval);\n                if (<recovery-expr>()) {\n                }\n            } else {\n                DbEvalContext *p;\n                if (objc >= 5 && *(char *)Tcl_GetString(<recovery-expr>()[3])) {\n                }\n                p = (DbEvalContext *)Tcl_Alloc(sizeof(DbEvalContext));\n            }\n            break;\n        }\n      case DB_FUNCTION:\n        {\n            int flags;\n            SqlFunc *pFunc;\n            char *zName;\n            int nArg = -1;\n            int i;\n            int eType;\n            if (objc < 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"NAME ?SWITCHES? SCRIPT\");\n            }\n            for (i = 3; i < (objc - 1); i++) {\n                const char *z = Tcl_GetString(<recovery-expr>()[i]);\n                int n = strlen30(z);\n                if (n > 1 && strncmp(z, \"-argcount\", n) == 0) {\n                    if (i == (objc - 2)) {\n                        Tcl_AppendResult(<recovery-expr>(), \"option requires an argument: \", z, (char *)0);\n                    }\n                    if (nArg < 0) {\n                        Tcl_AppendResult(<recovery-expr>(), \"number of arguments must be non-negative\", (char *)0);\n                    }\n                    i++;\n                } else if (n > 1 && strncmp(z, \"-deterministic\", n) == 0) {\n                } else if (n > 1 && strncmp(z, \"-directonly\", n) == 0) {\n                } else if (n > 1 && strncmp(z, \"-innocuous\", n) == 0) {\n                } else if (n > 1 && strncmp(z, \"-returntype\", n) == 0) {\n                    const char *azType[] = {\"integer\", \"real\", \"text\", \"blob\", \"any\", 0};\n                    if (i == (objc - 2)) {\n                        Tcl_AppendResult(<recovery-expr>(), \"option requires an argument: \", z, (char *)0);\n                    }\n                    i++;\n                    if (Tcl_GetIndexFromObj(<recovery-expr>(), <recovery-expr>()[i], azType, \"type\", 0, &eType)) {\n                    }\n                    eType++;\n                } else {\n                    Tcl_AppendResult(<recovery-expr>(), \"bad option \\\"\", z, \"\\\": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype\", (char *)0);\n                }\n            }\n            zName = Tcl_GetStringFromObj(<recovery-expr>()[2], 0);\n            pFunc = findSqlFunc(pDb, zName);\n            if (<recovery-expr>(pFunc)) {\n                Tcl_DecrRefCount(<recovery-expr>(pFunc));\n            }\n            pFunc->eType = eType;\n            rc = sqlite3_create_function(<recovery-expr>(pDb), zName, nArg, flags, pFunc, <recovery-expr>(), 0, 0);\n            if (<recovery-expr>()) {\n            }\n            break;\n        }\n      case DB_INCRBLOB:\n        {\n            int isReadonly = 0;\n            const char *zDb = \"main\";\n            const char *zTable;\n            const char *zColumn;\n            if (objc > 3 && strcmp(Tcl_GetString(<recovery-expr>()[2]), \"-readonly\") == 0) {\n                isReadonly = 1;\n            }\n            if (objc != (5 + isReadonly) && objc != (6 + isReadonly)) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?-readonly? ?DB? TABLE COLUMN ROWID\");\n            }\n            if (objc == (6 + isReadonly)) {\n                zDb = Tcl_GetString(<recovery-expr>()[2 + isReadonly]);\n            }\n            zTable = Tcl_GetString(<recovery-expr>()[objc - 3]);\n            zColumn = Tcl_GetString(<recovery-expr>()[objc - 2]);\n            if (<recovery-expr>()) {\n            }\n            break;\n        }\n      case DB_INTERRUPT:\n        {\n            sqlite3_interrupt(<recovery-expr>(pDb));\n            break;\n        }\n      case DB_NULLVALUE:\n        {\n            if (objc != 2 && objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"NULLVALUE\");\n            }\n            if (objc == 3) {\n                int len;\n                char *zNull = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (pDb->zNull) {\n                    Tcl_Free(pDb->zNull);\n                }\n                if (zNull && len > 0) {\n                    pDb->zNull = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zNull, zNull, len);\n                    pDb->zNull[len] = '\\x00';\n                } else {\n                    pDb->zNull = 0;\n                }\n            }\n            Tcl_SetObjResult(<recovery-expr>(), Tcl_NewStringObj(pDb->zNull, -1));\n            break;\n        }\n      case DB_LAST_INSERT_ROWID:\n        {\n            if (objc != 2) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"\");\n            }\n            break;\n        }\n      case DB_PROGRESS:\n        {\n            if (objc == 2) {\n                if (pDb->zProgress) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zProgress, (char *)0);\n                }\n            } else if (objc == 4) {\n                char *zProgress;\n                int len;\n                int N;\n                if (<recovery-expr>()) {\n                }\n                ;\n                if (pDb->zProgress) {\n                    Tcl_Free(pDb->zProgress);\n                }\n                zProgress = Tcl_GetStringFromObj(<recovery-expr>()[3], &len);\n                if (zProgress && len > 0) {\n                    pDb->zProgress = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zProgress, zProgress, len + 1);\n                } else {\n                    pDb->zProgress = 0;\n                }\n                if (pDb->zProgress) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_progress_handler(<recovery-expr>(pDb), N, DbProgressHandler, pDb);\n                } else {\n                    sqlite3_progress_handler(<recovery-expr>(pDb), 0, 0, 0);\n                }\n            } else {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"N CALLBACK\");\n            }\n            break;\n        }\n      case DB_PROFILE:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zProfile) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zProfile, (char *)0);\n                }\n            } else {\n                char *zProfile;\n                int len;\n                if (pDb->zProfile) {\n                    Tcl_Free(pDb->zProfile);\n                }\n                zProfile = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zProfile && len > 0) {\n                    pDb->zProfile = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zProfile, zProfile, len + 1);\n                } else {\n                    pDb->zProfile = 0;\n                }\n                if (pDb->zProfile) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_profile(<recovery-expr>(pDb), <recovery-expr>(), pDb);\n                } else {\n                    sqlite3_profile(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_REKEY:\n        {\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"KEY\");\n            }\n            break;\n        }\n      case DB_RESTORE:\n        {\n            const char *zSrcFile;\n            const char *zDestDb;\n            int nTimeout = 0;\n            if (objc == 3) {\n                zDestDb = \"main\";\n                zSrcFile = Tcl_GetString(<recovery-expr>()[2]);\n            } else if (objc == 4) {\n                zDestDb = Tcl_GetString(<recovery-expr>()[2]);\n                zSrcFile = Tcl_GetString(<recovery-expr>()[3]);\n            } else {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?DATABASE? FILENAME\");\n            }\n            if (<recovery-expr>()) {\n            }\n            if (<recovery-expr>()) {\n                Tcl_AppendResult(<recovery-expr>(), \"restore failed: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n            }\n            while (<recovery-expr>())\n                {\n                    if (<recovery-expr>()) {\n                        if (nTimeout++ >= 3)\n                            break;\n                        sqlite3_sleep(100);\n                    }\n                }\n            if (<recovery-expr>()) {\n            } else if (<recovery-expr>()) {\n                Tcl_AppendResult(<recovery-expr>(), \"restore failed: source database busy\", (char *)0);\n            } else {\n                Tcl_AppendResult(<recovery-expr>(), \"restore failed: \", sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n            }\n            break;\n        }\n      case DB_SERIALIZE:\n        {\n            const char *zSchema = objc >= 3 ? Tcl_GetString(<recovery-expr>()[2]) : \"main\";\n            unsigned char *pData;\n            if (objc != 2 && objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?DATABASE?\");\n            } else {\n                int needFree;\n                if (pData) {\n                    needFree = 0;\n                } else {\n                    needFree = 1;\n                }\n                if (needFree)\n                    sqlite3_free(pData);\n            }\n            break;\n        }\n      case DB_STATUS:\n        {\n            int v;\n            const char *zOp;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"(step|sort|autoindex)\");\n            }\n            zOp = Tcl_GetString(<recovery-expr>()[2]);\n            if (strcmp(zOp, \"step\") == 0) {\n                v = pDb->nStep;\n            } else if (strcmp(zOp, \"sort\") == 0) {\n                v = pDb->nSort;\n            } else if (strcmp(zOp, \"autoindex\") == 0) {\n                v = pDb->nIndex;\n            } else if (strcmp(zOp, \"vmstep\") == 0) {\n                v = pDb->nVMStep;\n            } else {\n                Tcl_AppendResult(<recovery-expr>(), \"bad argument: should be autoindex, step, sort or vmstep\", (char *)0);\n            }\n            Tcl_SetObjResult(<recovery-expr>(), Tcl_NewIntObj(v));\n            break;\n        }\n      case DB_TIMEOUT:\n        {\n            int ms;\n            if (objc != 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"MILLISECONDS\");\n            }\n            sqlite3_busy_timeout(<recovery-expr>(pDb), ms);\n            break;\n        }\n      case DB_TOTAL_CHANGES:\n        {\n            if (objc != 2) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"\");\n            }\n            break;\n        }\n      case DB_TRACE:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK?\");\n            } else if (objc == 2) {\n                if (pDb->zTrace) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zTrace, (char *)0);\n                }\n            } else {\n                char *zTrace;\n                int len;\n                if (pDb->zTrace) {\n                    Tcl_Free(pDb->zTrace);\n                }\n                zTrace = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zTrace && len > 0) {\n                    pDb->zTrace = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zTrace, zTrace, len + 1);\n                } else {\n                    pDb->zTrace = 0;\n                }\n                if (pDb->zTrace) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                    sqlite3_trace(<recovery-expr>(pDb), DbTraceHandler, pDb);\n                } else {\n                    sqlite3_trace(<recovery-expr>(pDb), 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_TRACE_V2:\n        {\n            if (objc > 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?CALLBACK? ?MASK?\");\n            } else if (objc == 2) {\n                if (pDb->zTraceV2) {\n                    Tcl_AppendResult(<recovery-expr>(), pDb->zTraceV2, (char *)0);\n                }\n            } else {\n                char *zTraceV2;\n                int len;\n                if (objc == 4) {\n                    static const char *TTYPE_strs[] = {\"statement\", \"profile\", \"row\", \"close\", 0};\n                    enum TTYPE_enum {\n                        TTYPE_STMT,\n                        TTYPE_PROFILE,\n                        TTYPE_ROW,\n                        TTYPE_CLOSE\n                    };\n                    int i;\n                    if (<recovery-expr>()) {\n                    }\n                    for (i = 0; i < len; i++) {\n                        int ttype;\n                        if (<recovery-expr>()) {\n                        }\n                        if (<recovery-expr>()) {\n                            if (<recovery-expr>()) {\n                            } else {\n                            }\n                        } else {\n                            switch ((enum TTYPE_enum)ttype) {\n                              case TTYPE_STMT:\n                                ;\n                                break;\n                              case TTYPE_PROFILE:\n                                ;\n                                break;\n                              case TTYPE_ROW:\n                                ;\n                                break;\n                              case TTYPE_CLOSE:\n                                ;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                }\n                if (pDb->zTraceV2) {\n                    Tcl_Free(pDb->zTraceV2);\n                }\n                zTraceV2 = Tcl_GetStringFromObj(<recovery-expr>()[2], &len);\n                if (zTraceV2 && len > 0) {\n                    pDb->zTraceV2 = Tcl_Alloc(len + 1);\n                    memcpy(pDb->zTraceV2, zTraceV2, len + 1);\n                } else {\n                    pDb->zTraceV2 = 0;\n                }\n                if (pDb->zTraceV2) {\n                    <recovery-expr>(pDb) = <recovery-expr>();\n                } else {\n                    sqlite3_trace_v2(<recovery-expr>(pDb), 0, 0, 0);\n                }\n            }\n            break;\n        }\n      case DB_TRANSACTION:\n        {\n            const char *zBegin = \"SAVEPOINT _tcl_transaction\";\n            if (objc != 3 && objc != 4) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"[TYPE] SCRIPT\");\n            }\n            if (pDb->nTransaction == 0 && objc == 4) {\n                static const char *TTYPE_strs[] = {\"deferred\", \"exclusive\", \"immediate\", 0};\n                enum TTYPE_enum {\n                    TTYPE_DEFERRED,\n                    TTYPE_EXCLUSIVE,\n                    TTYPE_IMMEDIATE\n                };\n                int ttype;\n                if (Tcl_GetIndexFromObj(<recovery-expr>(), <recovery-expr>()[2], TTYPE_strs, \"transaction type\", 0, &ttype)) {\n                }\n                switch ((enum TTYPE_enum)ttype) {\n                  case TTYPE_DEFERRED:\n                    ;\n                    break;\n                  case TTYPE_EXCLUSIVE:\n                    zBegin = \"BEGIN EXCLUSIVE\";\n                    break;\n                  case TTYPE_IMMEDIATE:\n                    zBegin = \"BEGIN IMMEDIATE\";\n                    break;\n                }\n            }\n            pDb->disableAuth++;\n            rc = sqlite3_exec(<recovery-expr>(pDb), zBegin, 0, 0, 0);\n            pDb->disableAuth--;\n            if (<recovery-expr>()) {\n                Tcl_AppendResult(<recovery-expr>(), sqlite3_errmsg(<recovery-expr>(pDb)), (char *)0);\n            }\n            pDb->nTransaction++;\n            addDatabaseRef(pDb);\n            if (0) {\n                (void)0;\n                (void)0;\n            } else {\n            }\n            break;\n        }\n      case DB_UNLOCK_NOTIFY:\n        {\n            Tcl_AppendResult(<recovery-expr>(), \"unlock_notify not available in this build\", (char *)0);\n            break;\n        }\n      case DB_PREUPDATE:\n        {\n            Tcl_AppendResult(<recovery-expr>(), \"preupdate_hook was omitted at compile-time\", (char *)0);\n            break;\n        }\n      case DB_WAL_HOOK:\n      case DB_UPDATE_HOOK:\n      case DB_ROLLBACK_HOOK:\n        {\n            if (objc > 3) {\n                Tcl_WrongNumArgs(<recovery-expr>(), 2, <recovery-expr>(), \"?SCRIPT?\");\n            }\n            break;\n        }\n      case DB_VERSION:\n        {\n            int i;\n            for (i = 2; i < objc; i++) {\n                const char *zArg = Tcl_GetString(<recovery-expr>()[i]);\n                {\n                    Tcl_AppendResult(<recovery-expr>(), \"unknown argument: \", zArg, (char *)0);\n                }\n            }\n            if (i == 2) {\n            }\n            break;\n        }\n    }\n    return rc;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/decompress.c#106:1#BZ2_decompress",
    "gotos": 85,
    "labels": 2,
    "body": "{\n    UChar uc;\n    Int32 retVal;\n    Int32 minLen, maxLen;\n    bz_stream *strm = s->strm;\n    Int32 i;\n    Int32 j;\n    Int32 t;\n    Int32 alphaSize;\n    Int32 nGroups;\n    Int32 nSelectors;\n    Int32 EOB;\n    Int32 groupNo;\n    Int32 groupPos;\n    Int32 nextSym;\n    Int32 nblockMAX;\n    Int32 nblock;\n    Int32 es;\n    Int32 N;\n    Int32 curr;\n    Int32 zt;\n    Int32 zn;\n    Int32 zvec;\n    Int32 zj;\n    Int32 gSel;\n    Int32 gMinlen;\n    Int32 *gLimit;\n    Int32 *gBase;\n    Int32 *gPerm;\n    if (s->state == 10) {\n        s->save_i = 0;\n        s->save_j = 0;\n        s->save_t = 0;\n        s->save_alphaSize = 0;\n        s->save_nGroups = 0;\n        s->save_nSelectors = 0;\n        s->save_EOB = 0;\n        s->save_groupNo = 0;\n        s->save_groupPos = 0;\n        s->save_nextSym = 0;\n        s->save_nblockMAX = 0;\n        s->save_nblock = 0;\n        s->save_es = 0;\n        s->save_N = 0;\n        s->save_curr = 0;\n        s->save_zt = 0;\n        s->save_zn = 0;\n        s->save_zvec = 0;\n        s->save_zj = 0;\n        s->save_gSel = 0;\n        s->save_gMinlen = 0;\n    }\n    i = s->save_i;\n    j = s->save_j;\n    t = s->save_t;\n    alphaSize = s->save_alphaSize;\n    nGroups = s->save_nGroups;\n    nSelectors = s->save_nSelectors;\n    EOB = s->save_EOB;\n    groupNo = s->save_groupNo;\n    groupPos = s->save_groupPos;\n    nextSym = s->save_nextSym;\n    nblockMAX = s->save_nblockMAX;\n    nblock = s->save_nblock;\n    es = s->save_es;\n    N = s->save_N;\n    curr = s->save_curr;\n    zt = s->save_zt;\n    zn = s->save_zn;\n    zvec = s->save_zvec;\n    zj = s->save_zj;\n    gSel = s->save_gSel;\n    gMinlen = s->save_gMinlen;\n    gLimit = s->save_gLimit;\n    gBase = s->save_gBase;\n    gPerm = s->save_gPerm;\n    retVal = 0;\n    switch (s->state) {\n      case 10:\n        s->state = 10;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 66) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 11:\n        s->state = 11;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 90) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 12:\n        s->state = 12;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        if (uc != 104) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 13:\n        s->state = 13;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    s->blockSize100k = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        if (s->blockSize100k < (48 + 1) || s->blockSize100k > (48 + 9)) {\n            retVal = (-5);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->blockSize100k -= 48;\n        if (s->smallDecompress) {\n            s->ll16 = (strm->bzalloc)(strm->opaque, (s->blockSize100k * 100000 * sizeof(UInt16)), 1);\n            s->ll4 = (strm->bzalloc)(strm->opaque, (((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar)), 1);\n            if (<recovery-expr>()) {\n                retVal = (-3);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        } else {\n            s->tt = (strm->bzalloc)(strm->opaque, (s->blockSize100k * 100000 * sizeof(Int32)), 1);\n            if (<recovery-expr>()) {\n                retVal = (-3);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        }\n      case 14:\n        s->state = 14;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc == 23)\n            goto endhdr_2;\n        if (uc != 49) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 15:\n        s->state = 15;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 65) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 16:\n        s->state = 16;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 89) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 17:\n        s->state = 17;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 38) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 18:\n        s->state = 18;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 83) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 19:\n        s->state = 19;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 89) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->currBlockNo++;\n        s->storedBlockCRC = 0;\n      case 20:\n        s->state = 20;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 21:\n        s->state = 21;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 22:\n        s->state = 22;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 23:\n        s->state = 23;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      case 24:\n        s->state = 24;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 1) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                    s->bsLive -= 1;\n                    s->blockRandomised = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = 0;\n      case 25:\n        s->state = 25;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      case 26:\n        s->state = 26;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      case 27:\n        s->state = 27;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n        if (s->origPtr < 0) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        if (s->origPtr > 10 + 100000 * s->blockSize100k) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i < 16; i++) {\n          case 28:\n            s->state = 28;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= 1) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                        s->bsLive -= 1;\n                        uc = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            if (uc == 1)\n                s->inUse16[i] = ((Bool)1);\n            else\n                s->inUse16[i] = ((Bool)0);\n        }\n        for (i = 0; i < 256; i++)\n            s->inUse[i] = ((Bool)0);\n        for (i = 0; i < 16; i++)\n            if (s->inUse16[i])\n                for (j = 0; j < 16; j++) {\n                  case 29:\n                    s->state = 29;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                uc = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    if (uc == 1)\n                        s->inUse[i * 16 + j] = ((Bool)1);\n                }\n        makeMaps_d(s);\n        if (s->nInUse == 0) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        alphaSize = s->nInUse + 2;\n      case 30:\n        s->state = 30;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 3) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 3)) & ((1 << 3) - 1);\n                    s->bsLive -= 3;\n                    nGroups = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (nGroups < 2 || nGroups > 6) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 31:\n        s->state = 31;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 15) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 15)) & ((1 << 15) - 1);\n                    s->bsLive -= 15;\n                    nSelectors = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (nSelectors < 1) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i < nSelectors; i++) {\n            j = 0;\n            while (((Bool)1))\n                {\n                  case 32:\n                    s->state = 32;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                uc = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    if (uc == 0)\n                        break;\n                    j++;\n                    if (j >= nGroups) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                }\n            if (i < (2 + (900000 / 50)))\n                s->selectorMtf[i] = j;\n        }\n        if (nSelectors > (2 + (900000 / 50)))\n            nSelectors = (2 + (900000 / 50));\n        {\n            UChar pos[6], tmp, v;\n            for (v = 0; v < nGroups; v++)\n                pos[v] = v;\n            for (i = 0; i < nSelectors; i++) {\n                v = s->selectorMtf[i];\n                tmp = pos[v];\n                while (v > 0)\n                    {\n                        pos[v] = pos[v - 1];\n                        v--;\n                    }\n                pos[0] = tmp;\n                s->selector[i] = tmp;\n            }\n        }\n        for (t = 0; t < nGroups; t++) {\n          case 33:\n            s->state = 33;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= 5) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - 5)) & ((1 << 5) - 1);\n                        s->bsLive -= 5;\n                        curr = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            for (i = 0; i < alphaSize; i++) {\n                while (((Bool)1))\n                    {\n                        if (curr < 1 || curr > 20) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                      case 34:\n                        s->state = 34;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= 1) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                    s->bsLive -= 1;\n                                    uc = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        if (uc == 0)\n                            break;\n                      case 35:\n                        s->state = 35;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= 1) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                    s->bsLive -= 1;\n                                    uc = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        if (uc == 0)\n                            curr++;\n                        else\n                            curr--;\n                    }\n                s->len[t][i] = curr;\n            }\n        }\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (s->len[t][i] > maxLen)\n                    maxLen = s->len[t][i];\n                if (s->len[t][i] < minLen)\n                    minLen = s->len[t][i];\n            }\n            BZ2_hbCreateDecodeTables(&(s->limit[t][0]), &(s->base[t][0]), &(s->perm[t][0]), &(s->len[t][0]), minLen, maxLen, alphaSize);\n            s->minLens[t] = minLen;\n        }\n        EOB = s->nInUse + 1;\n        nblockMAX = 100000 * s->blockSize100k;\n        groupNo = -1;\n        groupPos = 0;\n        for (i = 0; i <= 255; i++)\n            s->unzftab[i] = 0;\n        {\n            Int32 ii, jj, kk;\n            kk = 4096 - 1;\n            for (ii = 256 / 16 - 1; ii >= 0; ii--) {\n                for (jj = 16 - 1; jj >= 0; jj--) {\n                    s->mtfa[kk] = (UChar)(ii * 16 + jj);\n                    kk--;\n                }\n                s->mtfbase[ii] = kk + 1;\n            }\n        }\n        nblock = 0;\n        {\n            if (groupPos == 0) {\n                groupNo++;\n                if (groupNo >= nSelectors) {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                groupPos = 50;\n                gSel = s->selector[groupNo];\n                gMinlen = s->minLens[gSel];\n                gLimit = &(s->limit[gSel][0]);\n                gPerm = &(s->perm[gSel][0]);\n                gBase = &(s->base[gSel][0]);\n            }\n            groupPos--;\n            zn = gMinlen;\n          case 36:\n            s->state = 36;\n            while (((Bool)1))\n                {\n                    if (s->bsLive >= zn) {\n                        UInt32 v;\n                        v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                        s->bsLive -= zn;\n                        zvec = v;\n                        break;\n                    }\n                    if (s->strm->avail_in == 0) {\n                        retVal = 0;\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                    s->bsLive += 8;\n                    s->strm->next_in++;\n                    s->strm->avail_in--;\n                    s->strm->total_in_lo32++;\n                    if (s->strm->total_in_lo32 == 0)\n                        s->strm->total_in_hi32++;\n                }\n            ;\n            while (1)\n                {\n                    if (zn > 20) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    if (zvec <= gLimit[zn])\n                        break;\n                    zn++;\n                  case 37:\n                    s->state = 37;\n                    while (((Bool)1))\n                        {\n                            if (s->bsLive >= 1) {\n                                UInt32 v;\n                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                s->bsLive -= 1;\n                                zj = v;\n                                break;\n                            }\n                            if (s->strm->avail_in == 0) {\n                                retVal = 0;\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                            s->bsLive += 8;\n                            s->strm->next_in++;\n                            s->strm->avail_in--;\n                            s->strm->total_in_lo32++;\n                            if (s->strm->total_in_lo32 == 0)\n                                s->strm->total_in_hi32++;\n                        }\n                    ;\n                    zvec = (zvec << 1) | zj;\n                }\n            ;\n            if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                retVal = (-4);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n            nextSym = gPerm[zvec - gBase[zn]];\n        }\n        ;\n        while (((Bool)1))\n            {\n                if (nextSym == EOB)\n                    break;\n                if (nextSym == 0 || nextSym == 1) {\n                    es = -1;\n                    N = 1;\n                    do {\n                        if (N >= 2 * 1024 * 1024) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                        if (nextSym == 0)\n                            es = es + (0 + 1) * N;\n                        else if (nextSym == 1)\n                            es = es + (1 + 1) * N;\n                        N = N * 2;\n                        {\n                            if (groupPos == 0) {\n                                groupNo++;\n                                if (groupNo >= nSelectors) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                groupPos = 50;\n                                gSel = s->selector[groupNo];\n                                gMinlen = s->minLens[gSel];\n                                gLimit = &(s->limit[gSel][0]);\n                                gPerm = &(s->perm[gSel][0]);\n                                gBase = &(s->base[gSel][0]);\n                            }\n                            groupPos--;\n                            zn = gMinlen;\n                          case 38:\n                            s->state = 38;\n                            while (((Bool)1))\n                                {\n                                    if (s->bsLive >= zn) {\n                                        UInt32 v;\n                                        v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                                        s->bsLive -= zn;\n                                        zvec = v;\n                                        break;\n                                    }\n                                    if (s->strm->avail_in == 0) {\n                                        retVal = 0;\n                                        goto save_state_and_return;\n                                    }\n                                    ;\n                                    ;\n                                    s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                    s->bsLive += 8;\n                                    s->strm->next_in++;\n                                    s->strm->avail_in--;\n                                    s->strm->total_in_lo32++;\n                                    if (s->strm->total_in_lo32 == 0)\n                                        s->strm->total_in_hi32++;\n                                }\n                            ;\n                            while (1)\n                                {\n                                    if (zn > 20) {\n                                        retVal = (-4);\n                                        goto save_state_and_return;\n                                    }\n                                    ;\n                                    ;\n                                    if (zvec <= gLimit[zn])\n                                        break;\n                                    zn++;\n                                  case 39:\n                                    s->state = 39;\n                                    while (((Bool)1))\n                                        {\n                                            if (s->bsLive >= 1) {\n                                                UInt32 v;\n                                                v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                                s->bsLive -= 1;\n                                                zj = v;\n                                                break;\n                                            }\n                                            if (s->strm->avail_in == 0) {\n                                                retVal = 0;\n                                                goto save_state_and_return;\n                                            }\n                                            ;\n                                            ;\n                                            s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                            s->bsLive += 8;\n                                            s->strm->next_in++;\n                                            s->strm->avail_in--;\n                                            s->strm->total_in_lo32++;\n                                            if (s->strm->total_in_lo32 == 0)\n                                                s->strm->total_in_hi32++;\n                                        }\n                                    ;\n                                    zvec = (zvec << 1) | zj;\n                                }\n                            ;\n                            if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                                retVal = (-4);\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            nextSym = gPerm[zvec - gBase[zn]];\n                        }\n                        ;\n                    } while (nextSym == 0 || nextSym == 1);\n                    es++;\n                    uc = s->seqToUnseq[s->mtfa[s->mtfbase[0]]];\n                    s->unzftab[uc] += es;\n                    if (s->smallDecompress)\n                        while (es > 0)\n                            {\n                                if (nblock >= nblockMAX) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->ll16[nblock] = (UInt16)uc;\n                                nblock++;\n                                es--;\n                            }\n                    else\n                        while (es > 0)\n                            {\n                                if (nblock >= nblockMAX) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->tt[nblock] = (UInt32)uc;\n                                nblock++;\n                                es--;\n                            }\n                    ;\n                    continue;\n                } else {\n                    if (nblock >= nblockMAX) {\n                        retVal = (-4);\n                        goto save_state_and_return;\n                    }\n                    ;\n                    ;\n                    {\n                        Int32 ii, jj, kk, pp, lno, off;\n                        UInt32 nn;\n                        nn = (UInt32)(nextSym - 1);\n                        if (nn < 16) {\n                            pp = s->mtfbase[0];\n                            uc = s->mtfa[pp + nn];\n                            while (nn > 3)\n                                {\n                                    Int32 z = pp + nn;\n                                    s->mtfa[(z)] = s->mtfa[(z) - 1];\n                                    s->mtfa[(z) - 1] = s->mtfa[(z) - 2];\n                                    s->mtfa[(z) - 2] = s->mtfa[(z) - 3];\n                                    s->mtfa[(z) - 3] = s->mtfa[(z) - 4];\n                                    nn -= 4;\n                                }\n                            while (nn > 0)\n                                {\n                                    s->mtfa[(pp + nn)] = s->mtfa[(pp + nn) - 1];\n                                    nn--;\n                                }\n                            ;\n                            s->mtfa[pp] = uc;\n                        } else {\n                            lno = nn / 16;\n                            off = nn % 16;\n                            pp = s->mtfbase[lno] + off;\n                            uc = s->mtfa[pp];\n                            while (pp > s->mtfbase[lno])\n                                {\n                                    s->mtfa[pp] = s->mtfa[pp - 1];\n                                    pp--;\n                                }\n                            ;\n                            s->mtfbase[lno]++;\n                            while (lno > 0)\n                                {\n                                    s->mtfbase[lno]--;\n                                    s->mtfa[s->mtfbase[lno]] = s->mtfa[s->mtfbase[lno - 1] + 16 - 1];\n                                    lno--;\n                                }\n                            s->mtfbase[0]--;\n                            s->mtfa[s->mtfbase[0]] = uc;\n                            if (s->mtfbase[0] == 0) {\n                                kk = 4096 - 1;\n                                for (ii = 256 / 16 - 1; ii >= 0; ii--) {\n                                    for (jj = 16 - 1; jj >= 0; jj--) {\n                                        s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];\n                                        kk--;\n                                    }\n                                    s->mtfbase[ii] = kk + 1;\n                                }\n                            }\n                        }\n                    }\n                    s->unzftab[s->seqToUnseq[uc]]++;\n                    if (s->smallDecompress)\n                        s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]);\n                    else\n                        s->tt[nblock] = (UInt32)(s->seqToUnseq[uc]);\n                    nblock++;\n                    {\n                        if (groupPos == 0) {\n                            groupNo++;\n                            if (groupNo >= nSelectors) {\n                                retVal = (-4);\n                                goto save_state_and_return;\n                            }\n                            ;\n                            ;\n                            groupPos = 50;\n                            gSel = s->selector[groupNo];\n                            gMinlen = s->minLens[gSel];\n                            gLimit = &(s->limit[gSel][0]);\n                            gPerm = &(s->perm[gSel][0]);\n                            gBase = &(s->base[gSel][0]);\n                        }\n                        groupPos--;\n                        zn = gMinlen;\n                      case 40:\n                        s->state = 40;\n                        while (((Bool)1))\n                            {\n                                if (s->bsLive >= zn) {\n                                    UInt32 v;\n                                    v = (s->bsBuff >> (s->bsLive - zn)) & ((1 << zn) - 1);\n                                    s->bsLive -= zn;\n                                    zvec = v;\n                                    break;\n                                }\n                                if (s->strm->avail_in == 0) {\n                                    retVal = 0;\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                s->bsLive += 8;\n                                s->strm->next_in++;\n                                s->strm->avail_in--;\n                                s->strm->total_in_lo32++;\n                                if (s->strm->total_in_lo32 == 0)\n                                    s->strm->total_in_hi32++;\n                            }\n                        ;\n                        while (1)\n                            {\n                                if (zn > 20) {\n                                    retVal = (-4);\n                                    goto save_state_and_return;\n                                }\n                                ;\n                                ;\n                                if (zvec <= gLimit[zn])\n                                    break;\n                                zn++;\n                              case 41:\n                                s->state = 41;\n                                while (((Bool)1))\n                                    {\n                                        if (s->bsLive >= 1) {\n                                            UInt32 v;\n                                            v = (s->bsBuff >> (s->bsLive - 1)) & ((1 << 1) - 1);\n                                            s->bsLive -= 1;\n                                            zj = v;\n                                            break;\n                                        }\n                                        if (s->strm->avail_in == 0) {\n                                            retVal = 0;\n                                            goto save_state_and_return;\n                                        }\n                                        ;\n                                        ;\n                                        s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                                        s->bsLive += 8;\n                                        s->strm->next_in++;\n                                        s->strm->avail_in--;\n                                        s->strm->total_in_lo32++;\n                                        if (s->strm->total_in_lo32 == 0)\n                                            s->strm->total_in_hi32++;\n                                    }\n                                ;\n                                zvec = (zvec << 1) | zj;\n                            }\n                        ;\n                        if (zvec - gBase[zn] < 0 || zvec - gBase[zn] >= 258) {\n                            retVal = (-4);\n                            goto save_state_and_return;\n                        }\n                        ;\n                        ;\n                        nextSym = gPerm[zvec - gBase[zn]];\n                    }\n                    ;\n                    continue;\n                }\n            }\n        if (s->origPtr < 0 || s->origPtr >= nblock) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        for (i = 0; i <= 255; i++) {\n            if (s->unzftab[i] < 0 || s->unzftab[i] > nblock) {\n                retVal = (-4);\n                goto save_state_and_return;\n            }\n            ;\n            ;\n        }\n        s->cftab[0] = 0;\n        for (i = 1; i <= 256; i++)\n            s->cftab[i] = s->unzftab[i - 1];\n        for (i = 1; i <= 256; i++)\n            s->cftab[i] += s->cftab[i - 1];\n        for (i = 0; i <= 256; i++) {\n            if (s->cftab[i] < 0 || s->cftab[i] > nblock) {\n                {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n            }\n        }\n        for (i = 1; i <= 256; i++) {\n            if (s->cftab[i - 1] > s->cftab[i]) {\n                {\n                    retVal = (-4);\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n            }\n        }\n        s->state_out_len = 0;\n        s->state_out_ch = 0;\n        {\n            s->calculatedBlockCRC = 4294967295L;\n        }\n        ;\n        s->state = 2;\n        if (s->smallDecompress) {\n            for (i = 0; i <= 256; i++)\n                s->cftabCopy[i] = s->cftab[i];\n            for (i = 0; i < nblock; i++) {\n                uc = (UChar)(s->ll16[i]);\n                {\n                    s->ll16[i] = (UInt16)(s->cftabCopy[uc] & 65535);\n                    {\n                        if (((i) & 1) == 0)\n                            s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 240) | (s->cftabCopy[uc] >> 16);\n                        else\n                            s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 15) | ((s->cftabCopy[uc] >> 16) << 4);\n                    }\n                    ;\n                }\n                ;\n                s->cftabCopy[uc]++;\n            }\n            i = s->origPtr;\n            j = (((UInt32)s->ll16[i]) | (((((UInt32)(s->ll4[(i) >> 1])) >> (((i) << 2) & 4)) & 15) << 16));\n            do {\n                Int32 tmp = (((UInt32)s->ll16[j]) | (((((UInt32)(s->ll4[(j) >> 1])) >> (((j) << 2) & 4)) & 15) << 16));\n                {\n                    s->ll16[j] = (UInt16)(i & 65535);\n                    {\n                        if (((j) & 1) == 0)\n                            s->ll4[(j) >> 1] = (s->ll4[(j) >> 1] & 240) | (i >> 16);\n                        else\n                            s->ll4[(j) >> 1] = (s->ll4[(j) >> 1] & 15) | ((i >> 16) << 4);\n                    }\n                    ;\n                }\n                ;\n                i = j;\n                j = tmp;\n            } while (i != s->origPtr);\n            s->tPos = s->origPtr;\n            s->nblock_used = 0;\n            if (s->blockRandomised) {\n                s->rNToGo = 0;\n                s->rTPos = 0;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->k0 = BZ2_indexIntoF(s->tPos, s->cftab);\n                s->tPos = (((UInt32)s->ll16[s->tPos]) | (((((UInt32)(s->ll4[(s->tPos) >> 1])) >> (((s->tPos) << 2) & 4)) & 15) << 16));\n                ;\n                s->nblock_used++;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                s->k0 ^= ((s->rNToGo == 1) ? 1 : 0);\n            } else {\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->k0 = BZ2_indexIntoF(s->tPos, s->cftab);\n                s->tPos = (((UInt32)s->ll16[s->tPos]) | (((((UInt32)(s->ll4[(s->tPos) >> 1])) >> (((s->tPos) << 2) & 4)) & 15) << 16));\n                ;\n                s->nblock_used++;\n            }\n        } else {\n            for (i = 0; i < nblock; i++) {\n                uc = (UChar)(s->tt[i] & 255);\n                s->tt[s->cftab[uc]] |= (i << 8);\n                s->cftab[uc]++;\n            }\n            s->tPos = s->tt[s->origPtr] >> 8;\n            s->nblock_used = 0;\n            if (s->blockRandomised) {\n                s->rNToGo = 0;\n                s->rTPos = 0;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                s->k0 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                s->nblock_used++;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                s->k0 ^= ((s->rNToGo == 1) ? 1 : 0);\n            } else {\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                s->k0 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                s->nblock_used++;\n            }\n        }\n        {\n            retVal = 0;\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      endhdr_2:\n      case 42:\n        s->state = 42;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 114) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 43:\n        s->state = 43;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 69) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 44:\n        s->state = 44;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 56) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 45:\n        s->state = 45;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 80) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      case 46:\n        s->state = 46;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        if (uc != 144) {\n            retVal = (-4);\n            goto save_state_and_return;\n        }\n        ;\n        ;\n        s->storedCombinedCRC = 0;\n      case 47:\n        s->state = 47;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 48:\n        s->state = 48;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 49:\n        s->state = 49;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      case 50:\n        s->state = 50;\n        while (((Bool)1))\n            {\n                if (s->bsLive >= 8) {\n                    UInt32 v;\n                    v = (s->bsBuff >> (s->bsLive - 8)) & ((1 << 8) - 1);\n                    s->bsLive -= 8;\n                    uc = v;\n                    break;\n                }\n                if (s->strm->avail_in == 0) {\n                    retVal = 0;\n                    goto save_state_and_return;\n                }\n                ;\n                ;\n                s->bsBuff = (s->bsBuff << 8) | ((UInt32)(*((UChar *)(s->strm->next_in))));\n                s->bsLive += 8;\n                s->strm->next_in++;\n                s->strm->avail_in--;\n                s->strm->total_in_lo32++;\n                if (s->strm->total_in_lo32 == 0)\n                    s->strm->total_in_hi32++;\n            }\n        ;\n        s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n        s->state = 1;\n        {\n            retVal = 4;\n            goto save_state_and_return;\n        }\n        ;\n        ;\n      default:\n        {\n            if (!(((Bool)0)))\n                BZ2_bz__AssertH__fail(4001);\n        }\n        ;\n    }\n    {\n        if (!(((Bool)0)))\n            BZ2_bz__AssertH__fail(4002);\n    }\n    ;\n  save_state_and_return:\n    s->save_i = i;\n    s->save_j = j;\n    s->save_t = t;\n    s->save_alphaSize = alphaSize;\n    s->save_nGroups = nGroups;\n    s->save_nSelectors = nSelectors;\n    s->save_EOB = EOB;\n    s->save_groupNo = groupNo;\n    s->save_groupPos = groupPos;\n    s->save_nextSym = nextSym;\n    s->save_nblockMAX = nblockMAX;\n    s->save_nblock = nblock;\n    s->save_es = es;\n    s->save_N = N;\n    s->save_curr = curr;\n    s->save_zt = zt;\n    s->save_zn = zn;\n    s->save_zvec = zvec;\n    s->save_zj = zj;\n    s->save_gSel = gSel;\n    s->save_gMinlen = gMinlen;\n    s->save_gLimit = gLimit;\n    s->save_gBase = gBase;\n    s->save_gPerm = gPerm;\n    return retVal;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/blocksort.c#750:1#mainSort",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    Int32 i, j, k, ss, sb;\n    Int32 runningOrder[256];\n    Bool bigDone[256];\n    Int32 copyStart[256];\n    Int32 copyEnd[256];\n    UChar c1;\n    Int32 numQSorted;\n    UInt16 s;\n    for (i = 65536; i >= 0; i--)\n        ftab[i] = 0;\n    j = block[0] << 8;\n    i = nblock - 1;\n    for (; i >= 3; i -= 4) {\n        quadrant[i] = 0;\n        j = (j >> 8) | (((UInt16)block[i]) << 8);\n        ftab[j]++;\n        quadrant[i - 1] = 0;\n        j = (j >> 8) | (((UInt16)block[i - 1]) << 8);\n        ftab[j]++;\n        quadrant[i - 2] = 0;\n        j = (j >> 8) | (((UInt16)block[i - 2]) << 8);\n        ftab[j]++;\n        quadrant[i - 3] = 0;\n        j = (j >> 8) | (((UInt16)block[i - 3]) << 8);\n        ftab[j]++;\n    }\n    for (; i >= 0; i--) {\n        quadrant[i] = 0;\n        j = (j >> 8) | (((UInt16)block[i]) << 8);\n        ftab[j]++;\n    }\n    for (i = 0; i < (2 + 12 + 18 + 2); i++) {\n        block[nblock + i] = block[i];\n        quadrant[nblock + i] = 0;\n    }\n    for (i = 1; i <= 65536; i++)\n        ftab[i] += ftab[i - 1];\n    s = block[0] << 8;\n    i = nblock - 1;\n    for (; i >= 3; i -= 4) {\n        s = (s >> 8) | (block[i] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i;\n        s = (s >> 8) | (block[i - 1] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i - 1;\n        s = (s >> 8) | (block[i - 2] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i - 2;\n        s = (s >> 8) | (block[i - 3] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i - 3;\n    }\n    for (; i >= 0; i--) {\n        s = (s >> 8) | (block[i] << 8);\n        j = ftab[s] - 1;\n        ftab[s] = j;\n        ptr[j] = i;\n    }\n    for (i = 0; i <= 255; i++) {\n        bigDone[i] = ((Bool)0);\n        runningOrder[i] = i;\n    }\n    {\n        Int32 vv;\n        Int32 h = 1;\n        do \n            h = 3 * h + 1;\n        while (h <= 256);\n        do {\n            h = h / 3;\n            for (i = h; i <= 255; i++) {\n                vv = runningOrder[i];\n                j = i;\n                while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8]))\n                    {\n                        runningOrder[j] = runningOrder[j - h];\n                        j = j - h;\n                        if (j <= (h - 1))\n                            goto zero;\n                    }\n              zero:\n                runningOrder[j] = vv;\n            }\n        } while (h != 1);\n    }\n    numQSorted = 0;\n    for (i = 0; i <= 255; i++) {\n        ss = runningOrder[i];\n        for (j = 0; j <= 255; j++) {\n            if (j != ss) {\n                sb = (ss << 8) + j;\n                if (!(ftab[sb] & (1 << 21))) {\n                    Int32 lo = ftab[sb] & (~((1 << 21)));\n                    Int32 hi = (ftab[sb + 1] & (~((1 << 21)))) - 1;\n                    if (hi > lo) {\n                        mainQSort3(ptr, block, quadrant, nblock, lo, hi, 2, budget);\n                        numQSorted += (hi - lo + 1);\n                        if (*budget < 0)\n                            return;\n                    }\n                }\n                ftab[sb] |= (1 << 21);\n            }\n        }\n        {\n            if (!(!bigDone[ss]))\n                BZ2_bz__AssertH__fail(1006);\n        }\n        ;\n        {\n            for (j = 0; j <= 255; j++) {\n                copyStart[j] = ftab[(j << 8) + ss] & (~((1 << 21)));\n                copyEnd[j] = (ftab[(j << 8) + ss + 1] & (~((1 << 21)))) - 1;\n            }\n            for (j = ftab[ss << 8] & (~((1 << 21))); j < copyStart[ss]; j++) {\n                k = ptr[j] - 1;\n                if (k < 0)\n                    k += nblock;\n                c1 = block[k];\n                if (!bigDone[c1])\n                    ptr[copyStart[c1]++] = k;\n            }\n            for (j = (ftab[(ss + 1) << 8] & (~((1 << 21)))) - 1; j > copyEnd[ss]; j--) {\n                k = ptr[j] - 1;\n                if (k < 0)\n                    k += nblock;\n                c1 = block[k];\n                if (!bigDone[c1])\n                    ptr[copyEnd[c1]--] = k;\n            }\n        }\n        {\n            if (!((copyStart[ss] - 1 == copyEnd[ss]) || (copyStart[ss] == 0 && copyEnd[ss] == nblock - 1)))\n                BZ2_bz__AssertH__fail(1007);\n        }\n        for (j = 0; j <= 255; j++)\n            ftab[(j << 8) + ss] |= (1 << 21);\n        bigDone[ss] = ((Bool)1);\n        if (i < 255) {\n            Int32 bbStart = ftab[ss << 8] & (~((1 << 21)));\n            Int32 bbSize = (ftab[(ss + 1) << 8] & (~((1 << 21)))) - bbStart;\n            Int32 shifts = 0;\n            while ((bbSize >> shifts) > 65534)\n                shifts++;\n            for (j = bbSize - 1; j >= 0; j--) {\n                Int32 a2update = ptr[bbStart + j];\n                UInt16 qVal = (UInt16)(j >> shifts);\n                quadrant[a2update] = qVal;\n                if (a2update < (2 + 12 + 18 + 2))\n                    quadrant[a2update + nblock] = qVal;\n            }\n            {\n                if (!(((bbSize - 1) >> shifts) <= 65535))\n                    BZ2_bz__AssertH__fail(1002);\n            }\n            ;\n        }\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/bzlib.c#1301:1#BZ2_bzBuffToBuffDecompress",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    bz_stream strm;\n    int ret;\n    if (<recovery-expr>())\n        return (-2);\n    ret = BZ2_bzDecompressInit(&strm, verbosity, small);\n    if (ret != 0)\n        return ret;\n    strm.next_in = source;\n    strm.next_out = dest;\n    strm.avail_in = sourceLen;\n    strm.avail_out = *destLen;\n    ret = BZ2_bzDecompress(&strm);\n    if (ret == 0)\n        goto output_overflow_or_eof;\n    if (ret != 4)\n        goto errhandler;\n    *destLen -= strm.avail_out;\n    BZ2_bzDecompressEnd(&strm);\n    return 0;\n  output_overflow_or_eof:\n    if (strm.avail_out > 0) {\n        BZ2_bzDecompressEnd(&strm);\n        return (-7);\n    } else {\n        BZ2_bzDecompressEnd(&strm);\n        return (-8);\n    }\n    ;\n  errhandler:\n    BZ2_bzDecompressEnd(&strm);\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/bzlib.c#1249:1#BZ2_bzBuffToBuffCompress",
    "gotos": 2,
    "labels": 2,
    "body": "{\n    bz_stream strm;\n    int ret;\n    if (<recovery-expr>())\n        return (-2);\n    if (workFactor == 0)\n        workFactor = 30;\n    ret = BZ2_bzCompressInit(&strm, blockSize100k, verbosity, workFactor);\n    if (ret != 0)\n        return ret;\n    strm.next_in = source;\n    strm.next_out = dest;\n    strm.avail_in = sourceLen;\n    strm.avail_out = *destLen;\n    ret = BZ2_bzCompress(&strm, 2);\n    if (ret == 3)\n        goto output_overflow;\n    if (ret != 4)\n        goto errhandler;\n    *destLen -= strm.avail_out;\n    BZ2_bzCompressEnd(&strm);\n    return 0;\n  output_overflow:\n    BZ2_bzCompressEnd(&strm);\n    return (-8);\n  errhandler:\n    BZ2_bzCompressEnd(&strm);\n    return ret;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/bzlib.c#537:1#unRLE_obuf_to_output_FAST",
    "gotos": 5,
    "labels": 2,
    "body": "{\n    UChar k1;\n    if (s->blockRandomised) {\n        while (((Bool)1))\n            {\n                while (((Bool)1))\n                    {\n                        if (s->strm->avail_out == 0)\n                            return ((Bool)0);\n                        if (s->state_out_len == 0)\n                            break;\n                        *((UChar *)(s->strm->next_out)) = s->state_out_ch;\n                        {\n                            s->calculatedBlockCRC = (s->calculatedBlockCRC << 8) ^ BZ2_crc32Table[(s->calculatedBlockCRC >> 24) ^ ((UChar)s->state_out_ch)];\n                        }\n                        ;\n                        s->state_out_len--;\n                        s->strm->next_out++;\n                        s->strm->avail_out--;\n                        s->strm->total_out_lo32++;\n                        if (s->strm->total_out_lo32 == 0)\n                            s->strm->total_out_hi32++;\n                    }\n                if (s->nblock_used == s->save_nblock + 1)\n                    return ((Bool)0);\n                if (s->nblock_used > s->save_nblock + 1)\n                    return ((Bool)1);\n                s->state_out_len = 1;\n                s->state_out_ch = s->k0;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                k1 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                k1 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n                if (s->nblock_used == s->save_nblock + 1)\n                    continue;\n                if (k1 != s->k0) {\n                    s->k0 = k1;\n                    continue;\n                }\n                ;\n                s->state_out_len = 2;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                k1 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                k1 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n                if (s->nblock_used == s->save_nblock + 1)\n                    continue;\n                if (k1 != s->k0) {\n                    s->k0 = k1;\n                    continue;\n                }\n                ;\n                s->state_out_len = 3;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                k1 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                k1 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n                if (s->nblock_used == s->save_nblock + 1)\n                    continue;\n                if (k1 != s->k0) {\n                    s->k0 = k1;\n                    continue;\n                }\n                ;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                k1 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                k1 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n                s->state_out_len = ((Int32)k1) + 4;\n                if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k)\n                    return ((Bool)1);\n                s->tPos = s->tt[s->tPos];\n                s->k0 = (UChar)(s->tPos & 255);\n                s->tPos >>= 8;\n                ;\n                if (s->rNToGo == 0) {\n                    s->rNToGo = BZ2_rNums[s->rTPos];\n                    s->rTPos++;\n                    if (s->rTPos == 512)\n                        s->rTPos = 0;\n                }\n                s->rNToGo--;\n                ;\n                s->k0 ^= ((s->rNToGo == 1) ? 1 : 0);\n                s->nblock_used++;\n            }\n    } else {\n        UInt32 c_calculatedBlockCRC = s->calculatedBlockCRC;\n        UChar c_state_out_ch = s->state_out_ch;\n        Int32 c_state_out_len = s->state_out_len;\n        Int32 c_nblock_used = s->nblock_used;\n        Int32 c_k0 = s->k0;\n        UInt32 *c_tt = s->tt;\n        UInt32 c_tPos = s->tPos;\n        char *cs_next_out = s->strm->next_out;\n        unsigned int cs_avail_out = s->strm->avail_out;\n        Int32 ro_blockSize100k = s->blockSize100k;\n        UInt32 avail_out_INIT = cs_avail_out;\n        Int32 s_save_nblockPP = s->save_nblock + 1;\n        unsigned int total_out_lo32_old;\n        while (((Bool)1))\n            {\n                if (c_state_out_len > 0) {\n                    while (((Bool)1))\n                        {\n                            if (cs_avail_out == 0)\n                                goto return_notr;\n                            if (c_state_out_len == 1)\n                                break;\n                            *((UChar *)(cs_next_out)) = c_state_out_ch;\n                            {\n                                c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ ((UChar)c_state_out_ch)];\n                            }\n                            ;\n                            c_state_out_len--;\n                            cs_next_out++;\n                            cs_avail_out--;\n                        }\n                  s_state_out_len_eq_one:\n                    {\n                        if (cs_avail_out == 0) {\n                            c_state_out_len = 1;\n                            goto return_notr;\n                        }\n                        ;\n                        *((UChar *)(cs_next_out)) = c_state_out_ch;\n                        {\n                            c_calculatedBlockCRC = (c_calculatedBlockCRC << 8) ^ BZ2_crc32Table[(c_calculatedBlockCRC >> 24) ^ ((UChar)c_state_out_ch)];\n                        }\n                        ;\n                        cs_next_out++;\n                        cs_avail_out--;\n                    }\n                }\n                if (c_nblock_used > s_save_nblockPP)\n                    return ((Bool)1);\n                if (c_nblock_used == s_save_nblockPP) {\n                    c_state_out_len = 0;\n                    goto return_notr;\n                }\n                ;\n                c_state_out_ch = c_k0;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                k1 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n                if (k1 != c_k0) {\n                    c_k0 = k1;\n                    goto s_state_out_len_eq_one;\n                }\n                ;\n                if (c_nblock_used == s_save_nblockPP)\n                    goto s_state_out_len_eq_one;\n                c_state_out_len = 2;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                k1 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n                if (c_nblock_used == s_save_nblockPP)\n                    continue;\n                if (k1 != c_k0) {\n                    c_k0 = k1;\n                    continue;\n                }\n                ;\n                c_state_out_len = 3;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                k1 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n                if (c_nblock_used == s_save_nblockPP)\n                    continue;\n                if (k1 != c_k0) {\n                    c_k0 = k1;\n                    continue;\n                }\n                ;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                k1 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n                c_state_out_len = ((Int32)k1) + 4;\n                if (c_tPos >= (UInt32)100000 * (UInt32)ro_blockSize100k)\n                    return ((Bool)1);\n                c_tPos = c_tt[c_tPos];\n                c_k0 = (UChar)(c_tPos & 255);\n                c_tPos >>= 8;\n                ;\n                c_nblock_used++;\n            }\n      return_notr:\n        total_out_lo32_old = s->strm->total_out_lo32;\n        s->strm->total_out_lo32 += (avail_out_INIT - cs_avail_out);\n        if (s->strm->total_out_lo32 < total_out_lo32_old)\n            s->strm->total_out_hi32++;\n        s->calculatedBlockCRC = c_calculatedBlockCRC;\n        s->state_out_ch = c_state_out_ch;\n        s->state_out_len = c_state_out_len;\n        s->nblock_used = c_nblock_used;\n        s->k0 = c_k0;\n        s->tt = c_tt;\n        s->tPos = c_tPos;\n        s->strm->next_out = cs_next_out;\n        s->strm->avail_out = cs_avail_out;\n    }\n    return ((Bool)0);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/bzlib.c#409:1#BZ2_bzCompress",
    "gotos": 2,
    "labels": 1,
    "body": "{\n    Bool progress;\n    EState *s;\n    if (<recovery-expr>())\n        return (-2);\n    s = strm->state;\n    if (<recovery-expr>())\n        return (-2);\n    if (s->strm != strm)\n        return (-2);\n  preswitch:\n    switch (s->mode) {\n      case 1:\n        return (-1);\n      case 2:\n        if (action == 0) {\n            progress = handle_compress(strm);\n            return progress ? 1 : (-2);\n        } else if (action == 1) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = 3;\n            goto preswitch;\n        } else if (action == 2) {\n            s->avail_in_expect = strm->avail_in;\n            s->mode = 4;\n            goto preswitch;\n        } else\n            return (-2);\n      case 3:\n        if (action != 1)\n            return (-1);\n        if (s->avail_in_expect != s->strm->avail_in)\n            return (-1);\n        progress = handle_compress(strm);\n        if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)\n            return 2;\n        s->mode = 2;\n        return 1;\n      case 4:\n        if (action != 2)\n            return (-1);\n        if (s->avail_in_expect != s->strm->avail_in)\n            return (-1);\n        progress = handle_compress(strm);\n        if (!progress)\n            return (-1);\n        if (s->avail_in_expect > 0 || !isempty_RL(s) || s->state_out_pos < s->numZ)\n            return 3;\n        s->mode = 1;\n        return 4;\n    }\n    return 0;\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/bzip2.c#415:1#uncompressStream",
    "gotos": 15,
    "labels": 4,
    "body": "{\n    BZFILE *bzf;\n    Int32 bzerr, bzerr_dummy, ret, nread, streamNo, i;\n    UChar obuf[5000];\n    UChar unused[5000];\n    Int32 nUnused;\n    void *unusedTmpV;\n    UChar *unusedTmp;\n    nUnused = 0;\n    streamNo = 0;\n    SET_BINARY_MODE(<recovery-expr>());\n    SET_BINARY_MODE(<recovery-expr>());\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    while (((Bool)1))\n        {\n            bzf = <recovery-expr>()(&bzerr, <recovery-expr>(), verbosity, (int)smallMode, unused, nUnused);\n            if (<recovery-expr>())\n                goto errhandler;\n            streamNo++;\n            while (bzerr == 0)\n                {\n                    nread = BZ2_bzRead(&bzerr, bzf, obuf, 5000);\n                    if (bzerr == (-5))\n                        goto trycat;\n                    if ((bzerr == 0 || bzerr == 4) && nread > 0)\n                        fwrite(obuf, sizeof(UChar), nread, <recovery-expr>());\n                    if (ferror(<recovery-expr>()))\n                        goto errhandler_io;\n                }\n            if (bzerr != 4)\n                goto errhandler;\n            BZ2_bzReadGetUnused(&bzerr, bzf, &unusedTmpV, &nUnused);\n            if (bzerr != 0)\n                panic(\"decompress:bzReadGetUnused\");\n            unusedTmp = (UChar *)unusedTmpV;\n            for (i = 0; i < nUnused; i++)\n                unused[i] = unusedTmp[i];\n            BZ2_bzReadClose(&bzerr, bzf);\n            if (bzerr != 0)\n                panic(\"decompress:bzReadGetUnused\");\n            if (nUnused == 0 && <recovery-expr>()(<recovery-expr>()))\n                break;\n        }\n  closeok:\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    if (<recovery-expr>()) {\n        Int32 fd = fileno(<recovery-expr>());\n        if (fd < 0)\n            goto errhandler_io;\n        applySavedFileAttrToOutputFile(fd);\n    }\n    ret = fclose(<recovery-expr>());\n    if (<recovery-expr>())\n        goto errhandler_io;\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    ret = fflush(<recovery-expr>());\n    if (ret != 0)\n        goto errhandler_io;\n    if (<recovery-expr>()) {\n        ret = fclose(<recovery-expr>());\n        if (<recovery-expr>())\n            goto errhandler_io;\n    }\n    return ((Bool)1);\n  trycat:\n    if (forceOverwrite) {\n        rewind(<recovery-expr>());\n        while (((Bool)1))\n            {\n                if (<recovery-expr>()(<recovery-expr>()))\n                    break;\n                nread = fread(obuf, sizeof(UChar), 5000, <recovery-expr>());\n                if (ferror(<recovery-expr>()))\n                    goto errhandler_io;\n                if (nread > 0)\n                    fwrite(obuf, sizeof(UChar), nread, <recovery-expr>());\n                if (ferror(<recovery-expr>()))\n                    goto errhandler_io;\n            }\n        goto closeok;\n    }\n  errhandler:\n    BZ2_bzReadClose(&bzerr_dummy, bzf);\n    switch (bzerr) {\n      case (-9):\n        configError();\n        break;\n      case (-6):\n      errhandler_io:\n        ioError();\n        break;\n      case (-4):\n        crcError();\n      case (-3):\n        outOfMemory();\n      case (-7):\n        compressedStreamEOF();\n      case (-5):\n        if (<recovery-expr>())\n            fclose(<recovery-expr>());\n        if (<recovery-expr>())\n            fclose(<recovery-expr>());\n        if (streamNo == 1) {\n            return ((Bool)0);\n        } else {\n            return ((Bool)1);\n        }\n      default:\n        panic(\"decompress:unexpected error\");\n    }\n    panic(\"decompress:end\");\n    return ((Bool)1);\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/bzip2.c#1304:1#uncompress",
    "gotos": 1,
    "labels": 1,
    "body": "{\n    Int32 n, i;\n    Bool magicNumberOK;\n    Bool cantGuess;\n    struct MY_STAT statBuf;\n    deleteOutputOnInterrupt = ((Bool)0);\n    if (<recovery-expr>())\n        <recovery-expr>()(\"uncompress: bad modes\\n\");\n    cantGuess = ((Bool)0);\n    switch (srcMode) {\n      case 1:\n        copyFileName(inName, (Char *)\"(stdin)\");\n        copyFileName(outName, (Char *)\"(stdout)\");\n        break;\n      case 3:\n        copyFileName(inName, name);\n        copyFileName(outName, name);\n        for (i = 0; i < 4; i++)\n            if (mapSuffix(outName, zSuffix[i], unzSuffix[i]))\n                goto zzz;\n        cantGuess = ((Bool)1);\n        strcat(outName, \".out\");\n        break;\n      case 2:\n        copyFileName(inName, name);\n        copyFileName(outName, (Char *)\"(stdout)\");\n        break;\n    }\n  zzz:\n    if (srcMode != 1 && containsDubiousChars(inName)) {\n        setExit(1);\n        return;\n    }\n    if (srcMode != 1 && !fileExists(inName)) {\n        setExit(1);\n        return;\n    }\n    if (srcMode == 3 || srcMode == 2) {\n        MY_STAT(inName, &<recovery-expr>());\n        if (MY_S_ISDIR(<recovery-expr>().st_mode)) {\n            setExit(1);\n            return;\n        }\n    }\n    if (srcMode == 3 && !forceOverwrite && notAStandardFile(inName)) {\n        setExit(1);\n        return;\n    }\n    if (cantGuess) {\n    }\n    if (srcMode == 3 && fileExists(outName)) {\n        if (forceOverwrite) {\n            remove(outName);\n        } else {\n            setExit(1);\n            return;\n        }\n    }\n    if (srcMode == 3 && !forceOverwrite && (n = countHardLinks(inName)) > 0) {\n        setExit(1);\n        return;\n    }\n    if (srcMode == 3) {\n        saveInputFileMetaInfo(inName);\n    }\n    switch (srcMode) {\n      case 1:\n        ;\n        if (<recovery-expr>()) {\n            setExit(1);\n            return;\n        }\n        ;\n        break;\n      case 2:\n        ;\n        if (<recovery-expr>()) {\n            setExit(1);\n            return;\n        }\n        ;\n        break;\n      case 3:\n        ;\n        if (<recovery-expr>()) {\n            setExit(1);\n            return;\n        }\n        if (<recovery-expr>()) {\n            setExit(1);\n            return;\n        }\n        ;\n        break;\n      default:\n        <recovery-expr>()(\"uncompress: bad srcMode\");\n        break;\n    }\n    if (verbosity >= 1) {\n        pad(inName);\n    }\n    deleteOutputOnInterrupt = ((Bool)1);\n    if (magicNumberOK) {\n        if (srcMode == 3) {\n            applySavedTimeInfoToOutputFile(outName);\n            deleteOutputOnInterrupt = ((Bool)0);\n            if (!keepInputFiles) {\n                IntNative retVal = remove(inName);\n                {\n                    if ((retVal) != 0)\n                        <recovery-expr>()();\n                }\n                ;\n            }\n        }\n    } else {\n        unzFailsExist = ((Bool)1);\n        deleteOutputOnInterrupt = ((Bool)0);\n        if (srcMode == 3) {\n            IntNative retVal = remove(outName);\n            {\n                if ((retVal) != 0)\n                    <recovery-expr>()();\n            }\n            ;\n        }\n    }\n    deleteOutputOnInterrupt = ((Bool)0);\n    if (magicNumberOK) {\n    } else {\n        setExit(2);\n    }\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/bzip2.c#311:1#compressStream",
    "gotos": 12,
    "labels": 2,
    "body": "{\n    BZFILE *bzf;\n    UChar ibuf[5000];\n    Int32 nIbuf;\n    UInt32 nbytes_in_lo32, nbytes_in_hi32;\n    UInt32 nbytes_out_lo32, nbytes_out_hi32;\n    Int32 bzerr, bzerr_dummy, ret;\n    SET_BINARY_MODE(<recovery-expr>());\n    SET_BINARY_MODE(<recovery-expr>());\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    bzf = <recovery-expr>()(&bzerr, <recovery-expr>(), blockSize100k, verbosity, workFactor);\n    if (bzerr != 0)\n        goto errhandler;\n    while (((Bool)1))\n        {\n            if (<recovery-expr>()(<recovery-expr>()))\n                break;\n            nIbuf = fread(ibuf, sizeof(UChar), 5000, <recovery-expr>());\n            if (ferror(<recovery-expr>()))\n                goto errhandler_io;\n            if (nIbuf > 0)\n                BZ2_bzWrite(&bzerr, bzf, (void *)ibuf, nIbuf);\n            if (bzerr != 0)\n                goto errhandler;\n        }\n    BZ2_bzWriteClose64(&bzerr, bzf, 0, &nbytes_in_lo32, &nbytes_in_hi32, &nbytes_out_lo32, &nbytes_out_hi32);\n    if (bzerr != 0)\n        goto errhandler;\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    ret = fflush(<recovery-expr>());\n    if (<recovery-expr>())\n        goto errhandler_io;\n    if (<recovery-expr>()) {\n        Int32 fd = fileno(<recovery-expr>());\n        if (fd < 0)\n            goto errhandler_io;\n        applySavedFileAttrToOutputFile(fd);\n        ret = fclose(<recovery-expr>());\n        if (<recovery-expr>())\n            goto errhandler_io;\n    }\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    ret = fclose(<recovery-expr>());\n    if (<recovery-expr>())\n        goto errhandler_io;\n    if (verbosity >= 1) {\n        if (nbytes_in_lo32 == 0 && nbytes_in_hi32 == 0) {\n        } else {\n            Char buf_nin[32], buf_nout[32];\n            UInt64 nbytes_in, nbytes_out;\n            double nbytes_in_d, nbytes_out_d;\n            uInt64_from_UInt32s(&nbytes_in, nbytes_in_lo32, nbytes_in_hi32);\n            uInt64_from_UInt32s(&nbytes_out, nbytes_out_lo32, nbytes_out_hi32);\n            nbytes_in_d = uInt64_to_double(&nbytes_in);\n            nbytes_out_d = uInt64_to_double(&nbytes_out);\n            uInt64_toAscii(buf_nin, &nbytes_in);\n            uInt64_toAscii(buf_nout, &nbytes_out);\n        }\n    }\n    return;\n  errhandler:\n    BZ2_bzWriteClose64(&bzerr_dummy, bzf, 1, &nbytes_in_lo32, &nbytes_in_hi32, &nbytes_out_lo32, &nbytes_out_hi32);\n    switch (bzerr) {\n      case (-9):\n        configError();\n        break;\n      case (-3):\n        outOfMemory();\n        break;\n      case (-6):\n      errhandler_io:\n        ioError();\n        break;\n      default:\n        panic(\"compress:unexpected error\");\n    }\n    panic(\"compress:end\");\n}\n"
  },
  {
    "id": "/Users/henriquepreto/Desktop/cc-ast-tool/scripts/benchmarks/bzip2/bzip2.c#536:1#testStream",
    "gotos": 6,
    "labels": 2,
    "body": "{\n    BZFILE *bzf;\n    Int32 bzerr, bzerr_dummy, ret, streamNo, i;\n    UChar obuf[5000];\n    UChar unused[5000];\n    Int32 nUnused;\n    void *unusedTmpV;\n    UChar *unusedTmp;\n    nUnused = 0;\n    streamNo = 0;\n    SET_BINARY_MODE(<recovery-expr>());\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    while (((Bool)1))\n        {\n            bzf = <recovery-expr>()(&bzerr, <recovery-expr>(), verbosity, (int)smallMode, unused, nUnused);\n            if (<recovery-expr>())\n                goto errhandler;\n            streamNo++;\n            while (bzerr == 0)\n                {\n                    BZ2_bzRead(&bzerr, bzf, obuf, 5000);\n                    if (bzerr == (-5))\n                        goto errhandler;\n                }\n            if (bzerr != 4)\n                goto errhandler;\n            BZ2_bzReadGetUnused(&bzerr, bzf, &unusedTmpV, &nUnused);\n            if (bzerr != 0)\n                panic(\"test:bzReadGetUnused\");\n            unusedTmp = (UChar *)unusedTmpV;\n            for (i = 0; i < nUnused; i++)\n                unused[i] = unusedTmp[i];\n            BZ2_bzReadClose(&bzerr, bzf);\n            if (bzerr != 0)\n                panic(\"test:bzReadGetUnused\");\n            if (nUnused == 0 && <recovery-expr>()(<recovery-expr>()))\n                break;\n        }\n    if (ferror(<recovery-expr>()))\n        goto errhandler_io;\n    ret = fclose(<recovery-expr>());\n    if (<recovery-expr>())\n        goto errhandler_io;\n    return ((Bool)1);\n  errhandler:\n    BZ2_bzReadClose(&bzerr_dummy, bzf);\n    switch (bzerr) {\n      case (-9):\n        configError();\n        break;\n      case (-6):\n      errhandler_io:\n        ioError();\n        break;\n      case (-4):\n        ;\n        return ((Bool)0);\n      case (-3):\n        outOfMemory();\n      case (-7):\n        ;\n        return ((Bool)0);\n      case (-5):\n        if (<recovery-expr>())\n            fclose(<recovery-expr>());\n        if (streamNo == 1) {\n            return ((Bool)0);\n        } else {\n            return ((Bool)1);\n        }\n      default:\n        panic(\"test:unexpected error\");\n    }\n    panic(\"test:end\");\n    return ((Bool)1);\n}\n"
  }]
